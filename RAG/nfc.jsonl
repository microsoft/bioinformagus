[{"question": "Description: The goal of the Shasta long read assembler is to rapidly produce accurate assembled sequence using DNA reads generated by Oxford Nanopore flow cells as input. Please note Assembler is design to focus on speed, so assembly may be considered somewhat non-deterministic as final assembly may vary across executions. See https://github.com/chanzuckerberg/shasta/issues/296.\nTags: nanopore, de-novo, assembly, longread", "answer": "process SHASTA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/shasta:0.8.0--h7d875b9_0':\n        'biocontainers/shasta:0.8.0--h7d875b9_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*_Assembly.fasta.gz\"), emit: assembly\n    tuple val(meta), path(\"*_Assembly.gfa.gz\")  , emit: gfa\n    tuple val(meta), path(\"ShastaRun/\")                 , emit: results\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def model  = \"${meta.model}\" ?: 'Nanopore-Oct2021'\n    \"\"\"\n    # shasta requires uncompressed\n    zcat -f $reads > reads.fq\n\n    # run shasta\n    shasta \\\\\n        --input reads.fq \\\\\n        --config $model \\\\\n        $args \\\\\n        --threads $task.cpus\n\n    # compress results\n    gzip -c ShastaRun/Assembly.fasta > ${prefix}_Assembly.fasta.gz\n    gzip -c ShastaRun/Assembly.gfa   > ${prefix}_Assembly.gfa.gz\n\n    # cleanup temp files\n    rm reads.fq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shasta: \\$(shasta --version | head -n 1 | cut -f 3 -d \" \")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extract files.\nTags: untar, uncompress, files", "answer": "process UNTARFILES {\n    tag \"$archive\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:20.04' :\n        'nf-core/ubuntu:20.04' }\"\n\n    input:\n    tuple val(meta), path(archive)\n\n    output:\n    tuple val(meta), path(\"${prefix}/**\") , emit: files\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    prefix    = task.ext.prefix ?: ( meta.id ? \"${meta.id}\" : archive.baseName.toString().replaceFirst(/\\.tar$/, \"\"))\n\n    \"\"\"\n    mkdir $prefix\n\n    tar \\\\\n        -C $prefix \\\\\n        -xavf \\\\\n        $args \\\\\n        $archive \\\\\n        $args2\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        untar: \\$(echo \\$(tar --version 2>&1) | sed 's/^.*(GNU tar) //; s/ Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix    = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir $prefix\n    touch ${prefix}/file.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        untar: \\$(echo \\$(tar --version 2>&1) | sed 's/^.*(GNU tar) //; s/ Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool to phase common sites, typically SNP array data, or the first step of WES/WGS data.\nTags: phasing, haplotype, shapeit", "answer": "process SHAPEIT5_PHASECOMMON {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/shapeit5:1.0.0--h0c8ee15_0':\n        'biocontainers/shapeit5:1.0.0--h0c8ee15_0'}\"\n\n    input:\n        tuple val(meta) , path(input), path(input_index), path(pedigree), val(region)\n        tuple val(meta2), path(reference), path(reference_index)\n        tuple val(meta3), path(scaffold), path(scaffold_index)\n        tuple val(meta4), path(map)\n\n    output:\n        tuple val(meta), path(\"*.{vcf,bcf,vcf.gz,bcf.gz}\"), emit: phased_variant\n        path \"versions.yml\"                               , emit: versions\n\n    when:\n        task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n\n    if (\"$input\" == \"${prefix}.${suffix}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    def map_command       = map       ? \"--map $map\"             : \"\"\n    def reference_command = reference ? \"--reference $reference\" : \"\"\n    def scaffold_command  = scaffold  ? \"--scaffold $scaffold\"   : \"\"\n    def pedigree_command  = pedigree  ? \"--pedigree $pedigree\"   : \"\"\n\n    \"\"\"\n    SHAPEIT5_phase_common \\\\\n        $args \\\\\n        --input $input \\\\\n        $map_command \\\\\n        $reference_command \\\\\n        $scaffold_command \\\\\n        $pedigree_command \\\\\n        --region $region \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shapeit5: \"\\$(SHAPEIT5_phase_common | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shapeit5: \"\\$(SHAPEIT5_phase_common | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool to phase rare variants onto a scaffold of common variants (output of phase_common / ligate).\nRequire feature AVX2.\n\nTags: phasing, rare variants, haplotype, shapeit", "answer": "process SHAPEIT5_PHASERARE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    beforeScript  \"\"\"\n    if cat /proc/cpuinfo | grep avx2 -q\n    then\n        echo \"Feature AVX2 present on host\"\n    else\n        echo \"Feature AVX2 not present on host\"\n        exit 1\n    fi\n    \"\"\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/shapeit5:1.0.0--h0c8ee15_0':\n        'biocontainers/shapeit5:1.0.0--h0c8ee15_0' }\"\n\n    input:\n        tuple val(meta) , path(input_plain), path(input_plain_index), path(pedigree), val(input_region)\n        tuple val(meta2), path(scaffold)   , path(scaffold_index)   , val(scaffold_region)\n        tuple val(meta3), path(map)\n\n    output:\n        tuple val(meta), path(\"*.{vcf,bcf,vcf.gz,bcf.gz}\"), emit: phased_variant\n        path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n\n    if (\"$input_plain\" == \"${prefix}.${suffix}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    def map_command       = map       ? \"--map $map\"             : \"\"\n    def pedigree_command  = pedigree  ? \"--pedigree $pedigree\"   : \"\"\n\n    \"\"\"\n    SHAPEIT5_phase_rare \\\\\n        $args \\\\\n        --input-plain $input_plain \\\\\n        --scaffold $scaffold \\\\\n        $map_command \\\\\n        $pedigree_command \\\\\n        --input-region $input_region \\\\\n        --scaffold-region $scaffold_region \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shapeit5: \"\\$(SHAPEIT5_phase_rare | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shapeit5: \"\\$(SHAPEIT5_phase_rare | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Ligate multiple phased BCF/VCF files into a single whole chromosome file.\nTypically run to ligate multiple chunks of phased common variants.\n\nTags: ligate, haplotype, shapeit", "answer": "process SHAPEIT5_LIGATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/shapeit5:1.0.0--h0c8ee15_0':\n        'biocontainers/shapeit5:1.0.0--h0c8ee15_0'}\"\n\n    input:\n    tuple val(meta), path(input_list), path (input_list_index)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,bcf,vcf.gz,bcf.gz}\"), emit: merged_variants\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    printf \"%s\\\\n\" $input_list | tr -d '[],' > all_files.txt\n\n    SHAPEIT5_ligate \\\\\n        $args \\\\\n        --input all_files.txt \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shapeit5: \"\\$(SHAPEIT5_ligate | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -n 1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shapeit5: \"\\$(SHAPEIT5_ligate | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -n 1)\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Program to compute switch error rate and genotyping error rate given simulated or trio data.\nTags: error, phasing, genotype, switch", "answer": "process SHAPEIT5_SWITCH {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/shapeit5:1.0.0--h0c8ee15_0':\n        'biocontainers/shapeit5:1.0.0--h0c8ee15_0'}\"\n\n    input:\n        tuple val(meta) , path(estimate), path(estimate_index), val(region), path(pedigree)\n        tuple val(meta2), path(truth)   , path(truth_index)\n        tuple val(meta3), path(freq)    , path(freq_index)\n\n    output:\n        tuple val(meta), path(\"*.txt.gz\"), emit: errors\n        path \"versions.yml\"              , emit: versions\n\n    when:\n        task.ext.when == null || task.ext.when\n\n    script:\n    def args         = task.ext.args   ?: ''\n    def prefix       = task.ext.prefix ?: \"${meta.id}\"\n    def freq_cmd     = freq            ? \"--frequency ${freq}\"   : \"\"\n    def pedigree_cmd = pedigree        ? \"--pedigree ${pedigree}\": \"\"\n\n    \"\"\"\n    SHAPEIT5_switch \\\\\n        $args \\\\\n        --estimation $estimate \\\\\n        --region $region \\\\\n        --validation $truth \\\\\n        $freq_cmd \\\\\n        $pedigree_cmd \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shapeit5: \"\\$(SHAPEIT5_switch | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args         = task.ext.args   ?: ''\n    def prefix       = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.block.switch.txt.gz\n    touch ${prefix}.calibration.switch.txt.gz\n    touch ${prefix}.flipsAndSwitches.txt.gz\n    touch ${prefix}.frequency.switch.txt.gz\n    touch ${prefix}.sample.switch.txt.gz\n    touch ${prefix}.sample.typing.txt.gz\n    touch ${prefix}.type.switch.txt.gz\n    touch ${prefix}.variant.switch.txt.gz\n    touch ${prefix}.variant.typing.txt.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shapeit5: \"\\$(SHAPEIT5_switch | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split bam file into manageable chunks\nTags: bam, split by chromosome", "answer": "process ELPREP_SPLIT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/elprep:5.1.2--he881be0_0':\n        'biocontainers/elprep:5.1.2--he881be0_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"output/**.{bam,sam}\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def prefix      = task.ext.prefix ?: \"${meta.id}\"\n    def single_end  = meta.single_end ? \" --single-end\": \"\"\n\n    \"\"\"\n    # create directory and move all input so elprep can find and merge them before splitting\n    mkdir input\n    mv ${bam} input/\n\n    mkdir ${prefix}\n\n    elprep split \\\\\n        input \\\\\n        output/ \\\\\n        $args \\\\\n        $single_end \\\\\n        --nr-of-threads $task.cpus \\\\\n        --output-prefix $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        elprep: \\$(elprep 2>&1 | head -n2 | tail -n1 |sed 's/^.*version //;s/ compiled.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge split bam/sam chunks in one file\nTags: bam, sam, merge", "answer": "process ELPREP_MERGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/elprep:5.1.2--he881be0_0':\n        'biocontainers/elprep:5.1.2--he881be0_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"output/**.{bam,sam}\")    , emit: bam\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def prefix      = task.ext.prefix ?: \"${meta.id}\"\n    def suffix      = args.contains(\"--output-type sam\") ? \"sam\" : \"bam\"\n    def single_end  = meta.single_end ? \" --single-end\" : \"\"\n\n    \"\"\"\n    # create directory and move all input so elprep can find and merge them before splitting\n    mkdir input\n    mv ${bam} input/\n\n    elprep merge \\\\\n        input/ \\\\\n        output/${prefix}.${suffix} \\\\\n        $args \\\\\n        ${single_end} \\\\\n        --nr-of-threads $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        elprep: \\$(elprep 2>&1 | head -n2 | tail -n1 |sed 's/^.*version //;s/ compiled.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filter, sort and markdup sam/bam files, with optional BQSR and variant calling.\nTags: sort, bam, sam, filter, variant calling", "answer": "process ELPREP_FILTER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/elprep:5.1.2--he881be0_0':\n        'biocontainers/elprep:5.1.2--he881be0_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    val(run_haplotypecaller)\n    val(run_bqsr)\n    path(reference_sequences)\n    path(filter_regions_bed)\n    path(reference_elfasta)\n    path(known_sites_elsites)\n    path(target_regions_bed)\n    path(intermediate_bqsr_tables)\n    val(bqsr_tables_only)\n    val(get_activity_profile)\n    val(get_assembly_regions)\n\n\n    output:\n    tuple val(meta), path(\"output/**.{bam,sam}\")    ,emit: bam\n    tuple val(meta), path(\"*.metrics.txt\")          ,optional: true, emit: metrics\n    tuple val(meta), path(\"*.recall\")               ,optional: true, emit: recall\n    tuple val(meta), path(\"*.vcf.gz\")               ,optional: true, emit: gvcf\n    tuple val(meta), path(\"*.table\")                ,optional: true, emit: table\n    tuple val(meta), path(\"*.activity_profile.igv\") ,optional: true, emit: activity_profile\n    tuple val(meta), path(\"*.assembly_regions.igv\") ,optional: true, emit: assembly_regions\n    path \"versions.yml\"                             ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = args.contains(\"--output-type sam\") ? \"sam\" : \"bam\"\n\n    // filter args\n    def reference_sequences_cmd = reference_sequences ? \" --replace-reference-sequences ${reference_sequences}\" : \"\"\n    def filter_regions_cmd      = filter_regions_bed  ? \" --filter-non-overlapping-reads ${filter_regions_bed}\" : \"\"\n\n    // markdup args\n    def markdup_cmd = args.contains(\"--mark-duplicates\") ? \" --mark-optical-duplicates ${prefix}.metrics.txt\": \"\"\n\n    // variant calling args\n    def haplotyper_cmd = run_haplotypecaller ? \" --haplotypecaller ${prefix}.g.vcf.gz\": \"\"\n\n    def fasta_cmd           = reference_elfasta   ? \" --reference ${reference_elfasta}\": \"\"\n    def known_sites_cmd     = known_sites_elsites ? \" --known-sites ${known_sites_elsites}\": \"\"\n    def target_regions_cmd  = target_regions_bed  ? \" --target-regions ${target_regions_bed}\": \"\"\n\n    // bqsr args\n    def bqsr_cmd = run_bqsr ? \" --bqsr ${prefix}.recall\": \"\"\n    def bqsr_tables_only_cmd = bqsr_tables_only ? \" --bqsr-tables-only ${prefix}.table\": \"\"\n\n    def intermediate_bqsr_cmd = intermediate_bqsr_tables ? \" --bqsr-apply .\": \"\"\n\n    // misc\n    def activity_profile_cmd = get_activity_profile ? \" --activity-profile ${prefix}.activity_profile.igv\": \"\"\n    def assembly_regions_cmd = get_assembly_regions ? \" --assembly-regions ${prefix}.assembly_regions.igv\": \"\"\n\n    \"\"\"\n    elprep filter ${bam} output/${prefix}.${suffix} \\\\\n        ${reference_sequences_cmd} \\\\\n        ${filter_regions_cmd} \\\\\n        ${markdup_cmd} \\\\\n        ${haplotyper_cmd} \\\\\n        ${fasta_cmd} \\\\\n        ${known_sites_cmd} \\\\\n        ${target_regions_cmd} \\\\\n        ${bqsr_cmd} \\\\\n        ${bqsr_tables_only_cmd} \\\\\n        ${intermediate_bqsr_cmd} \\\\\n        ${activity_profile_cmd} \\\\\n        ${assembly_regions_cmd} \\\\\n        --nr-of-threads ${task.cpus} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        elprep: \\$(elprep 2>&1 | head -n2 | tail -n1 |sed 's/^.*version //;s/ compiled.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: calculate clusters of highly similar sequences\nTags: clustering, alignment, genomics, proteomics", "answer": "process DIAMOND_CLUSTER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/diamond:2.1.9--h43eeafb_0':\n        'biocontainers/diamond:2.1.9--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(db)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def mem    = task.memory.toKilo() + 'K'\n    def memarg = \"-M ${mem}\"\n    \"\"\"\n    diamond \\\\\n        cluster \\\\\n        $args \\\\\n        $memarg \\\\\n        -p $task.cpus \\\\\n        -d $db \\\\\n        -o ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        diamond: \\$(diamond --version |& sed '1!d ; s/diamond version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        diamond: \\$(diamond --version |& sed '1!d ; s/diamond version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Queries a DIAMOND database using blastp mode\nTags: fasta, diamond, blastp, DNA sequence", "answer": "process DIAMOND_BLASTP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/diamond:2.1.8--h43eeafb_0' :\n        'biocontainers/diamond:2.1.8--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(db)\n    val out_ext\n    val blast_columns\n\n    output:\n    tuple val(meta), path('*.blast'), optional: true, emit: blast\n    tuple val(meta), path('*.xml')  , optional: true, emit: xml\n    tuple val(meta), path('*.txt')  , optional: true, emit: txt\n    tuple val(meta), path('*.daa')  , optional: true, emit: daa\n    tuple val(meta), path('*.sam')  , optional: true, emit: sam\n    tuple val(meta), path('*.tsv')  , optional: true, emit: tsv\n    tuple val(meta), path('*.paf')  , optional: true, emit: paf\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getExtension() == \"gz\" ? true : false\n    def fasta_name = is_compressed ? fasta.getBaseName() : fasta\n    def columns = blast_columns ? \"${blast_columns}\" : ''\n    switch ( out_ext ) {\n        case \"blast\": outfmt = 0; break\n        case \"xml\": outfmt = 5; break\n        case \"txt\": outfmt = 6; break\n        case \"daa\": outfmt = 100; break\n        case \"sam\": outfmt = 101; break\n        case \"tsv\": outfmt = 102; break\n        case \"paf\": outfmt = 103; break\n        default:\n            outfmt = '6';\n            out_ext = 'txt';\n            log.warn(\"Unknown output file format provided (${out_ext}): selecting DIAMOND default of tabular BLAST output (txt)\");\n            break\n    }\n    \"\"\"\n    if [ \"${is_compressed}\" == \"true\" ]; then\n        gzip -c -d ${fasta} > ${fasta_name}\n    fi\n\n    DB=`find -L ./ -name \"*.dmnd\" | sed 's/\\\\.dmnd\\$//'`\n\n    diamond \\\\\n        blastp \\\\\n        --threads ${task.cpus} \\\\\n        --db \\$DB \\\\\n        --query ${fasta_name} \\\\\n        --outfmt ${outfmt} ${columns} \\\\\n        ${args} \\\\\n        --out ${prefix}.${out_ext}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        diamond: \\$(diamond --version 2>&1 | tail -n 1 | sed 's/^diamond version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    switch ( out_ext ) {\n        case \"blast\": outfmt = 0; break\n        case \"xml\": outfmt = 5; break\n        case \"txt\": outfmt = 6; break\n        case \"daa\": outfmt = 100; break\n        case \"sam\": outfmt = 101; break\n        case \"tsv\": outfmt = 102; break\n        case \"paf\": outfmt = 103; break\n        default:\n            outfmt = '6';\n            out_ext = 'txt';\n            log.warn(\"Unknown output file format provided (${out_ext}): selecting DIAMOND default of tabular BLAST output (txt)\");\n            break\n    }\n\n    \"\"\"\n    touch ${prefix}.${out_ext}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        diamond: \\$(diamond --version 2>&1 | tail -n 1 | sed 's/^diamond version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Queries a DIAMOND database using blastx mode\nTags: fasta, diamond, blastx, DNA sequence", "answer": "process DIAMOND_BLASTX {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/diamond:2.1.8--h43eeafb_0' :\n        'biocontainers/diamond:2.1.8--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(db)\n    val out_ext\n    val blast_columns\n\n    output:\n    tuple val(meta), path('*.blast'), optional: true, emit: blast\n    tuple val(meta), path('*.xml')  , optional: true, emit: xml\n    tuple val(meta), path('*.txt')  , optional: true, emit: txt\n    tuple val(meta), path('*.daa')  , optional: true, emit: daa\n    tuple val(meta), path('*.sam')  , optional: true, emit: sam\n    tuple val(meta), path('*.tsv')  , optional: true, emit: tsv\n    tuple val(meta), path('*.paf')  , optional: true, emit: paf\n    tuple val(meta), path(\"*.log\")  , emit: log\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getExtension() == \"gz\" ? true : false\n    def fasta_name = is_compressed ? fasta.getBaseName() : fasta\n    def columns = blast_columns ? \"${blast_columns}\" : ''\n    switch ( out_ext ) {\n        case \"blast\": outfmt = 0; break\n        case \"xml\": outfmt = 5; break\n        case \"txt\": outfmt = 6; break\n        case \"daa\": outfmt = 100; break\n        case \"sam\": outfmt = 101; break\n        case \"tsv\": outfmt = 102; break\n        case \"paf\": outfmt = 103; break\n        default:\n            outfmt = '6';\n            out_ext = 'txt';\n            log.warn(\"Unknown output file format provided (${out_ext}): selecting DIAMOND default of tabular BLAST output (txt)\");\n            break\n    }\n    \"\"\"\n    if [ \"${is_compressed}\" == \"true\" ]; then\n        gzip -c -d ${fasta} > ${fasta_name}\n    fi\n\n    DB=`find -L ./ -name \"*.dmnd\" | sed 's/\\\\.dmnd\\$//'`\n\n    diamond \\\\\n        blastx \\\\\n        --threads ${task.cpus} \\\\\n        --db \\$DB \\\\\n        --query ${fasta_name} \\\\\n        --outfmt ${outfmt} ${columns} \\\\\n        ${args} \\\\\n        --out ${prefix}.${out_ext} \\\\\n        --log\n\n    mv diamond.log ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        diamond: \\$(diamond --version 2>&1 | tail -n 1 | sed 's/^diamond version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    switch ( out_ext ) {\n        case \"blast\": outfmt = 0; break\n        case \"xml\": outfmt = 5; break\n        case \"txt\": outfmt = 6; break\n        case \"daa\": outfmt = 100; break\n        case \"sam\": outfmt = 101; break\n        case \"tsv\": outfmt = 102; break\n        case \"paf\": outfmt = 103; break\n        default:\n            outfmt = '6';\n            out_ext = 'txt';\n            log.warn(\"Unknown output file format provided (${out_ext}): selecting DIAMOND default of tabular BLAST output (txt)\");\n            break\n    }\n\n    \"\"\"\n    touch ${prefix}.${out_ext}\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        diamond: \\$(diamond --version 2>&1 | tail -n 1 | sed 's/^diamond version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Builds a DIAMOND database\nTags: fasta, diamond, index, database", "answer": "process DIAMOND_MAKEDB {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/diamond:2.1.8--h43eeafb_0' :\n        'biocontainers/diamond:2.1.8--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path taxonmap\n    path taxonnodes\n    path taxonnames\n\n    output:\n    tuple val(meta), path(\"*.dmnd\"), emit: db\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args              = task.ext.args ?: ''\n    def prefix            = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed     = fasta.getExtension() == \"gz\" ? true : false\n    def fasta_name        = is_compressed ? fasta.getBaseName() : fasta\n    def insert_taxonmap   = taxonmap ? \"--taxonmap $taxonmap\" : \"\"\n    def insert_taxonnodes = taxonnodes ? \"--taxonnodes $taxonnodes\" : \"\"\n    def insert_taxonnames = taxonnames ? \"--taxonnames $taxonnames\" : \"\"\n\n    \"\"\"\n    if [ \"${is_compressed}\" == \"true\" ]; then\n        gzip -c -d ${fasta} > ${fasta_name}\n    fi\n\n    diamond \\\\\n        makedb \\\\\n        --threads ${task.cpus} \\\\\n        --in  ${fasta_name} \\\\\n        -d ${prefix} \\\\\n        ${args} \\\\\n        ${insert_taxonmap} \\\\\n        ${insert_taxonnodes} \\\\\n        ${insert_taxonnames}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        diamond: \\$(diamond --version 2>&1 | tail -n 1 | sed 's/^diamond version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.dmnd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        diamond: \\$(diamond --version 2>&1 | tail -n 1 | sed 's/^diamond version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: convert between genome builds\nTags: bed, ucsc, ucsc/liftover", "answer": "process UCSC_LIFTOVER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ucsc-liftover:377--h0b8a92a_3' :\n        'biocontainers/ucsc-liftover:377--h0b8a92a_3' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path(chain)\n\n    output:\n    tuple val(meta), path(\"*.lifted.bed\")  , emit: lifted\n    tuple val(meta), path(\"*.unlifted.bed\"), emit: unlifted\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '377' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    liftOver \\\\\n        $args \\\n        $bed \\\\\n        $chain \\\\\n        ${prefix}.lifted.bed \\\\\n        ${prefix}.unlifted.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: compute average score of bigwig over bed file\nTags: gtf, genepred, refflat, ucsc, gtftogenepred", "answer": "process UCSC_GTFTOGENEPRED {\n    tag \"${meta.id}\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ucsc-gtftogenepred:447--h954228d_0':\n        'biocontainers/ucsc-gtftogenepred:447--h954228d_0' }\"\n\n    input:\n    tuple val(meta), path(gtf)\n\n    output:\n    tuple val(meta), path(\"*.genepred\"), emit: genepred\n    tuple val(meta), path(\"*.refflat\") , emit: refflat , optional: true\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def gen_refflat = args.contains(\"-genePredExt\") && args.contains(\"-geneNameAsName2\") ? \"true\" : \"false\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '447' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    gtfToGenePred \\\\\n        $args \\\\\n        $gtf  \\\\\n        ${prefix}.genepred\n\n    if [ \"${gen_refflat}\" == \"true\" ] ; then\n        awk 'BEGIN { OFS=\"\\\\t\"} {print \\$12, \\$1, \\$2, \\$3, \\$4, \\$5, \\$6, \\$7, \\$8, \\$9, \\$10}' ${prefix}.genepred > ${prefix}.refflat\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '447'\n    \"\"\"\n    touch ${prefix}.genepred\n    touch ${prefix}.refflat\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Remove lines from bed file that refer to off-chromosome locations.\nTags: bed, genomics, ucsc", "answer": "process UCSC_BEDCLIP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ucsc-bedclip:377--h0b8a92a_2' :\n        'biocontainers/ucsc-bedclip:377--h0b8a92a_2' }\"\n\n    input:\n    tuple val(meta), path(bedgraph)\n    path  sizes\n\n    output:\n    tuple val(meta), path(\"*.bedGraph\"), emit: bedgraph\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '377' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    bedClip \\\\\n        $bedgraph \\\\\n        $sizes \\\\\n        ${prefix}.bedGraph\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '377' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.bedGraph\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert a bedGraph file to bigWig format.\nTags: bedgraph, bigwig, ucsc, bedgraphtobigwig, converter", "answer": "process UCSC_BEDGRAPHTOBIGWIG {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ucsc-bedgraphtobigwig:445--h954228d_0' :\n        'biocontainers/ucsc-bedgraphtobigwig:445--h954228d_0' }\"\n\n    input:\n    tuple val(meta), path(bedgraph)\n    path  sizes\n\n    output:\n    tuple val(meta), path(\"*.bigWig\"), emit: bigwig\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '445' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    bedGraphToBigWig \\\\\n        $bedgraph \\\\\n        $sizes \\\\\n        ${prefix}.bigWig\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '445' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.bigWig\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert ascii format wig file to binary big wig format\nTags: wig, bigwig, ucsc", "answer": "process UCSC_WIGTOBIGWIG {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ucsc-wigtobigwig:447--h2a80c09_1' :\n        'biocontainers/ucsc-wigtobigwig:447--h2a80c09_1' }\"\n\n    input:\n    tuple val(meta), path(wig)\n    path sizes\n\n    output:\n    tuple val(meta), path(\"*.bw\"), emit: bw\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '447' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    wigToBigWig \\\\\n        $args \\\\\n        $wig \\\\\n        $sizes \\\\\n        ${prefix}.bw\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '447' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.bw\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: compute average score of bigwig over bed file\nTags: bigwig, bedGraph, ucsc", "answer": "process UCSC_BIGWIGAVERAGEOVERBED {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ucsc-bigwigaverageoverbed:377--h0b8a92a_2' :\n        'biocontainers/ucsc-bigwigaverageoverbed:377--h0b8a92a_2' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path bigwig\n\n    output:\n    tuple val(meta), path(\"*.tab\"), emit: tab\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '377' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    // BUG: bigWigAverageOverBed cannot handle ensembl seqlevels style\n    \"\"\"\n    bigWigAverageOverBed \\\\\n        $args \\\\\n        $bigwig \\\\\n        $bed \\\\\n        ${prefix}.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '377' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert file from bed to bigBed format\nTags: bed, bigbed, ucsc, bedtobigbed, converter", "answer": "process UCSC_BEDTOBIGBED {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ucsc-bedtobigbed:447--h954228d_0' :\n        'biocontainers/ucsc-bedtobigbed:447--h954228d_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path  sizes\n    path  autosql\n\n    output:\n    tuple val(meta), path(\"*.bigBed\"), emit: bigbed\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def as_option = autosql ? \"-as=${autosql}\" : \"\"\n    def VERSION = '447' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    bedToBigBed \\\\\n        $bed \\\\\n        $sizes \\\\\n        $as_option \\\\\n        $args \\\\\n        ${prefix}.bigBed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '447' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.bigBed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ucsc: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GangSTR is a tool for genome-wide profiling tandem repeats from short reads.\nTags: gangstr, STR, bam, cram, vcf", "answer": "process GANGSTR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gangstr:2.5.0--h48cf4b7_4':\n        'biocontainers/gangstr:2.5.0--h48cf4b7_4' }\"\n\n    input:\n    tuple val(meta), path(alignment_files), path(alignment_indices), path(ref_regions)\n    path(fasta)\n    path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf\")              , emit: vcf\n    tuple val(meta), path(\"*.samplestats.tab\")  , emit: samplestats\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def input = alignment_files.join(\",\")\n\n    \"\"\"\n    GangSTR \\\\\n        --bam ${input} \\\\\n        --ref ${fasta} \\\\\n        --regions ${ref_regions} \\\\\n        --out ${prefix} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gangstr: \\$(echo \\$(GangSTR --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a schema to determine the allelic profiles of a genome\nTags: cgMLST, WGS, genomics", "answer": "process CHEWBBACA_CREATESCHEMA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/chewbbaca:3.3.5--pyhdfd78af_0':\n        'biocontainers/chewbbaca:3.3.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta, stageAs: \"input_genomes/*\")\n    path prodigal_tf\n    path cds\n\n    output:\n    tuple val(meta), path(\"results/$meta.id\"), emit: schema\n    path \"results/cds_coordinates.tsv\"       , emit: cds_coordinates\n    path \"results/invalid_cds.txt\"           , emit: invalid_cds\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def schema = \"--n ${prefix}\"\n    def prodigal_tf = prodigal_tf ? \"--ptf ${prodigal_tf}\" : \"\"\n    def cds = cds ? \"--cds ${cds}\" : \"\"\n\n    \"\"\"\n    find ./input_genomes/ -name \"*.gz\" | sed 's/.gz//' | xargs -I {} bash -c 'gzip -cdf {}.gz > {}'\n\n    chewie \\\\\n        CreateSchema \\\\\n        -i input_genomes/ \\\\\n        -o results \\\\\n        $schema \\\\\n        $args \\\\\n        $prodigal_tf \\\\\n        $cds \\\\\n        --cpu $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        chewbbaca: \\$(echo \\$(chewie --version 2>&1 | sed 's/^.*chewBBACA version: //g; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def schema = \"--n ${prefix}\"\n\n    \"\"\"\n    mkdir -p results/$meta.id/short/\n    touch results/$meta.id/contigs-protein{1..*}.fasta\n    touch results/$meta.id/.genes_list\n    touch results/$meta.id/.schema_config\n    touch results/$meta.id/short/contigs-protein{1..*}_short.fasta\n    touch results/cds_coordinates.tsv\n    touch results/invalid_cds.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        chewbbaca: \\$(echo \\$(chewie --version 2>&1 | sed 's/^.*chewBBACA version: //g; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create MD5 (128-bit) checksums\nTags: checksum, MD5, 128 bit", "answer": "process MD5SUM {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:20.04' :\n        'nf-core/ubuntu:20.04' }\"\n\n    input:\n    tuple val(meta), path(files)\n    val as_separate_files\n\n    output:\n    tuple val(meta), path(\"*.md5\"), emit: checksum\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\" // will only use when as_separate_files = false\n    if ( as_separate_files ) {\n        \"\"\"\n        find -L * -maxdepth 0 -type f \\\\\n            ! -name '*.md5' \\\\\n            -exec sh -c 'md5sum $args \"\\$1\" > \"\\$1.md5\"' _ \"{}\" \\\\;\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            md5sum: \\$( md5sum --version | sed '1!d; s/.* //' )\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        find -L * -type f \\\\\n            ! -name '*.md5' \\\\\n            -exec md5sum $args \"{}\" + \\\\\n            > ${prefix}.md5\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            md5sum: \\$( md5sum --version | sed '1!d; s/.* //' )\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if ( as_separate_files ) {\n        \"\"\"\n        find -L * -type f \\\\\n            ! -name '*.md5' \\\\\n            -exec sh -c 'touch \"\\$1.md5\"' _ \"{}\" \\\\;\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            md5sum: \\$( md5sum --version | sed '1!d; s/.* //' )\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        touch ${prefix}.md5\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            md5sum: \\$( md5sum --version | sed '1!d; s/.* //' )\n        END_VERSIONS\n        \"\"\"\n    }\n\n}\n"}
{"question": "Description: A tool that mines antimicrobial peptides (AMPs) from (meta)genomes by predicting peptides from genomes (provided as contigs) and outputs all the predicted anti-microbial peptides found.\nTags: AMP, antimicrobial peptides, genome mining, metagenomes, peptide prediction", "answer": "process MACREL_CONTIGS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/macrel:1.2.0--pyh5e36f6f_0':\n        'biocontainers/macrel:1.2.0--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*/*.smorfs.faa.gz\")      , emit: smorfs\n    tuple val(meta), path(\"*/*.all_orfs.faa.gz\")    , emit: all_orfs\n    tuple val(meta), path(\"*/*.prediction.gz\")      , emit: amp_prediction\n    tuple val(meta), path(\"*/*.md\")                 , emit: readme_file\n    tuple val(meta), path(\"*/*_log.txt\")            , emit: log_file\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    macrel contigs \\\\\n        $args \\\\\n        --fasta $fasta \\\\\n        --output ${prefix}/ \\\\\n        --tag ${prefix} \\\\\n        --log-file ${prefix}/${prefix}_log.txt \\\\\n        --threads $task.cpus\n\n    gzip --no-name ${prefix}/*.faa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        macrel: \\$(echo \\$(macrel --version | sed 's/macrel //g'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A program to convert bam into paf.\nTags: paf, bam, conversion", "answer": "process PAFTOOLS_SAM2PAF {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // Note: the versions here need to match the versions used in the mulled container below and minimap2/index\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-66534bcbb7031a148b13e2ad42583020b9cd25c4:1679e915ddb9d6b4abda91880c4b48857d471bd8-0' :\n        'biocontainers/mulled-v2-66534bcbb7031a148b13e2ad42583020b9cd25c4:1679e915ddb9d6b4abda91880c4b48857d471bd8-0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), file(\"*.paf\")      , emit: paf\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args     ?: \"\"\n    def prefix  = task.ext.prefix   ?: \"${meta.id}\"\n\n    \"\"\"\n    samtools view -h ${bam} | paftools.js sam2paf - > ${prefix}.paf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paftools.js: \\$(paftools.js --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix   ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.paf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paftools.js: \\$(paftools.js --version)\n    END VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs fastq alignment to a reference using NARFMAP\nTags: alignment, map, fastq, bam, sam", "answer": "process NARFMAP_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/narfmap_align:8bad41386eab9997':\n        'community.wave.seqera.io/library/narfmap_align:517a1fed8e4e84c1' }\"\n\n    input:\n    tuple val(meta) , path(reads)\n    tuple val(meta2), path(hashmap)\n    tuple val(meta3), path(fasta)\n    val   sort_bam\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path('*.log'), emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads_command       = meta.single_end ? \"-1 $reads\" : \"-1 ${reads[0]} -2 ${reads[1]}\"\n    def samtools_command    = sort_bam ? 'sort' : 'view'\n    def extension_pattern   = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher   =  (args2 =~ extension_pattern)\n    def extension           = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference           = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    \"\"\"\n    dragen-os \\\\\n        -r $hashmap \\\\\n        $args \\\\\n        --num-threads $task.cpus \\\\\n        $reads_command \\\\\n        2> >(tee ${prefix}.narfmap.log >&2) \\\\\n        | samtools $samtools_command $args2 --threads $task.cpus ${reference} -o ${prefix}.${extension} -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        narfmap: \\$(echo \\$(dragen-os --version 2>&1))\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads_command = meta.single_end ? \"-1 $reads\" : \"-1 ${reads[0]} -2 ${reads[1]}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    def extension_pattern = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher =  (args2 =~ extension_pattern)\n    def extension = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    def create_index = \"\"\n    if (extension == \"cram\") {\n        create_index = \"touch ${prefix}.crai\"\n    } else if (extension == \"bam\") {\n        create_index = \"touch ${prefix}.csi\"\n    }\n\n    \"\"\"\n    touch ${prefix}.${extension}\n    ${create_index}\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        narfmap: \\$(echo \\$(dragen-os --version 2>&1))\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create DRAGEN hashtable for reference genome\nTags: index, fasta, genome, reference", "answer": "process NARFMAP_HASHTABLE {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/narfmap:1.4.2--h43eeafb_0':\n        'biocontainers/narfmap:1.4.2--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"narfmap\")    , emit: hashmap\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir narfmap\n    dragen-os \\\\\n        --build-hash-table true \\\\\n        --ht-reference $fasta \\\\\n        --output-directory narfmap \\\\\n        $args \\\\\n        --ht-num-threads $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        narfmap: \\$(echo \\$(dragen-os --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir narfmap\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        narfmap: \\$(echo \\$(dragen-os --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: A module for concatenation of gzipped or uncompressed files\nTags: concatenate, gzip, cat", "answer": "process CAT_CAT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pigz:2.3.4' :\n        'biocontainers/pigz:2.3.4' }\"\n\n    input:\n    tuple val(meta), path(files_in)\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: file_out\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def file_list = files_in.collect { it.toString() }\n\n    // choose appropriate concatenation tool depending on input and output format\n\n    // | input     | output     | command1 | command2 |\n    // |-----------|------------|----------|----------|\n    // | gzipped   | gzipped    | cat      |          |\n    // | ungzipped | ungzipped  | cat      |          |\n    // | gzipped   | ungzipped  | zcat     |          |\n    // | ungzipped | gzipped    | cat      | pigz     |\n\n    // Use input file ending as default\n    prefix   = task.ext.prefix ?: \"${meta.id}${getFileSuffix(file_list[0])}\"\n    out_zip  = prefix.endsWith('.gz')\n    in_zip   = file_list[0].endsWith('.gz')\n    command1 = (in_zip && !out_zip) ? 'zcat' : 'cat'\n    command2 = (!in_zip && out_zip) ? \"| pigz -c -p $task.cpus $args2\" : ''\n    if(file_list.contains(prefix.trim())) {\n        error \"The name of the input file can't be the same as for the output prefix in the \" +\n        \"module CAT_CAT (currently `$prefix`). Please choose a different one.\"\n    }\n    \"\"\"\n    $command1 \\\\\n        $args \\\\\n        ${file_list.join(' ')} \\\\\n        $command2 \\\\\n        > ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def file_list   = files_in.collect { it.toString() }\n    prefix          = task.ext.prefix ?: \"${meta.id}${file_list[0].substring(file_list[0].lastIndexOf('.'))}\"\n    if(file_list.contains(prefix.trim())) {\n        error \"The name of the input file can't be the same as for the output prefix in the \" +\n        \"module CAT_CAT (currently `$prefix`). Please choose a different one.\"\n    }\n    \"\"\"\n    touch $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n}\n\n// for .gz files also include the second to last extension if it is present. E.g., .fasta.gz\ndef getFileSuffix(filename) {\n    def match = filename =~ /^.*?((\\.\\w{1,5})?(\\.\\w{1,5}\\.gz$))/\n    return match ? match[0][1] : filename.substring(filename.lastIndexOf('.'))\n}\n"}
{"question": "Description: Concatenates fastq files\nTags: cat, fastq, concatenate", "answer": "process CAT_FASTQ {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:20.04' :\n        'nf-core/ubuntu:20.04' }\"\n\n    input:\n    tuple val(meta), path(reads, stageAs: \"input*/*\")\n\n    output:\n    tuple val(meta), path(\"*.merged.fastq.gz\"), emit: reads\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def readList = reads instanceof List ? reads.collect{ it.toString() } : [reads.toString()]\n    if (meta.single_end) {\n        if (readList.size >= 1) {\n            \"\"\"\n            cat ${readList.join(' ')} > ${prefix}.merged.fastq.gz\n\n            cat <<-END_VERSIONS > versions.yml\n            \"${task.process}\":\n                cat: \\$(echo \\$(cat --version 2>&1) | sed 's/^.*coreutils) //; s/ .*\\$//')\n            END_VERSIONS\n            \"\"\"\n        }\n    } else {\n        if (readList.size >= 2) {\n            def read1 = []\n            def read2 = []\n            readList.eachWithIndex{ v, ix -> ( ix & 1 ? read2 : read1 ) << v }\n            \"\"\"\n            cat ${read1.join(' ')} > ${prefix}_1.merged.fastq.gz\n            cat ${read2.join(' ')} > ${prefix}_2.merged.fastq.gz\n\n            cat <<-END_VERSIONS > versions.yml\n            \"${task.process}\":\n                cat: \\$(echo \\$(cat --version 2>&1) | sed 's/^.*coreutils) //; s/ .*\\$//')\n            END_VERSIONS\n            \"\"\"\n        }\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def readList = reads instanceof List ? reads.collect{ it.toString() } : [reads.toString()]\n    if (meta.single_end) {\n        if (readList.size >= 1) {\n            \"\"\"\n            echo '' | gzip > ${prefix}.merged.fastq.gz\n\n            cat <<-END_VERSIONS > versions.yml\n            \"${task.process}\":\n                cat: \\$(echo \\$(cat --version 2>&1) | sed 's/^.*coreutils) //; s/ .*\\$//')\n            END_VERSIONS\n            \"\"\"\n        }\n    } else {\n        if (readList.size >= 2) {\n            \"\"\"\n            echo '' | gzip > ${prefix}_1.merged.fastq.gz\n            echo '' | gzip > ${prefix}_2.merged.fastq.gz\n\n            cat <<-END_VERSIONS > versions.yml\n            \"${task.process}\":\n                cat: \\$(echo \\$(cat --version 2>&1) | sed 's/^.*coreutils) //; s/ .*\\$//')\n            END_VERSIONS\n            \"\"\"\n        }\n    }\n}\n"}
{"question": "Description: CIRCexplorer2 parses fusion junction files from multiple aligners to prepare them for CIRCexplorer2 annotate.\nTags: parse, circrna, splice", "answer": "process CIRCEXPLORER2_PARSE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/circexplorer2:2.3.8--pyh864c0ab_1':\n        'biocontainers/circexplorer2:2.3.8--pyh864c0ab_1' }\"\n\n    input:\n    tuple val(meta), path(fusions)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: junction\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def aligner = \"${fusions}\".endsWith(\".junction\") ? \"-t STAR\" : \"${fusions}\".endsWith(\".txt\") ? \"-t MapSplice\" : \"${fusions}\".endsWith(\".bam\") ? \"-t BWA\" : \"-t segemehl\"\n    if (\"${fusions}\" == \"${prefix}.bed\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    CIRCexplorer2 \\\\\n        parse \\\\\n        $aligner \\\\\n        $fusions \\\\\n        -b ${prefix}.bed \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        circexplorer2: \\$( echo \\$(CIRCexplorer2 --version 2>&1) )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        circexplorer2: \\$( echo \\$(CIRCexplorer2 --version 2>&1) )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Annotate circRNAs detected in the output from CIRCexplorer2 parse\nTags: circrna, annotate", "answer": "process CIRCEXPLORER2_ANNOTATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/circexplorer2:2.3.8--pyh864c0ab_1':\n        'biocontainers/circexplorer2:2.3.8--pyh864c0ab_1' }\"\n\n    input:\n    tuple val(meta), path(junctions)\n    path(fasta)\n    path(gene_annotation)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    CIRCexplorer2 \\\\\n        annotate \\\\\n        -r $gene_annotation \\\\\n        -g $fasta \\\\\n        -b $junctions \\\\\n        -o ${prefix}.txt \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        circexplorer2: \\$(echo \\$(CIRCexplorer2 --version 2>&1) )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        circexplorer2: \\$(echo \\$(CIRCexplorer2 --version 2>&1) )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Datavzrd is a tool to create visual HTML reports from collections of CSV/TSV tables.\nTags: visualisation, tsv, csv", "answer": "process DATAVZRD {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/datavzrd:2.36.12--bb93c8c988b7a9af':\n        'community.wave.seqera.io/library/datavzrd:2.36.12--593eb75e566b7f2a' }\"\n\n    input:\n    tuple val(meta), file(config_file), file(table)\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: report\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    datavzrd \\\\\n        ${args} \\\\\n        ${config_file} \\\\\n        --output ${prefix} \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        datavzrd: \\$(echo \\$( datavzrd --version | sed -e 's/[^0-9.]//g' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    mkdir ${prefix}/static\n    mkdir ${prefix}/network\n    mkdir ${prefix}/network/data\n    mkdir ${prefix}/network/plots\n    touch ./${prefix}/index.html\n    touch ./${prefix}/static/bootstrap.min.css\n    touch ./${prefix}/static/bootstrap-select.min.css\n    touch ./${prefix}/static/bootstrap-table.min.css\n    touch ./${prefix}/static/bootstrap-table-fixed-columns.min.css\n    touch ./${prefix}/static/bundle.js\n    touch ./${prefix}/static/datavzrd.css\n    touch ./${prefix}/network/index_1.html\n    touch ./${prefix}/network/config.js\n    touch ./${prefix}/network/functions.js\n    touch ./${prefix}/network/heatmap.js\n    touch ./${prefix}/network/data/data_1.js\n    touch ./${prefix}/network/plots/plot_0.js\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        datavzrd: \\$(echo \\$( datavzrd --version | sed -e 's/[^0-9.]//g' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: normalizes variants in a VCF file\nTags: normalization, vcf, snps, indels", "answer": "\n\nprocess VT_NORMALIZE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vt:2015.11.10--h5ef6573_4':\n        'biocontainers/vt:2015.11.10--h5ef6573_4' }\"\n\n    input:\n    tuple val(meta) , path(vcf), path(tbi), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")       , emit: vcf\n    tuple val(meta), path(\"${fasta}.fai\")   , emit: fai, optional: true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions = intervals ? \"-i ${intervals}\" : \"\"\n\n    if (\"$vcf\" == \"${prefix}.vcf\" || \"$vcf\" == \"${prefix}.vcf.gz\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n\n    def VERSION = \"2015.11.10\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    vt normalize \\\\\n        -o ${prefix}.vcf \\\\\n        -r ${fasta} \\\\\n        ${regions} \\\\\n        ${args} \\\\\n        ${vcf}\n\n    bgzip ${args2} --threads ${task.cpus} ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vt: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$vcf\" == \"${prefix}.vcf\" || \"$vcf\" == \"${prefix}.vcf.gz\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n\n    def VERSION = \"2015.11.10\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vt: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: decomposes multiallelic variants into biallelic in a VCF file.\nTags: decompose, multiallelic, small variants, snps, indels", "answer": "process VT_DECOMPOSE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vt:2015.11.10--h5ef6573_4':\n        'biocontainers/vt:2015.11.10--h5ef6573_4' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(intervals)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")   , emit: vcf\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$vcf\" == \"${prefix}.vcf\" || \"$vcf\" == \"${prefix}.vcf.gz\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n\n    def bed = intervals ? \"-i ${intervals}\" : \"\"\n    def VERSION = \"2015.11.10\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    vt decompose \\\\\n        -o ${prefix}.vcf \\\\\n        ${bed} \\\\\n        ${args} \\\\\n        ${vcf}\n\n    bgzip ${args2} --threads ${task.cpus} ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vt: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$vcf\" == \"${prefix}.vcf\" || \"$vcf\" == \"${prefix}.vcf.gz\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n\n    def VERSION = \"2015.11.10\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vt: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculte TIN (transcript integrity number) from RNA-seq reads\nTags: rnaseq, transcript, integrity", "answer": "process RSEQC_TIN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rseqc:5.0.3--py39hf95cd2a_0' :\n        'biocontainers/rseqc:5.0.3--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path  bed\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    tuple val(meta), path(\"*.xls\"), emit: xls\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    tin.py \\\\\n        -i $bam \\\\\n        -r $bed \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(tin.py --version | sed -e \"s/tin.py //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${bam.fileName}.summary.txt\n    touch ${bam.fileName}.tin.xls\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(tin.py --version | sed -e \"s/tin.py //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate how mapped reads are distributed over genomic features\nTags: read distribution, genomics, rnaseq", "answer": "process RSEQC_READDISTRIBUTION {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rseqc:5.0.3--py39hf95cd2a_0' :\n        'biocontainers/rseqc:5.0.3--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  bed\n\n    output:\n    tuple val(meta), path(\"*.read_distribution.txt\"), emit: txt\n    path  \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    read_distribution.py \\\\\n        -i $bam \\\\\n        -r $bed \\\\\n        > ${prefix}.read_distribution.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(read_distribution.py --version | sed -e \"s/read_distribution.py //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.read_distribution.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(read_distribution.py --version | sed -e \"s/read_distribution.py //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: compare detected splice junctions to reference gene model\nTags: junctions, splicing, rnaseq", "answer": "process RSEQC_JUNCTIONSATURATION {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rseqc:5.0.3--py39hf95cd2a_0' :\n        'biocontainers/rseqc:5.0.3--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  bed\n\n    output:\n    tuple val(meta), path(\"*.pdf\"), emit: pdf\n    tuple val(meta), path(\"*.r\")  , emit: rscript\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    junction_saturation.py \\\\\n        -i $bam \\\\\n        -r $bed \\\\\n        -o $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(junction_saturation.py --version | sed -e \"s/junction_saturation.py //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.junctionSaturation_plot.pdf\n    touch ${prefix}.junctionSaturation_plot.r\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(junction_saturation.py --version | sed -e \"s/junction_saturation.py //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate read duplication rate\nTags: rnaseq, duplication, sequence-based, mapping-based", "answer": "process RSEQC_READDUPLICATION {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rseqc:5.0.3--py39hf95cd2a_0' :\n        'biocontainers/rseqc:5.0.3--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*seq.DupRate.xls\"), emit: seq_xls\n    tuple val(meta), path(\"*pos.DupRate.xls\"), emit: pos_xls\n    tuple val(meta), path(\"*.pdf\")           , emit: pdf\n    tuple val(meta), path(\"*.r\")             , emit: rscript\n    path  \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    read_duplication.py \\\\\n        -i $bam \\\\\n        -o $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(read_duplication.py --version | sed -e \"s/read_duplication.py //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.seq.DupRate.xls\n    touch ${prefix}.pos.DupRate.xls\n    touch ${prefix}.DupRate_plot.pdf\n    touch ${prefix}.DupRate_plot.r\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(read_duplication.py --version | sed -e \"s/read_duplication.py //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Infer strandedness from sequencing reads\nTags: rnaseq, strandedness, experiment", "answer": "process RSEQC_INFEREXPERIMENT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rseqc:5.0.3--py39hf95cd2a_0' :\n        'biocontainers/rseqc:5.0.3--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  bed\n\n    output:\n    tuple val(meta), path(\"*.infer_experiment.txt\"), emit: txt\n    path  \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    infer_experiment.py \\\\\n        -i $bam \\\\\n        -r $bed \\\\\n        $args \\\\\n        > ${prefix}.infer_experiment.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(infer_experiment.py --version | sed -e \"s/infer_experiment.py //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.infer_experiment.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(infer_experiment.py --version | sed -e \"s/infer_experiment.py //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate statistics from a bam file\nTags: bam, qc, bamstat", "answer": "process RSEQC_BAMSTAT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rseqc:5.0.3--py39hf95cd2a_0' :\n        'biocontainers/rseqc:5.0.3--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam_stat.txt\"), emit: txt\n    path  \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bam_stat.py \\\\\n        -i $bam \\\\\n        $args \\\\\n        > ${prefix}.bam_stat.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(bam_stat.py --version | sed -e \"s/bam_stat.py //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam_stat.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(bam_stat.py --version | sed -e \"s/bam_stat.py //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate inner distance between read pairs.\nTags: read_pairs, fragment_size, inner_distance", "answer": "process RSEQC_INNERDISTANCE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rseqc:5.0.3--py39hf95cd2a_0' :\n        'biocontainers/rseqc:5.0.3--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  bed\n\n    output:\n    tuple val(meta), path(\"*distance.txt\"), optional:true, emit: distance\n    tuple val(meta), path(\"*freq.txt\")    , optional:true, emit: freq\n    tuple val(meta), path(\"*mean.txt\")    , optional:true, emit: mean\n    tuple val(meta), path(\"*.pdf\")        , optional:true, emit: pdf\n    tuple val(meta), path(\"*.r\")          , optional:true, emit: rscript\n    path  \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (!meta.single_end) {\n        \"\"\"\n        inner_distance.py \\\\\n            -i $bam \\\\\n            -r $bed \\\\\n            -o $prefix \\\\\n            $args \\\\\n            > stdout.txt\n        head -n 2 stdout.txt > ${prefix}.inner_distance_mean.txt\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            rseqc: \\$(inner_distance.py --version | sed -e \"s/inner_distance.py //g\")\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            rseqc: \\$(inner_distance.py --version | sed -e \"s/inner_distance.py //g\")\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.inner_distance.txt\n    touch ${prefix}.inner_distance_freq.txt\n    touch ${prefix}.inner_distance_mean.txt\n    touch ${prefix}.inner_distance_plot.pdf\n    touch ${prefix}.inner_distance_plot.r\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(inner_distance.py --version | sed -e \"s/inner_distance.py //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: compare detected splice junctions to reference gene model\nTags: junctions, splicing, rnaseq", "answer": "process RSEQC_JUNCTIONANNOTATION {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rseqc:5.0.3--py39hf95cd2a_0' :\n        'biocontainers/rseqc:5.0.3--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  bed\n\n    output:\n    tuple val(meta), path(\"*.xls\")         , emit: xls\n    tuple val(meta), path(\"*.r\")           , emit: rscript\n    tuple val(meta), path(\"*.log\")         , emit: log\n    tuple val(meta), path(\"*.junction.bed\"), optional:true, emit: bed\n    tuple val(meta), path(\"*.Interact.bed\"), optional:true, emit: interact_bed\n    tuple val(meta), path(\"*junction.pdf\") , optional:true, emit: pdf\n    tuple val(meta), path(\"*events.pdf\")   , optional:true, emit: events_pdf\n    path  \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    junction_annotation.py \\\\\n        -i $bam \\\\\n        -r $bed \\\\\n        -o $prefix \\\\\n        $args \\\\\n        2> >(grep -v 'E::idx_find_and_load' | tee ${prefix}.junction_annotation.log >&2)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(junction_annotation.py --version | sed -e \"s/junction_annotation.py //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.junction.xls\n    touch ${prefix}.junction_plot.r\n    touch ${prefix}.junction_annotation.log\n    touch ${prefix}.junction.bed\n    touch ${prefix}.Interact.bed\n    touch ${prefix}.junction.pdf\n    touch ${prefix}.events.pdf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rseqc: \\$(junction_annotation.py --version | sed -e \"s/junction_annotation.py //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: FastK based version of Merqury\nTags: Merqury, reference-free, assembly evaluation", "answer": "process MERQURYFK_MERQURYFK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container 'ghcr.io/nbisweden/fastk_genescopefk_merquryfk:1.2'\n\n    input:\n    tuple val(meta), path(fastk_hist), path(fastk_ktab), path(assembly), path(haplotigs)\n\n    output:\n    tuple val(meta), path(\"${prefix}.completeness.stats\") , emit: stats\n    tuple val(meta), path(\"${prefix}.*_only.bed\")         , emit: bed\n    tuple val(meta), path(\"${prefix}.*.qv\")               , emit: assembly_qv\n    tuple val(meta), path(\"${prefix}.*.spectra-cn.fl.png\"), emit: spectra_cn_fl_png,  optional: true\n    tuple val(meta), path(\"${prefix}.*.spectra-cn.fl.pdf\"), emit: spectra_cn_fl_pdf,  optional: true\n    tuple val(meta), path(\"${prefix}.*.spectra-cn.ln.png\"), emit: spectra_cn_ln_png,  optional: true\n    tuple val(meta), path(\"${prefix}.*.spectra-cn.ln.pdf\"), emit: spectra_cn_ln_pdf,  optional: true\n    tuple val(meta), path(\"${prefix}.*.spectra-cn.st.png\"), emit: spectra_cn_st_png,  optional: true\n    tuple val(meta), path(\"${prefix}.*.spectra-cn.st.pdf\"), emit: spectra_cn_st_pdf,  optional: true\n    tuple val(meta), path(\"${prefix}.qv\")                 , emit: qv\n    tuple val(meta), path(\"${prefix}.spectra-asm.fl.png\") , emit: spectra_asm_fl_png, optional: true\n    tuple val(meta), path(\"${prefix}.spectra-asm.fl.pdf\") , emit: spectra_asm_fl_pdf, optional: true\n    tuple val(meta), path(\"${prefix}.spectra-asm.ln.png\") , emit: spectra_asm_ln_png, optional: true\n    tuple val(meta), path(\"${prefix}.spectra-asm.ln.pdf\") , emit: spectra_asm_ln_pdf, optional: true\n    tuple val(meta), path(\"${prefix}.spectra-asm.st.png\") , emit: spectra_asm_st_png, optional: true\n    tuple val(meta), path(\"${prefix}.spectra-asm.st.pdf\") , emit: spectra_asm_st_pdf, optional: true\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"MERQURYFK_MERQURYFK module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FASTK_VERSION = 'f18a4e6d2207539f7b84461daebc54530a9559b0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def MERQURY_VERSION = '8ae344092df5dcaf83cfb7f90f662597a9b1fc61' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    MerquryFK \\\\\n        $args \\\\\n        -T$task.cpus \\\\\n        ${fastk_ktab.find{ it.toString().endsWith(\".ktab\") }} \\\\\n        $assembly \\\\\n        $haplotigs \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastk: $FASTK_VERSION\n        merquryfk: $MERQURY_VERSION\n        r: \\$( R --version | sed '1!d; s/.*version //; s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A reimplemenation of Kat Comp to work with FastK databases\nTags: fastk, k-mer, compare", "answer": "process MERQURYFK_KATCOMP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container 'ghcr.io/nbisweden/fastk_genescopefk_merquryfk:1.2'\n\n    input:\n    tuple val(meta), path(fastk1_hist), path(fastk1_ktab), path(fastk2_hist), path(fastk2_ktab)\n\n    output:\n    tuple val(meta), path(\"*.fi.png\"), emit: filled_png , optional: true\n    tuple val(meta), path(\"*.ln.png\"), emit: line_png   , optional: true\n    tuple val(meta), path(\"*.st.png\"), emit: stacked_png, optional: true\n    tuple val(meta), path(\"*.fi.pdf\"), emit: filled_pdf , optional: true\n    tuple val(meta), path(\"*.ln.pdf\"), emit: line_pdf   , optional: true\n    tuple val(meta), path(\"*.st.pdf\"), emit: stacked_pdf, optional: true\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"MERQURYFK_KATCOMP module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FASTK_VERSION = 'f18a4e6d2207539f7b84461daebc54530a9559b0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def MERQURY_VERSION = '8f3ab706e4cf4d7b7d1dfe5739859e3ebd26c494' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    KatComp \\\\\n        $args \\\\\n        -T$task.cpus \\\\\n        ${fastk1_ktab.find{ it.toString().endsWith(\".ktab\") }} \\\\\n        ${fastk2_ktab.find{ it.toString().endsWith(\".ktab\") }} \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastk: $FASTK_VERSION\n        merquryfk: $MERQURY_VERSION\n        r: \\$( R --version | sed '1!d; s/.*version //; s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A reimplemenation of KatGC to work with FastK databases\nTags: k-mer frequency, GC content, 3D heat map, contour map", "answer": "process MERQURYFK_KATGC {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container 'ghcr.io/nbisweden/fastk_genescopefk_merquryfk:1.2'\n\n    input:\n    tuple val(meta), path(fastk_hist), path(fastk_ktab)\n\n    output:\n    tuple val(meta), path(\"*.fi.png\"), emit: filled_gc_plot_png , optional: true\n    tuple val(meta), path(\"*.fi.pdf\"), emit: filled_gc_plot_pdf , optional: true\n    tuple val(meta), path(\"*.ln.png\"), emit: line_gc_plot_png   , optional: true\n    tuple val(meta), path(\"*.ln.pdf\"), emit: line_gc_plot_pdf   , optional: true\n    tuple val(meta), path(\"*.st.png\"), emit: stacked_gc_plot_png, optional: true\n    tuple val(meta), path(\"*.st.pdf\"), emit: stacked_gc_plot_pdf, optional: true\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"MERQURYFK_KATGC module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FASTK_VERSION   = 'f18a4e6d2207539f7b84461daebc54530a9559b0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def MERQURY_VERSION = '8f3ab706e4cf4d7b7d1dfe5739859e3ebd26c494' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    KatGC \\\\\n        $args \\\\\n        -T$task.cpus \\\\\n        ${fastk_ktab.find{ it.toString().endsWith(\".ktab\") }} \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastk: $FASTK_VERSION\n        merquryfk: $MERQURY_VERSION\n        r: \\$( R --version | sed '1!d; s/.*version //; s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: An improved version of Smudgeplot using FastK\nTags: kmer, smudgeplot, ploidy", "answer": "process MERQURYFK_PLOIDYPLOT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container 'ghcr.io/nbisweden/fastk_genescopefk_merquryfk:1.2'\n\n    input:\n    tuple val(meta), path(fastk_hist), path(fastk_ktab)\n\n    output:\n    tuple val(meta), path(\"*.fi.png\"), emit: filled_ploidy_plot_png , optional: true\n    tuple val(meta), path(\"*.fi.pdf\"), emit: filled_ploidy_plot_pdf , optional: true\n    tuple val(meta), path(\"*.ln.png\"), emit: line_ploidy_plot_png   , optional: true\n    tuple val(meta), path(\"*.ln.pdf\"), emit: line_ploidy_plot_pdf   , optional: true\n    tuple val(meta), path(\"*.st.png\"), emit: stacked_ploidy_plot_png, optional: true\n    tuple val(meta), path(\"*.st.pdf\"), emit: stacked_ploidy_plot_pdf, optional: true\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"MERQURYFK_PLOIDYPLOT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FASTK_VERSION = 'f18a4e6d2207539f7b84461daebc54530a9559b0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def MERQURY_VERSION = '8f3ab706e4cf4d7b7d1dfe5739859e3ebd26c494' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    PloidyPlot \\\\\n        $args \\\\\n        -T$task.cpus \\\\\n        -o$prefix \\\\\n        ${fastk_ktab.find{ it.toString().endsWith(\".ktab\") }}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastk: $FASTK_VERSION\n        merquryfk: $MERQURY_VERSION\n        r: \\$( R --version | sed '1!d; s/.*version //; s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extract sequencing reads in FASTQ format from a given NCBI Sequence Read Archive (SRA).\nTags: sequencing, FASTQ, dump", "answer": "process SRATOOLS_FASTERQDUMP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-5f89fe0cd045cb1d615630b9261a1d17943a9b6a:2f4a4c900edd6801ff0068c2b3048b4459d119eb-0' :\n        'biocontainers/mulled-v2-5f89fe0cd045cb1d615630b9261a1d17943a9b6a:2f4a4c900edd6801ff0068c2b3048b4459d119eb-0' }\"\n\n    input:\n    tuple val(meta), path(sra)\n    path ncbi_settings\n    path certificate\n\n    output:\n    tuple val(meta), path('*.fastq.gz'), emit: reads\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def outfile = \"${prefix}.fastq\"\n    def exclude_third = meta.single_end ? '' : \"mv $outfile $prefix || echo 'No third file'\"\n    // Excludes the \"${prefix}.fastq\" file from output `reads` channel for paired end cases and\n    // avoids the '.' in the path bug: https://github.com/ncbi/sra-tools/issues/865\n    def key_file = ''\n    if (certificate.toString().endsWith('.jwt')) {\n        key_file += \" --perm ${certificate}\"\n    } else if (certificate.toString().endsWith('.ngc')) {\n        key_file += \" --ngc ${certificate}\"\n    }\n    \"\"\"\n    export NCBI_SETTINGS=\"\\$PWD/${ncbi_settings}\"\n\n    fasterq-dump \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --outfile $outfile \\\\\n        ${key_file} \\\\\n        ${sra}\n\n    $exclude_third\n\n    pigz \\\\\n        $args2 \\\\\n        --no-name \\\\\n        --processes $task.cpus \\\\\n        *.fastq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sratools: \\$(fasterq-dump --version 2>&1 | grep -Eo '[0-9.]+')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def outfile = \"${prefix}.fastq\"\n    def exclude_third = meta.single_end ? '' : \"mv $outfile $prefix || echo 'No third file'\"\n    // Excludes the \"${prefix}.fastq\" file from output `reads` channel for paired end cases and\n    // avoids the '.' in the path bug: https://github.com/ncbi/sra-tools/issues/865\n    def key_file = ''\n    if (certificate.toString().endsWith('.jwt')) {\n        key_file += \" --perm ${certificate}\"\n    } else if (certificate.toString().endsWith('.ngc')) {\n        key_file += \" --ngc ${certificate}\"\n    }\n    def touch_outfiles = meta.single_end ? \"${prefix}.fastq\" : \"${prefix}_1.fastq ${prefix}_2.fastq\"\n    \"\"\"\n    touch $touch_outfiles\n\n    export NCBI_SETTINGS=\"\\$PWD/${ncbi_settings}\"\n\n    echo \\\\\n    \"fasterq-dump \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --outfile $outfile \\\\\n        ${key_file} \\\\\n        ${sra}\"\n\n    $exclude_third\n\n    pigz \\\\\n        $args2 \\\\\n        --no-name \\\\\n        --processes $task.cpus \\\\\n        *.fastq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sratools: \\$(fasterq-dump --version 2>&1 | grep -Eo '[0-9.]+')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download sequencing data from the NCBI Sequence Read Archive (SRA).\nTags: sequencing, fastq, prefetch", "answer": "process SRATOOLS_PREFETCH {\n    tag \"$id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sra-tools:3.1.0--h9f5acd7_0' :\n        'biocontainers/sra-tools:3.1.0--h9f5acd7_0' }\"\n\n    input:\n    tuple val(meta), val(id)\n    path ncbi_settings\n    path certificate\n\n    output:\n    tuple val(meta), path(id), emit: sra\n    path 'versions.yml'      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    shell:\n    args = task.ext.args ?: ''\n    args2 = task.ext.args2 ?: '5 1 100'  // <num retries> <base delay in seconds> <max delay in seconds>\n    if (certificate) {\n        if (certificate.toString().endsWith('.jwt')) {\n            args += \" --perm ${certificate}\"\n        }\n        else if (certificate.toString().endsWith('.ngc')) {\n            args += \" --ngc ${certificate}\"\n        }\n    }\n\n    template 'retry_with_backoff.sh'\n\n    stub:\n    \"\"\"\n    mkdir $id\n    touch $id/${id}.sra\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sratools: \\$(prefetch --version 2>&1 | grep -Eo '[0-9.]+')\n        curl: \\$(curl --version | head -n 1 | sed 's/^curl //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: create tabix index from a sorted bgzip tab-delimited genome file\nTags: index, tabix, vcf", "answer": "process TABIX_TABIX {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/htslib:1.20--h5efdd21_2' :\n        'biocontainers/htslib:1.20--h5efdd21_2' }\"\n\n    input:\n    tuple val(meta), path(tab)\n\n    output:\n    tuple val(meta), path(\"*.tbi\"), optional:true, emit: tbi\n    tuple val(meta), path(\"*.csi\"), optional:true, emit: csi\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    tabix \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tabix: \\$(echo \\$(tabix -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${tab}.tbi\n    touch ${tab}.csi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tabix: \\$(echo \\$(tabix -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: bgzip a sorted tab-delimited genome file and then create tabix index\nTags: bgzip, compress, index, tabix, vcf", "answer": "process TABIX_BGZIPTABIX {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/htslib:1.20--h5efdd21_2' :\n        'biocontainers/htslib:1.20--h5efdd21_2' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.gz\"), path(\"*.tbi\"), optional: true, emit: gz_tbi\n    tuple val(meta), path(\"*.gz\"), path(\"*.csi\"), optional: true, emit: gz_csi\n    path  \"versions.yml\" ,                        emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bgzip  --threads ${task.cpus} -c $args $input > ${prefix}.${input.getExtension()}.gz\n    tabix --threads ${task.cpus} $args2 ${prefix}.${input.getExtension()}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tabix: \\$(echo \\$(tabix -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.${input.getExtension()}.gz\n    touch ${prefix}.${input.getExtension()}.gz.tbi\n    touch ${prefix}.${input.getExtension()}.gz.csi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tabix: \\$(echo \\$(tabix -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compresses/decompresses files\nTags: compress, decompress, bgzip, tabix", "answer": "process TABIX_BGZIP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/htslib:1.20--h5efdd21_2' :\n        'biocontainers/htslib:1.20--h5efdd21_2' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"${output}\")    , emit: output\n    tuple val(meta), path(\"${output}.gzi\"), emit: gzi, optional: true\n    path  \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    in_bgzip = [\"gz\", \"bgz\", \"bgzf\"].contains(input.getExtension())\n    extension = in_bgzip ? input.getBaseName().tokenize(\".\")[-1] : input.getExtension()\n    output   = in_bgzip ? \"${prefix}.${extension}\" : \"${prefix}.${extension}.gz\"\n    command = in_bgzip ? '-d' : ''\n    // Name the index according to $prefix, unless a name has been requested\n    if ((args.matches(\"(^| )-i\\\\b\") || args.matches(\"(^| )--index(\\$| )\")) && !args.matches(\"(^| )-I\\\\b\") && !args.matches(\"(^| )--index-name\\\\b\")) {\n        args = args + \" -I ${output}.gzi\"\n    }\n    \"\"\"\n    bgzip $command -c $args -@${task.cpus} $input > ${output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tabix: \\$(echo \\$(tabix -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    in_bgzip = [\"gz\", \"bgz\", \"bgzf\"].contains(input.getExtension())\n    output   = in_bgzip ? input.getBaseName() : \"${prefix}.${input.getExtension()}.gz\"\n\n    \"\"\"\n    echo \"\" | gzip > ${output}\n    touch ${output}.gzi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tabix: \\$(echo \\$(tabix -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: lima - The PacBio Barcode Demultiplexer and Primer Remover\nTags: isoseq, ccs, primer, pacbio, barcode", "answer": "process LIMA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lima:2.9.0--h9ee0642_1' :\n        'biocontainers/lima:2.9.0--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(ccs)\n    path primers\n\n    output:\n    tuple val(meta), path(\"*.counts\") , emit: counts\n    tuple val(meta), path(\"*.report\") , emit: report\n    tuple val(meta), path(\"*.summary\"), emit: summary\n    path \"versions.yml\"               , emit: versions\n\n    tuple val(meta), path(\"*.bam\")              , optional: true, emit: bam\n    tuple val(meta), path(\"*.bam.pbi\")          , optional: true, emit: pbi\n    tuple val(meta), path(\"*.{fa, fasta}\")      , optional: true, emit: fasta\n    tuple val(meta), path(\"*.{fa.gz, fasta.gz}\"), optional: true, emit: fastagz\n    tuple val(meta), path(\"*.fastq\")            , optional: true, emit: fastq\n    tuple val(meta), path(\"*.fastq.gz\")         , optional: true, emit: fastqgz\n    tuple val(meta), path(\"*.xml\")              , optional: true, emit: xml\n    tuple val(meta), path(\"*.json\")             , optional: true, emit: json\n    tuple val(meta), path(\"*.clips\")            , optional: true, emit: clips\n    tuple val(meta), path(\"*.guess\")            , optional: true, emit: guess\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$ccs\" == \"${prefix}.bam\" )      error \"Input and output names are the same, set prefix in module configuration\"\n    if( \"$ccs\" == \"${prefix}.fasta\" )    error \"Input and output names are the same, set prefix in module configuration\"\n    if( \"$ccs\" == \"${prefix}.fasta.gz\" ) error \"Input and output names are the same, set prefix in module configuration\"\n    if( \"$ccs\" == \"${prefix}.fastq\" )    error \"Input and output names are the same, set prefix in module configuration\"\n    if( \"$ccs\" == \"${prefix}.fastq.gz\" ) error \"Input and output names are the same, set prefix in module configuration\"\n\n    \"\"\"\n    OUT_EXT=\"\"\n\n    if [[ $ccs =~ bam\\$ ]]; then\n        OUT_EXT=\"bam\"\n    elif [[ $ccs =~ fasta\\$ ]]; then\n        OUT_EXT=\"fasta\"\n    elif [[ $ccs =~ fasta.gz\\$ ]]; then\n        OUT_EXT=\"fasta.gz\"\n    elif [[ $ccs =~ fastq\\$ ]]; then\n        OUT_EXT=\"fastq\"\n    elif [[ $ccs =~ fastq.gz\\$ ]]; then\n        OUT_EXT=\"fastq.gz\"\n    fi\n\n    lima \\\\\n        $ccs \\\\\n        $primers \\\\\n        $prefix.\\$OUT_EXT \\\\\n        -j $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lima: \\$( lima --version | head -n1 | sed 's/lima //g' | sed 's/ (.\\\\+//g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch dummy.counts\n    touch dummy.report\n    touch dummy.summary\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lima: \\$( lima --version | head -n1 | sed 's/lima //g' | sed 's/ (.\\\\+//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assembly polisher using short (and long) reads\nTags: assembly, polishing, nanopore, illumina", "answer": "process HYPO {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hypo:1.0.3--h9a82719_1':\n        'biocontainers/hypo:1.0.3--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(sr_bam)\n    tuple val(meta2), path(reads)\n    path draft\n    val genome_size\n    val reads_coverage\n\n    output:\n    tuple val(meta), path(\"*.fasta\"), emit: fasta\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    echo \"${reads.join(' ')}\" | tr \" \" \"\\\\n\" > sr.fofn\n    hypo \\\\\n        -r @sr.fofn \\\\\n        -d $draft \\\\\n        -b $sr_bam \\\\\n        -c $reads_coverage \\\\\n        -s $genome_size \\\\\n        -t $task.cpus \\\\\n        -o ${prefix}.fasta \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hypo: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: See above\n    \"\"\"\n    touch ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hypo: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cluster contigs from multiple assemblies by similarity\nTags: cluster, alignment, fastq, fasta, genomics", "answer": "process TRYCYCLER_CLUSTER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/trycycler:0.5.3--pyhdfd78af_0':\n        'biocontainers/trycycler:0.5.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(contigs), path(reads)\n\n    output:\n    tuple val(meta), path(\"*\") , emit: cluster_dir\n    path \"versions.yml\"        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    trycycler \\\\\n        cluster \\\\\n        $args \\\\\n        --assemblies ${contigs} \\\\\n        --reads ${reads} \\\\\n        --threads $task.cpus \\\\\n        --out_dir ${prefix}\n\n    gzip $args2 ${prefix}/cluster_*/*/*.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trycycler: \\$(trycycler --version | sed 's/Trycycler v//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}/cluster_001/1_contigs\n    echo \"\" | gzip > ${prefix}/cluster_001/1_contigs/A_contig_2a.fasta.gz\n    touch ${prefix}/contigs.newick\n    touch ${prefix}/contigs.phylip\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trycycler: \\$(trycycler --version | sed 's/Trycycler v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Subsample a long-read sequencing fastq file for multiple assemblies\nTags: subsample, fastq, genomics", "answer": "process TRYCYCLER_SUBSAMPLE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/trycycler:0.5.3--pyhdfd78af_0':\n        'biocontainers/trycycler:0.5.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*/*.fastq.gz\") , emit: subreads\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    trycycler \\\\\n        subsample \\\\\n        $args \\\\\n        --reads ${reads} \\\\\n        --threads $task.cpus \\\\\n        --out_dir ${prefix}\n\n    gzip $args2 ${prefix}/*.fastq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trycycler: \\$(trycycler --version | sed 's/Trycycler v//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // Pull out the count integer from the args string, if provided\n    // Otherwise use default value of 12\n    def matches = (args =~ /--count\\s+(\\d+)/)\n    def count = matches ? matches[0][1] as Integer : 12\n    \"\"\"\n    for n in \\$(seq $count); do\n        printf -v i \"%02d\" \\$n\n        mkdir -p ${prefix}\n        echo \"\" | gzip > ${prefix}/sample_\\${i}.fastq.gz\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trycycler: \\$(trycycler --version | sed 's/Trycycler v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Gene Allele Mutation Microbial Assessment\nTags: gamma, gene-calling", "answer": "\nprocess GAMMA_GAMMA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gamma%3A2.1--hdfd78af_0':\n        'biocontainers/gamma:2.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path(db)\n\n    output:\n    tuple val(meta), path(\"*.gamma\")                , emit: gamma\n    tuple val(meta), path(\"*.psl\")                  , emit: psl\n    tuple val(meta), path(\"*.gff\")  , optional:true , emit: gff\n    tuple val(meta), path(\"*.fasta\"), optional:true , emit: fasta\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    if [[ ${fasta} == *.gz ]]\n    then\n        FNAME=\\$(basename ${fasta} .gz)\n        gunzip -f ${fasta}\n        GAMMA.py \\\\\n        $args \\\\\n        \"\\${FNAME}\" \\\\\n        $db \\\\\n        $prefix\n    else\n        GAMMA.py \\\\\n        $args \\\\\n        $fasta \\\\\n        $db \\\\\n        $prefix\n    fi\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gamma: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Detecting and estimating inter-sample DNA contamination became a crucial quality assessment step to ensure high quality sequence reads and reliable downstream analysis.\nTags: qc, contamination, bam", "answer": "process VERIFYBAMID_VERIFYBAMID {\n    tag \"${meta.id}\"\n    label \"process_single\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/verifybamid%3A1.1.3--h5b5514e_6':\n        'biocontainers/verifybamid:1.1.3--h5b5514e_6' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path refvcf\n\n    output:\n    tuple val(meta), path(\"*.log\")                                  , emit: log\n    tuple val(meta), path(\"*.selfSM\")                , optional:true, emit: selfsm\n    tuple val(meta), path(\"*.depthSM\")               , optional:true, emit: depthsm\n    tuple val(meta), path(\"*.selfRG\")                , optional:true, emit: selfrg\n    tuple val(meta), path(\"*.depthRG\")               , optional:true, emit: depthrg\n    tuple val(meta), path(\"*.bestSM\")                , optional:true, emit: bestsm\n    tuple val(meta), path(\"*.bestRG\")                , optional:true, emit: bestrg\n    path \"versions.yml\"                                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.1.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    verifyBamID \\\\\n        --bam ${bam} \\\\\n        --vcf ${refvcf} \\\\\n        --out ${prefix} \\\\\n        ${args} \\\\\n        > ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        verifybamid: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Detecting and estimating inter-sample DNA contamination became a crucial quality assessment step to ensure high quality sequence reads and reliable downstream analysis.\nTags: contamination, bam", "answer": "process VERIFYBAMID_VERIFYBAMID2 {\n    tag '${meta.id}'\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/verifybamid2:2.0.1--hbb20b25_6' :\n        'biocontainers/verifybamid2:2.0.1--h19d48f6_8' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple path(svd_ud), path(svd_mu), path(svd_bed)\n    path refvcf\n    path references\n\n    output:\n    tuple val(meta), path(\"*.log\")             , optional:true, emit: log\n    tuple val(meta), path(\"*.UD\")              , optional:true, emit: ud\n    tuple val(meta), path(\"*.bed\")             , optional:true, emit: bed\n    tuple val(meta), path(\"*.mu\")              , optional:true, emit: mu\n    tuple val(meta), path(\"*.selfSM\")          , optional:true, emit: self_sm\n    tuple val(meta), path(\"*.Ancestry\")        , optional:true, emit: ancestry\n    path \"versions.yml\"                                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args_list = args.tokenize()\n\n    def bam_file = \"${bam}.endsWith('.bam|.cram')\" ? \"--BamFile ${bam}\" : \"\"\n\n    def svd_args = (svd_ud.baseName.equals(svd_mu.baseName) && svd_ud.baseName.equals(svd_bed.baseName)) ?\n        \"--SVDPrefix ${svd_ud.baseName}\" : \"--UDPath ${svd_ud} --MeanPath ${svd_mu} --BedPath ${svd_bed}\"\n    def refvcf_args = \"${refvcf}\".endsWith(\".vcf\") ? \"--RefVCF ${refvcf}\" : \"\"\n\n    def reference_args = (\"$references\".endsWith('.fasta')) ?\n        \"--Reference ${references}\" : ''\n\n    \"\"\"\n    verifybamid2 \\\\\n        --NumThread $task.cpus \\\\\n        ${svd_args} \\\\\n        ${bam_file} \\\\\n        ${refvcf_args} \\\\\n        ${reference_args}  \\\\\n        ${args_list.join(' ')} \\\\\n        > ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        verifybamid: \\$(echo \\$(verifybamid2 --help 2>&1 | sed -e '3p;d' | sed -e 's/ Version://'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: structural-variant calling with cutesv\nTags: cutesv, structural-variant calling", "answer": "process CUTESV {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cutesv:1.0.12--pyhdfd78af_0' :\n        'biocontainers/cutesv:2.0.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cuteSV \\\n        ${bam} \\\\\n        ${fasta} \\\\\n        ${prefix}.vcf \\\\\n        . \\\\\n        --threads $task.cpus \\\\\n        $args\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cuteSV: \\$( cuteSV --version 2>&1 | sed 's/cuteSV //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert BAM/GFF/GTF/GVF/PSL files to bed\nTags: convert, bed, genomics", "answer": "process BEDOPS_CONVERT2BED {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedops:2.4.41--h4ac6f70_2':\n        'biocontainers/bedops:2.4.41--h4ac6f70_2' }\"\n\n    input:\n    tuple val(meta), path(in_file)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def format = in_file.getExtension()\n    \"\"\"\n    convert2bed \\\\\n        $args \\\\\n        -i $format \\\\\n        < $in_file \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedops/convert2bed: \\$(convert2bed --version | grep vers | sed 's/^.*.version:  //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedops/convert2bed: \\$(convert2bed --version | grep vers | sed 's/^.*.version:  //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert gtf format to bed format\nTags: gtf, bed, conversion", "answer": "process BEDOPS_GTF2BED {\n    tag \"$gtf\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedops:2.4.41--h4ac6f70_2':\n        'biocontainers/bedops:2.4.41--h4ac6f70_2' }\"\n\n    input:\n    tuple val(meta), path(gtf)\n\n    output:\n    tuple val(meta), path('*.bed'), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}\"\n\n    \"\"\"\n    cat \\\\\n    $gtf \\\\\n    | gtf2bed \\\\\n    $args \\\\\n    --attribute-key=exon_id \\\\\n    > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gtf2bed: \\$(bedops --version | grep version | awk ' { print \\$2 } ')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gtf2bed: \\$(bedops --version | grep version | awk ' { print \\$2 } ')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: reads a maxQuant proteinGroups file with Proteus\nTags: proteomics, proteus, readproteingroups", "answer": "process PROTEUS_READPROTEINGROUPS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-503e259d7d34ce533ce66c4c8871af4ab409db6d:1e504ef71c83943061a39b6260d826b988bfa56f-0':\n        'biocontainers/mulled-v2-503e259d7d34ce533ce66c4c8871af4ab409db6d:1e504ef71c83943061a39b6260d826b988bfa56f-0' }\"\n\n    input:\n    tuple val(meta), path(samplesheet), path(intensities)\n\n    output:\n    tuple val(meta), path(\"*dendrogram.png\")                    , emit: dendro_plot\n    tuple val(meta), path(\"*mean_variance_relationship.png\")    , emit: mean_var_plot\n    tuple val(meta), path(\"*raw_distributions.png\")             , emit: raw_dist_plot\n    tuple val(meta), path(\"*normalized_distributions.png\")      , emit: norm_dist_plot\n    tuple val(meta), path(\"*raw_proteingroups.rds\")             , emit: raw_rdata\n    tuple val(meta), path(\"*normalized_proteingroups.rds\")      , emit: norm_rdata\n    tuple val(meta), path(\"*raw_proteingroups_tab.tsv\")         , emit: raw_tab\n    tuple val(meta), path(\"*normalized_proteingroups_tab.tsv\")  , emit: norm_tab\n    tuple val(meta), path(\"*R_sessionInfo.log\")                 , emit: session_info\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'proteus_readproteingroups.R'\n}\n"}
{"question": "Description: Alignment by Simultaneous Harmonization of Layer/Adjacency Registration\nTags: image_processing, alignment, registration", "answer": "process ASHLAR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ashlar:1.17.0--pyh5e36f6f_0' :\n        'biocontainers/ashlar:1.17.0--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(images)\n    path(opt_dfp)\n    path(opt_ffp)\n\n    output:\n    tuple val(meta), path(\"*.ome.tif\"), emit: tif\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args          = task.ext.args           ?: ''\n    def prefix        = task.ext.prefix         ?: \"${meta.id}\"\n    def dfp           = opt_dfp                 ? \"--dfp $opt_dfp\" : \"\"\n    def ffp           = opt_ffp                 ? \"--ffp $opt_ffp\" : \"\"\n    def num_files     = images instanceof List  ? images.size()    : 1\n    def opt_dfp_size  = opt_dfp instanceof List ? opt_dfp.size()   : 1\n    def opt_ffp_size  = opt_ffp instanceof List ? opt_ffp.size()   : 1\n    def dfp_validated = (opt_dfp_size == 0 || opt_dfp_size == 1 || opt_dfp_size == num_files) ? true : false\n    def ffp_validated = (opt_ffp_size == 0 || opt_ffp_size == 1 || opt_ffp_size == num_files) ? true : false\n\n    if ( !dfp_validated ) { error \"Please input only zero, one, or N dfp files, where N is the number of input images\" }\n    if ( !ffp_validated ) { error \"Please input only zero, one, or N ffp files, where N is the number of input images\" }\n\n    \"\"\"\n\n    ashlar \\\\\n        -o ${prefix}.ome.tif \\\\\n        $images \\\\\n        $args \\\\\n        $dfp \\\\\n        $ffp\n\n    sed -i -E 's/UUID=\"urn:uuid:[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12}\"/                                                    /g' ${prefix}.ome.tif\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ashlar: \\$(ashlar --version | sed 's/^.*ashlar //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Core-SNP alignment from Snippy outputs\nTags: core, alignment, bacteria, snippy", "answer": "process SNIPPY_CORE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snippy:4.6.0--hdfd78af_2':\n        'biocontainers/snippy:4.6.0--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(aligned_fa)\n    path reference\n\n    output:\n    tuple val(meta), path(\"${prefix}.aln\")     , emit: aln\n    tuple val(meta), path(\"${prefix}.full.aln\"), emit: full_aln\n    tuple val(meta), path(\"${prefix}.tab\")     , emit: tab\n    tuple val(meta), path(\"${prefix}.vcf\")     , emit: vcf\n    tuple val(meta), path(\"${prefix}.txt\")     , emit: txt\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = reference.getName().endsWith(\".gz\") ? true : false\n    def reference_name = reference.getName().replace(\".gz\", \"\")\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $reference > $reference_name\n    fi\n\n    # Collect samples into necessary folders\n    mkdir samples\n    find . -name \"*.vcf\" | sed 's/\\\\.vcf\\$//' | xargs -I {} bash -c 'mkdir samples/{}'\n    find . -name \"*.vcf\" | sed 's/\\\\.vcf\\$//' | xargs -I {} bash -c 'cp -L {}.vcf samples/{}/{}.vcf'\n    find . -name \"*.aligned.fa\" | sed 's/\\\\.aligned.fa\\$//' | xargs -I {} bash -c 'cp -L {}.aligned.fa samples/{}/{}.aligned.fa'\n\n    # Run snippy-core\n    snippy-core \\\\\n        $args \\\\\n        --ref $reference_name \\\\\n        --prefix $prefix \\\\\n        samples/*\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snippy-core: \\$(echo \\$(snippy-core --version 2>&1) | sed 's/snippy-core //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Rapid haploid variant calling\nTags: variant, fastq, bacteria", "answer": "process SNIPPY_RUN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snippy:4.6.0--hdfd78af_2' :\n        'biocontainers/snippy:4.6.0--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path reference\n\n    output:\n    tuple val(meta), path(\"${prefix}/${prefix}.tab\")              , emit: tab\n    tuple val(meta), path(\"${prefix}/${prefix}.csv\")              , emit: csv\n    tuple val(meta), path(\"${prefix}/${prefix}.html\")             , emit: html\n    tuple val(meta), path(\"${prefix}/${prefix}.vcf\")              , emit: vcf\n    tuple val(meta), path(\"${prefix}/${prefix}.bed\")              , emit: bed\n    tuple val(meta), path(\"${prefix}/${prefix}.gff\")              , emit: gff\n    tuple val(meta), path(\"${prefix}/${prefix}.bam\")              , emit: bam\n    tuple val(meta), path(\"${prefix}/${prefix}.bam.bai\")          , emit: bai\n    tuple val(meta), path(\"${prefix}/${prefix}.log\")              , emit: log\n    tuple val(meta), path(\"${prefix}/${prefix}.aligned.fa\")       , emit: aligned_fa\n    tuple val(meta), path(\"${prefix}/${prefix}.consensus.fa\")     , emit: consensus_fa\n    tuple val(meta), path(\"${prefix}/${prefix}.consensus.subs.fa\"), emit: consensus_subs_fa\n    tuple val(meta), path(\"${prefix}/${prefix}.raw.vcf\")          , emit: raw_vcf\n    tuple val(meta), path(\"${prefix}/${prefix}.filt.vcf\")         , emit: filt_vcf\n    tuple val(meta), path(\"${prefix}/${prefix}.vcf.gz\")           , emit: vcf_gz\n    tuple val(meta), path(\"${prefix}/${prefix}.vcf.gz.csi\")       , emit: vcf_csi\n    tuple val(meta), path(\"${prefix}/${prefix}.txt\")              , emit: txt\n    path \"versions.yml\"                                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def read_inputs = meta.single_end ? \"--se ${reads[0]}\" : \"--R1 ${reads[0]} --R2 ${reads[1]}\"\n    \"\"\"\n    snippy \\\\\n        $args \\\\\n        --cpus $task.cpus \\\\\n        --outdir $prefix \\\\\n        --reference $reference \\\\\n        --prefix $prefix \\\\\n        $read_inputs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snippy: \\$(echo \\$(snippy --version 2>&1) | sed 's/snippy //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Alignment-free computation of average nucleotide Identity (ANI)\nTags: genome, fasta, ANI", "answer": "process FASTANI {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fastani:1.32--he1c1bb9_0' :\n        'biocontainers/fastani:1.32--he1c1bb9_0' }\"\n\n    input:\n    tuple val(meta), path(query)\n    path reference\n\n    output:\n    tuple val(meta), path(\"*.ani.txt\"), emit: ani\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (meta.batch_input) {\n        \"\"\"\n        fastANI \\\\\n            -ql $query \\\\\n            -rl $reference \\\\\n            -o ${prefix}.ani.txt\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            fastani: \\$(fastANI --version 2>&1 | sed 's/version//;')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        fastANI \\\\\n            -q $query \\\\\n            -r $reference \\\\\n            -o ${prefix}.ani.txt\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            fastani: \\$(fastANI --version 2>&1 | sed 's/version//;')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Determine Streptococcus pneumoniae serotype from Illumina paired-end reads\nTags: fastq, serotype, Streptococcus pneumoniae", "answer": "VERSION = '1.2.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\nprocess PNEUMOCAT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pneumocat:1.2.1--0':\n        'biocontainers/pneumocat:1.2.1--0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.xml\"), emit: xml\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    PneumoCaT.py \\\\\n        --input_directory ./ \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --output_dir ./\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pneumocat: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.results.xml\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pneumocat: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: classification into haplogroups\nTags: haplogroups.", "answer": "process HAPLOGREP2_CLASSIFY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/haplogrep:2.4.0--hdfd78af_0':\n        'biocontainers/haplogrep:2.4.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(inputfile)\n    val(format)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    haplogrep \\\\\n        classify \\\\\n        $args \\\\\n        --in $inputfile \\\\\n        --out ${prefix}.txt \\\\\n        --format $format\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        haplogrep2: \\$(echo \\$(haplogrep --version 2>&1) | (sed 's/htt.*//') | (sed 's/.*v//'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        haplogrep2: \\$(echo \\$(haplogrep --version 2>&1) | (sed 's/htt.*//') | (sed 's/.*v//'))\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: RAxML-NG is a phylogenetic tree inference tool which uses maximum-likelihood (ML) optimality criterion.\nTags: phylogeny, newick, maximum likelihood", "answer": "process RAXMLNG {\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/raxml-ng:1.0.3--h32fcf60_0' :\n        'biocontainers/raxml-ng:1.0.3--h32fcf60_0' }\"\n\n    input:\n    path alignment\n\n    output:\n    path \"*.raxml.bestTree\", emit: phylogeny\n    path \"*.raxml.support\" , optional:true, emit: phylogeny_bootstrapped\n    path \"versions.yml\"    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    raxml-ng \\\\\n        $args \\\\\n        --msa $alignment \\\\\n        --threads $task.cpus \\\\\n        --prefix output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        raxmlng: \\$(echo \\$(raxml-ng --version 2>&1) | sed 's/^.*RAxML-NG v. //; s/released.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Arriba is a command-line tool for the detection of gene fusions from RNA-Seq data.\nTags: fusion, arriba, detection, RNA-Seq", "answer": "process ARRIBA_ARRIBA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/arriba:2.4.0--h0033a41_2' :\n        'biocontainers/arriba:2.4.0--h0033a41_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(gtf)\n    tuple val(meta4), path(blacklist)\n    tuple val(meta5), path(known_fusions)\n    tuple val(meta6), path(structural_variants)\n    tuple val(meta7), path(tags)\n    tuple val(meta8), path(protein_domains)\n\n    output:\n    tuple val(meta), path(\"*.fusions.tsv\")          , emit: fusions\n    tuple val(meta), path(\"*.fusions.discarded.tsv\"), emit: fusions_fail\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def blacklist = blacklist ? \"-b $blacklist\" : \"-f blacklist\"\n    def known_fusions = known_fusions ? \"-k $known_fusions\" : \"\"\n    def structural_variants = structural_variants ? \"-d $structual_variants\" : \"\"\n    def tags = tags ? \"-t $tags\" : \"\"\n    def protein_domains = protein_domains ? \"-p $protein_domains\" : \"\"\n\n    \"\"\"\n    arriba \\\\\n        -x $bam \\\\\n        -a $fasta \\\\\n        -g $gtf \\\\\n        -o ${prefix}.fusions.tsv \\\\\n        -O ${prefix}.fusions.discarded.tsv \\\\\n        $blacklist \\\\\n        $known_fusions \\\\\n        $structural_variants \\\\\n        $tags \\\\\n        $protein_domains \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        arriba: \\$(arriba -h | grep 'Version:' 2>&1 |  sed 's/Version:\\s//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo stub > ${prefix}.fusions.tsv\n    echo stub > ${prefix}.fusions.discarded.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        arriba: \\$(arriba -h | grep 'Version:' 2>&1 |  sed 's/Version:\\s//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Arriba is a command-line tool for the detection of gene fusions from RNA-Seq data.\nTags: fusion, arriba, reference", "answer": "process ARRIBA_DOWNLOAD {\n    tag \"arriba\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/arriba:2.4.0--h0033a41_2' :\n        'biocontainers/arriba:2.4.0--h0033a41_2' }\"\n\n    output:\n    path \"*\"              , emit: reference\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    \"\"\"\n    wget https://github.com/suhrig/arriba/releases/download/v2.4.0/arriba_v2.4.0.tar.gz -O arriba_v2.4.0.tar.gz\n    tar -xzvf arriba_v2.4.0.tar.gz\n    rm arriba_v2.4.0.tar.gz\n    mv arriba_v2.4.0/database/* .\n    rm -r arriba_v2.4.0\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        arriba_download: \\$(arriba -h | grep 'Version:' 2>&1 |  sed 's/Version:\\s//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch blacklist_hg38_GRCh38_v2.4.0.tsv.gz\n    touch protein_domains_hg38_GRCh38_v2.4.0.gff3\n    touch cytobands_hg38_GRCh38_v2.4.0.tsv\n    touch known_fusions_hg38_GRCh38_v2.4.0.tsv.gz\n    touch protein_domains_hg38_GRCh38_v2.4.0.gff3\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        arriba_download: \\$(arriba -h | grep 'Version:' 2>&1 |  sed 's/Version:\\s//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate pan-genome from annotated bacterial assemblies in GFF3 format\nTags: gff, pan-genome, alignment", "answer": "process ROARY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/roary:3.13.0--pl526h516909a_0' :\n        'biocontainers/roary:3.13.0--pl526h516909a_0' }\"\n\n    input:\n    tuple val(meta), path(gff)\n\n    output:\n    tuple val(meta), path(\"results/*\")                    , emit: results\n    tuple val(meta), path(\"results/*.aln\"), optional: true, emit: aln\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    roary \\\\\n        $args \\\\\n        -p $task.cpus \\\\\n        -f results/ \\\\\n        $gff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        roary: \\$( roary --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Pairwise SNP distance matrix from a FASTA sequence alignment\nTags: snp-dists, distance-matrix", "answer": "process SNPDISTS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snp-dists:0.8.2--h5bf99c6_0' :\n        'biocontainers/snp-dists:0.8.2--h5bf99c6_0' }\"\n\n    input:\n    tuple val(meta), path(alignment)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    snp-dists \\\\\n        $args \\\\\n        $alignment > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpdists: \\$(snp-dists -v 2>&1 | sed 's/snp-dists //;')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: runs a functional enrichment analysis with gprofiler2\nTags: gene set analysis, enrichment, gprofiler2, gost, gene set", "answer": "process GPROFILER2_GOST {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-3712554873398d849d0d11b22440f41febbc4ede:aa19bb8afc0ec6456a4f3cd650f7577c3bbdd4f3-0':\n        'biocontainers/mulled-v2-3712554873398d849d0d11b22440f41febbc4ede:aa19bb8afc0ec6456a4f3cd650f7577c3bbdd4f3-0' }\"\n\n    input:\n    tuple val(meta), path(de_file)\n    path(gmt_file)\n    path(background_file)\n\n    output:\n    tuple val(meta), path(\"*.gprofiler2.all_enriched_pathways.tsv\")     , emit: all_enrich\n    tuple val(meta), path(\"*.gprofiler2.gost_results.rds\")              , emit: rds         , optional: true\n    tuple val(meta), path(\"*.gprofiler2.gostplot.png\")                  , emit: plot_png    , optional: true\n    tuple val(meta), path(\"*.gprofiler2.gostplot.html\")                 , emit: plot_html   , optional: true\n    tuple val(meta), path(\"*.gprofiler2.*.sub_enriched_pathways.tsv\")   , emit: sub_enrich  , optional: true\n    tuple val(meta), path(\"*.gprofiler2.*.sub_enriched_pathways.png\")   , emit: sub_plot    , optional: true\n    tuple val(meta), path(\"*ENSG_filtered.gmt\")                         , emit: filtered_gmt, optional: true\n    tuple val(meta), path(\"*R_sessionInfo.log\")                         , emit: session_info\n    path \"versions.yml\"                                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'gprofiler2_gost.R'\n}\n"}
{"question": "Description: The Snakemake workflow management system is a tool to create reproducible and scalable data analyses. This module runs a simple Snakemake pipeline based on input snakefile. Expect many limitations.\"\nTags: snakemake, workflow, workflow_mode", "answer": "process SNAKEMAKE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // You will have to add all modules to this Conda definition and\n    // replace the container definition for one that suits your needs\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snakemake:7.31.0--hdfd78af_1' :\n        'biocontainers/snakemake:7.31.0--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(inputs)\n    tuple val(meta2), path(snakefile)\n\n    output:\n    tuple val(meta), path(\"[!.snakemake|versions.yml]**\")         , emit: outputs      , optional: true\n    tuple val(meta), path(\".snakemake\", type: 'dir', hidden: true), emit: snakemake_dir\n    path \"versions.yml\"                                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def cores  = task.cpus ? \"--cores ${task.cpus}\" : \"--cores all\"\n    \"\"\"\n    snakemake \\\\\n        $args \\\\\n        $cores \\\\\n        --snakefile $snakefile\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snakemake: \\$(snakemake --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def cores  = task.cpus ? \"--cores ${task.cpus}\" : \"--cores all\"\n    \"\"\"\n    snakemake \\\\\n        $args \\\\\n        --snakefile $snakefile \\\\\n        $cores \\\\\n        --dry-run\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snakemake: \\$(snakemake --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create fasta consensus with TOPAS toolkit with options to penalize substitutions for typical DNA damage present in ancient DNA\nTags: consensus, fasta, ancient DNA", "answer": "process TOPAS_GENCONS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/topas:1.0.1--hdfd78af_1':\n        'biocontainers/topas:1.0.1--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    tuple val(meta2), path(vcf_indels)\n    tuple val(meta3), path(reference)\n    tuple val(meta4), path(fai)\n    val(vcf_output)\n\n    output:\n    tuple val(meta), path(\"*.fasta.gz\"), emit: fasta\n    tuple val(meta), path(\"*.vcf.gz\")  , emit: vcf     , optional: true\n    tuple val(meta), path(\"*.ccf\")     , emit: ccf\n    tuple val(meta), path(\"*.log\")     , emit: log\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def optionalvcfindels = vcf_indels ? \"-indels ${vcf_indels}\" : ''\n    def optionalfai = fai ? \"-fai ${fai}\" : ''\n    def vcfoutput = vcf_output ? \"-vcf_out ${prefix}.vcf\" : \"\"\n    def VERSION = '1.0.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n\n    topas \\\\\n        GenConS \\\\\n        $args \\\\\n        -o ${prefix}.fasta \\\\\n        -snps $vcf \\\\\n        $optionalvcfindels \\\\\n        $vcfoutput \\\\\n        -ref $reference\n\n    gzip -n ${prefix}.fasta\n\n    if [[ -f ${prefix}.vcf ]];then\n        gzip -n ${prefix}.vcf\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        topas: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sorts BAM/SAM files based on a variety of picard specific criteria\nTags: sort, bam, sam, picard", "answer": "process PICARD_SORTSAM {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    val sort_order\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard SortSam] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    picard \\\\\n        SortSam \\\\\n        -Xmx${avail_mem}M \\\\\n        --INPUT $bam \\\\\n        --OUTPUT ${prefix}.bam \\\\\n        --SORT_ORDER $sort_order\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard SortSam --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collects hybrid-selection (HS) metrics for a SAM or BAM file.\nTags: alignment, metrics, statistics, insert, hybrid-selection, quality, bam", "answer": "process PICARD_COLLECTHSMETRICS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(bait_intervals, stageAs: \"baits/*\"), path(target_intervals, stageAs: 'targets/*')\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path(\"*_metrics\")  , emit: metrics\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard CollectHsMetrics] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    def bait_interval_list = bait_intervals\n    def bait_intervallist_cmd = \"\"\n    if (bait_intervals =~ /.(bed|bed.gz)$/){\n        bait_interval_list = bait_intervals.toString().replaceAll(/.(bed|bed.gz)$/, \".interval_list\")\n        bait_intervallist_cmd = \"picard -Xmx${avail_mem}M  BedToIntervalList --INPUT ${bait_intervals} --OUTPUT ${bait_interval_list} --SEQUENCE_DICTIONARY ${dict} --TMP_DIR .\"\n    }\n\n    def target_interval_list = target_intervals\n    def target_intervallist_cmd = \"\"\n    if (target_intervals =~ /.(bed|bed.gz)$/){\n        target_interval_list = target_intervals.toString().replaceAll(/.(bed|bed.gz)$/, \".interval_list\")\n        target_intervallist_cmd = \"picard -Xmx${avail_mem}M  BedToIntervalList --INPUT ${target_intervals} --OUTPUT ${target_interval_list} --SEQUENCE_DICTIONARY ${dict} --TMP_DIR .\"\n    }\n\n\n    \"\"\"\n\n    $bait_intervallist_cmd\n    $target_intervallist_cmd\n\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        CollectHsMetrics \\\\\n        $args \\\\\n        $reference \\\\\n        --BAIT_INTERVALS $bait_interval_list \\\\\n        --TARGET_INTERVALS $target_interval_list \\\\\n        --INPUT $bam \\\\\n        --OUTPUT ${prefix}.CollectHsMetrics.coverage_metrics\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard CollectHsMetrics --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.CollectHsMetrics.coverage_metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard CollectHsMetrics --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collect metrics about the insert size distribution of a paired-end library.\nTags: metrics, alignment, insert, statistics, bam", "answer": "process PICARD_COLLECTINSERTSIZEMETRICS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: metrics\n    tuple val(meta), path(\"*.pdf\"), emit: histogram\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard CollectInsertSizeMetrics] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        CollectInsertSizeMetrics \\\\\n        $args \\\\\n        --INPUT $bam \\\\\n        --OUTPUT ${prefix}.txt \\\\\n        --Histogram_FILE ${prefix}.pdf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard CollectInsertSizeMetrics --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.pdf\n    touch ${prefix}.txt\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard CollectInsertSizeMetrics --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n\n\n}\n"}
{"question": "Description: Writes an interval list created by splitting a reference at Ns.A Program for breaking up a reference into intervals of alternating regions of N and ACGT bases\nTags: interval_list, scatter, regions", "answer": "process PICARD_SCATTERINTERVALSBYNS {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(fai)\n    tuple val(meta3), path(dict)\n\n    output:\n    tuple val(meta), path(\"*.interval_list\"), emit: intervals\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    picard ScatterIntervalsByNs \\\\\n        --REFERENCE ${fasta} \\\\\n        --OUTPUT ${prefix}.interval_list \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard ScatterIntervalsByNs --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.interval_list\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard ScatterIntervalsByNs --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: changes name of sample in the vcf file\nTags: picard, picard/renamesampleinvcf, vcf", "answer": "\nprocess PICARD_RENAMESAMPLEINVCF {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def extended_args = args.contains(\"--NEW_SAMPLE_NAME\") ? $args : \"${args} --NEW_SAMPLE_NAME ${meta.id}\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard RenameSampleInVcf] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    picard \\\\\n        RenameSampleInVcf \\\\\n        -Xmx${avail_mem}M \\\\\n        --INPUT $vcf \\\\\n        --OUTPUT ${prefix}_renam.vcf.gz \\\\\n        $extended_args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard RenameSampleInVcf --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_renam.vcf.gz\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard RenameSampleInVcf --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Checks that all data in the set of input files appear to come from the same individual\nTags: alignment, metrics, statistics, fingerprint, bam", "answer": "process PICARD_CROSSCHECKFINGERPRINTS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta),  path(input1), path(input1_index), path(input2), path(input2_index), path(haplotype_map)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.crosscheck_metrics.txt\"), emit: crosscheck_metrics\n    path \"versions.yml\"                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def input1_cmd = input1.collect{\"--INPUT $it\"}.join(' ')\n    def input2_cmd = input2.collect{\"--SECOND_INPUT $it\"}.join(' ')\n    def reference_cmd = fasta ? \"--REFERENCE_SEQUENCE $fasta\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard CrosscheckFingerprints] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        CrosscheckFingerprints \\\\\n        ${input1_cmd} \\\\\n        ${input2_cmd} \\\\\n        ${reference_cmd} \\\\\n        --HAPLOTYPE_MAP ${haplotype_map} \\\\\n        --OUTPUT ${prefix}.crosscheck_metrics.txt \\\\\n        --NUM_THREADS ${task.cpus} \\\\\n        $args\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$( picard CrosscheckFingerprints --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d: )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.crosscheck_metrics.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard CollectHsMetrics --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a FASTQ file to an unaligned BAM or SAM file.\nTags: fastq, unaligned, bam", "answer": "process PICARD_FASTQTOSAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (!task.memory) {\n        log.warn '[Picard FastqToSam] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    }\n    def avail_mem = task.memory ? (task.memory.mega*0.8).intValue() : 3072\n    def input = meta.single_end ? \"--FASTQ ${reads}\" : \"--FASTQ ${reads[0]} --FASTQ2 ${reads[1]}\"\n    def sample_name = args.contains(\"--SAMPLE_NAME\") || args.contains(\"-SM\") ? \"\" : \"--SAMPLE_NAME ${prefix}\"\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        FastqToSam \\\\\n        ${args} \\\\\n        ${input} \\\\\n        ${sample_name} \\\\\n        --OUTPUT ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard FastqToSam --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Verify mate-pair information between mates and fix if needed\nTags: mate-pair, picard, bam, sam", "answer": "process PICARD_FIXMATEINFORMATION {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def STRINGENCY = task.ext.stringency ?: \"STRICT\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard FixMateInformation] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    picard \\\\\n        FixMateInformation \\\\\n        -Xmx${avail_mem}M \\\\\n        --INPUT ${bam} \\\\\n        --OUTPUT ${prefix}.bam \\\\\n        --VALIDATION_STRINGENCY ${STRINGENCY}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard FixMateInformation --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard FixMateInformation --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Collect multiple metrics from a BAM file\nTags: alignment, metrics, statistics, insert, quality, bam", "answer": "process PICARD_COLLECTMULTIPLEMETRICS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta) , path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*_metrics\"), emit: metrics\n    tuple val(meta), path(\"*.pdf\")    , emit: pdf, optional: true\n    path  \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard CollectMultipleMetrics] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        CollectMultipleMetrics \\\\\n        $args \\\\\n        --INPUT $bam \\\\\n        --OUTPUT ${prefix}.CollectMultipleMetrics \\\\\n        $reference\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard CollectMultipleMetrics --version 2>&1 | grep -o 'Version.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.CollectMultipleMetrics.alignment_summary_metrics\n    touch ${prefix}.CollectMultipleMetrics.insert_size_metrics\n    touch ${prefix}.CollectMultipleMetrics.quality_distribution.pdf\n    touch ${prefix}.CollectMultipleMetrics.base_distribution_by_cycle_metrics\n    touch ${prefix}.CollectMultipleMetrics.quality_by_cycle_metrics\n    touch ${prefix}.CollectMultipleMetrics.read_length_histogram.pdf\n    touch ${prefix}.CollectMultipleMetrics.base_distribution_by_cycle.pdf\n    touch ${prefix}.CollectMultipleMetrics.quality_by_cycle.pdf\n    touch ${prefix}.CollectMultipleMetrics.insert_size_histogram.pdf\n    touch ${prefix}.CollectMultipleMetrics.quality_distribution_metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard CollectMultipleMetrics --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cleans the provided BAM, soft-clipping beyond-end-of-reference alignments and setting MAPQ to 0 for unmapped reads\nTags: clean, bam, picard, sam, clipping", "answer": "process PICARD_CLEANSAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard CleanSam] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        CleanSam  \\\\\n        ${args} \\\\\n        --INPUT ${bam} \\\\\n        --OUTPUT ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard CleanSam --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard CleanSam --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates a sequence dictionary for a reference sequence.\nTags: sequence, dictionary, picard", "answer": "process PICARD_CREATESEQUENCEDICTIONARY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.dict\"), emit: reference_dict\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard CreateSequenceDictionary] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        CreateSequenceDictionary  \\\\\n        $args \\\\\n        --REFERENCE $fasta \\\\\n        --OUTPUT ${prefix}.dict\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard CreateSequenceDictionary --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sorts vcf files\nTags: sort, vcf, sortvcf", "answer": "process PICARD_SORTVCF {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(dict)\n\n    output:\n    tuple val(meta), path(\"*_sorted.vcf.gz\"), emit: vcf\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def seq_dict = dict ? \"--SEQUENCE_DICTIONARY $dict\" : \"\"\n    def reference = fasta ? \"--REFERENCE_SEQUENCE $fasta\" : \"\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard SortVcf] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    picard \\\\\n        SortVcf \\\\\n        -Xmx${avail_mem}M \\\\\n        --INPUT $vcf \\\\\n        $args \\\\\n        $seq_dict \\\\\n        $reference \\\\\n        --OUTPUT ${prefix}_sorted.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard SortVcf --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_sorted.vcf.gz\n    touch ${prefix}.bam.bai\n    touch ${prefix}.MarkDuplicates.metrics.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard SortVcf --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filters SAM/BAM files to include/exclude either aligned/unaligned reads or based on a read list\nTags: bam, filter, picard, sam", "answer": "process PICARD_FILTERSAMREADS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(readlist)\n    val filter\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard FilterSamReads] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    if ( filter == 'includeAligned' || filter == 'excludeAligned' ) {\n        \"\"\"\n        picard \\\\\n            FilterSamReads \\\\\n            -Xmx${avail_mem}M \\\\\n            --INPUT $bam \\\\\n            --OUTPUT ${prefix}.bam \\\\\n            --FILTER $filter \\\\\n            $args\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            picard: \\$(picard FilterSamReads --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n        END_VERSIONS\n        \"\"\"\n    } else if ( filter == 'includeReadList' || filter == 'excludeReadList' ) {\n        \"\"\"\n        picard \\\\\n            FilterSamReads \\\\\n            -Xmx${avail_mem}M \\\\\n            --INPUT $bam \\\\\n            --OUTPUT ${prefix}.bam \\\\\n            --FILTER $filter \\\\\n            --READ_LIST_FILE $readlist \\\\\n            $args\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            picard: \\$(picard FilterSamReads --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard FilterSamReads --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Collect metrics from a RNAseq BAM file\nTags: rna, bam, metrics, alignment, statistics, quality", "answer": "process PICARD_COLLECTRNASEQMETRICS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path ref_flat\n    path fasta\n    path rrna_intervals\n\n    output:\n    tuple val(meta), path(\"*.rna_metrics\")  , emit: metrics\n    tuple val(meta), path(\"*.pdf\")          , emit: pdf, optional: true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n    def rrna = rrna_intervals ? \"--RIBOSOMAL_INTERVALS ${rrna_intervals}\" : \"\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard CollectRnaSeqMetrics] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        CollectRnaSeqMetrics \\\\\n        $args \\\\\n        $reference \\\\\n        $rrna \\\\\n        --REF_FLAT $ref_flat \\\\\n        --INPUT $bam \\\\\n        --OUTPUT ${prefix}.rna_metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard CollectRnaSeqMetrics --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.rna_metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard CollectRnaSeqMetrics --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes/Extracts the fingerprint genotype likelihoods from the supplied file. It is given as a list of PLs at the fingerprinting sites.\nTags: picard, extract, fingerprint, bam", "answer": "process PICARD_EXTRACTFINGERPRINT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path  haplotype_map\n    path  fasta\n    path  fasta_fai\n    path  sequence_dictionary\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")    , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\"), emit: tbi\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n    def bam_name = bam.simpleName\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[PICARD ExtractFingerprint] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        ExtractFingerprint \\\\\n        --INPUT ${bam} \\\\\n        --HAPLOTYPE_MAP ${haplotype_map} \\\\\n        --OUTPUT ${prefix}.vcf.gz \\\\\n        ${reference} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard ExtractFingerprint --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard ExtractFingerprint --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates an interval list from a bed file and a reference dict\nTags: bed, interval list, picard, convert", "answer": "process PICARD_BEDTOINTERVALLIST {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta) , path(bed)\n    tuple val(meta2), path(dict)\n    file  arguments_file\n\n    output:\n    tuple val(meta), path('*.interval_list'), emit: interval_list\n    path  \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args_file = arguments_file ? \"--arguments_file ${arguments_file}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard BedToIntervalList] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        BedToIntervalList \\\\\n        --INPUT $bed \\\\\n        --OUTPUT ${prefix}.interval_list \\\\\n        --SEQUENCE_DICTIONARY $dict \\\\\n        --TMP_DIR . \\\\\n        $args_file $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard BedToIntervalList --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"picard \\\\\n        -Xmx${avail_mem}M \\\\\n        BedToIntervalList \\\\\n        --INPUT $bed \\\\\n        --OUTPUT ${prefix}.interval_list \\\\\n        --SEQUENCE_DICTIONARY $dict \\\\\n        --TMP_DIR . \\\\\n        $args_file $args\"\n\n    touch ${prefix}.interval_list\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard BedToIntervalList --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assigns all the reads in a file to a single new read-group\nTags: add, replace, read-group, picard", "answer": "process PICARD_ADDORREPLACEREADGROUPS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_index)\n\n    output:\n    tuple val(meta), path(\"*.bam\") , emit: bam,  optional: true\n    tuple val(meta), path(\"*.bai\") , emit: bai,  optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram, optional: true\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args        ?: ''\n    def prefix = task.ext.prefix    ?: \"${meta.id}\"\n    def suffix = task.ext.suffix    ?: \"${reads.getExtension()}\"\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard AddOrReplaceReadGroups] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    if (\"$reads\" == \"${prefix}.${suffix}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        AddOrReplaceReadGroups \\\\\n        $args \\\\\n        $reference \\\\\n        --INPUT ${reads} \\\\\n        --OUTPUT ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard AddOrReplaceReadGroups --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix    ?: \"${meta.id}\"\n    def suffix = task.ext.suffix    ?: \"${reads.getExtension()}\"\n    if (\"$reads\" == \"${prefix}.${suffix}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard AddOrReplaceReadGroups --version 2>&1 | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Locate and tag duplicate reads in a BAM file\nTags: markduplicates, pcr, duplicates, bam, sam, cram", "answer": "process PICARD_MARKDUPLICATES {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.bam\") , emit: bam,  optional: true\n    tuple val(meta), path(\"*.bai\") , emit: bai,  optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram, optional: true\n    tuple val(meta), path(\"*.metrics.txt\"), emit: metrics\n    path  \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix    ?: \"${reads.getExtension()}\"\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard MarkDuplicates] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    if (\"$reads\" == \"${prefix}.${suffix}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        MarkDuplicates \\\\\n        $args \\\\\n        --INPUT $reads \\\\\n        --OUTPUT ${prefix}.${suffix} \\\\\n        $reference \\\\\n        --METRICS_FILE ${prefix}.MarkDuplicates.metrics.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard MarkDuplicates --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix    ?: \"${reads.getExtension()}\"\n    if (\"$reads\" == \"${prefix}.${suffix}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n    touch ${prefix}.MarkDuplicates.metrics.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard MarkDuplicates --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges multiple BAM files into a single file\nTags: merge, alignment, bam, sam", "answer": "process PICARD_MERGESAMFILES {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bams)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bam_files = bams.sort()\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard MergeSamFiles] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    if (bam_files.size() > 1) {\n        \"\"\"\n        picard \\\\\n            -Xmx${avail_mem}M \\\\\n            MergeSamFiles \\\\\n            $args \\\\\n            ${'--INPUT '+bam_files.join(' --INPUT ')} \\\\\n            --OUTPUT ${prefix}.bam\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            picard: \\$( echo \\$(picard MergeSamFiles --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        ln -s ${bam_files[0]} ${prefix}.bam\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            picard: \\$( echo \\$(picard MergeSamFiles --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Collect metrics about coverage and performance of whole genome sequencing (WGS) experiments.\nTags: alignment, metrics, statistics, quality, bam", "answer": "process PICARD_COLLECTWGSMETRICS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    path  intervallist\n\n    output:\n    tuple val(meta), path(\"*_metrics\"), emit: metrics\n    path  \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args ?: ''\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = 3072\n    def interval  = intervallist ? \"--INTERVALS ${intervallist}\" : ''\n    if (!task.memory) {\n        log.info '[Picard CollectWgsMetrics] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        CollectWgsMetrics \\\\\n        $args \\\\\n        --INPUT $bam \\\\\n        --OUTPUT ${prefix}.CollectWgsMetrics.coverage_metrics \\\\\n        --REFERENCE_SEQUENCE ${fasta} \\\\\n        $interval\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard CollectWgsMetrics --version 2>&1 | grep -o 'Version.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.CollectWgsMetrics.coverage_metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(picard CollectWgsMetrics --version 2>&1 | grep -o 'Version.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Lifts over a VCF file from one reference build to another.\nTags: vcf, picard, liftovervcf", "answer": "process PICARD_LIFTOVERVCF {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/picard:3.2.0--hdfd78af_0' :\n        'biocontainers/picard:3.2.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input_vcf)\n    tuple val(meta2), path(dict)\n    tuple val(meta3), path(fasta)\n    tuple val(meta4), path(chain)\n\n    output:\n    tuple val(meta), path(\"*.lifted.vcf.gz\")  , emit: vcf_lifted\n    tuple val(meta), path(\"*.unlifted.vcf.gz\"), emit: vcf_unlifted\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[Picard LiftoverVcf] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    picard \\\\\n        -Xmx${avail_mem}M \\\\\n        LiftoverVcf \\\\\n        $args \\\\\n        --INPUT $input_vcf \\\\\n        --OUTPUT ${prefix}.lifted.vcf.gz \\\\\n        --CHAIN $chain \\\\\n        --REJECT ${prefix}.unlifted.vcf.gz \\\\\n        --REFERENCE_SEQUENCE $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard LiftoverVcf --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.lifted.vcf.gz\n    touch ${prefix}.unlifted.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        picard: \\$(echo \\$(picard LiftoverVcf --version 2>&1) | grep -o 'Version:.*' | cut -f2- -d:)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: antiSMASH allows the rapid genome-wide identification, annotation\nand analysis of secondary metabolite biosynthesis gene clusters.\n\nTags: secondary metabolites, BGC, biosynthetic gene cluster, genome mining, NRPS, RiPP, antibiotics, prokaryotes, bacteria, eukaryotes, fungi, antismash", "answer": "process ANTISMASH_ANTISMASHLITE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/antismash-lite:7.1.0--pyhdfd78af_0' :\n        'biocontainers/antismash-lite:7.1.0--pyhdfd78af_0' }\"\n\n    containerOptions {\n        workflow.containerEngine == 'singularity' ?\n        \"-B $antismash_dir:/usr/local/lib/python3.10/site-packages/antismash\" :\n        workflow.containerEngine == 'docker' ?\n        \"-v \\$PWD/$antismash_dir:/usr/local/lib/python3.10/site-packages/antismash\" :\n        ''\n        }\n\n    input:\n    tuple val(meta), path(sequence_input)\n    path(databases)\n    path(antismash_dir) // Optional input: AntiSMASH installation folder. It is not needed for using this module with conda, but required for docker/singularity (see meta.yml).\n    path(gff)\n\n    output:\n    tuple val(meta), path(\"${prefix}/clusterblast/*_c*.txt\")                 , optional: true, emit: clusterblast_file\n    tuple val(meta), path(\"${prefix}/{css,images,js}\")                       , emit: html_accessory_files\n    tuple val(meta), path(\"${prefix}/knownclusterblast/region*/ctg*.html\")   , optional: true, emit: knownclusterblast_html\n    tuple val(meta), path(\"${prefix}/knownclusterblast/\")                    , optional: true, emit: knownclusterblast_dir\n    tuple val(meta), path(\"${prefix}/knownclusterblast/*_c*.txt\")            , optional: true, emit: knownclusterblast_txt\n    tuple val(meta), path(\"${prefix}/svg/clusterblast*.svg\")                 , optional: true, emit: svg_files_clusterblast\n    tuple val(meta), path(\"${prefix}/svg/knownclusterblast*.svg\")            , optional: true, emit: svg_files_knownclusterblast\n    tuple val(meta), path(\"${prefix}/*.gbk\")                                 , emit: gbk_input\n    tuple val(meta), path(\"${prefix}/*.json\")                                , emit: json_results\n    tuple val(meta), path(\"${prefix}/*.log\")                                 , emit: log\n    tuple val(meta), path(\"${prefix}/*.zip\")                                 , emit: zip\n    tuple val(meta), path(\"${prefix}/*region*.gbk\")                          , optional: true, emit: gbk_results\n    tuple val(meta), path(\"${prefix}/clusterblastoutput.txt\")                , optional: true, emit: clusterblastoutput\n    tuple val(meta), path(\"${prefix}/index.html\")                            , emit: html\n    tuple val(meta), path(\"${prefix}/knownclusterblastoutput.txt\")           , optional: true, emit: knownclusterblastoutput\n    tuple val(meta), path(\"${prefix}/regions.js\")                            , emit: json_sideloading\n    path \"versions.yml\"                                                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.suffix ? \"${meta.id}${task.ext.suffix}\" : \"${meta.id}\"\n    gff_flag = gff ? \"--genefinding-gff3 ${gff}\" : \"\"\n\n    \"\"\"\n    ## We specifically do not include on-the-fly annotations (--genefinding-tool none) as\n    ## this should be run as a separate module for versioning purposes\n\n    antismash \\\\\n        $args \\\\\n        $gff_flag \\\\\n        -c $task.cpus \\\\\n        --output-dir $prefix \\\\\n        --output-basename $prefix \\\\\n        --genefinding-tool none \\\\\n        --logfile $prefix/${prefix}.log \\\\\n        --databases $databases \\\\\n        $sequence_input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        antismash-lite: \\$(echo \\$(antismash --version) | sed 's/antiSMASH //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.suffix ? \"${meta.id}${task.ext.suffix}\" : \"${meta.id}\"\n    def VERSION = '7.1.0' // WARN: Version information not provided by tool during stub run. Please update this string when bumping container versions.\n    \"\"\"\n    mkdir -p ${prefix}/css\n    mkdir ${prefix}/images\n    mkdir ${prefix}/js\n    touch ${prefix}/NZ_CP069563.1.region001.gbk\n    touch ${prefix}/NZ_CP069563.1.region002.gbk\n    touch ${prefix}/css/bacteria.css\n    touch ${prefix}/genome.gbk\n    touch ${prefix}/genome.json\n    touch ${prefix}/genome.zip\n    touch ${prefix}/images/about.svg\n    touch ${prefix}/index.html\n    touch ${prefix}/js/antismash.js\n    touch ${prefix}/js/jquery.js\n    touch ${prefix}/regions.js\n    touch ${prefix}/test.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        antismash-lite: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: antiSMASH allows the rapid genome-wide identification, annotation and analysis of secondary metabolite biosynthesis gene clusters. This module downloads the antiSMASH databases for conda and docker/singularity runs.\nTags: secondary metabolites, BGC, biosynthetic gene cluster, genome mining, NRPS, RiPP, antibiotics, prokaryotes, bacteria, eukaryotes, fungi, antismash, database", "answer": "process ANTISMASH_ANTISMASHLITEDOWNLOADDATABASES {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/antismash-lite:7.1.0--pyhdfd78af_0' :\n        'biocontainers/antismash-lite:7.1.0--pyhdfd78af_0' }\"\n\n    /*\n    These files are normally downloaded/created by download-antismash-databases itself, and must be retrieved for input by manually running the command with conda or a standalone installation of antiSMASH. Therefore we do not recommend using this module for production pipelines, but rather require users to specify their own local copy of the antiSMASH database in pipelines. This is solely for use for CI tests of the nf-core/module version of antiSMASH.\n    Reason: Upon execution, the tool checks if certain database files are present within the container and if not, it tries to create them in /usr/local/bin, for which only root user has write permissions. Mounting those database files with this module prevents the tool from trying to create them.\n    These files are also emitted as output channels in this module to enable the antismash-lite module to use them as mount volumes to the docker/singularity containers.\n    */\n\n    containerOptions {\n        workflow.containerEngine == 'singularity' ?\n        \"-B $database_css:/usr/local/lib/python3.10/site-packages/antismash/outputs/html/css,$database_detection:/usr/local/lib/python3.10/site-packages/antismash/detection,$database_modules:/usr/local/lib/python3.10/site-packages/antismash/modules\" :\n        workflow.containerEngine == 'docker' ?\n        \"-v \\$PWD/$database_css:/usr/local/lib/python3.10/site-packages/antismash/outputs/html/css -v \\$PWD/$database_detection:/usr/local/lib/python3.10/site-packages/antismash/detection -v \\$PWD/$database_modules:/usr/local/lib/python3.10/site-packages/antismash/modules\" :\n        ''\n        }\n\n    input:\n    path database_css\n    path database_detection\n    path database_modules\n\n    output:\n    path(\"antismash_db\") , emit: database\n    path(\"antismash_dir\"), emit: antismash_dir\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    cp_cmd = ( session.config.conda && session.config.conda.enabled ) ? \"cp -r \\$(python -c 'import antismash;print(antismash.__file__.split(\\\"/__\\\")[0])') antismash_dir;\" : \"cp -r /usr/local/lib/python3.10/site-packages/antismash antismash_dir;\"\n    \"\"\"\n    download-antismash-databases \\\\\n        --database-dir antismash_db \\\\\n        $args\n\n    $cp_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        antismash-lite: \\$(antismash --version | sed 's/antiSMASH //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    cp_cmd = (session.config.conda && session.config.conda.enabled ) ? \"cp -r \\$(python -c 'import antismash;print(antismash.__file__.split(\\\"/__\\\")[0])') antismash_dir;\" : \"cp -r /usr/local/lib/python3.10/site-packages/antismash antismash_dir;\"\n    def VERSION = '7.1.0' // WARN: Version information not provided by tool during stub run. Please update this string when bumping container versions.\n    \"\"\"\n    echo \"download-antismash-databases --database-dir antismash_db $args\"\n\n    echo \"$cp_cmd\"\n\n    mkdir antismash_dir\n    mkdir antismash_db\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        antismash-lite: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NUCmer is a pipeline for the alignment of multiple closely related nucleotide sequences.\nTags: align, nucleotide", "answer": "process NUCMER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mummer:3.23--pl5262h1b792b2_12' :\n        'biocontainers/mummer:3.23--pl5262h1b792b2_12' }\"\n\n    input:\n    tuple val(meta), path(ref), path(query)\n\n    output:\n    tuple val(meta), path(\"*.delta\") , emit: delta\n    tuple val(meta), path(\"*.coords\"), emit: coords\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed_ref   = ref.getName().endsWith(\".gz\")   ? true : false\n    def is_compressed_query = query.getName().endsWith(\".gz\") ? true : false\n    def fasta_name_ref      = ref.getName().replace(\".gz\", \"\")\n    def fasta_name_query    = query.getName().replace(\".gz\", \"\")\n    \"\"\"\n    if [ \"$is_compressed_ref\" == \"true\" ]; then\n        gzip -c -d $ref > $fasta_name_ref\n    fi\n    if [ \"$is_compressed_query\" == \"true\" ]; then\n        gzip -c -d $query > $fasta_name_query\n    fi\n\n    nucmer \\\\\n        -p $prefix \\\\\n        --coords \\\\\n        $args \\\\\n        $fasta_name_ref \\\\\n        $fasta_name_query\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nucmer: \\$( nucmer --version 2>&1  | grep \"version\" | sed -e \"s/NUCmer (NUCleotide MUMmer) version //g; s/nucmer//g;\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to build the reference needed by the 10x Genomics Cell Ranger ATAC tool. Uses the cellranger-atac mkref command.\nTags: reference, mkref, index", "answer": "process CELLRANGERATAC_MKREF {\n    tag \"$reference_config\"\n    label 'process_medium'\n\n    container \"nf-core/cellranger-atac:2.1.0\"\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGERATAC_MKREF module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    input:\n    path fasta\n    path gtf\n    path motifs\n    path reference_config\n    val reference_name\n\n    output:\n    path \"${reference_name}\", emit: reference\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    cellranger-atac \\\\\n        mkref \\\\\n        --config=$reference_config \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangeratac: \\$(echo \\$( cellranger-atac --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to create fastqs needed by the 10x Genomics Cell Ranger ATAC tool. Uses the cellranger-atac mkfastq command.\nTags: reference, mkfastq, fastq, illumina, bcl2fastq", "answer": "process CELLRANGERATAC_MKFASTQ {\n    tag \"mkfastq\"\n    label 'process_medium'\n\n    container \"nf-core/cellranger-atac:2.1.0\"\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGERATAC_MKFASTQ module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    input:\n    path bcl\n    path csv\n\n    output:\n    path \"versions.yml\", emit: versions\n    path \"${bcl.getSimpleName()}/outs/fastq_path/*.fastq.gz\"  , emit: fastq\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    cellranger-atac mkfastq --id=${bcl.getSimpleName()} \\\n        --run=$bcl \\\n        --csv=$csv \\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangeratac: \\$(echo \\$( cellranger-atac --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir -p \"${bcl.getSimpleName()}/outs/fastq_path/\"\n    touch ${bcl.getSimpleName()}/outs/fastq_path/fake_file.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangeratac: \\$(echo \\$( cellranger-atac --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to use Cell Ranger's ATAC pipelines analyze sequencing data produced from Chromium Single Cell ATAC.\nTags: align, count, reference", "answer": "process CELLRANGERATAC_COUNT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nf-core/cellranger-atac:2.1.0\"\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGERATAC_COUNT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    input:\n    tuple val(meta), path(reads)\n    path reference\n\n    output:\n    tuple val(meta), path(\"${meta.id}/outs/*\"), emit: outs\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def sample_arg = meta.samples.unique().join(\",\")\n    def reference_name = reference.name\n    \"\"\"\n    cellranger-atac \\\\\n        count \\\\\n        --id='${meta.id}' \\\\\n        --fastqs=. \\\\\n        --reference=$reference_name \\\\\n        --sample=$sample_arg \\\\\n        --localcores=$task.cpus \\\\\n        --localmem=${task.memory.toGiga()} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangeratac: \\$(echo \\$( cellranger-atac --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir -p \"${meta.id}/outs/\"\n    touch ${meta.id}/outs/fake_file.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangeratac: \\$(echo \\$( cellranger-atac --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: PileupCaller is a tool to create genotype calls from bam files using read-sampling methods\nTags: genotyping, mpileup, random draw, pseudohaploid, pseudodiploid, freqsum, plink, bed, eigenstrat", "answer": "process SEQUENCETOOLS_PILEUPCALLER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sequencetools:1.5.2--hec16e2b_1':\n        'biocontainers/sequencetools:1.5.2--hec16e2b_1' }\"\n\n    input:\n    tuple val(meta), path(mpileup)\n    path snpfile\n    path sample_names_fn\n\n    output:\n    tuple val(meta), path(\"*.geno\"), path(\"*.snp\"), path(\"*.ind\")   , optional:true, emit: eigenstrat\n    tuple val(meta), path(\"*.bed\"), path(\"*.bim\"), path(\"*.fam\")    , optional:true, emit: plink\n    tuple val(meta), path(\"*.freqsum.gz\")                           , optional:true, emit: freqsum\n    path \"versions.yml\"                                                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def sample_names = sample_names_fn ? \"--sampleNameFile ${sample_names_fn}\" : ''\n    def args_list = args.tokenize()\n    // If no output format is set, freqsum is produced in stdout.\n    freqsum_output = \"-e\" in args_list || \"--eigenstratOut\" in args_list || \"-p\" in args_list || \"--plinkOut\" in args_list ? '' : \"| gzip -c > ${prefix}.freqsum.gz\"\n\n    \"\"\"\n    gzip -cdf ${mpileup} | \\\\\n    pileupCaller \\\\\n        -f ${snpfile} \\\\\n        ${sample_names} \\\\\n        ${args} \\\\\n        ${freqsum_output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sequencetools: \\$(echo \\$(pileupCaller --version 2>&1) )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Removes all non-variant blocks from a gVCF file to produce a smaller variant-only VCF file.\nTags: gvcftools, extract_variants, extractvariants, gvcf, vcf", "answer": "process GVCFTOOLS_EXTRACTVARIANTS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gvcftools:0.17.0--he941832_3':\n        'biocontainers/gvcftools:0.17.0--he941832_3' }\"\n\n    input:\n    tuple val(meta), path(gvcf)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def open_gvcf = gvcf.extension == \"gz\" ? \"gzip -dc $gvcf\" : \"cat $gvcf\"\n\n    \"\"\"\n    $open_gvcf |\n    extract_variants \\\\\n        $args \\\\\n        $gvcf |\n    gzip -c > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gvcftools: \\$(extract_variants --help 2>&1 | grep version | sed 's/version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Identify chromosomal rearrangements.\nTags: structural, variants, vcf", "answer": "process TIDDIT_SV {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/tiddit:3.6.1--py38h24c8ff8_0' :\n        'biocontainers/tiddit:3.6.1--py38h24c8ff8_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(bwa_index)\n\n    output:\n    tuple val(meta), path(\"*.vcf\")         , emit: vcf\n    tuple val(meta), path(\"*.ploidies.tab\"), emit: ploidy\n    path  \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bwa_command = bwa_index ? \"[[ -d $bwa_index ]] && for i in $bwa_index/*; do [[ -f $fasta && ! \\\"\\$i\\\" =~ .*\\\"$fasta.\\\".* ]] && ln -s \\$i ${fasta}.\\${i##*.} || ln -s \\$i .; done\" : \"\"\n\n    \"\"\"\n    $bwa_command\n\n    tiddit \\\\\n        --sv \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --bam $input \\\\\n        --ref $fasta \\\\\n        -o $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tiddit: \\$(echo \\$(tiddit 2>&1) | sed 's/^.*tiddit-//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf\n    touch ${prefix}.ploidies.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tiddit: \\$(echo \\$(tiddit 2>&1) | sed 's/^.*tiddit-//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes the coverage of different regions from the bam file.\nTags: coverage, bam, statistics, chromosomal rearrangements", "answer": "process TIDDIT_COV {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/tiddit:3.6.1--py38h24c8ff8_0' :\n        'biocontainers/tiddit:3.6.1--py38h24c8ff8_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), optional: true, emit: cov\n    tuple val(meta), path(\"*.wig\"), optional: true, emit: wig\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--ref $fasta\" : \"\"\n    \"\"\"\n    tiddit \\\\\n        --cov \\\\\n        -o $prefix \\\\\n        $args \\\\\n        --bam $input \\\\\n        $reference\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tiddit: \\$(echo \\$(tiddit 2>&1) | sed 's/^.*tiddit-//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.wig\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tiddit: \\$(echo \\$(tiddit 2>&1) | sed 's/^.*tiddit-//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The wham suite consists of two programs, wham and whamg. wham, the original tool, is a very sensitive method with a high false discovery rate. The second program, whamg, is more accurate and better suited for general structural variant (SV) discovery.\nTags: whamg, wham, vcf, bam, variant calling", "answer": "process WHAMG {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-fb3127231a8f88daa68d5eb0eec49593cd98b440:e6a1c182ebdfe372b5e3cdc05a6cece64cef7274-0':\n        'biocontainers/mulled-v2-fb3127231a8f88daa68d5eb0eec49593cd98b440:e6a1c182ebdfe372b5e3cdc05a6cece64cef7274-0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path(fasta)\n    path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")       , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\")   , emit: tbi\n    tuple val(meta), path(\"*.txt\")          , emit: graph, optional: true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    whamg \\\\\n        -x ${task.cpus} \\\\\n        -f ${bam} \\\\\n        -a ${fasta} \\\\\n        ${args} \\\\\n        | bgzip ${args2} --threads ${task.cpus} --stdout > ${prefix}.vcf.gz\n\n        tabix ${args3} ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        whamg: \\$(echo \\$(whamg 2>&1 | grep Version | sed 's/^Version: v//; s/-.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Scans genome contigs against the ResFinder, PlasmidFinder, and PointFinder databases.\nTags: amr, plasmid, mlst, genomics", "answer": "process STARAMR_SEARCH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/staramr:0.10.0--pyhdfd78af_0':\n        'biocontainers/staramr:0.10.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(genome_fasta) // genome as a fasta file\n\n    output:\n    tuple val(meta), path(\"*_results/results.xlsx\")        , emit: results_xlsx\n    tuple val(meta), path(\"*_results/summary.tsv\")         , emit: summary_tsv\n    tuple val(meta), path(\"*_results/detailed_summary.tsv\"), emit: detailed_summary_tsv\n    tuple val(meta), path(\"*_results/resfinder.tsv\")       , emit: resfinder_tsv\n    tuple val(meta), path(\"*_results/plasmidfinder.tsv\")   , emit: plasmidfinder_tsv\n    tuple val(meta), path(\"*_results/mlst.tsv\")            , emit: mlst_tsv\n    tuple val(meta), path(\"*_results/settings.txt\")        , emit: settings_txt\n    tuple val(meta), path(\"*_results/pointfinder.tsv\")     , emit: pointfinder_tsv, optional: true\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_gzipped = genome_fasta.getName().endsWith(\".gz\") ? true : false\n    def genome_uncompressed_name = genome_fasta.getName().replace(\".gz\", \"\")\n    \"\"\"\n    if [ \"$is_gzipped\" = \"true\" ]; then\n        gzip -c -d $genome_fasta > $genome_uncompressed_name\n    fi\n\n    staramr \\\\\n        search \\\\\n        $args \\\\\n        --nprocs $task.cpus \\\\\n        -o ${prefix}_results \\\\\n        $genome_uncompressed_name\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        staramr : \\$(echo \\$(staramr --version 2>&1) | sed 's/^.*staramr //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}_results\n    touch ${prefix}_results/results.xlsx\n    touch ${prefix}_results/{summary,detailed_summary,resfinder,pointfinder,plasmidfinder,mlst}.tsv.gz\n    touch ${prefix}_results/settings.txt.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        staramr : \\$(echo \\$(staramr --version 2>&1) | sed 's/^.*staramr //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: igv.js is an embeddable interactive genome visualization component\nTags: igv, igv.js, js, genome browser", "answer": "\nprocess IGV_JS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:22.04' :\n        'nf-core/ubuntu:22.04' }\"\n\n    input:\n    tuple val(meta), path(alignment), path(index)\n\n    output:\n    tuple val(meta), path(\"*_genome-browser.html\") , emit: browser\n    tuple val(meta), path(alignment)               , emit: align_files\n    tuple val(meta), path(index)                   , emit: index_files\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def browser_args = task.ext.args ?: ''\n    def track_args = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cat  <<IGV > ${prefix}_genome-browser.html\n    <html>\n        <head>\n            <script src=\"https://cdn.jsdelivr.net/npm/igv@2.13.9/dist/igv.min.js\"></script> <!-- https://github.com/igvteam/igv.js/ -->\n        </head>\n        <body>\n\n        <div id=\"igv-div\"></div>\n        <script>\n            var igvDiv = document.getElementById(\"igv-div\");\n            var options =\n            {\n                $browser_args,\n                tracks: [\n                    {\n                        \"name\": \"$prefix\",\n                        \"url\": \"$alignment\",\n                        \"indexURL\": \"$index\",\n                        $track_args\n                    }\n                ]\n            };\n            igv.removeAllBrowsers();\n            igv.createBrowser(igvDiv, options)\n                .then(function(browser){\n                    igv.browser = browser;\n                })\n        </script>\n\n        </body>\n    </html>\n    IGV\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cat: \\$(echo \\$(cat --version 2>&1) | sed 's/^.*coreutils) //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Evaluate alignment data\nTags: quality control, qc, rnaseq", "answer": "process QUALIMAP_RNASEQ {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/qualimap:2.3--hdfd78af_0' :\n        'biocontainers/qualimap:2.3--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(gtf)\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: results\n    path  \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def paired_end = meta.single_end ? '' : '-pe'\n    def memory = (task.memory.mega*0.8).intValue() + 'M'\n\n    def strandedness = 'non-strand-specific'\n    if (meta.strandedness == 'forward') {\n        strandedness = 'strand-specific-forward'\n    } else if (meta.strandedness == 'reverse') {\n        strandedness = 'strand-specific-reverse'\n    }\n    \"\"\"\n    unset DISPLAY\n    mkdir -p tmp\n    export _JAVA_OPTIONS=-Djava.io.tmpdir=./tmp\n    qualimap \\\\\n        --java-mem-size=$memory \\\\\n        rnaseq \\\\\n        $args \\\\\n        -bam $bam \\\\\n        -gtf $gtf \\\\\n        -p $strandedness \\\\\n        $paired_end \\\\\n        -outdir $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        qualimap: \\$(echo \\$(qualimap 2>&1) | sed 's/^.*QualiMap v.//; s/Built.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        qualimap: \\$(echo \\$(qualimap 2>&1) | sed 's/^.*QualiMap v.//; s/Built.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Evaluate alignment data\nTags: quality control, qc, bam", "answer": "process QUALIMAP_BAMQC {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/qualimap:2.3--hdfd78af_0' :\n        'biocontainers/qualimap:2.3--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path gff\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: results\n    path  \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n\n    def collect_pairs = meta.single_end ? '' : '--collect-overlap-pairs'\n    def memory = (task.memory.mega*0.8).intValue() + 'M'\n    def regions = gff ? \"--gff $gff\" : ''\n\n    def strandedness = 'non-strand-specific'\n    if (meta.strandedness == 'forward') {\n        strandedness = 'strand-specific-forward'\n    } else if (meta.strandedness == 'reverse') {\n        strandedness = 'strand-specific-reverse'\n    }\n    \"\"\"\n    unset DISPLAY\n    mkdir -p tmp\n    export _JAVA_OPTIONS=-Djava.io.tmpdir=./tmp\n    qualimap \\\\\n        --java-mem-size=$memory \\\\\n        bamqc \\\\\n        $args \\\\\n        -bam $bam \\\\\n        $regions \\\\\n        -p $strandedness \\\\\n        $collect_pairs \\\\\n        -outdir $prefix \\\\\n        -nt $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        qualimap: \\$(echo \\$(qualimap 2>&1) | sed 's/^.*QualiMap v.//; s/Built.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.suffix ? \"${meta.id}${task.ext.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    mkdir -p $prefix/css\n    mkdir $prefix/images_qualimapReport\n    mkdir $prefix/raw_data_qualimapReport\n    cd $prefix/css\n    touch agogo.css\n    touch basic.css\n    touch bgtop.png\n    touch comment-close.png\n    touch doctools.js\n    touch down-pressed.png\n    touch jquery.js\n    touch plus.png\n    touch qualimap_logo_small.png\n    touch searchtools.js\n    touch up.png\n    touch websupport.js\n    touch ajax-loader.gif\n    touch bgfooter.png\n    touch comment-bright.png\n    touch comment.png\n    touch down.png\n    touch file.png\n    touch minus.png\n    touch pygments.css\n    touch report.css\n    touch underscore.js\n    touch up-pressed.png\n    cd ../images_qualimapReport/\n    touch genome_coverage_0to50_histogram.png\n    touch genome_coverage_quotes.png\n    touch genome_insert_size_across_reference.png\n    touch genome_mapping_quality_histogram.png\n    touch genome_uniq_read_starts_histogram.png\n    touch genome_coverage_across_reference.png\n    touch genome_gc_content_per_window.png\n    touch genome_insert_size_histogram.png\n    touch genome_reads_clipping_profile.png\n    touch genome_coverage_histogram.png\n    touch genome_homopolymer_indels.png\n    touch genome_mapping_quality_across_reference.png\n    touch genome_reads_content_per_read_position.png\n    cd ../raw_data_qualimapReport\n    touch coverage_across_reference.txt\n    touch genome_fraction_coverage.txt\n    touch insert_size_histogram.txt\n    touch mapped_reads_nucleotide_content.txt\n    touch coverage_histogram.txt\n    touch homopolymer_indels.txt\n    touch mapped_reads_clipping_profile.txt\n    touch mapping_quality_across_reference.txt\n    touch duplication_rate_histogram.txt\n    touch insert_size_across_reference.txt\n    touch mapped_reads_gc-content_distribution.txt\n    touch mapping_quality_histogram.txt\n    cd ../\n    touch genome_results.txt\n    touch qualimapReport.html\n    cd ../\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        qualimap: \\$(echo \\$(qualimap 2>&1) | sed 's/^.*QualiMap v.//; s/Built.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Evaluate alignment data\nTags: quality control, qc, bam", "answer": "process QUALIMAP_BAMQCCRAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d3934ca6bb4e61334891ffa2e9a4c87a530e3188:00d3c18496ddf07ea580fd00d1dd203cf31ab630-0' :\n        'biocontainers/mulled-v2-d3934ca6bb4e61334891ffa2e9a4c87a530e3188:00d3c18496ddf07ea580fd00d1dd203cf31ab630-0' }\"\n\n    input:\n    tuple val(meta), path(cram), path(crai)\n    path  gff\n    path  fasta\n    path  fasta_fai\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: results\n    path  \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n\n    def collect_pairs = meta.single_end ? '' : '--collect-overlap-pairs'\n    def memory = (task.memory.mega*0.8).intValue() + 'M'\n    def regions = gff ? \"--gff $gff\" : ''\n\n    def strandedness = 'non-strand-specific'\n    if (meta.strandedness == 'forward') {\n        strandedness = 'strand-specific-forward'\n    } else if (meta.strandedness == 'reverse') {\n        strandedness = 'strand-specific-reverse'\n    }\n    \"\"\"\n    unset DISPLAY\n    mkdir -p tmp\n    export _JAVA_OPTIONS=-Djava.io.tmpdir=./tmp\n\n    samtools view -hb -T ${fasta} ${cram} |\n    qualimap \\\\\n        --java-mem-size=$memory \\\\\n        bamqc \\\\\n        $args \\\\\n        -bam /dev/stdin \\\\\n        $regions \\\\\n        -p $strandedness \\\\\n        $collect_pairs \\\\\n        -outdir $prefix \\\\\n        -nt $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        qualimap: \\$(echo \\$(qualimap 2>&1) | sed 's/^.*QualiMap v.//; s/Built.*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        qualimap: \\$(echo \\$(qualimap 2>&1) | sed 's/^.*QualiMap v.//; s/Built.*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: PEAR is an ultrafast, memory-efficient and highly accurate pair-end read merger.\nTags: pair-end, read, merge", "answer": "process PEAR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pear:0.9.6--h67092d7_8':\n        'biocontainers/pear:0.9.6--h67092d7_8' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.assembled.fastq.gz\")                                                  , emit: assembled\n    tuple val(meta), path(\"*.unassembled.forward.fastq.gz\"), path(\"*.unassembled.reverse.fastq.gz\"), emit: unassembled\n    tuple val(meta), path(\"*.discarded.fastq.gz\")                                                  , emit: discarded\n    path \"versions.yml\"                                                                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gunzip -f ${reads[0]}\n    gunzip -f ${reads[1]}\n    pear \\\\\n        -f ${reads[0].baseName} \\\\\n        -r ${reads[1].baseName} \\\\\n        -o $prefix \\\\\n        -j $task.cpus \\\\\n        $args\n    gzip -f ${prefix}.assembled.fastq\n    gzip -f ${prefix}.unassembled.forward.fastq\n    gzip -f ${prefix}.unassembled.reverse.fastq\n    gzip -f ${prefix}.discarded.fastq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pear: \\$(pear -h | grep 'PEAR v' | sed 's/PEAR v//' | sed 's/ .*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Main caller script for peak calling\nTags: peak-calling, CoPRO, GRO-cap, PRO-cap, CAGE, NETCAGE, RAMPAGE, csRNA-seq, STRIPE-seq, PRO-seq, GRO-seq", "answer": "process PINTS_CALLER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pypints:1.1.8--pyh7cba7a3_0' :\n        'biocontainers/pypints:1.1.8--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(bams)\n\n    output:\n    tuple val(meta), path(\"*_divergent_peaks.bed\")     , optional:true, emit: divergent_TREs\n    tuple val(meta), path(\"*_bidirectional_peaks.bed\") , optional:true, emit: bidirectional_TREs\n    tuple val(meta), path(\"*_unidirectional_peaks.bed\"), optional:true, emit: unidirectional_TREs\n    tuple val(meta), path(\"peakcalling_*.log\")                        , emit: peakcalling_log\n    path  \"versions.yml\"                                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // TODO handle bigwigs\n    // def input_type  = (\"${input[0]}\".endsWith(\".bam\")) ? \"--bam-file $input\" :\n    //                    (\"$input\".contains(\".bw\")) ? \"--bw-pl ${input[0]} --bw-mn ${input[1]}\" :\n    //                    error \"Please use bam or BigWig files\"\n    \"\"\"\n    pints_caller \\\\\n        --bam-file $bams \\\\\n        --save-to . \\\\\n        --file-prefix $prefix \\\\\n        --thread $task.cpus \\\\\n        --dont-check-updates \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        python: \\$(python --version | sed 's/Python //g')\n        pints: \\$(pints_caller --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Demultiplex Illumina BCL files\nTags: demultiplex, illumina, fastq", "answer": "process BCLCONVERT {\n    tag {\"$meta.lane\" ? \"$meta.id\"+\".\"+\"$meta.lane\" : \"$meta.id\" }\n    label 'process_high'\n\n    container \"nf-core/bclconvert:4.3.6\"\n\n    input:\n    tuple val(meta), path(samplesheet), path(run_dir)\n\n    output:\n    tuple val(meta), path(\"output/**_S[1-9]*_R?_00?.fastq.gz\")           , emit: fastq\n    tuple val(meta), path(\"output/**_S[1-9]*_I?_00?.fastq.gz\")           , optional:true, emit: fastq_idx\n    tuple val(meta), path(\"output/**Undetermined_S0*_R?_00?.fastq.gz\")   , optional:true, emit: undetermined\n    tuple val(meta), path(\"output/**Undetermined_S0*_I?_00?.fastq.gz\")   , optional:true, emit: undetermined_idx\n    tuple val(meta), path(\"output/Reports\")                              , emit: reports\n    tuple val(meta), path(\"output/Logs\")                                 , emit: logs\n    tuple val(meta), path(\"**/InterOp/*.bin\", includeInputs: true), emit: interop\n    path(\"versions.yml\")                                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"BCLCONVERT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def input_tar = run_dir.toString().endsWith(\".tar.gz\") ? true : false\n    def input_dir = input_tar ? run_dir.toString() - '.tar.gz' : run_dir\n    \"\"\"\n    if [ ! -d ${input_dir} ]; then\n        mkdir -p ${input_dir}\n    fi\n\n    if ${input_tar}; then\n        ## Ensures --strip-components only applied when top level of tar contents is a directory\n        ## If just files or multiple directories, place all in $input_dir\n\n        if [[ \\$(tar -taf ${run_dir} | grep -o -P \"^.*?\\\\/\" | uniq | wc -l) -eq 1 ]]; then\n            tar \\\\\n                -C $input_dir --strip-components 1 \\\\\n                -xavf \\\\\n                $args2 \\\\\n                $run_dir \\\\\n                $args3\n        else\n            tar \\\\\n                -C $input_dir \\\\\n                -xavf \\\\\n                $args2 \\\\\n                $run_dir \\\\\n                $args3\n        fi\n    fi\n\n    bcl-convert \\\\\n        $args \\\\\n        --output-directory output \\\\\n        --bcl-input-directory ${input_dir} \\\\\n        --sample-sheet ${samplesheet}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bclconvert: \\$(bcl-convert -V 2>&1 | head -n 1 | sed 's/^.*Version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Read CEL files into an ExpressionSet and generate a matrix\nTags: affy, microarray, expression, matrix", "answer": "process AFFY_JUSTRMA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-affy:1.78.0--r43ha9d7317_1':\n        'biocontainers/bioconductor-affy:1.78.0--r43ha9d7317_1' }\"\n\n    input:\n    tuple val(meta), path(samplesheet), path(celfiles_dir)\n    tuple val(meta2), path(description)\n\n    output:\n    tuple val(meta), path(\"*.rds\")             , emit: rds\n    tuple val(meta), path(\"*matrix.tsv\")       , emit: expression\n    tuple val(meta), path(\"*.annotation.tsv\")  , emit: annotation, optional: true\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    template 'affy_justrma.R'\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_eset.rds\n    touch ${prefix}_matrix.tsv\n    touch R_sessionInfo.log\n    touch versions.yml\n    \"\"\"\n}\n"}
{"question": "Description: Generate tables of feature metadata from GTF files\nTags: gtf, gene, annotation", "answer": "process ATLASGENEANNOTATIONMANIPULATION_GTF2FEATUREANNOTATION {\n    tag \"${meta.id}\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/atlas-gene-annotation-manipulation%3A1.1.1--hdfd78af_0':\n        'biocontainers/atlas-gene-annotation-manipulation:1.1.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gtf)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.anno.tsv\")                 , emit: feature_annotation\n    tuple val(meta), path(\"*.fa.gz\")                    , emit: filtered_cdna, optional: true\n    path(\"versions.yml\")                                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: meta.id\n    def reference_cdna = fasta ? \"--parse-cdnas $fasta\" : \"\"\n    def VERSION = '1.1.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    gtf2featureAnnotation.R \\\\\n        --gtf-file $gtf \\\\\n        --output-file ${prefix}.anno.tsv \\\\\n        $reference_cdna \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        atlas-gene-annotation-manipulation: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: meta.id\n    def reference_cdna = fasta ? \"--parse-cdnas $fasta\" : \"\"\n    def VERSION = '1.1.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${meta.id}.anno.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        atlas-gene-annotation-manipulation: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: A program to take a counts file and creates a file of genomic co-ordinates to be masked.\nTags: fasta, interval, windowmasker", "answer": "process WINDOWMASKER_USTAT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta) , path(counts)\n    tuple val(meta2), path(ref)\n\n    output:\n    tuple val(meta), path(\"${output}\")  , emit: intervals\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    =   task.ext.args         ?: \"\"\n    def prefix  =   task.ext.prefix       ?: \"${meta.id}\"\n    def outfmt  =   args.contains('-outfmt fasta')                ? 'fasta'               :\n                    args.contains('-outfmt maskinfo_asn1_bin')    ? 'maskinfo_asn1_bin'   :\n                    args.contains('-outfmt maskinfo_asn1_text')   ? 'maskinfo_asn1_text'  :\n                    args.contains('-outfmt maskinfo_xml')         ? 'maskinfo_xml'        :\n                    args.contains('-outfmt seqloc_asn1_bin')      ? 'seqloc_asn1_bin'     :\n                    args.contains('-outfmt seqloc_asn1_text')     ? 'seqloc_asn1_text'    :\n                    args.contains('-outfmt seqloc_xml')           ? 'seqloc_xml'          :\n                    'interval'\n\n    output  = \"${prefix}.${outfmt}\"\n\n    \"\"\"\n    windowmasker -ustat \\\\\n        ${counts} \\\\\n        $args \\\\\n        -in ${ref} \\\\\n        -out ${output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        windowmasker: \\$(windowmasker -version-full | head -n 1 | sed 's/^.*windowmasker: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args    =   task.ext.args         ?: \"\"\n    def prefix  =   task.ext.prefix       ?: \"${meta.id}\"\n    def outfmt  =   args.contains('-outfmt fasta')                ? 'fasta'               :\n                    args.contains('-outfmt maskinfo_asn1_bin')    ? 'maskinfo_asn1_bin'   :\n                    args.contains('-outfmt maskinfo_asn1_text')   ? 'maskinfo_asn1_text'  :\n                    args.contains('-outfmt maskinfo_xml')         ? 'maskinfo_xml'        :\n                    args.contains('-outfmt seqloc_asn1_bin')      ? 'seqloc_asn1_bin'     :\n                    args.contains('-outfmt seqloc_asn1_text')     ? 'seqloc_asn1_text'    :\n                    args.contains('-outfmt seqloc_xml')           ? 'seqloc_xml'          :\n                    'interval'\n\n    output  = \"${prefix}.${outfmt}\"\n    \"\"\"\n    touch ${output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        windowmasker: \\$(windowmasker -version-full | head -n 1 | sed 's/^.*windowmasker: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A program to generate frequency counts of repetitive units.\nTags: fasta, interval, windowmasker", "answer": "process WINDOWMASKER_MKCOUNTS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta), path(ref)\n\n    output:\n    tuple val(meta), path(\"*.txt\")  , emit: counts\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args     ?: \"\"\n    def prefix  = task.ext.prefix   ?: \"${meta.id}\"\n\n    def memory  = 3072\n    if (!task.memory) {\n        log.info '[WINDOWMASKER: MK_COUNTS] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        memory  = (task.memory.toMega()).intValue()\n    }\n\n    \"\"\"\n    windowmasker -mk_counts \\\\\n        $args \\\\\n        -mem ${memory} \\\\\n        -in ${ref} \\\\\n        -out ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        windowmasker: \\$(windowmasker -version-full | head -n 1 | sed 's/^.*windowmasker: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix   ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        windowmasker: \\$(windowmasker -version-full | head -n 1 | sed 's/^.*windowmasker: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Masks out highly repetitive DNA sequences with low complexity in a genome\nTags: fasta, blast, windowmasker", "answer": "process WINDOWMASKER_CONVERT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta), path(counts)\n\n    output:\n    tuple val(meta), path(\"${output}\"), emit: converted\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   =    task.ext.args                       ?: ''\n    def prefix =    task.ext.prefix                     ?: \"${meta.id}\"\n    def outfmt =    args.contains('-sformat binary')    ? 'binary'  :\n                    args.contains('-sformat oascii')    ? 'oascii'  :\n                    args.contains('-sformat obinary')   ? 'obinary' :\n                    'ascii'\n    output  = \"${prefix}.${outfmt}\"\n    \"\"\"\n    windowmasker -convert \\\\\n        -in $counts \\\\\n        -out $output \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        windowmasker: \\$(windowmasker -version-full | head -n 1 | sed 's/^.*windowmasker: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   =    task.ext.args                       ?: ''\n    def prefix =    task.ext.prefix                     ?: \"${meta.id}\"\n    def outfmt =    args.contains('-sformat binary')    ? 'binary'  :\n                    args.contains('-sformat oascii')    ? 'oascii'  :\n                    args.contains('-sformat obinary')   ? 'obinary' :\n                    'ascii'\n    output  = \"${prefix}.${outfmt}\"\n    \"\"\"\n    touch ${output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        windowmasker: \\$(windowmasker -version-full | head -n 1 | sed 's/^.*windowmasker: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Post-processing script of the MaltExtract component of the HOPS package\nTags: malt, MaltExtract, HOPS, amps, alignment, metagenomics, ancient DNA, aDNA, palaeogenomics, archaeogenomics, microbiome, authentication, damage, edit distance, post Post-processing, visualisation", "answer": "process AMPS {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hops:0.35--hdfd78af_1' :\n        'biocontainers/hops:0.35--hdfd78af_1' }\"\n\n    input:\n    path maltextract_results\n    path taxon_list\n    val filter\n\n    output:\n    path \"results/heatmap_overview_Wevid.json\" , emit: json\n    path \"results/heatmap_overview_Wevid.pdf\"  , emit: summary_pdf\n    path \"results/heatmap_overview_Wevid.tsv\"  , emit: tsv\n    path \"results/pdf_candidate_profiles/\"     , emit: candidate_pdfs\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    postprocessing.AMPS.r \\\\\n        -r $maltextract_results \\\\\n        -n $taxon_list \\\\\n        -m $filter \\\\\n        -t $task.cpus \\\\\n        -j \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        amps: \\$(echo \\$(hops --version 2>&1) | sed 's/HOPS version//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates a Krona chart from text files listing quantities and lineages.\nTags: plot, taxonomy, interactive, html, visualisation, krona chart, metagenomics", "answer": "process KRONA_KTIMPORTTEXT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krona:2.8.1--pl5321hdfd78af_1':\n        'biocontainers/krona:2.8.1--pl5321hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(report)\n\n    output:\n    tuple val(meta), path ('*.html'), emit: html\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ktImportText  \\\\\n        $args \\\\\n        -o ${prefix}.html \\\\\n        $report\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        krona: \\$( echo \\$(ktImportText 2>&1) | sed 's/^.*KronaTools //g; s/- ktImportText.*\\$//g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        krona: \\$( echo \\$(ktImportText 2>&1) | sed 's/^.*KronaTools //g; s/- ktImportText.*\\$//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: KronaTools Update Taxonomy downloads a taxonomy database\nTags: database, taxonomy, krona", "answer": "def VERSION='2.7.1' // Version information not provided by tool on CLI\n\nprocess KRONA_KRONADB {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krona:2.7.1--pl526_5' :\n        'biocontainers/krona:2.7.1--pl526_5' }\"\n\n    output:\n    path 'taxonomy/taxonomy.tab', emit: db\n    path \"versions.yml\"         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    ktUpdateTaxonomy.sh \\\\\n        $args \\\\\n        taxonomy/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        krona: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: KronaTools Import Taxonomy imports taxonomy classifications and produces an interactive Krona plot.\nTags: plot, taxonomy, interactive, html, visualisation, krona chart", "answer": "process KRONA_KTIMPORTTAXONOMY {\n    tag \"${meta.id}\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krona:2.8.1--pl5321hdfd78af_1':\n        'biocontainers/krona:2.8.1--pl5321hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(report)\n    path taxonomy, stageAs: 'taxonomy.tab'\n\n    output:\n    tuple val(meta), path ('*.html'), emit: html\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.8.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    TAXONOMY=\\$(find -L . -name '*.tab' -exec dirname {} \\\\;)\n    echo \\$TAXONOMY\n\n    ktImportTaxonomy \\\\\n        $args \\\\\n        -o ${prefix}.html \\\\\n        -tax \\$TAXONOMY/ \\\\\n        $report\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        krona: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.8.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        krona: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: KronaTools Update Taxonomy downloads a taxonomy database\nTags: database, taxonomy, krona, visualisation", "answer": "def VERSION='2.7.1' // Version information not provided by tool on CLI\n\nprocess KRONA_KTUPDATETAXONOMY {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krona:2.7.1--pl526_5' :\n        'biocontainers/krona:2.7.1--pl526_5' }\"\n\n    output:\n    path 'taxonomy/taxonomy.tab', emit: db\n    path \"versions.yml\"         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    ktUpdateTaxonomy.sh \\\\\n        $args \\\\\n        taxonomy/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        krona: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes cytosine methylation and callable SNV mutations, optionally in reference to a germline BAM to call somatic variants\nTags: bisulfite, DNA methylation, pileup, variant calling, WGBS, scWGBS, bam, vcf", "answer": "process BISCUIT_PILEUP {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0':\n        'biocontainers/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0' }\"\n\n    input:\n    tuple val(meta), path(normal_bams), path(normal_bais), path(tumor_bam), path(tumor_bai)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def biscuit_cpus = (int) Math.max(Math.floor(task.cpus*0.9),1)\n    def bgzip_cpus = task.cpus-biscuit_cpus\n    if ( tumor_bam != [] && normal_bams.toList().size() > 1 ) error \"[BISCUIT_PILEUP] error: Tumor BAM provided with more than one normal BAM\"\n    if ( tumor_bam.toList().size() > 1 ) error \"[BISCUIT_PILEUP] error: more than one tumor BAM provided\"\n    input = ( tumor_bam==[] ) ? \"${normal_bams}\" : \"-S -T ${tumor_bam} -I ${normal_bams}\"\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.bis.amb\" | sed 's/\\\\.bis.amb\\$//'`\n\n    biscuit pileup \\\\\n        -@ $biscuit_cpus \\\\\n        $args \\\\\n        \\$INDEX \\\\\n        $input \\\\\n        | bgzip -@ $bgzip_cpus $args2 > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A fast, compact one-liner to produce duplicate-marked, sorted, and indexed BAM files using Biscuit\nTags: biscuit, DNA methylation, WGBS, scWGBS, bisulfite sequencing, aligner, bam", "answer": "process BISCUIT_BLASTER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0':\n        'biocontainers/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path(\"*.bai\"), emit: bai\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def biscuit_cpus = (int) Math.max(Math.floor(task.cpus*0.95),1)\n    def samtools_cpus = task.cpus-biscuit_cpus\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.bis.amb\" | sed 's/\\\\.bis.amb\\$//'`\n\n    biscuit align \\\\\n        -@ $biscuit_cpus \\\\\n        $args \\\\\n        \\$INDEX \\\\\n        $reads | \\\\\n    samblaster \\\\\n        $args2 | \\\\\n    samtools sort \\\\\n        -@ $samtools_cpus \\\\\n        $args3 \\\\\n        --write-index \\\\\n        -o ${prefix}.bam##idx##${prefix}.bam.bai\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n        samtools: \\$( samtools --version |& sed '1!d; s/^.*samtools //' )\n        samblaster: \\$( samblaster --version |& sed 's/^.*samblaster: Version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix}.bam.bai\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n        samtools: \\$( samtools --version |& sed '1!d; s/^.*samtools //' )\n        samblaster: \\$( samblaster --version |& sed 's/^.*samblaster: Version //' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Merges methylation information for opposite-strand C's in a CpG context\nTags: biscuit, DNA methylation, WGBS, scWGBS, bisulfite sequencing, aligner, bed", "answer": "process BISCUIT_MERGECG {\n    tag \"$meta.id\"\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0':\n        'biocontainers/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0' }\"\n\n\n    input:\n    tuple val(meta), path(bed)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.bed.gz\"), emit: mergecg_bed\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.bis.amb\" | sed 's/\\\\.bis.amb\\$//'`\n\n    biscuit mergecg \\\\\n        $args \\\\\n        \\$INDEX \\\\\n        $bed | \\\\\n    LC_ALL=C sort -k1,1 -k2,2n | \\\\\n    bgzip \\\\\n        $args2 \\\\\n        -c > ${prefix}.bed.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n        samtools: \\$( samtools --version |& sed '1!d; s/^.*samtools //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.bed.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n        samtools: \\$( samtools --version |& sed '1!d; s/^.*samtools //' )\n    END_VERSIONS\n    \"\"\"\n\n\n}\n"}
{"question": "Description: Aligns single- or paired-end reads from bisulfite-converted libraries to a reference genome using Biscuit.\nTags: biscuit, DNA methylation, WGBS, scWGBS, bisulfite sequencing, aligner, bam", "answer": "process BISCUIT_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0':\n        'biocontainers/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path(\"*.bai\"), emit: bai\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def biscuit_cpus = (int) Math.max(Math.floor(task.cpus*0.9),1)\n    def samtools_cpus = task.cpus-biscuit_cpus\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.bis.amb\" | sed 's/\\\\.bis.amb\\$//'`\n\n    biscuit align \\\\\n        $args \\\\\n        -@ $biscuit_cpus \\\\\n        \\$INDEX \\\\\n        $reads \\\\\n        | samtools sort $args2 --threads $samtools_cpus --write-index -o ${prefix}.bam##idx##${prefix}.bam.bai -\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n        samtools: \\$( samtools --version |& sed '1!d; s/^.*samtools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Indexes a reference genome for use with Biscuit\nTags: biscuit, DNA methylation, WGBS, scWGBS, bisulfite sequencing, index, reference, fasta", "answer": "process BISCUIT_INDEX {\n    tag \"$fasta\"\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/biscuit:1.1.0.20220707--he272189_1':\n        'biocontainers/biscuit:1.1.0.20220707--he272189_1' }\"\n\n    input:\n    path fasta, stageAs: \"BiscuitIndex/*\"\n\n    output:\n    path \"BiscuitIndex/*.fa*\", emit: index, includeInputs: true\n    path \"versions.yml\"      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    biscuit \\\\\n        index \\\\\n        $args \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Summarize and/or filter reads based on bisulfite conversion rate\nTags: biscuit, DNA methylation, WGBS, scWGBS, bisulfite sequencing, aligner, bam, filter", "answer": "process BISCUIT_BSCONV {\n    tag \"$meta.id\"\n    label 'process_long'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/biscuit:1.1.0.20220707--he272189_1':\n        'biocontainers/biscuit:1.1.0.20220707--he272189_1' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path(index)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bsconv_bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.bis.amb\" | sed 's/\\\\.bis.amb\\$//'`\n\n    biscuit bsconv \\\\\n        $args \\\\\n        \\$INDEX \\\\\n        $bam \\\\\n        ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n    END_VERSIONS\n    \"\"\"\n\n\n}\n"}
{"question": "Description: Summarizes methylation or SNV information from a Biscuit VCF in a\nstandard-compliant BED file.\n\nTags: biscuit, DNA methylation, WGBS, scWGBS, bisulfite sequencing, aligner, vcf", "answer": "process BISCUIT_VCF2BED {\n    tag \"$meta.id\"\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0':\n        'biocontainers/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.bed.gz\"), emit: bed\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    biscuit vcf2bed \\\\\n        $args \\\\\n        $vcf | \\\\\n    LC_ALL=C sort -k1,1 -k2,2n | \\\\\n    bgzip \\\\\n        $args2 \\\\\n        -c > ${prefix}.bed.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$(echo \\$(biscuit version 2>&1) | sed 's/^.*BISCUIT Version: //; s/Using.*\\$//')\n        samtools: \\$( samtools --version |& sed '1!d; s/^.*samtools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Perform basic quality control on a BAM file generated with Biscuit\nTags: biscuit, DNA methylation, WGBS, scWGBS, bisulfite sequencing, index, BAM, quality control", "answer": "process BISCUIT_QC {\n    tag \"$meta.id\"\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/biscuit:1.1.0.20220707--he272189_1':\n        'biocontainers/biscuit:1.1.0.20220707--he272189_1' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path(index)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: biscuit_qc_reports\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def se = meta.single_end ? \"-s\" : \"\"\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.bis.amb\" | sed 's/\\\\.bis.amb\\$//'`\n\n    biscuit qc \\\\\n        $args \\\\\n        $se \\\\\n        \\$INDEX \\\\\n        $bam \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Summarizes read-level methylation (and optionally SNV) information from a\nBiscuit BAM file in a standard-compliant BED format.\n\nTags: biscuit, DNA methylation, WGBS, scWGBS, bisulfite sequencing, aligner, bam", "answer": "process BISCUIT_EPIREAD {\n    tag \"$meta.id\"\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0':\n        'biocontainers/mulled-v2-d94f582b04a3edcede1215189c0d881506640fd9:6519548ea4f3d6a526c78ad0350c58f867f28574-0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(snp_bed)\n    path(index)\n\n    output:\n    tuple val(meta), path(\"*.bed.gz\"), emit: epiread_bed\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def biscuit_cpus = (int) Math.max(Math.floor(task.cpus*0.9),1)\n    def samtools_cpus = task.cpus-biscuit_cpus\n    // As of 2/25/22, epiread does not support reading a gzipped SNP BED file.\n    // This is a bit hacky but allows the user to supply a gzipped OR uncompressed bed file\n    def unzip_snp_bed = snp_bed && (snp_bed.toString() =~ /\\.gz$/) ? \"bgzip -d ${snp_bed}\" : \"\"\n    def unzipped_snp_bed = snp_bed ? snp_bed.toString() - ~/\\.gz$/: \"\"\n    // SNP BED input is optional\n    def options_snp_bed = snp_bed ? \"-B ${unzipped_snp_bed}\" : \"\"\n    if (\"$options_snp_bed\" == \"${prefix}.bed.gz\") error \"Input and output names for biscuit epiread are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.bis.amb\" | sed 's/\\\\.bis.amb\\$//'`\n\n    $unzip_snp_bed\n\n    biscuit epiread \\\\\n        -@ $biscuit_cpus \\\\\n        $args \\\\\n        $options_snp_bed \\\\\n        \\$INDEX \\\\\n        $bam | \\\\\n    LC_ALL=C sort -k1,1 -k2,2n | \\\\\n    bgzip \\\\\n        -@ $samtools_cpus \\\\\n        $args2 \\\\\n        -c > ${prefix}.bed.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biscuit: \\$( biscuit version |& sed '1!d; s/^.*BISCUIT Version: //' )\n        samtools: \\$( samtools --version |& sed '1!d; s/^.*samtools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Kleborate is a tool to screen genome assemblies of Klebsiella pneumoniae and the Klebsiella pneumoniae species complex (KpSC).\nTags: screening assemblies, Klebsiella pneumoniae", "answer": "process KLEBORATE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kleborate:2.1.0--pyhdfd78af_1' :\n        'biocontainers/kleborate:2.1.0--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(fastas)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    kleborate \\\\\n        $args \\\\\n        --outfile ${prefix}.results.txt \\\\\n        --assemblies $fastas\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kleborate: \\$( echo \\$(kleborate --version | sed 's/Kleborate v//;'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The merge module merges structural variants within one or more vcf files.\nTags: structural variants, vcf, merge", "answer": "process SVDB_MERGE {\n    tag \"$meta.id\"\n    label 'process_medium'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-c8daa8f9d69d3c5a1a4ff08283a166c18edb0000:511069f65a53621c5503e5cfee319aa3c735abfa-0':\n        'biocontainers/mulled-v2-c8daa8f9d69d3c5a1a4ff08283a166c18edb0000:511069f65a53621c5503e5cfee319aa3c735abfa-0' }\"\n\n    input:\n    tuple val(meta), path(vcfs)\n    val (priority)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input  = \"${vcfs.join(\" \")}\"\n    def prio   = \"\"\n    if(priority) {\n        prio = \"--priority ${priority.join(',')}\"\n        input = \"\"\n        for (int index = 0; index < vcfs.size(); index++) {\n            input += \" ${vcfs[index]}:${priority[index]}\"\n        }\n    }\n    \"\"\"\n    svdb \\\\\n        --merge \\\\\n        $args \\\\\n        $prio \\\\\n        --vcf $input \\\\\n        > ${prefix}.vcf\n    bgzip ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svdb: \\$( echo \\$(svdb) | head -1 | sed 's/usage: SVDB-\\\\([0-9]\\\\.[0-9]\\\\.[0-9]\\\\).*/\\\\1/' )\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svdb: \\$( echo \\$(svdb) | head -1 | sed 's/usage: SVDB-\\\\([0-9]\\\\.[0-9]\\\\.[0-9]\\\\).*/\\\\1/' )\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Query a structural variant database, using a vcf file as query\nTags: structural variants, query, svdb", "answer": "process SVDB_QUERY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svdb:2.8.1--py39h5371cbf_0':\n        'biocontainers/svdb:2.8.1--py39h5371cbf_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    val(in_occs)\n    val(in_frqs)\n    val(out_occs)\n    val(out_frqs)\n    path(vcf_dbs)\n    path(bedpe_dbs)\n\n    output:\n    tuple val(meta), path(\"*_query.vcf\")    , emit: vcf\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args             = task.ext.args ?: ''\n    def prefix           = task.ext.prefix ?: \"${meta.id}\"\n    def in_occ           = \"\"\n    def in_frq           = \"\"\n    def out_occ          = \"\"\n    def out_frq          = \"\"\n    def dbs_argument     = vcf_dbs  ? \"--db ${vcf_dbs.join(',')}\" : ''\n    def bedpeds_argument = bedpe_dbs ? \"--bedpedb ${bedpe_dbs.join(',')}\" : ''\n    if (in_occs) {\n        in_occ  = \"--in_occ ${in_occs.join(',')}\"\n    }\n    if (in_frqs) {\n        in_frq  = \"--in_frq ${in_frqs.join(',')}\"\n    }\n    if (out_occs) {\n        out_occ = \"--out_occ ${out_occs.join(',')}\"\n    }\n    if (out_frqs) {\n        out_frq = \"--out_frq ${out_frqs.join(',')}\"\n    }\n    if ( vcf_dbs && bedpe_dbs ) error \"bedpedb input is not compatible with db inputs\"\n    \"\"\"\n    svdb \\\\\n        --query \\\\\n        $in_occ \\\\\n        $in_frq \\\\\n        $out_occ \\\\\n        $out_frq \\\\\n        $args \\\\\n        $dbs_argument \\\\\n        $bedpeds_argument \\\\\n        --query_vcf $vcf \\\\\n        --prefix ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svdb: \\$( echo \\$(svdb) | head -1 | sed 's/usage: SVDB-\\\\([0-9]\\\\.[0-9]\\\\.[0-9]\\\\).*/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_query.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svdb: \\$( echo \\$(svdb) | head -1 | sed 's/usage: SVDB-\\\\([0-9]\\\\.[0-9]\\\\.[0-9]\\\\).*/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge search results from multiple databases.\nTags: metagenomics, classify, taxonomic profiling, fastq, sequences, kmers", "answer": "\nprocess KMCP_MERGE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kmcp:0.9.1--h9ee0642_0':\n        'biocontainers/kmcp:0.9.1--h9ee0642_0' }\"\n\n\n    input:\n    tuple val(meta), path(search_out)\n\n    output:\n    tuple val(meta), path(\"*.gz\"),  emit: result\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    kmcp \\\\\n        merge \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --out-file ${prefix}.gz \\\\\n        $search_out\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}\n    gzip ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Search sequences against database\nTags: metagenomics, classify, taxonomic profiling, fastq, sequences, kmers", "answer": "process KMCP_SEARCH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kmcp:0.9.4--h9ee0642_0':\n        'biocontainers/kmcp:0.9.4--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path(db)\n\n    output:\n    tuple val(meta), path(\"*.gz\") , emit: result\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input  = meta.single_end ? \"${reads}\": \"-1 ${reads[0]} -2 ${reads[1]}\"\n    \"\"\"\n    kmcp \\\\\n        search \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --db-dir $db \\\\\n        $reads \\\\\n        --out-file ${prefix}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Generate taxonomic profile from search results\nTags: metagenomics, classify, taxonomic profiling, fastq, sequences, kmers, index", "answer": "process KMCP_PROFILE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kmcp:0.9.4--h9ee0642_0':\n        'biocontainers/kmcp:0.9.4--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(search_results)\n    path (db)\n\n    output:\n    tuple val(meta), path(\"*.profile\"), emit: profile\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    taxid=`find -L ${db} -name \"*map\"`\n    taxdump=`find -L ${db}/*/ -type d  -not -name \"R001\"`\n    kmcp \\\\\n        profile \\\\\n        $args \\\\\n        -X \\$taxdump \\\\\n        -T \\$taxid \\\\\n        -j $task.cpus \\\\\n        -o ${prefix}.profile \\\\\n        $search_results\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.profile\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate k-mers (sketches) from FASTA/Q sequences\nTags: metagenomics, classify, taxonomic profiling, fastq, sequences, kmers", "answer": "process KMCP_COMPUTE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kmcp:0.9.4--h9ee0642_0':\n        'biocontainers/kmcp:0.9.4--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(sequences)\n\n    output:\n    tuple val(meta), path(\"${prefix}\")             , emit: outdir\n    tuple val(meta), path(\"${prefix}/_info.txt\")   , emit: info\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input = sequences.isDirectory()? \"--in-dir ${sequences}\" : \"${sequences}\"\n    \"\"\"\n    kmcp \\\\\n        compute \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --out-dir ${prefix}/ \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir $prefix\n    touch $prefix/_info.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Construct KMCP database from k-mer files\nTags: metagenomics, classify, taxonomic profiling, fastq, sequences, kmers, index", "answer": "process KMCP_INDEX {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kmcp:0.9.4--h9ee0642_0':\n        'biocontainers/kmcp:0.9.4--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(compute_dir)\n\n    output:\n    tuple val(meta), path(\"${prefix}\")   , emit: kmcp\n    tuple val(meta), path(\"*.log\")       , emit: log\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    kmcp \\\\\n        index \\\\\n        --in-dir $compute_dir \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --log ${prefix}.log \\\\\n        --out-dir ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kmcp: \\$(echo \\$(kmcp version 2>&1) | sed -n 1p | sed 's/^.*kmcp v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to parse and summarise results from antimicrobial peptides tools and present functional classification.\nTags: antimicrobial peptides, amps, parsing, reporting, align, macrel, amplify, hmmsearch, neubi, ampir, DRAMP", "answer": "def deprecation_message = \"\"\"\nWARNING: This module has been deprecated.\n\nReason:\nThis module is no longer recommended for use to parse results from antimicrobial tools.\nIt is recommended to use ampcombi v.0.2.2 submodules instead:\n- nf-core/modules/ampcombi2/parse_tables\n- nf-core/modules/ampcombi2/complete\n- nf-core/modules/ampcombi2/cluster\n\n\"\"\"\nprocess AMPCOMBI {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ampcombi:0.1.7--pyhdfd78af_0':\n        'biocontainers/ampcombi:0.1.7--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta),  path(amp_input)\n    path(faa_input)\n    path(opt_amp_db)\n\n    output:\n    tuple val(meta), path(\"${meta.id}/\")                    , emit: sample_dir\n    tuple val(meta), path(\"${meta.id}/*diamond_matches.txt\"), emit: txt\n    tuple val(meta), path(\"${meta.id}/*ampcombi.csv\")       , emit: csv\n    tuple val(meta), path(\"${meta.id}/*amp.faa\")            , emit: faa\n    tuple val(meta), path(\"AMPcombi_summary.csv\")           , optional:true, emit: summary_csv\n    tuple val(meta), path(\"AMPcombi_summary.html\")          , optional:true, emit: summary_html\n    tuple val(meta), path(\"*.log\")                          , optional:true, emit: log\n    tuple val(meta), path(\"amp_ref_database/\")              , optional:true, emit: results_db\n    tuple val(meta), path(\"amp_ref_database/*.dmnd\")        , optional:true, emit: results_db_dmnd\n    tuple val(meta), path(\"amp_ref_database/*.clean.fasta\") , optional:true, emit: results_db_fasta\n    tuple val(meta), path(\"amp_ref_database/*.tsv\")         , optional:true, emit: results_db_tsv\n    path \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    assert true: deprecation_message\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def db = opt_amp_db? \"--amp_database $opt_amp_db\": \"\"\n    \"\"\"\n    ampcombi \\\\\n        --path_list '${amp_input.collect{\"$it\"}.join(\"' '\")}' \\\\\n        --sample_list ${prefix} \\\\\n        ${db} \\\\\n        --faa ${faa_input} \\\\\n        $args \\\\\n        --log True \\\\\n        --threads ${task.cpus} \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ampcombi: \\$(ampcombi --version | sed 's/ampcombi //')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def db = opt_amp_db? \"--amp_database $opt_amp_db\": \"\"\n\n    \"\"\"\n    mkdir -p ${prefix}\n    touch ${prefix}/*diamond_matches.txt\n    touch ${prefix}/*ampcombi.csv\n    touch ${prefix}/*amp.faa\n    touch AMPcombi_summary.csv\n    touch AMPcombi_summary.html\n    touch *.log\n\n    mkdir -p amp_ref_database\n    touch amp_ref_database/*.dmnd\n    touch amp_ref_database/*.clean.fasta\n    touch amp_ref_database/*.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ampcombi: \\$(ampcombi --version | sed 's/ampcombi //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: calculate locally stable secondary structures of RNAs\nTags: RNA, fasta, rna_structure", "answer": "process VIENNARNA_RNALFOLD {\n    tag '$rna_fastq'\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/viennarna:2.6.4--py310pl5321h6cc9453_1':\n        'biocontainers/viennarna:2.6.4--py310pl5321h6cc9453_1' }\"\n\n    input:\n    path fasta\n\n    output:\n    path \"*.lfold\"        , emit: rnalfold_txt\n    path \"versions.yml\"   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    RNALfold \\\\\n        ${args} \\\\\n        --infile=$fasta \\\\\n        --outfile=${fasta.baseName}.lfold\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        RNALfold: \\$( RNAfold --version |& sed '1!d ; s/RNALfold //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    touch ${fasta.baseName}.lfold\n    touch ${fasta}.ps\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        RNALfold: \\$( RNAfold --version |& sed '1!d ; s/RNALfold //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Predict RNA secondary structure using the ViennaRNA RNAfold tools. Calculate minimum free energy secondary structures and partition function of RNAs.\nTags: RNA, fasta, rna_structure", "answer": "process VIENNARNA_RNAFOLD {\n    tag '$rna_fastq'\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/viennarna:2.6.4--py310pl5321h6cc9453_1':\n        'biocontainers/viennarna:2.6.4--py310pl5321h6cc9453_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.fold\")      , emit: rnafold_txt\n    tuple val(meta), path(\"*.ps\")        , emit: rnafold_ps\n    tuple val(meta), path(\"versions.yml\"), emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = meta.id ?: \"${fasta.getName()}\"\n    \"\"\"\n    RNAfold \\\\\n        ${args} \\\\\n        --jobs=${task.cpus} \\\\\n        --infile=$fasta \\\\\n        --outfile=${fasta}.fold\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        RNAfold: \\$( RNAfold --version |& sed '1!d ; s/RNAfold //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    touch ${fasta}.fold\n    touch ${fasta}.ps\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        RNAfold: \\$( RNAfold --version |& sed '1!d ; s/RNAfold //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: calculate secondary structures of two RNAs with dimerization\nTags: RNA, fasta, rna_structure", "answer": "process VIENNARNA_RNACOFOLD {\n    tag \"$rnacofold_fasta\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/viennarna:2.6.4--py310pl5321h6cc9453_1':\n        'biocontainers/viennarna:2.6.4--py310pl5321h6cc9453_1' }\"\n\n    input:\n    tuple val(meta), path(rnacofold_fasta)\n\n    output:\n    tuple val(meta), path(\"*.csv\")  , emit: rnacofold_csv\n    tuple val(meta), path(\"*.ps\")   , emit: rnacofold_ps\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    RNAcofold < ${rnacofold_fasta} \\\\\n        --jobs=${task.cpus} \\\\\n        --output-format=\"D\" \\\\\n        > ${rnacofold_fasta.baseName}.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        RNAcofold: \\$( RNAcofold --version |& sed '1!d ; s/RNAcofold //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    touch ${rnacofold_fasta.baseName}.csv\n    touch ${rnacofold_fasta.baseName}.ps\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        RNAcofold: \\$( RNAcofold --version |& sed '1!d ; s/RNAcofold //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Controllable lossy compression of BAM/CRAM files\nTags: compress, bam, sam, cram", "answer": "process CRUMBLE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/crumble:0.9.1--hb0d9459_0':\n        'biocontainers/crumble:0.9.1--hb0d9459_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path keepbed\n    val bedout\n\n    output:\n    tuple val(meta), path(\"*.bam\"),  emit: bam,     optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram,    optional: true\n    tuple val(meta), path(\"*.sam\"),  emit: sam,     optional: true\n    tuple val(meta), path(\"*.bed\"),  emit: bed,     optional: true\n    path \"versions.yml\",             emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def extension  = args.contains(\"-O sam\") ? \"sam\" :\n                    args.contains(\"-O bam\") ? \"bam\" :\n                    args.contains(\"-O cram\") ? \"cram\" :\n                    \"sam\"\n    def bedin      = keepbed ? \"-R ${keepbed}\" : \"\"\n    def bedout     = bedout ? \"-b ${prefix}.out.bed\" : \"\"\n    if (\"$input\" == \"${prefix}.${extension}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    def CRUMBLE_VERSION = '0.9.1' //WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    crumble \\\\\n        $args \\\\\n        $bedin \\\\\n        $bedout \\\\\n        $input \\\\\n        ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        crumble: $CRUMBLE_VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate Mash distances between reference and query seqeunces\nTags: mash/dist", "answer": "process MASH_DIST {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mash:2.3--he348c14_1' :\n        'biocontainers/mash:2.3--he348c14_1' }\"\n\n    input:\n    tuple val(meta), path(query)\n    path reference\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: dist\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mash \\\\\n        dist \\\\\n        -p $task.cpus \\\\\n        $args \\\\\n        $reference \\\\\n        $query > ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mash: \\$(mash --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Screens query sequences against large sequence databases\nTags: screen, containment, contamination, taxonomic assignment", "answer": "process MASH_SCREEN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mash:2.3--he348c14_1':\n        'biocontainers/mash:2.3--he348c14_1' }\"\n\n    input:\n    tuple val(meta) , path(query)\n    tuple val(meta2), path(sequences_sketch)\n\n    output:\n    tuple val(meta), path(\"*.screen\"), emit: screen\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mash \\\\\n        screen \\\\\n        $args \\\\\n        -p $task.cpus \\\\\n        $sequences_sketch \\\\\n        $query \\\\\n        > ${prefix}.screen\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mash: \\$( mash --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.screen\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mash: \\$( mash --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates vastly reduced representations of sequences using MinHash\nTags: mash, mash/sketch, minhash, reduced, representations, sequences, sketch", "answer": "process MASH_SKETCH {\n    tag \"$meta.id\"\n    label 'process_medium'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mash:2.3--he348c14_1' :\n        'biocontainers/mash:2.3--he348c14_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.msh\")        , emit: mash\n    tuple val(meta), path(\"*.mash_stats\") , emit: stats\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mash \\\\\n        sketch \\\\\n        $args \\\\\n        $reads \\\\\n        -p $task.cpus \\\\\n        -o ${prefix} \\\\\n        2> >(tee ${prefix}.mash_stats >&2)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mash: \\$(mash --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.msh\n    touch ${prefix}.mash_stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mash: \\$(mash --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Runs PEKA CLIP peak k-mer analysis\nTags: motif, CLIP, iCLIP, genomics, k-mer", "answer": "process PEKA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/peka:1.0.0--pyhdfd78af_0':\n        'biocontainers/peka:1.0.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(peaks)\n    tuple val(meta), path(crosslinks)\n    path fasta\n    path fai\n    path gtf\n\n    output:\n    tuple val(meta), path(\"*mer_cluster_distribution*\")    , emit: cluster,      optional: true\n    tuple val(meta), path(\"*mer_distribution*\")            , emit: distribution, optional: true\n    tuple val(meta), path(\"*rtxn*\")                        , emit: rtxn,         optional: true\n    tuple val(meta), path(\"*.pdf\")                         , emit: pdf,          optional: true\n    tuple val(meta), path(\"*thresholded_sites*.bed.gz\")    , emit: tsites,       optional: true\n    tuple val(meta), path(\"*oxn*.bed.gz\")                  , emit: oxn,          optional: true\n    tuple val(meta), path(\"*_clusters.csv\")                , emit: clust,        optional: true\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def VERSION = '1.0.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    # If the modification date and time of the fai is before the fasta then\n    # there will be an error. Touching the file first avoids that.\n    touch $fai\n    mkdir tmp\n    TMPDIR=\\$(pwd)/tmp peka \\\n        -i $peaks \\\n        -x $crosslinks \\\n        -g $fasta \\\n        -gi $fai \\\n        -r $gtf \\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        peka: $VERSION\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}_4mer_cluster_distribution_genome.tsv\n    touch ${prefix}_4mer_distribution_genome.tsv\n    touch ${prefix}_4mer_genome.pdf\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        peka: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filter reads by quality score.\nTags: immcantation, airrseq, genomics, immunoinformatics", "answer": "process PRESTO_FILTERSEQ {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/presto:0.7.1--pyhdfd78af_0':\n        'biocontainers/presto:0.7.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*_quality-pass.fastq\"),  emit: reads\n    path \"*_command_log.txt\" , emit: logs\n    path \"versions.yml\" , emit: versions\n    path \"*.tab\" , emit: log_tab\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    FilterSeq.py quality \\\\\n    -s $reads \\\\\n    --outname ${meta.id} \\\\\n    --log ${reads.baseName}.log \\\\\n    --nproc ${task.cpus} \\\\\n    $args > ${meta.id}_command_log.txt\n\n    ParseLog.py -l ${reads.baseName}.log $args2 -f ID QUALITY\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        presto: \\$( FilterSeq.py --version | awk -F' '  '{print \\$2}' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch test_quality-pass.fastq test_quality-pass.fastq \\\\\n        test_command_log.txt test.log test.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        presto: \\$( FilterSeq.py --version | awk -F' '  '{print \\$2}' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Serotype prediction of Streptococcus suis assemblies\nTags: bacteria, fasta, streptococcus", "answer": "process SSUISSERO {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ssuissero%3A1.0.1--hdfd78af_0':\n        'biocontainers/ssuissero:1.0.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getName().endsWith(\".gz\") ? true : false\n    def fasta_name = fasta.getName().replace(\".gz\", \"\")\n    def VERSION = '1.0.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    SsuisSero.sh \\\\\n        -i $fasta_name \\\\\n        -o ./ \\\\\n        -s $prefix \\\\\n        -x fasta \\\\\n        -t $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ssuissero: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: convert2vcf.pl is command line tool to convert CNVnator calls to vcf format.\nTags: cnvnator, cnv, cna", "answer": "process CNVNATOR_CONVERT2VCF {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvnator:0.4.1--py310h2dce045_7':\n        'biocontainers/cnvnator:0.4.1--py310h2dce045_7' }\"\n\n    input:\n    tuple val(meta), path(calls)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args   ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cnvnator2VCF.pl \\\\\n        ${calls} \\\\\n        $args \\\\\n        > ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        CNVnator : \\$(echo \\$(cnvnator 2>&1 | sed -n '3p' | sed 's/CNVnator v//'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        CNVnator : \\$(echo \\$(cnvnator 2>&1 | sed -n '3p' | sed 's/CNVnator v//'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: CNVnator is a command line tool for CNV/CNA analysis from depth-of-coverage by mapped reads.\nTags: cnvnator, cnv, cna", "answer": "process CNVNATOR_CNVNATOR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvnator:0.4.1--py310h2dce045_7':\n        'biocontainers/cnvnator:0.4.1--py310h2dce045_7' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(root)\n    tuple val(meta3), path(fasta)\n    tuple val(meta4), path(fai)\n\n    output:\n    tuple val(output_meta), path(\"${prefix}.root\"), emit: root\n    tuple val(output_meta), path(\"${prefix}.tab\") , emit: tab, optional: true\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args   ?: ''\n    def input_cmd = bam             ? \"-tree ${bam}\"      : ''\n    output_meta   = bam             ? meta                : meta2\n    prefix        = task.ext.prefix ?: bam ? \"${meta.id}\" : \"${meta2.id}\"\n    if (fasta) {\n        reference = fasta.isDirectory() ? \"-d ${fasta}\" : \"-fasta ${fasta}\"\n    } else {\n        reference = ''\n    }\n    calls_cmd = args.contains(\"-call\") ? \"> ${prefix}.tab\" : ''\n    \"\"\"\n    cnvnator \\\\\n        -root ${prefix}.root \\\\\n        $args \\\\\n        $reference \\\\\n        $input_cmd \\\\\n        $calls_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        CNVnator: \\$(echo \\$(cnvnator 2>&1 | sed -n '3p' | sed 's/CNVnator v//'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args      = task.ext.args   ?: ''\n    prefix        = task.ext.prefix ?: bam ? \"${meta.id}\" : \"${meta2.id}\"\n    output_meta   = bam             ? meta                : meta2\n    def calls_cmd = args.contains(\"-call\") ? \"touch ${prefix}.tab\" : ''\n    \"\"\"\n    touch ${prefix}.root\n    $calls_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        CNVnator: \\$(echo \\$(cnvnator 2>&1 | sed -n '3p' | sed 's/CNVnator v//'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compare or merge VCF files to generate a consensus or multi sample VCF files.\nTags: survivor, merge, vcf, structural variants", "answer": "process SURVIVOR_MERGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/survivor:1.0.7--h9a82719_1':\n        'biocontainers/survivor:1.0.7--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(vcfs)\n    val(max_distance_breakpoints)\n    val(min_supporting_callers)\n    val(account_for_type)\n    val(account_for_sv_strands)\n    val(estimate_distanced_by_sv_size)\n    val(min_sv_size)\n\n    output:\n    tuple val(meta), path(\"*.vcf\")   , emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    vcfs.each{\n        if (it.getExtension() == \"gz\"){\n            error \"Gzipped files are not supported by Survivor, please gunzip your VCF files first.\"\n            // https://github.com/fritzsedlazeck/SURVIVOR/issues/158\n        }\n    }\n\n    \"\"\"\n    SURVIVOR merge \\\\\n        <(ls *.vcf) \\\\\n        ${max_distance_breakpoints} \\\\\n        ${min_supporting_callers} \\\\\n        ${account_for_type} \\\\\n        ${account_for_sv_strands} \\\\\n        ${estimate_distanced_by_sv_size} \\\\\n        ${min_sv_size} \\\\\n        ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    vcfs.each{\n        if (it.getExtension() == \"gz\"){\n            error \"Gzipped files are not supported by Survivor, please gunzip your VCF files first.\"\n            // https://github.com/fritzsedlazeck/SURVIVOR/issues/158\n        }\n    }\n\n    \"\"\"\n    touch ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a bedpe file ot a VCF file (beta version)\nTags: bedpe, conversion, vcf, structural variants", "answer": "\nprocess SURVIVOR_BEDPETOVCF {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/survivor:1.0.7--h9a82719_1':\n        'biocontainers/survivor:1.0.7--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(bedpe)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    SURVIVOR \\\\\n        bedpetovcf \\\\\n        $bedpe \\\\\n        ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Simulate an SV VCF file based on a reference genome\nTags: structural variants, simulation, sv, vcf", "answer": "process SURVIVOR_SIMSV {\n    tag \"simSV\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/survivor:1.0.7--hd03093a_2':\n        'biocontainers/survivor:1.0.7--hd03093a_2' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(fai)\n    tuple val(meta3), path(parameters)\n    val(snp_mutation_frequency)\n    val(sim_reads)\n\n    output:\n    tuple val(meta), path(\"*.txt\")          , emit: parameters, optional:true\n    tuple val(meta), path(\"*.vcf\")          , emit: vcf, optional:true\n    tuple val(meta), path(\"*.bed\")          , emit: bed, optional:true\n    tuple val(meta), path(\"*.fasta\")        , emit: fasta, optional:true\n    tuple val(meta), path(\"*.insertions.fa\"), emit: insertions, optional:true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: meta.id ?: \"simSV\"\n\n    def create_parameters = parameters ? \"\" : \"SURVIVOR simSV ${prefix}.txt\"\n    def params_file = parameters ? parameters : \"${prefix}.txt\"\n    def create_vcf = fasta ? \"SURVIVOR simSV ${fasta} ${params_file} ${snp_mutation_frequency} ${sim_reads} ${prefix}\" : \"\"\n\n    \"\"\"\n    ${create_parameters}\n\n    ${create_vcf}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: meta.id ?: \"simSV\"\n\n    def create_parameters = parameters ? \"\" : \"touch ${prefix}.txt\"\n    def create_vcf = fasta ? \"touch ${prefix}.vcf\" : \"\"\n\n    \"\"\"\n    ${create_parameters}\n\n    ${create_vcf}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filter a vcf file based on size and/or regions to ignore\nTags: survivor, filter, vcf, structural variants", "answer": "process SURVIVOR_FILTER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/survivor:1.0.7--h9a82719_1':\n        'biocontainers/survivor:1.0.7--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(vcf_file), path(bed) // VCF file to filter and BED file with regions to ignore (NA to disable)\n    val(minsv)          // Min SV size (-1 to disable)\n    val(maxsv)          // Max SV size (-1 to disable)\n    val(minallelefreq)  // Min allele frequency (0-1)\n    val(minnumreads)    // Min number of reads support: RE flag (-1 to disable)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bed_file = bed ? \"${bed}\" : \"NA\"\n\n    if( \"$vcf_file\" == \"${prefix}.vcf\" ){\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n    \"\"\"\n    SURVIVOR \\\\\n        filter \\\\\n        $vcf_file \\\\\n        $bed_file \\\\\n        $minsv \\\\\n        $maxsv \\\\\n        $minallelefreq \\\\\n        $minnumreads \\\\\n        ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bed_file = bed ? \"${bed}\" : \"NA\"\n\n    if( \"$vcf_file\" == \"${prefix}.vcf\" ){\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n\n    \"\"\"\n    touch ${prefix}.vcf\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Report multipe stats over a VCF file\nTags: survivor, statistics, vcf, structural variants", "answer": "process SURVIVOR_STATS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/survivor:1.0.7--h9a82719_1':\n        'biocontainers/survivor:1.0.7--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    val(minsv)          // Min SV size (-1 to disable)\n    val(maxsv)          // Max SV size (-1 to disable)\n    val(minnumreads)    // Min number of reads support: RE flag (-1 to disable)\n\n    output:\n    tuple val(meta), path(\"*.stats\"), emit: stats\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = vcf.getName().endsWith(\".gz\") ? true : false\n    vcf_name = vcf.getName().replace(\".gz\", \"\")\n\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $vcf > $vcf_name\n    fi\n\n    SURVIVOR \\\\\n        stats \\\\\n        $vcf_name \\\\\n        $minsv \\\\\n        $maxsv \\\\\n        $minnumreads \\\\\n        ${prefix}.stats\n\n    rm $vcf_name\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.stats\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        survivor: \\$(echo \\$(SURVIVOR 2>&1 | grep \"Version\" | sed 's/^Version: //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MaxBin is a software that is capable of clustering metagenomic contigs\nTags: metagenomics, assembly, binning, maxbin2, de novo assembly, mags, metagenome-assembled genomes, contigs", "answer": "process MAXBIN2 {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/maxbin2:2.2.7--he1b5a44_2' :\n        'biocontainers/maxbin2:2.2.7--he1b5a44_2' }\"\n\n    input:\n    tuple val(meta), path(contigs), path(reads), path(abund)\n\n    output:\n    tuple val(meta), path(\"*.fasta.gz\")   , emit: binned_fastas\n    tuple val(meta), path(\"*.summary\")    , emit: summary\n    tuple val(meta), path(\"*.log.gz\")     , emit: log\n    tuple val(meta), path(\"*.marker.gz\")  , emit: marker_counts\n    tuple val(meta), path(\"*.noclass.gz\") , emit: unbinned_fasta\n    tuple val(meta), path(\"*.tooshort.gz\"), emit: tooshort_fasta\n    tuple val(meta), path(\"*_bin.tar.gz\") , emit: marker_bins , optional: true\n    tuple val(meta), path(\"*_gene.tar.gz\"), emit: marker_genes, optional: true\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def associate_files = reads ? \"-reads $reads\" : \"-abund $abund\"\n    \"\"\"\n    mkdir input/ && mv $contigs input/\n    run_MaxBin.pl \\\\\n        -contig input/$contigs \\\\\n        $associate_files \\\\\n        -thread $task.cpus \\\\\n        $args \\\\\n        -out $prefix\n\n    gzip *.fasta *.noclass *.tooshort *log *.marker\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        maxbin2: \\$( run_MaxBin.pl -v | head -n 1 | sed 's/MaxBin //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A submodule that clusters the merged AMP hits generated from ampcombi2/parsetables and ampcombi2/complete using MMseqs2 cluster.\nTags: antimicrobial peptides, amps, parsing, reporting, align, clustering, mmseqs2", "answer": "process AMPCOMBI2_CLUSTER {\n    tag 'ampcombi2'\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ampcombi:0.2.2--pyhdfd78af_0':\n        'biocontainers/ampcombi:0.2.2--pyhdfd78af_0' }\"\n\n    input:\n    path(summary_file)\n\n    output:\n    path(\"Ampcombi_summary_cluster.tsv\")                   , emit: cluster_tsv\n    path(\"Ampcombi_summary_cluster_representative_seq.tsv\"), emit: rep_cluster_tsv\n    path(\"Ampcombi_cluster.log\")                           , emit: log, optional:true\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    ampcombi cluster \\\\\n        --ampcombi_summary ${summary_file} \\\\\n        $args \\\\\n        --threads ${task.cpus}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ampcombi: \\$(ampcombi --version | sed 's/ampcombi //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    touch Ampcombi_summary_cluster.tsv\n    touch Ampcombi_summary_cluster_representative_seq.tsv\n    touch Ampcombi_cluster.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ampcombi: \\$(ampcombi --version | sed 's/ampcombi //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A submodule that merges all output summary tables from ampcombi/parsetables in one summary file.\nTags: antimicrobial peptides, amps, parsing, reporting, align, macrel, amplify, hmmsearch, neubi, ampir, ampgram, amptransformer, DRAMP", "answer": "process AMPCOMBI2_COMPLETE {\n    tag \"ampcombi2\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ampcombi:0.2.2--pyhdfd78af_0':\n        'biocontainers/ampcombi:0.2.2--pyhdfd78af_0' }\"\n\n    input:\n    path(summaries)\n\n    output:\n    path(\"Ampcombi_summary.tsv\") , emit: tsv\n    path(\"Ampcombi_complete.log\"), emit: log, optional:true\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    ampcombi complete \\\\\n        --summaries_files '${summaries.collect{\"$it\"}.join(\"' '\")}' \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ampcombi: \\$(ampcombi --version | sed 's/ampcombi //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    touch Ampcombi_summary.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ampcombi: \\$(ampcombi --version | sed 's/ampcombi //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A submodule that parses and standardizes the results from various antimicrobial peptide identification tools.\nTags: antimicrobial peptides, amps, parsing, reporting, align, macrel, amplify, hmmsearch, neubi, ampir, ampgram, amptransformer, DRAMP", "answer": "process AMPCOMBI2_PARSETABLES {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ampcombi:0.2.2--pyhdfd78af_0':\n        'biocontainers/ampcombi:0.2.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(amp_input)\n    path(faa_input)\n    path(gbk_input)\n    path(opt_amp_db)\n\n    output:\n    tuple val(meta), path(\"${meta.id}/\")                              , emit: sample_dir\n    tuple val(meta), path(\"${meta.id}/contig_gbks/\")                  , emit: contig_gbks\n    tuple val(meta), path(\"${meta.id}/${meta.id}_diamond_matches.txt\"), emit: txt\n    tuple val(meta), path(\"${meta.id}/${meta.id}_ampcombi.tsv\")       , emit: tsv\n    tuple val(meta), path(\"${meta.id}/${meta.id}_amp.faa\")            , emit: faa\n    tuple val(meta), path(\"${meta.id}/${meta.id}_ampcombi.log\")       , emit: sample_log, optional:true\n    tuple val(meta), path(\"Ampcombi_parse_tables.log\")                , emit: full_log, optional:true\n    tuple val(meta), path(\"amp_ref_database/\")                        , emit: results_db, optional:true\n    tuple val(meta), path(\"amp_ref_database/*.dmnd\")                  , emit: results_db_dmnd, optional:true\n    tuple val(meta), path(\"amp_ref_database/*.clean.fasta\")           , emit: results_db_fasta, optional:true\n    tuple val(meta), path(\"amp_ref_database/*.tsv\")                   , emit: results_db_tsv, optional:true\n    path \"versions.yml\"                                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def db = opt_amp_db? \"--amp_database $opt_amp_db\": \"\"\n    \"\"\"\n    ampcombi parse_tables \\\\\n    --path_list '${amp_input.collect{\"$it\"}.join(\"' '\")}' \\\\\n    --faa ${faa_input} \\\\\n    --gbk ${gbk_input} \\\\\n    --sample_list ${prefix} \\\\\n    ${db} \\\\\n    $args \\\\\n    --threads ${task.cpus}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ampcombi: \\$(ampcombi --version | sed 's/ampcombi //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def db = opt_amp_db? \"--amp_database $opt_amp_db\": \"\"\n    \"\"\"\n    mkdir -p ${prefix}\n    mkdir -p ${prefix}/contig_gbks\n    touch ${prefix}/${meta.id}_diamond_matches.txt\n    touch ${prefix}/${meta.id}_ampcombi.tsv\n    touch ${prefix}/${meta.id}_amp.faa\n    touch ${prefix}/${meta.id}_ampcombi.log\n    touch Ampcombi_parse_tables.log\n\n    mkdir -p amp_ref_database\n    touch amp_ref_database/*.dmnd\n    touch amp_ref_database/*.clean.fasta\n    touch amp_ref_database/*.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ampcombi: \\$(ampcombi --version | sed 's/ampcombi //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculation of optimal P-site offsets, diagnostic analysis and visual inspection of ribosome profiling data\nTags: sort, example, genomics", "answer": "process RIBOWALTZ {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ribowaltz:2.0--r43hdfd78af_0':\n        'biocontainers/ribowaltz:2.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(gtf)\n    tuple val(meta3), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.best_offset.txt\")                , emit: best_offset          , optional: true\n    tuple val(meta), path(\"*.psite_offset.tsv{,.gz}\")         , emit: offset               , optional: true\n    tuple val(meta), path(\"offset_plot/*\")                    , emit: offset_plot          , optional: true\n    tuple val(meta), path(\"*.psite.tsv{,.gz}\")                , emit: psites               , optional: true\n    tuple val(meta), path(\"*.codon_coverage_rpf.tsv{,.gz}\")   , emit: codon_coverage_rpf   , optional: true\n    tuple val(meta), path(\"*.codon_coverage_psite.tsv{,.gz}\") , emit: codon_coverage_psite , optional: true\n    tuple val(meta), path(\"*.cds_coverage_psite.tsv{,.gz}\")   , emit: cds_coverage         , optional: true\n    tuple val(meta), path(\"*nt_coverage_psite.tsv{,.gz}\")     , emit: cds_window_coverage  , optional: true\n    tuple val(meta), path(\"ribowaltz_qc/*.pdf\")               , emit: ribowaltz_qc         , optional: true\n    path \"versions.yml\"                                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'ribowaltz.r'\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.best_offset.txt\n    touch ${prefix}.psite_offset.tsv\n    touch ${prefix}.psite.tsv\n    touch ${prefix}.codon_coverage_rpf.tsv\n    touch ${prefix}.codon_coverage_psite.tsv\n    touch ${prefix}.cds_coverage_psite.tsv\n    mkdir -p offset_plot/${prefix} && touch offset_plot/${prefix}/29.pdf\n    mkdir -p ribowaltz_qc && touch ribowaltz_qc/${prefix}.metaprofile_psite.pdf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bioconductor-ribowaltz: \\$(Rscript -e \"library(riboWaltz); cat(as.character(packageVersion('riboWaltz')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate expression with RSEM\nTags: rsem, expression, quantification", "answer": "process RSEM_CALCULATEEXPRESSION {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-cf0123ef83b3c38c13e3b0696a3f285d3f20f15b:64aad4a4e144878400649e71f42105311be7ed87-0' :\n        'biocontainers/mulled-v2-cf0123ef83b3c38c13e3b0696a3f285d3f20f15b:64aad4a4e144878400649e71f42105311be7ed87-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  index\n\n    output:\n    tuple val(meta), path(\"*.genes.results\")   , emit: counts_gene\n    tuple val(meta), path(\"*.isoforms.results\"), emit: counts_transcript\n    tuple val(meta), path(\"*.stat\")            , emit: stat\n    tuple val(meta), path(\"*.log\")             , emit: logs\n    path  \"versions.yml\"                       , emit: versions\n\n    tuple val(meta), path(\"*.STAR.genome.bam\")       , optional:true, emit: bam_star\n    tuple val(meta), path(\"${prefix}.genome.bam\")    , optional:true, emit: bam_genome\n    tuple val(meta), path(\"${prefix}.transcript.bam\"), optional:true, emit: bam_transcript\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n\n    def strandedness = ''\n    if (meta.strandedness == 'forward') {\n        strandedness = '--strandedness forward'\n    } else if (meta.strandedness == 'reverse') {\n        strandedness = '--strandedness reverse'\n    }\n    def paired_end = meta.single_end ? \"\" : \"--paired-end\"\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.grp\" | sed 's/\\\\.grp\\$//'`\n    rsem-calculate-expression \\\\\n        --num-threads $task.cpus \\\\\n        --temporary-folder ./tmp/ \\\\\n        $strandedness \\\\\n        $paired_end \\\\\n        $args \\\\\n        $reads \\\\\n        \\$INDEX \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rsem: \\$(rsem-calculate-expression --version | sed -e \"s/Current version: RSEM v//g\")\n        star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.genes.results\n    touch ${prefix}.isoforms.results\n    touch ${prefix}.stat\n    touch ${prefix}.log\n    touch ${prefix}.STAR.genome.bam\n    touch ${prefix}.genome.bam\n    touch ${prefix}.transcript.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rsem: \\$(rsem-calculate-expression --version | sed -e \"s/Current version: RSEM v//g\")\n        star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Prepare a reference genome for RSEM\nTags: rsem, genome, index", "answer": "process RSEM_PREPAREREFERENCE {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-cf0123ef83b3c38c13e3b0696a3f285d3f20f15b:64aad4a4e144878400649e71f42105311be7ed87-0' :\n        'biocontainers/mulled-v2-cf0123ef83b3c38c13e3b0696a3f285d3f20f15b:64aad4a4e144878400649e71f42105311be7ed87-0' }\"\n\n    input:\n    path fasta, stageAs: \"rsem/*\"\n    path gtf\n\n    output:\n    path \"rsem\"           , emit: index\n    path \"*transcripts.fa\", emit: transcript_fasta\n    path \"versions.yml\"   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args_list = args.tokenize()\n    if (args_list.contains('--star')) {\n        args_list.removeIf { it.contains('--star') }\n        def memory = task.memory ? \"--limitGenomeGenerateRAM ${task.memory.toBytes() - 100000000}\" : ''\n        \"\"\"\n        STAR \\\\\n            --runMode genomeGenerate \\\\\n            --genomeDir rsem/ \\\\\n            --genomeFastaFiles $fasta \\\\\n            --sjdbGTFfile $gtf \\\\\n            --runThreadN $task.cpus \\\\\n            $memory \\\\\n            $args2\n\n        rsem-prepare-reference \\\\\n            --gtf $gtf \\\\\n            --num-threads $task.cpus \\\\\n            ${args_list.join(' ')} \\\\\n            $fasta \\\\\n            rsem/genome\n\n        cp rsem/genome.transcripts.fa .\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            rsem: \\$(rsem-calculate-expression --version | sed -e \"s/Current version: RSEM v//g\")\n            star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        rsem-prepare-reference \\\\\n            --gtf $gtf \\\\\n            --num-threads $task.cpus \\\\\n            $args \\\\\n            $fasta \\\\\n            rsem/genome\n\n        cp rsem/genome.transcripts.fa .\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            rsem: \\$(rsem-calculate-expression --version | sed -e \"s/Current version: RSEM v//g\")\n            star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    \"\"\"\n    touch genome.transcripts.fa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rsem: \\$(rsem-calculate-expression --version | sed -e \"s/Current version: RSEM v//g\")\n        star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Deconstruct snarls present in a variation graph in GFA format to variants in VCF format\nTags: vcf, gfa, graph, pangenome graph, variation graph, graph projection to vcf", "answer": "process VG_DECONSTRUCT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vg:1.43.0--h9ee0642_0' :\n        'biocontainers/vg:1.43.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(gfa)\n    path(pb)\n    path(gbwt)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def snarls = pb ? \"--snarls ${pb}\" : \"\"\n    def gbwt_arg = gbwt ? \"--gbwt ${gwbt}\" : \"\"\n    \"\"\"\n    vg deconstruct \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $snarls \\\\\n        $gbwt_arg \\\\\n        $gfa > ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vg: \\$(vg version 2>&1 | grep -o 'vg .*' | cut -f3 -d ' ' | cut -f2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: write your description here\nTags: vg, index, graph, structural_variants", "answer": "process VG_INDEX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vg:1.45.0--h9ee0642_0':\n        'biocontainers/vg:1.45.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.xg\")       , emit: xg\n    tuple val(meta), path(\"*.vgi\")      , emit: vg_index, optional: true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    vg index \\\\\n        --temp-dir . \\\\\n        --threads ${task.cpus} \\\\\n        --xg-name ${prefix}.xg \\\\\n        ${input}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vg: \\$(echo \\$(vg 2>&1 | head -n 1 | sed 's/vg: variation graph tool, version v//;s/ \".*\"//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def vg_index = args.contains('--index-sorted-vg') ? \"touch ${prefix}.vg.vgi\" : \"\"\n\n    \"\"\"\n    touch ${prefix}.xg\n    ${vg_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vg: \\$(echo \\$(vg 2>&1 | head -n 1 | sed 's/vg: variation graph tool, version v//;s/ \".*\"//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Constructs a graph from a reference and variant calls or a multiple sequence alignment file\nTags: vg, graph, construct, fasta, vcf, structural variants", "answer": "process VG_CONSTRUCT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vg:1.45.0--h9ee0642_0':\n        'biocontainers/vg:1.45.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(tbis), path(insertions_fasta)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.vg\") , emit: graph\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def mode =  input instanceof ArrayList || input.toString().endsWith(\".vcf.gz\") ? 'vcf' : 'msa'\n\n    input_files = mode == 'vcf' ? input.collect { \"--vcf ${it}\" }.join(\" \") : \"--msa ${input}\"\n    reference = mode == 'vcf' ? \"--reference ${fasta}\" : \"\"\n\n    insertions = insertions_fasta ? \"--insertions ${insertions_fasta}\" : \"\"\n\n    \"\"\"\n    vg construct \\\\\n        ${args} \\\\\n        --threads ${task.cpus} \\\\\n        ${reference} \\\\\n        ${input_files} \\\\\n        ${insertions} \\\\\n        > ${prefix}.vg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vg: \\$(echo \\$(vg 2>&1 | head -n 1 | sed 's/vg: variation graph tool, version v//;s/ \".*\"//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n\n    \"\"\"\n    touch ${prefix}.vg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vg: \\$(echo \\$(vg 2>&1 | head -n 1 | sed 's/vg: variation graph tool, version v//;s/ \".*\"//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compresses files with pigz.\nTags: compress, gzip, parallelized", "answer": "process PIGZ_COMPRESS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pigz:2.8':\n        'biocontainers/pigz:2.8' }\"\n\n    input:\n    tuple val(meta), path(raw_file)\n\n    output:\n    tuple val(meta), path(\"$archive\"), emit: archive\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    archive = raw_file.toString() + \".gz\"\n    \"\"\"\n    # Note: needs --stdout for pigz to avoid the following issue:\n    #   pigz: skipping: ${raw_file} is a symbolic link\n    pigz --processes $task.cpus --stdout --force ${args} ${raw_file} > ${archive}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pigz:\\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    archive = raw_file.toString() + \".gz\"\n    \"\"\"\n    touch ${archive}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pigz:\\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: write your description here\nTags: uncompress, gzip, parallelized", "answer": "process PIGZ_UNCOMPRESS {\n    label 'process_low'\n    //stageInMode 'copy' // this directive can be set in case the original input should be kept\n\n    conda \"conda-forge::pigz\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pigz:2.8':\n        'biocontainers/pigz:2.8' }\"\n\n    input:\n    tuple val(meta), path(zip)\n\n    output:\n    tuple val(meta), path(\"${uncompressed_filename}\") , emit: file\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    uncompressed_filename = zip.toString() - '.gz'\n    // calling pigz -f to make it follow symlinks\n    \"\"\"\n    unpigz \\\\\n        -p $task.cpus \\\\\n        -fk \\\\\n        $args \\\\\n        ${zip}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    uncompressed_filename = zip.toString() - '.gz'\n    \"\"\"\n    touch ${zip.dropRight(3)}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MetaPhlAn is a tool for profiling the composition of microbial communities from metagenomic shotgun sequencing data.\nTags: metagenomics, classification, fastq, bam, fasta", "answer": "process METAPHLAN3_METAPHLAN3 {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metaphlan:3.0.12--pyhb7b1952_0' :\n        'biocontainers/metaphlan:3.0.12--pyhb7b1952_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path metaphlan_db\n\n    output:\n    tuple val(meta), path(\"*_profile.txt\")   ,                emit: profile\n    tuple val(meta), path(\"*.biom\")          ,                emit: biom\n    tuple val(meta), path('*.bowtie2out.txt'), optional:true, emit: bt2out\n    path \"versions.yml\"                      ,                emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_type  = (\"$input\".endsWith(\".fastq.gz\") || \"$input\".endsWith(\".fq.gz\")) ? \"--input_type fastq\" :  (\"$input\".contains(\".fasta\")) ? \"--input_type fasta\" : (\"$input\".endsWith(\".bowtie2out.txt\")) ? \"--input_type bowtie2out\" : \"--input_type sam\"\n    def input_data  = (\"$input_type\".contains(\"fastq\")) && !meta.single_end ? \"${input[0]},${input[1]}\" : \"$input\"\n    def bowtie2_out = \"$input_type\" == \"--input_type bowtie2out\" || \"$input_type\" == \"--input_type sam\" ? '' : \"--bowtie2out ${prefix}.bowtie2out.txt\"\n\n    \"\"\"\n    BT2_DB=`find -L \"${metaphlan_db}\" -name \"*rev.1.bt2\" -exec dirname {} \\\\;`\n\n    metaphlan \\\\\n        --nproc $task.cpus \\\\\n        $input_type \\\\\n        $input_data \\\\\n        $args \\\\\n        $bowtie2_out \\\\\n        --bowtie2db \\$BT2_DB \\\\\n        --biom ${prefix}.biom \\\\\n        --output_file ${prefix}_profile.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metaphlan3: \\$(metaphlan --version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges output abundance tables from MetaPhlAn3\nTags: metagenomics, classification, merge, table, profiles", "answer": "process METAPHLAN3_MERGEMETAPHLANTABLES {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metaphlan:3.0.12--pyhb7b1952_0' :\n        'biocontainers/metaphlan:3.0.12--pyhb7b1952_0' }\"\n\n    input:\n    tuple val(meta), path(profiles)\n\n    output:\n    tuple val(meta), path(\"${prefix}.txt\") , emit: txt\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    merge_metaphlan_tables.py \\\\\n        $args \\\\\n        -o ${prefix}.txt \\\\\n        ${profiles}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metaphlan3: \\$(metaphlan --version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Linearize and simplify variation graph in GFA format using blocked partial order alignment\nTags: gfa, graph, pangenome, variation graph, POA", "answer": "process SMOOTHXG {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/smoothxg:0.7.2--h40c17d1_0' :\n        'biocontainers/smoothxg:0.7.2--h40c17d1_0' }\"\n\n    input:\n    tuple val(meta), path(gfa)\n\n    output:\n    tuple val(meta), path(\"*smoothxg.gfa\"), emit: gfa\n    path(\"*.maf\") , optional: true, emit: maf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    smoothxg \\\\\n        --threads=$task.cpus \\\\\n        --gfa-in=${gfa} \\\\\n        --smoothed-out=${prefix}.smoothxg.gfa \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        smoothxg: \\$(smoothxg --version 2>&1 | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs alignment of BS-Seq reads using bwameth\nTags: bwameth, alignment, 3-letter genome, map, methylation, 5mC, methylseq, bisulphite, bisulfite, fastq, bam", "answer": "process BWAMETH_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bwameth:0.2.2--py_1' :\n        'biocontainers/bwameth:0.2.2--py_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def read_group = meta.read_group ? \"-R ${meta.read_group}\" : \"\"\n    \"\"\"\n    INDEX=`find -L ${index} -name \"*.bwameth.c2t\" | sed 's/\\\\.bwameth.c2t\\$//'`\n\n    # Modify the timestamps so that bwameth doesn't complain about building the index\n    # See https://github.com/nf-core/methylseq/pull/217\n    touch -c -- *\n\n    bwameth.py \\\\\n        $args \\\\\n        $read_group \\\\\n        -t $task.cpus \\\\\n        --reference \\$INDEX \\\\\n        $reads \\\\\n        | samtools view $args2 -@ $task.cpus -bhS -o ${prefix}.bam -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwameth: \\$(echo \\$(bwameth.py --version 2>&1) | cut -f2 -d\" \")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs indexing of c2t converted reference genome\nTags: bwameth, 3-letter genome, index, methylseq, bisulphite, bisulfite, fasta", "answer": "process BWAMETH_INDEX {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bwameth:0.2.2--py_1' :\n        'biocontainers/bwameth:0.2.2--py_1' }\"\n\n    input:\n    path fasta, stageAs: \"bwameth/*\"\n\n    output:\n    path \"bwameth\"      , emit: index\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    bwameth.py index $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwameth: \\$(echo \\$(bwameth.py --version 2>&1) | cut -f2 -d\" \")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filtering and trimming of Oxford Nanopore Sequencing data\nTags: nanopore, filtering, QC", "answer": "process NANOFILT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nanofilt:2.8.0--py_0':\n        'biocontainers/nanofilt:2.8.0--py_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  summary_file\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: filtreads\n    path \"*.log\"                       , optional: true, emit: log_file\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"filtered_${meta.id}\"\n    def sum    = summary_file ? \"--summary ${summary_file}\" : ''\n    \"\"\"\n    gunzip \\\\\n        -c $reads \\\\\n        | NanoFilt \\\\\n        $sum \\\\\n        $args \\\\\n        | gzip > ${prefix}.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanofilt: \\$(NanoFilt -v | sed 's/NanoFilt //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"filtered_${meta.id}\"\n    def sum    = summary_file ? \"--summary ${summary_file}\" : ''\n    \"\"\"\n    touch ${prefix}.fastq.gz\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanofilt: \\$(NanoFilt -v | sed 's/NanoFilt //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Queries a sequence subject\nTags: blat, sequence, search", "answer": "process BLAT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blat:36--0':\n        'biocontainers/blat:36--0' }\"\n\n    input:\n    tuple val(meta) , path(query)\n    tuple val(meta2), path(subject)\n\n    output:\n    tuple val(meta), path(\"*.psl\"), emit: psl\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def unzip = query.toString().endsWith(\".gz\")\n\n    \"\"\"\n    in=$query\n    if $unzip\n    then\n        gunzip -cdf $query > ${prefix}.fasta\n        in=${prefix}.fasta\n    fi\n\n    blat \\\\\n        $args \\\\\n        $subject \\\\\n        \\$in \\\\\n        ${prefix}.psl\n\n    if $unzip\n    then\n        rm ${prefix}.fasta\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blat: \\$(echo \\$(blat 2>&1) | sed 's/^.*BLAT v. //; s/ fast.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.psl\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blat: \\$(echo \\$(blat 2>&1) | sed 's/^.*BLAT v. //; s/ fast.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Pyrodigal is a Python module that provides bindings to Prodigal, a fast, reliable protein-coding gene prediction for prokaryotic genomes.\nTags: sort, annotation, prediction, prokaryote", "answer": "process PYRODIGAL {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-2fe9a8ce513c91df34b43a6610df94c3a2eb3bd0:47e7d40834619419f202394563267d74cef857be-0':\n        'biocontainers/mulled-v2-2fe9a8ce513c91df34b43a6610df94c3a2eb3bd0:47e7d40834619419f202394563267d74cef857be-0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val(output_format)\n\n    output:\n    tuple val(meta), path(\"*.${output_format}.gz\")      , emit: annotations\n    tuple val(meta), path(\"*.fna.gz\")                   , emit: fna\n    tuple val(meta), path(\"*.faa.gz\")                   , emit: faa\n    tuple val(meta), path(\"*.score.gz\")                 , emit: score\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pigz -cdf ${fasta} > pigz_fasta.fna\n\n    pyrodigal \\\\\n        $args \\\\\n        -i pigz_fasta.fna \\\\\n        -f $output_format \\\\\n        -o \"${prefix}.${output_format}\" \\\\\n        -d ${prefix}.fna \\\\\n        -a ${prefix}.faa \\\\\n        -s ${prefix}.score\n\n    pigz -nmf ${prefix}*\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pyrodigal: \\$(echo \\$(pyrodigal --version 2>&1 | sed 's/pyrodigal v//'))\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.${output_format}.gz\n    touch ${prefix}.fna.gz\n    touch ${prefix}.faa.gz\n    touch ${prefix}.score.gz\n    touch versions.yml\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pyrodigal: \\$(echo \\$(pyrodigal --version 2>&1 | sed 's/pyrodigal v//'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Platypus is a tool that efficiently and accurately calling genetic variants from next-generation DNA sequencing data\nTags: variant calling, dna sequencing", "answer": "/*\nunfortunately need to output the version manually\nbecouse platypus CallVariants does not include --version or -v commend\n*/\nprocess PLATYPUS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/platypus-variant:0.8.1--py27_1':\n        'biocontainers/platypus-variant:0.8.1--py27_1' }\"\n\n    input:\n\n    tuple val(meta), path(tumor_file), path(tumor_file_bai), path(control_file),  path(control_file_bai)\n    path fasta\n    path fai\n    path skipregions_file\n\n    output:\n    tuple val(meta), path('*.vcf.gz')            , emit: vcf\n    tuple val(meta), path('*.vcf.gz.tbi')        , emit: tbi\n    tuple val(meta), path('*.log')               , emit: log\n    path  \"versions.yml\"                         , emit: version\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bamlist = control_file ? \"${control_file},${tumor_file}\" : \"${tumor_file}\"\n    def skipregions = skipregions_file ? \"skipRegionsFile=${skipregions_file}\" : \"\"\n    def VERSION = '0.8.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    platypus callVariants \\\\\n        --nCPU=${task.cpus}\\\\\n        --bamFiles=$bamlist \\\\\n        --output=${prefix}.vcf \\\\\n        --refFile=$fasta \\\\\n        --logFileName=${prefix}.log \\\\\n        ${skipregions} \\\\\n        $args\n\n    bgzip  --threads ${task.cpus} -c ${prefix}.vcf > ${prefix}.vcf.gz\n    tabix  ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        platypus: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: a tool to build k-mer hash table for fasta and fastq files\nTags: kmer, fastq, sequence, count, assembly", "answer": "process YAK_COUNT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/yak:0.1--he4a0461_4':\n        'biocontainers/yak:0.1--he4a0461_4' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n\n    output:\n    tuple val(meta), path(\"*.yak\"), emit: yak\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    input_command = meta.single_end ? \"${fastq}\" : \"<(zcat ${fastq}) <(zcat ${fastq})\"\n    \"\"\"\n    yak \\\\\n        count \\\\\n        $args \\\\\n        -t${task.cpus} \\\\\n        -o ${prefix}.yak \\\\\n        $input_command\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        yak: \\$(yak version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.yak\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        yak: \\$(yak version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Hap.py is a tool to compare diploid genotypes at haplotype level. Rather than comparing VCF records row by row, hap.py will generate and match alternate sequences in a superlocus. A superlocus is a small region of the genome (sized between 1 and around 1000 bp) that contains one or more variants.\nTags: happy, benchmark, haplotype, validation", "answer": "process HAPPY_HAPPY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hap.py:0.3.14--py27h5c5a3ab_0':\n        'biocontainers/hap.py:0.3.14--py27h5c5a3ab_0' }\"\n\n    input:\n    tuple val(meta), path(query_vcf), path(truth_vcf), path(regions_bed), path(targets_bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n    tuple val(meta4), path(false_positives_bed)\n    tuple val(meta5), path(stratification_tsv)\n    tuple val(meta6), path(stratification_beds)\n\n    output:\n    tuple val(meta), path('*.summary.csv')                      , emit: summary_csv\n    tuple val(meta), path('*.roc.all.csv.gz')                   , emit: roc_all_csv\n    tuple val(meta), path('*.roc.Locations.INDEL.csv.gz')       , emit: roc_indel_locations_csv\n    tuple val(meta), path('*.roc.Locations.INDEL.PASS.csv.gz')  , emit: roc_indel_locations_pass_csv\n    tuple val(meta), path('*.roc.Locations.SNP.csv.gz')         , emit: roc_snp_locations_csv\n    tuple val(meta), path('*.roc.Locations.SNP.PASS.csv.gz')    , emit: roc_snp_locations_pass_csv\n    tuple val(meta), path('*.extended.csv')                     , emit: extended_csv\n    tuple val(meta), path('*.runinfo.json')                     , emit: runinfo\n    tuple val(meta), path('*.metrics.json.gz')                  , emit: metrics_json\n    tuple val(meta), path('*.vcf.gz')                           , emit: vcf, optional:true\n    tuple val(meta), path('*.tbi')                              , emit: tbi, optional:true\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions = regions_bed ? \"-R ${regions_bed}\" : \"\"\n    def targets = targets_bed ? \"-T ${targets_bed}\" : \"\"\n    def false_positives = false_positives_bed ? \"--false-positives ${false_positives_bed}\" : \"\"\n    def stratification = stratification_tsv ? \"--stratification ${stratification_tsv}\" : \"\"\n    def VERSION = '0.3.14' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    hap.py \\\\\n        ${truth_vcf} \\\\\n        ${query_vcf} \\\\\n        ${args} \\\\\n        --reference ${fasta} \\\\\n        --threads ${task.cpus} \\\\\n        ${regions} \\\\\n        ${targets} \\\\\n        ${false_positives} \\\\\n        ${stratification} \\\\\n        -o ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hap.py: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def VERSION = '0.3.14' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.summary.csv\n    touch ${prefix}.roc.all.csv.gz\n    touch ${prefix}.roc.Locations.INDEL.csv.gz\n    touch ${prefix}.roc.Locations.INDEL.PASS.csv.gz\n    touch ${prefix}.roc.Locations.SNP.csv.gz\n    touch ${prefix}.roc.Locations.SNP.PASS.csv.gz\n    touch ${prefix}.extended.csv\n    touch ${prefix}.runinfo.json\n    touch ${prefix}.metrics.json.gz\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hap.py: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Hap.py is a tool to compare diploid genotypes at haplotype level. som.py is a part of hap.py compares somatic variations.\nTags: happy, sompy, benchmark, haplotype, validation, somatic variants", "answer": "process HAPPY_SOMPY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hap.py:0.3.14--py27h5c5a3ab_0':\n        'biocontainers/hap.py:0.3.14--py27h5c5a3ab_0' }\"\n\n    input:\n    tuple val(meta), path(query_vcf), path(truth_vcf), path(regions_bed), path(targets_bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n    tuple val(meta4), path(false_positives_bed)\n    tuple val(meta5), path(ambiguous_beds)\n    tuple val(meta6), path(bams)\n\n    output:\n    tuple val(meta), path('*.features.csv')           , emit: features, optional: true\n    tuple val(meta), path('*.metrics.json')           , emit: metrics\n    tuple val(meta), path('*.stats.csv')              , emit: stats\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions = regions_bed ? \"-R ${regions_bed}\" : \"\"\n    def targets = targets_bed ? \"-T ${targets_bed}\" : \"\"\n    def false_positives = false_positives_bed ? \"--false-positives ${false_positives_bed}\" : \"\"\n    def ambiguous = ambiguous_beds ? \"--ambiguous ${ambiguous_beds}\" : \"\"\n    def bams = bams ? \"--bam ${bams}\" : \"\"\n    def VERSION = '0.3.14' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    som.py \\\\\n        ${truth_vcf} \\\\\n        ${query_vcf} \\\\\n        ${args} \\\\\n        --reference ${fasta} \\\\\n        ${regions} \\\\\n        ${targets} \\\\\n        ${false_positives} \\\\\n        ${ambiguous} \\\\\n        ${bams} \\\\\n        -o ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hap.py: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def VERSION = '0.3.14' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.features.csv\n    touch ${prefix}.metrics.json\n    touch ${prefix}.stats.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hap.py: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Pre.py is a preprocessing tool made to preprocess VCF files for Hap.py\nTags: happy, benchmark, haplotype", "answer": "process HAPPY_PREPY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hap.py:0.3.14--py27h5c5a3ab_0':\n        'biocontainers/hap.py:0.3.14--py27h5c5a3ab_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path('*.vcf.gz')  , emit: preprocessed_vcf\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def restrict_region = bed ? \"-R ${bed}\": \"\"\n    def VERSION = '0.3.14' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    pre.py \\\\\n        $args \\\\\n        $restrict_region \\\\\n        --reference $fasta \\\\\n        --threads $task.cpus \\\\\n        $vcf \\\\\n        ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pre.py: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def restrict_region = bed ? \"-R ${bed}\": \"\"\n    def VERSION = '0.3.14' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pre.py: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Somatic VCF Feature Extraction tool from hap.y.\nTags: happy, featuretable, somatic, extraction", "answer": "process HAPPY_FTXPY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hap.py:0.3.14--py27h5c5a3ab_0':\n        'biocontainers/hap.py:0.3.14--py27h5c5a3ab_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(regions_bed), path(targets_bed), path(bam)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.csv\"), emit: features\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions = regions_bed ? \"-R ${regions_bed}\" : \"\"\n    def targets = targets_bed ? \"-T ${targets_bed}\" : \"\"\n    def bams = bam ? \"--bam ${bam}\" : \"\"\n    def VERSION = '0.3.14' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    ftx.py \\\\\n        -o ${prefix} \\\\\n        $regions \\\\\n        $targets \\\\\n        $bams \\\\\n        --reference ${fasta} \\\\\n        $args \\\\\n        $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hap.py: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions = regions_bed ? \"-R ${regions_bed}\" : \"\"\n    def targets = targets_bed ? \"-T ${targets_bed}\" : \"\"\n    def bams = bam ? \"--bam ${bam}\" : \"\"\n    def VERSION = '0.3.14' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hap.py: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: splits an alignment into reference and query parts\nTags: phylogeny, phylogenetic placement, sequences", "answer": "process EPANG_SPLIT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/epa-ng:0.3.8--h9a82719_1':\n        'biocontainers/epa-ng:0.3.8--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(refaln), path(fullaln)\n\n    output:\n    tuple val(meta), path(\"*query.fasta.gz\")    , emit: query\n    tuple val(meta), path(\"*reference.fasta.gz\"), emit: reference\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    epa-ng \\\\\n        $args \\\\\n        --split $refaln $fullaln\n\n    gzip -c query.fasta > ${prefix}.query.fasta.gz; rm query.fasta\n    gzip -c reference.fasta > ${prefix}.reference.fasta.gz; rm reference.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        epang: \\$(echo \\$(epa-ng --version 2>&1) | sed 's/^EPA-ng v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: phylogenetic placement of query sequences in a reference tree\nTags: phylogeny, phylogenetic placement, sequences", "answer": "process EPANG_PLACE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/epa-ng:0.3.8--h9a82719_1':\n        'biocontainers/epa-ng:0.3.8--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(queryaln), path(referencealn), path(referencetree)\n    path bfastfile\n    path binaryfile\n\n    output:\n    tuple val(meta), path(\"./.\")                   , emit: epang   , optional: true\n    tuple val(meta), path(\"*.epa_result.jplace.gz\"), emit: jplace  , optional: true\n    path \"*.epa_info.log\"                          , emit: log\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args   ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def queryarg   = queryaln        ? \"--query $queryaln\"       : \"\"\n    def refalnarg  = referencealn    ? \"--ref-msa $referencealn\" : \"\"\n    def reftreearg = referencetree   ? \"--tree $referencetree\"   : \"\"\n    def bfastarg   = bfastfile       ? \"--bfast $bfastfile\"      : \"\"\n    def binaryarg  = binaryfile      ? \"--binary $binaryfile\"    : \"\"\n    if ( binaryfile && ( referencealn || referencetree ) ) error \"[EPANG] Cannot supply both binary and reference MSA or reference tree. Check input\"\n    \"\"\"\n    epa-ng \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        $queryarg \\\\\n        $refalnarg \\\\\n        $reftreearg \\\\\n        $bfastarg \\\\\n        $binaryarg\n\n    if [ -e epa_result.jplace ]; then\n        gzip epa_result.jplace\n        cp epa_result.jplace.gz ${prefix}.epa_result.jplace.gz\n    fi\n    [ -e epa_info.log ]      && cp epa_info.log ${prefix}.epa_info.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        epang: \\$(echo \\$(epa-ng --version 2>&1) | sed 's/^EPA-ng v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split a .pairsam file into .pairs and .sam.\nTags: split, pairs, bam", "answer": "process PAIRTOOLS_SPLIT {\n    tag \"${meta.id}\"\n    label 'process_medium'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"bioconda::pairtools=1.0.2 conda-forge::numpy=1.23\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(pairs)\n\n    output:\n    tuple val(meta), path(\"*.split.pairs.gz\"), emit:pairs\n    tuple val(meta), path(\"*.bam\")           , emit:bam   , optional:true\n    path(\"versions.yml\")                     , emit:versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    export MPLCONFIGDIR=tmp\n    pairtools split \\\n        --nproc-in ${task.cpus} --nproc-out ${task.cpus} \\\n        --output-pairs ${prefix}.split.pairs.gz \\\n        ${args} \\\n        ${pairs}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version 2>&1 | sed 's/pairtools, version //')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    export MPLCONFIGDIR=tmp\n    echo \"\" | gzip > ${prefix}.split.pairs.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | sed 's/pairtools, version //')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Sort a .pairs/.pairsam file\nTags: sort, pairs, pairsam", "answer": "process PAIRTOOLS_SORT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.pairs.gz\"), emit: sorted\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def buffer = task.memory.toGiga().intdiv(2)\n    \"\"\"\n    pairtools \\\\\n        sort \\\\\n        $args \\\\\n        --nproc $task.cpus \\\\\n        --memory ${buffer}G \\\\\n        -o ${prefix}.pairs.gz \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | tr '\\\\n' ',' | sed 's/.*pairtools.*version //' | sed 's/,\\$/\\\\n/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assign restriction fragments to pairs\nTags: pairs, pairstools, restriction fragments", "answer": "process PAIRTOOLS_RESTRICT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(pairs)\n    path frag\n\n    output:\n    tuple val(meta), path(\"*.pairs.gz\"), emit: restrict\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pairtools \\\\\n        restrict \\\\\n        -f $frag \\\\\n        $args \\\\\n        -o ${prefix}.pairs.gz \\\\\n        $pairs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | tr '\\\\n' ',' | sed 's/.*pairtools.*version //' | sed 's/,\\$/\\\\n/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge multiple pairs/pairsam files\nTags: merge, pairs, pairsam", "answer": "process PAIRTOOLS_MERGE {\n    tag \"${meta.id}\"\n    label 'process_medium'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(allpairs)\n\n    output:\n    tuple val(meta), path(\"*pairs.gz\"), emit:pairs\n    path(\"versions.yml\"), emit:versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_merged\"\n    \"\"\"\n    pairtools merge \\\n        ${args} \\\n        --nproc ${task.cpus} \\\n        -o ${prefix}.pairs.gz \\\n        ${allpairs}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | tr '\\\\n' ',' | sed 's/.*pairtools.*version //' | sed 's/,\\$/\\\\n/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Find ligation junctions in .sam, make .pairs\nTags: ligation junctions, parse, pairtools", "answer": "process PAIRTOOLS_PARSE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path chromsizes\n\n    output:\n    tuple val(meta), path(\"*.pairsam.gz\")  , emit: pairsam\n    tuple val(meta), path(\"*.pairsam.stat\"), emit: stat\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pairtools \\\\\n        parse \\\\\n        -c $chromsizes \\\\\n        $args \\\\\n        --output-stats ${prefix}.pairsam.stat \\\\\n        -o ${prefix}.pairsam.gz \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | tr '\\\\n' ',' | sed 's/.*pairtools.*version //' | sed 's/,\\$/\\\\n/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Flip pairs to get an upper-triangular matrix\nTags: flip, pairs, upper-triangular matrix", "answer": "process PAIRTOOLS_FLIP {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(sam)\n    path chromsizes\n\n    output:\n    tuple val(meta), path(\"*.flip.gz\"), emit: flip\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pairtools \\\\\n        flip \\\\\n        -c $chromsizes \\\\\n        $args \\\\\n        -o ${prefix}.flip.gz \\\\\n        $sam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | tr '\\\\n' ',' | sed 's/.*pairtools.*version //' | sed 's/,\\$/\\\\n/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Select pairs according to given condition by options.args\nTags: select, pairs, filter", "answer": "process PAIRTOOLS_SELECT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.selected.pairs.gz\")  , emit: selected\n    tuple val(meta), path(\"*.unselected.pairs.gz\"), emit: unselected\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pairtools select \\\\\n        \"$args\" \\\\\n        -o ${prefix}.selected.pairs.gz \\\\\n        --output-rest ${prefix}.unselected.pairs.gz \\\\\n        ${input}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | tr '\\\\n' ',' | sed 's/.*pairtools.*version //' | sed 's/,\\$/\\\\n/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate pairs statistics\nTags: stats, pairs, pairsam", "answer": "process PAIRTOOLS_STATS {\n    tag \"${meta.id}\"\n    label 'process_low'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(pairs)\n\n    output:\n    tuple val(meta), path(\"*.pairs.stat\"), emit:stats\n    path(\"versions.yml\"), emit:versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pairtools stats \\\\\n        ${args} \\\\\n        --nproc-in ${task.cpus} --nproc-out ${task.cpus} \\\\\n        -o ${prefix}.pairs.stat \\\\\n        ${pairs}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | tr '\\\\n' ',' | sed 's/.*pairtools.*version //' | sed 's/,\\$/\\\\n/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Find and remove PCR/optical duplicates\nTags: dedup, deduplication, PCR/optical duplicates, pairs", "answer": "process PAIRTOOLS_DEDUP {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    // Pinning numpy to 1.23 until https://github.com/open2c/pairtools/issues/170 is resolved\n    // Not an issue with the biocontainers because they were built prior to numpy 1.24\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairtools:1.0.2--py39h2a9f597_0' :\n        'biocontainers/pairtools:1.0.2--py39h2a9f597_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.pairs.gz\")  , emit: pairs\n    tuple val(meta), path(\"*.pairs.stat\"), emit: stat\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pairtools dedup \\\\\n        $args \\\\\n        -o ${prefix}.pairs.gz \\\\\n        --output-stats ${prefix}.pairs.stat \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairtools: \\$(pairtools --version | tr '\\\\n' ',' | sed 's/.*pairtools.*version //' | sed 's/,\\$/\\\\n/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Count reads that map to genomic features\nTags: counts, fasta, genome, reference", "answer": "process SUBREAD_FEATURECOUNTS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/subread:2.0.1--hed695b0_0' :\n        'biocontainers/subread:2.0.1--hed695b0_0' }\"\n\n    input:\n    tuple val(meta), path(bams), path(annotation)\n\n    output:\n    tuple val(meta), path(\"*featureCounts.txt\")        , emit: counts\n    tuple val(meta), path(\"*featureCounts.txt.summary\"), emit: summary\n    path \"versions.yml\"                                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def paired_end = meta.single_end ? '' : '-p'\n\n    def strandedness = 0\n    if (meta.strandedness == 'forward') {\n        strandedness = 1\n    } else if (meta.strandedness == 'reverse') {\n        strandedness = 2\n    }\n    \"\"\"\n    featureCounts \\\\\n        $args \\\\\n        $paired_end \\\\\n        -T $task.cpus \\\\\n        -a $annotation \\\\\n        -s $strandedness \\\\\n        -o ${prefix}.featureCounts.txt \\\\\n        ${bams.join(' ')}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        subread: \\$( echo \\$(featureCounts -v 2>&1) | sed -e \"s/featureCounts v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.featureCounts.txt\n    touch ${prefix}.featureCounts.txt.summary\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        subread: \\$( echo \\$(featureCounts -v 2>&1) | sed -e \"s/featureCounts v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Get dataset for SARS-CoV-2 genome clade assignment, mutation calling, and sequence quality checks (C++ implementation)\nTags: nextclade, variant, consensus", "answer": "process NEXTCLADE_DATASETGET {\n    tag \"$dataset\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nextclade:2.12.0--h9ee0642_0' :\n        'biocontainers/nextclade:2.12.0--h9ee0642_0' }\"\n\n    input:\n    val dataset\n    val reference\n    val tag\n\n    output:\n    path \"$prefix\"     , emit: dataset\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${dataset}\"\n    def fasta = reference ? \"--reference ${reference}\" : ''\n    def version = tag ? \"--tag ${tag}\" : ''\n    \"\"\"\n    nextclade \\\\\n        dataset \\\\\n        get \\\\\n        $args \\\\\n        --name $dataset \\\\\n        $fasta \\\\\n        $version \\\\\n        --output-dir $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nextclade: \\$(echo \\$(nextclade --version 2>&1) | sed 's/^.*nextclade //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SARS-CoV-2 genome clade assignment, mutation calling, and sequence quality checks (C++ implementation)\nTags: nextclade, variant, consensus", "answer": "process NEXTCLADE_RUN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nextclade:2.12.0--h9ee0642_0' :\n        'biocontainers/nextclade:2.12.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path dataset\n\n    output:\n    tuple val(meta), path(\"${prefix}.csv\")           , optional:true, emit: csv\n    tuple val(meta), path(\"${prefix}.errors.csv\")    , optional:true, emit: csv_errors\n    tuple val(meta), path(\"${prefix}.insertions.csv\"), optional:true, emit: csv_insertions\n    tuple val(meta), path(\"${prefix}.tsv\")           , optional:true, emit: tsv\n    tuple val(meta), path(\"${prefix}.json\")          , optional:true, emit: json\n    tuple val(meta), path(\"${prefix}.auspice.json\")  , optional:true, emit: json_auspice\n    tuple val(meta), path(\"${prefix}.ndjson\")        , optional:true, emit: ndjson\n    tuple val(meta), path(\"${prefix}.aligned.fasta\") , optional:true, emit: fasta_aligned\n    tuple val(meta), path(\"*.translation.fasta\")     , optional:true, emit: fasta_translation\n    path \"versions.yml\"                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    nextclade \\\\\n        run \\\\\n        $args \\\\\n        --jobs $task.cpus \\\\\n        --input-dataset $dataset \\\\\n        --output-all ./ \\\\\n        --output-basename ${prefix} \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nextclade: \\$(echo \\$(nextclade --version 2>&1) | sed 's/^.*nextclade //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A command line tool that makes it easier to find sequencing data from the SRA / GEO / ENA.\nTags: SRA, ENA, GEO, metadata, fetch, public, databases", "answer": "process FFQ {\n    tag \"${ids.size() == 1 ? ids[0] : \"${ids[0]+'..'+ids[-1]}\"}\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ffq:0.2.1--pyhdfd78af_0':\n        'biocontainers/ffq:0.2.1--pyhdfd78af_0' }\"\n\n    input:\n    val ids\n\n    output:\n    path \"*.json\"      , emit: json\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def id_list = ids.sort()\n    def name = id_list.size() == 1 ? ids[0] : 'metadata'\n    def prefix = task.ext.prefix ?: \"${name}\"\n    \"\"\"\n    ffq \\\\\n        ${id_list.join(' ')} \\\\\n        $args \\\\\n        > ${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ffq: \\$(echo \\$(ffq --help 2>&1) | sed 's/^.*ffq //; s/: A command.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Analysis of mcr-1 gene (mobilized colistin resistance) for sequence variation\nTags: resistance, fasta", "answer": "process MCRONI {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mcroni%3A1.0.4--pyh5e36f6f_0':\n        'biocontainers/mcroni:1.0.4--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\")               , emit: tsv\n    tuple val(meta), path(\"*.fa\"), optional: true, emit: fa\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getName().endsWith(\".gz\") ? true : false\n    def fasta_name = fasta.getName().replace(\".gz\", \"\")\n    def VERSION = '1.0.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    mcroni \\\\\n        $args \\\\\n        --output $prefix \\\\\n        --fasta $fasta_name\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mcroni: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GTDB-Tk is a software toolkit for assigning objective taxonomic classifications to bacterial and archaeal genomes based on the Genome Database Taxonomy GTDB.\nTags: GTDB taxonomy, taxonomic classification, metagenomics, classification, genome taxonomy database, bacteria, archaea", "answer": "process GTDBTK_CLASSIFYWF {\n    tag \"${prefix}\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gtdbtk:2.4.0--pyhdfd78af_1' :\n        'biocontainers/gtdbtk:2.4.0--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(\"bins/*\")\n    tuple val(db_name), path(\"database/*\")\n    path(mash_db)\n\n    output:\n    tuple val(meta), path(\"gtdbtk.${prefix}.*.summary.tsv\")         , emit: summary\n    tuple val(meta), path(\"gtdbtk.${prefix}.*.classify.tree.gz\")    , emit: tree, optional: true\n    tuple val(meta), path(\"gtdbtk.${prefix}.*.markers_summary.tsv\") , emit: markers, optional: true\n    tuple val(meta), path(\"gtdbtk.${prefix}.*.msa.fasta.gz\")        , emit: msa, optional: true\n    tuple val(meta), path(\"gtdbtk.${prefix}.*.user_msa.fasta.gz\")   , emit: user_msa, optional: true\n    tuple val(meta), path(\"gtdbtk.${prefix}.*.filtered.tsv\")        , emit: filtered, optional: true\n    tuple val(meta), path(\"gtdbtk.${prefix}.failed_genomes.tsv\")    , emit: failed, optional: true\n    tuple val(meta), path(\"gtdbtk.${prefix}.log\")                   , emit: log\n    tuple val(meta), path(\"gtdbtk.${prefix}.warnings.log\")          , emit: warnings\n    path(\"versions.yml\")                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def pplacer_scratch = params.gtdbtk_pplacer_scratch ? \"--scratch_dir pplacer_tmp\" : \"\"\n    def mash_mode = mash_db ? \"--mash_db ${mash_db}\" : \"--skip_ani_screen\"\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    export GTDBTK_DATA_PATH=\"\\${PWD}/database\"\n    if [ ${pplacer_scratch} != \"\" ] ; then\n        mkdir pplacer_tmp\n    fi\n\n    gtdbtk classify_wf \\\\\n        $args \\\\\n        --genome_dir bins \\\\\n        --prefix \"gtdbtk.${prefix}\" \\\\\n        --out_dir \"\\${PWD}\" \\\\\n        --cpus $task.cpus \\\\\n        $mash_mode \\\\\n        $pplacer_scratch \\\\\n        --min_perc_aa $params.gtdbtk_min_perc_aa \\\\\n        --min_af $params.gtdbtk_min_af\n\n    ## If mash db given, classify/ and identify/ directories won't be created\n    if [[ -d classify/ ]]; then\n        mv classify/* .\n    fi\n\n    if [[ -d identify/ ]]; then\n        mv identify/* .\n    fi\n\n    ## If nothing aligns, no output, so only run\n    if [[ -d align/ ]]; then\n        mv align/* .\n    fi\n\n    mv gtdbtk.log \"gtdbtk.${prefix}.log\"\n\n    mv gtdbtk.warnings.log \"gtdbtk.${prefix}.warnings.log\"\n\n    find -name \"gtdbtk.${prefix}.*.classify.tree\" | xargs -r gzip # do not fail if .tree is missing\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gtdbtk: \\$(echo \\$(gtdbtk --version -v 2>&1) | sed \"s/gtdbtk: version //; s/ Copyright.*//\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def VERSION = '2.3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch gtdbtk.${prefix}.stub.summary.tsv\n    echo \"\" | gzip > gtdbtk.${prefix}.stub.classify.tree.gz\n    touch gtdbtk.${prefix}.stub.markers_summary.tsv\n    echo \"\" | gzip > gtdbtk.${prefix}.stub.msa.fasta.gz\n    echo \"\" | gzip > gtdbtk.${prefix}.stub.user_msa.fasta.gz\n    touch gtdbtk.${prefix}.stub.filtered.tsv\n    touch gtdbtk.${prefix}.log\n    touch gtdbtk.${prefix}.warnings.log\n    touch gtdbtk.${prefix}.failed_genomes.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gtdbtk: \\$(echo \"$VERSION\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Uses the RTN R package for transcriptional regulatory network inference (TNI).\nTags: regulatory network, transcriptomics, transcription factors", "answer": "process RTN_TNI {\n    debug true\n    tag \"{$expression_matrix.name}\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-rtn:2.26.0--r43hdfd78af_0':\n        'biocontainers/bioconductor-rtn:2.26.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(expression_matrix)\n\n    output:\n    tuple val(meta), path(\"tni.rds\")               , emit: tni\n    tuple val(meta), path(\"tni_permutated.rds\")    , emit: tni_perm\n    tuple val(meta), path(\"tni_bootstrapped.rds\")  , emit: tni_bootstrap\n    tuple val(meta), path(\"tni_filtered.rds\")      , emit: tni_filtered\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    template 'rtn_tni.r'\n\n    stub:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    touch tni.rds\n    touch tni_permutated.rds\n    touch tni_bootstrapped.rds\n    touch tni_filtered.rds\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bioconductor-rtn: \\$(Rscript -e \"suppressWarnings(library(RTN)); cat(as.character(packageVersion('RTN')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Find split or spliced alignments in a MAF file\nTags: LAST, split, spliced, alignment, MAF", "answer": "process LAST_SPLIT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/last:1542--h43eeafb_1' :\n        'biocontainers/last:1542--h43eeafb_1' }\"\n\n    input:\n    tuple val(meta), path(maf)\n\n    output:\n    tuple val(meta), path(\"*.maf.gz\"), emit: maf\n    tuple val(meta), path(\"*.tsv\")   , emit: multiqc\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$maf\" == \"${prefix}.maf.gz\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    set -o pipefail\n\n    function calculate_psl_metrics() {\n        awk 'BEGIN {\n            FS=\"\\t\";  # Set field separator as tab\n            totalMatches = 0;\n            totalAlignmentLength = 0;\n            print \"Sample\\tTotalAlignmentLength\\tPercentSimilarity\";  # Header for MultiQC\n        }\n        {\n            totalMatches += \\$1 + \\$3;  # Sum matches and repMatches\n            totalAlignmentLength += \\$1 + \\$2 + \\$3 + \\$6 + \\$8;  # Sum matches, misMatches, repMatches, qBaseInsert, and tBaseInsert\n        }\n        END {\n            percentSimilarity = (totalAlignmentLength > 0) ? (totalMatches / totalAlignmentLength * 100) : 0;\n            print \"$meta.id\" \"\\t\" totalAlignmentLength \"\\t\" percentSimilarity;  # Data in TSV format\n        }'\n    }\n\n    zcat < $maf |\n        last-split $args |\n        tee >(gzip --no-name  > ${prefix}.maf.gz) |\n        maf-convert psl |\n        calculate_psl_metrics > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(last-split --version 2>&1 | sed 's/last-split //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$maf\" == \"${prefix}.maf.gz\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    echo stub | gzip --no-name > ${prefix}.maf.gz\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(last-split --version 2>&1 | sed 's/last-split //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Reorder alignments in a MAF file\nTags: LAST, reorder, alignment, MAF", "answer": "process LAST_MAFSWAP {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/last:1542--h43eeafb_1' :\n        'biocontainers/last:1542--h43eeafb_1' }\"\n\n    input:\n    tuple val(meta), path(maf)\n\n    output:\n    tuple val(meta), path(\"*.maf.gz\"), emit: maf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    set -o pipefail\n    maf-swap $args $maf | gzip --no-name > ${prefix}.swapped.maf.gz\n\n    # maf-swap has no --version option but lastdb, part of the same package, has.\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastdb --version 2>&1 | sed 's/lastdb //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo stub | gzip --no-name > ${prefix}.swapped.maf.gz\n\n    # maf-swap has no --version option but lastdb, part of the same package, has.\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastdb --version 2>&1 | sed 's/lastdb //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Aligns query sequences to target sequences indexed with lastdb\nTags: LAST, align, fastq, fasta", "answer": "process LAST_LASTAL {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/last:1542--h43eeafb_1' :\n        'biocontainers/last:1542--h43eeafb_1' }\"\n\n    input:\n    tuple val(meta), path(fastx), path (param_file)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.maf.gz\"), emit: maf\n    tuple val(meta), path(\"*.tsv\")   , emit: multiqc\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def trained_params = param_file ? \"-p ${param_file}\"  : ''\n    \"\"\"\n    INDEX_NAME=\\$(basename \\$(ls $index/*.des) .des)\n    set -o pipefail\n\n    function calculate_psl_metrics() {\n        awk 'BEGIN {\n            FS=\"\\t\";  # Set field separator as tab\n            totalMatches = 0;\n            totalAlignmentLength = 0;\n            print \"Sample\\tTotalAlignmentLength\\tPercentSimilarity\";  # Header for MultiQC\n        }\n        {\n            totalMatches += \\$1 + \\$3;  # Sum matches and repMatches\n            totalAlignmentLength += \\$1 + \\$2 + \\$3 + \\$6 + \\$8;  # Sum matches, misMatches, repMatches, qBaseInsert, and tBaseInsert\n        }\n        END {\n            percentSimilarity = (totalAlignmentLength > 0) ? (totalMatches / totalAlignmentLength * 100) : 0;\n            print \"$meta.id\" \"\\t\" totalAlignmentLength \"\\t\" percentSimilarity;  # Data in TSV format\n        }'\n    }\n\n    lastal \\\\\n        -P $task.cpus \\\\\n        $trained_params \\\\\n        $args \\\\\n        ${index}/\\$INDEX_NAME \\\\\n        $fastx |\n        tee >(gzip --no-name  > ${prefix}.maf.gz) |\n        maf-convert psl |\n        calculate_psl_metrics > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastal --version 2>&1 | sed 's/lastal //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def trained_params = param_file ? \"-p ${param_file}\"  : ''\n    \"\"\"\n    INDEX_NAME=STUB\n    echo stub | gzip --no-name > ${prefix}.\\$INDEX_NAME.maf.gz\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastal --version 2>&1 | sed 's/lastal //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Makes a dotplot (Oxford Grid) of pair-wise sequence alignments\nTags: LAST, plot, pair, alignment, MAF", "answer": "process LAST_DOTPLOT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/last:1542--h43eeafb_1' :\n        'biocontainers/last:1542--h43eeafb_1' }\"\n\n    input:\n    tuple val(meta), path(maf), path(annot_b)\n    tuple val(meta2), path(annot_a)\n    val(format)\n\n    output:\n    tuple val(meta), path(\"*.gif\"), optional:true, emit: gif\n    tuple val(meta), path(\"*.png\"), optional:true, emit: png\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def annot_a_arg = annot_a ? \"-a ${annot_a}\" : ''\n    def annot_b_arg = annot_b ? \"-b ${annot_b}\" : ''\n    \"\"\"\n    last-dotplot \\\\\n        $args \\\\\n        $annot_a_arg \\\\\n        $annot_b_arg \\\\\n        $maf \\\\\n        $prefix.$format\n\n    # last-dotplot has no --version option so let's use lastal from the same suite\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastal --version | sed 's/lastal //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch $prefix.$format\n\n    # last-dotplot has no --version option so let's use lastal from the same suite\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastal --version | sed 's/lastal //')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Find suitable score parameters for sequence alignment\nTags: LAST, train, fastq, fasta", "answer": "process LAST_TRAIN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/last:1542--h43eeafb_1' :\n        'biocontainers/last:1542--h43eeafb_1' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n    path  index\n\n    output:\n    tuple val(meta), path(\"*.train\"), emit: param_file\n    tuple val(meta), path(\"*.tsv\")  , emit: multiqc\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    INDEX_NAME=\\$(basename \\$(ls $index/*.des) .des)\n\n    last-train \\\\\n        $args \\\\\n        -P $task.cpus \\\\\n        ${index}/\\$INDEX_NAME \\\\\n        $fastx \\\\\n        > ${prefix}.\\$INDEX_NAME.train\n\n    echo \"id\\tsubstitution_percent_identity\\tlast -t\\tlast -a\\tlast -A\\tlast -b\\tlast -B\\tlast -S\" > ${prefix}.train.tsv\n    printf \"\\$(basename ${prefix}.\\$INDEX_NAME.train .target.train)\\t\" >> ${prefix}.train.tsv\n    grep 'substitution percent identity' ${prefix}.\\$INDEX_NAME.train | tail -n 1 | awk '{print \\$5}' | tr '\\n' '\\t' >> ${prefix}.train.tsv\n    grep 'last -t' ${prefix}.\\$INDEX_NAME.train | tail -n 1 | awk '{print \\$2}' | sed -e 's/-t//' | tr '\\n' '\\t' >> ${prefix}.train.tsv\n    grep 'last -a' ${prefix}.\\$INDEX_NAME.train | tail -n 1 | awk '{print \\$3}' | tr '\\n' '\\t' >> ${prefix}.train.tsv\n    grep 'last -A' ${prefix}.\\$INDEX_NAME.train | tail -n 1 | awk '{print \\$3}' | tr '\\n' '\\t' >> ${prefix}.train.tsv\n    grep 'last -b' ${prefix}.\\$INDEX_NAME.train | tail -n 1 | awk '{print \\$3}' | tr '\\n' '\\t' >> ${prefix}.train.tsv\n    grep 'last -B' ${prefix}.\\$INDEX_NAME.train | tail -n 1 | awk '{print \\$3}' | tr '\\n' '\\t' >> ${prefix}.train.tsv\n    grep 'last -S' ${prefix}.\\$INDEX_NAME.train | tail -n 1 | awk '{print \\$3}' >> ${prefix}.train.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastdb --version | sed 's/lastdb //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    INDEX_NAME=\\$(basename \\$(ls $index/*.des) .des)\n    touch ${prefix}.\\$INDEX_NAME.train\n    touch ${prefix}.train.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastdb --version | sed 's/lastdb //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Prepare sequences for subsequent alignment with lastal.\nTags: LAST, index, fasta, fastq", "answer": "process LAST_LASTDB {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/last:1542--h43eeafb_1' :\n        'biocontainers/last:1542--h43eeafb_1' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"lastdb\"), emit: index\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir lastdb\n    lastdb \\\\\n        $args \\\\\n        -P $task.cpus \\\\\n        lastdb/${prefix} \\\\\n        $fastx\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastdb --version 2>&1 | sed 's/lastdb //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir lastdb\n    touch lastdb/${prefix}.bck\n    touch lastdb/${prefix}.des\n    touch lastdb/${prefix}.prj\n    touch lastdb/${prefix}.sds\n    touch lastdb/${prefix}.ssp\n    touch lastdb/${prefix}.suf\n    touch lastdb/${prefix}.tis\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastdb --version 2>&1 | sed 's/lastdb //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts MAF alignments in another format.\nTags: LAST, convert, alignment, MAF", "answer": "process LAST_MAFCONVERT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/last:1542--h43eeafb_1' :\n        'biocontainers/last:1542--h43eeafb_1' }\"\n\n    input:\n    tuple val(meta), path(maf)\n    val(format)\n\n    output:\n    tuple val(meta), path(\"*.axt.gz\"),      optional:true, emit: axt_gz\n    tuple val(meta), path(\"*.blast.gz\"),    optional:true, emit: blast_gz\n    tuple val(meta), path(\"*.blasttab.gz\"), optional:true, emit: blasttab_gz\n    tuple val(meta), path(\"*.chain.gz\"),    optional:true, emit: chain_gz\n    tuple val(meta), path(\"*.gff.gz\"),      optional:true, emit: gff_gz\n    tuple val(meta), path(\"*.html.gz\"),     optional:true, emit: html_gz\n    tuple val(meta), path(\"*.psl.gz\"),      optional:true, emit: psl_gz\n    tuple val(meta), path(\"*.sam.gz\"),      optional:true, emit: sam_gz\n    tuple val(meta), path(\"*.tab.gz\"),      optional:true, emit: tab_gz\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    set -o pipefail\n    maf-convert $args $format $maf | gzip --no-name > ${prefix}.${format}.gz\n\n    # maf-convert has no --version option but lastdb (part of the same package) has.\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastdb --version 2>&1 | sed 's/lastdb //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo stub | gzip --no-name > ${prefix}.${format}.gz\n\n    # maf-convert has no --version option but lastdb (part of the same package) has.\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastdb --version 2>&1 | sed 's/lastdb //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Post-alignment masking\nTags: LAST, mask, alignment, MAF", "answer": "process LAST_POSTMASK {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/last:1542--h43eeafb_1' :\n        'biocontainers/last:1542--h43eeafb_1' }\"\n\n    input:\n    tuple val(meta), path(maf)\n\n    output:\n    tuple val(meta), path(\"*.maf.gz\"), emit: maf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$maf\" == \"${prefix}.maf.gz\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    set -o pipefail\n    last-postmask $args $maf | gzip --no-name > ${prefix}.maf.gz\n\n    # last-postmask does not have a --version option\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastal --version 2>&1 | sed 's/lastal //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$maf\" == \"${prefix}.maf.gz\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    echo stub | gzip --no-name > ${prefix}.maf.gz\n\n    # last-postmask does not have a --version option\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        last: \\$(lastal --version 2>&1 | sed 's/lastal //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Use vireo to perform donor deconvolution for multiplexed scRNA-seq data\nTags: genotype-based demultiplexing, donor deconvolution, cellsnp", "answer": "process VIREO {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vireosnp:0.5.8--pyh7cba7a3_0' :\n        'biocontainers/vireosnp:0.5.8--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(cell_data), val(n_donor), path(donor_file), path(vartrix_data)\n    output:\n    tuple val(meta), path('*_summary.tsv')        , emit: summary\n    tuple val(meta), path('*_donor_ids.tsv')      , emit: donor_ids\n    tuple val(meta), path('*_prob_singlet.tsv.gz'), emit: prob_singlets\n    tuple val(meta), path('*_prob_doublet.tsv.gz'), emit: prob_doublets\n    path 'versions.yml'                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input  = cell_data       ? \"-c ${cell_data}\" : \"--vartrixData ${vartrix_data}\"\n\n    \"\"\"\n    vireo \\\\\n        $input \\\\\n        -N ${n_donor} \\\\\n        -d ${donor_file} \\\\\n        -p $task.cpus \\\\\n        -o . \\\\\n        $args\n\n    mv summary.tsv ${prefix}_summary.tsv\n    mv donor_ids.tsv ${prefix}_donor_ids.tsv\n    mv prob_singlet.tsv.gz ${prefix}_prob_singlet.tsv.gz\n    mv prob_doublet.tsv.gz ${prefix}_prob_doublet.tsv.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vireo: \\$(vireo | sed '1!d ; s/Welcome to vireoSNP //; s/!//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}_summary.tsv\n    touch ${prefix}_donor_ids.tsv\n    echo \"\" | gzip > ${prefix}_prob_singlet.tsv.gz\n    echo \"\" | gzip > ${prefix}_prob_doublet.tsv.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vireo: \\$(vireo | sed '1!d ; s/Welcome to vireoSNP //; s/!//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Whole genome annotation of small genomes (bacterial, archeal, viral)\nTags: annotation, fasta, prokka", "answer": "process PROKKA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/prokka:1.14.6--pl5321hdfd78af_4' :\n        'biocontainers/prokka:1.14.6--pl5321hdfd78af_4' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path proteins\n    path prodigal_tf\n\n    output:\n    tuple val(meta), path(\"${prefix}/*.gff\"), emit: gff\n    tuple val(meta), path(\"${prefix}/*.gbk\"), emit: gbk\n    tuple val(meta), path(\"${prefix}/*.fna\"), emit: fna\n    tuple val(meta), path(\"${prefix}/*.faa\"), emit: faa\n    tuple val(meta), path(\"${prefix}/*.ffn\"), emit: ffn\n    tuple val(meta), path(\"${prefix}/*.sqn\"), emit: sqn\n    tuple val(meta), path(\"${prefix}/*.fsa\"), emit: fsa\n    tuple val(meta), path(\"${prefix}/*.tbl\"), emit: tbl\n    tuple val(meta), path(\"${prefix}/*.err\"), emit: err\n    tuple val(meta), path(\"${prefix}/*.log\"), emit: log\n    tuple val(meta), path(\"${prefix}/*.txt\"), emit: txt\n    tuple val(meta), path(\"${prefix}/*.tsv\"), emit: tsv\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def proteins_opt = proteins ? \"--proteins ${proteins[0]}\" : \"\"\n    def prodigal_tf = prodigal_tf ? \"--prodigaltf ${prodigal_tf[0]}\" : \"\"\n    \"\"\"\n    prokka \\\\\n        $args \\\\\n        --cpus $task.cpus \\\\\n        --prefix $prefix \\\\\n        $proteins_opt \\\\\n        $prodigal_tf \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        prokka: \\$(echo \\$(prokka --version 2>&1) | sed 's/^.*prokka //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Demultiplex fastq files\nTags: demultiplex, fastq, rust", "answer": "process FQTK {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fqtk:0.2.1--h9f5acd7_0' :\n        'biocontainers/fqtk:0.2.1--h9f5acd7_0' }\"\n\n    input:\n    tuple val(meta), path(sample_sheet), val(fastq_readstructure_pairs)\n    // fastq_readstructure_pairs example:\n    // [[<fastq name: string>, <read structure: string>, <path to fastqs: path>], [example_R1.fastq.gz, 150T, ./work/98/30bc..78y/fastqs/]]\n\n    output:\n    // Demultiplexed file name changes depending on the arg '--output-types'\n    tuple val(meta), path('output/*.fq.gz')                         , emit: sample_fastq\n    tuple val(meta), path('output/demux-metrics.txt')               , emit: metrics\n    tuple val(meta), path('output/unmatched*.fq.gz')                , emit: most_frequent_unmatched\n    path \"versions.yml\"                                             , emit: versions\n\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // Join the absolute path from UNTAR.out.untar to the fastq file names\n    fastqs = fastq_readstructure_pairs.collect{it[2]/it[0]}.join(\" \")\n    // Create a list of read structures, Example: 8B 8B 150T\n    read_structures = fastq_readstructure_pairs.collect{it[1]}.join(\" \")\n\n    \"\"\"\n    mkdir output\n    fqtk \\\\\n        demux \\\\\n            --inputs ${fastqs} \\\\\n            --read-structures ${read_structures} \\\\\n            --output output/ \\\\\n            --sample-metadata ${sample_sheet} \\\\\n            ${args}\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fqtk: \\$(echo \\$(fqtk --version 2>&1) | cut -d \" \" -f2)\n    \"\"\"\n}\n"}
{"question": "Description: tool to call the copy number of full-length SMN1, full-length SMN2, as well as SMN2\u03947\u20138 (SMN2 with a deletion of Exon7-8) from a whole-genome sequencing (WGS) BAM file.\nTags: copy number, BAM, CRAM, SMN1, SMN2", "answer": "process SMNCOPYNUMBERCALLER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/smncopynumbercaller:1.1.2--py310h7cba7a3_0' :\n        'biocontainers/smncopynumbercaller:1.1.2--py310h7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path(\"out/*.tsv\"),  emit: smncopynumber\n    tuple val(meta), path(\"out/*.json\"), emit: run_metrics\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"1.1.2\" // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    \"\"\"\n    echo $bam | tr ' ' '\n    ' > manifest.txt\n    smn_caller.py \\\\\n        $args \\\\\n        --manifest manifest.txt \\\\\n        --prefix $prefix \\\\\n        --outDir \"out\" \\\\\n        --threads $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        SMNCopyNumberCaller: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"1.1.2\"\n    \"\"\"\n    mkdir out\n    touch out/${prefix}.tsv\n    touch out/${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        SMNCopyNumberCaller: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Map short-reads to an indexed reference genome\nTags: mapad, ancient dna, adna, damage, deamination, miscoding lesions, c to t, palaeogenomics, archaeogenomics, palaeogenetics, archaeogenetics, short-read, align, aligner, alignment, map, mapper, mapping, reference, fasta, fastq, bam, cram", "answer": "process MAPAD_MAP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mapad:0.43.0--hc9368f3_0':\n        'biocontainers/mapad:0.43.0--hc9368f3_0' }\"\n\n    input:\n    tuple val(meta) , path(reads) // Supports only single-end or merged paired-end data\n    tuple val(meta2), path(index)\n    val mismatch_parameter\n    val double_stranded_library\n    val five_prime_overhang\n    val three_prime_overhang\n    val deam_rate_double_stranded\n    val deam_rate_single_stranded\n    val indel_rate\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def library_preparation = double_stranded_library ? 'double_stranded' : 'single_stranded'\n\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.tbw\" | sed 's/\\\\.tbw\\$//'`\n\n    mapad \\\\\n        map \\\\\n        ${args} \\\\\n        --threads ${task.cpus} \\\\\n        --reads ${reads} \\\\\n        --reference \\${INDEX} \\\\\n        --output ${prefix}.bam \\\\\n        -p ${mismatch_parameter} \\\\\n        --library ${library_preparation} \\\\\n        -f ${five_prime_overhang} \\\\\n        -t ${three_prime_overhang} \\\\\n        -d ${deam_rate_double_stranded} \\\\\n        -s ${deam_rate_single_stranded} \\\\\n        -i ${indel_rate}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mapad: \\$(echo \\$(mapad --version) | sed 's/^mapAD //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create mapAD index for reference genome\nTags: index, fasta, genome, reference", "answer": "process MAPAD_INDEX {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mapad:0.43.0--hc9368f3_0':\n        'biocontainers/mapad:0.43.0--hc9368f3_0' }\"\n\n    input:\n    tuple val(meta), path(fasta, stageAs: \"mapad/*\")\n\n    output:\n    tuple val(meta), path(\"mapad/\"), emit: index\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mapad \\\\\n        index \\\\\n        $args \\\\\n        --reference $fasta \\\\\n        --threads $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mapad: \\$(echo \\$(mapad --version) | sed 's/^mapAD //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Peak-calling for ChIP-seq and ATAC-seq enrichment experiments\nTags: peak-calling, ChIP-seq, ATAC-seq", "answer": "process GENRICH {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genrich:0.6.1--h5bf99c6_1' :\n        'biocontainers/genrich:0.6.1--h5bf99c6_1' }\"\n\n    input:\n    tuple val(meta), path(treatment_bam), path(control_bam)\n    path  blacklist_bed\n\n    output:\n    tuple val(meta), path(\"*.narrowPeak\")                     , emit: peak\n    path \"versions.yml\"                                       , emit: versions\n\n    tuple val(meta), path(\"*.pvalues.bedGraph\"), optional:true, emit: bedgraph_pvalues\n    tuple val(meta), path(\"*.pileup.bedGraph\") , optional:true, emit: bedgraph_pileup\n    tuple val(meta), path(\"*.intervals.bed\")   , optional:true, emit: bed_intervals\n    tuple val(meta), path(\"*.duplicates.txt\")  , optional:true, emit: duplicates\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args   ?: \"\"\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def treatment  = treatment_bam   ? \"-t ${treatment_bam.join(',')}\"   : \"\"\n    def control    = control_bam     ? \"-c ${control_bam.join(',')}\"     : \"\"\n    def blacklist  = blacklist_bed   ? \"-E $blacklist_bed\"               : \"\"\n\n    if (meta.single_end && (!args.contains(\"-y\") && !args.contains(\"-w\"))) {\n        log.info '[Genrich] Single-end data can only be analyzed if unpaired alignments are kept (-y or -w <int>), defaulting to -y option.'\n        args = \"-y ${args}\"\n    }\n    if (args.contains(\"-R\") && !args.contains(\"-r\")) {\n        log.info '[Genrich] Duplicates can only be saved if they are filtered out, defaulting to -r option (Remove PCR duplicates).'\n        args = \"-r ${args}\"\n    }\n    \"\"\"\n    Genrich \\\\\n        $args \\\\\n        $treatment \\\\\n        $control \\\\\n        $blacklist \\\\\n        -o ${prefix}.narrowPeak\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genrich: \\$(echo \\$(Genrich --version 2>&1) | sed 's/^Genrich, version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SVTyper performs breakpoint genotyping of structural variants (SVs) using whole genome sequencing data\nTags: sv, structural variants, genotyping", "answer": "process SVTYPER_SVTYPER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svtyper:0.7.0--py27h24bf2e0_1':\n        'biocontainers/svtyper:0.7.0--py27h24bf2e0_1' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bam_index), path(vcf)\n    tuple val(meta2), path(fasta)\n    tuple val(meta2), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.json\"), emit: json\n    tuple val(meta), path(\"*.vcf\") , emit: gt_vcf\n    tuple val(meta), path(\"*.bam\") , emit: bam\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def vcf  = vcf ? \"--input_vcf ${vcf}\" : \"\"\n    if (\"$vcf\" == \"${prefix}.vcf\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    svtyper \\\\\n        $vcf \\\\\n        --bam $bam \\\\\n        --lib_info ${prefix}.json \\\\\n        --output_vcf ${prefix}.vcf \\\\\n        --ref_fasta $fasta \\\\\n        --write_alignment ${prefix}.bam \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtyper: \\$(echo \\$(svtyper -h 2>&1 | grep \"version:\" | sed 's/^version: v//'))\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.json\n    touch ${prefix}.vcf\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtyper: \\$(echo \\$(svtyper -h 2>&1 | grep \"version:\" | sed 's/^version: v//'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SVTyper-sso computes structural variant (SV) genotypes based on breakpoint depth on a SINGLE sample\nTags: sv, structural variants, genotyping, Bayesian", "answer": "process SVTYPER_SVTYPERSSO {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svtyper:0.7.1--py_0':\n        'biocontainers/svtyper:0.7.1--py_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bam_index), path(vcf)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.vcf\") , emit: gt_vcf\n    tuple val(meta), path(\"*.json\"), emit: json\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def vcf    = vcf ? \"--input_vcf ${vcf}\" : \"\"\n    def fasta  = fasta ? \"--ref_fasta ${fasta}\" : \"\"\n    if (\"$vcf\" == \"${prefix}.vcf\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    svtyper-sso \\\\\n        --bam $bam \\\\\n        $vcf \\\\\n        $fasta \\\\\n        --output_vcf ${prefix}.vcf \\\\\n        --lib_info ${prefix}.json \\\\\n        --cores $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtyper: \\$(echo \\$(svtyper-sso -h 2>&1 | grep \"version:\" | sed 's/^version: v//'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.json\n    touch ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtyper: \\$(echo \\$(svtyper-sso -h 2>&1 | grep \"version:\" | sed 's/^version: v//'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Pangenome toolbox for bacterial genomes\nTags: gff, pan-genome, alignment", "answer": "process PIRATE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pirate:1.0.4--hdfd78af_2' :\n        'biocontainers/pirate:1.0.4--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(gff)\n\n    output:\n    tuple val(meta), path(\"results/*\")                                   , emit: results\n    tuple val(meta), path(\"results/core_alignment.fasta\"), optional: true, emit: aln\n    path \"versions.yml\"                                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    PIRATE \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --input ./ \\\\\n        --output results/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pirate: \\$( echo \\$( PIRATE --version 2>&1) | sed 's/PIRATE //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This module is used to clip primer sequences from your alignments.\nTags: primer, clipping, genomics, bam", "answer": "\nprocess BAMCLIPPER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bamclipper:1.0.0--hdfd78af_2':\n        'biocontainers/bamclipper:1.0.0--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(bedpe)\n\n    output:\n    tuple val(meta), path(\"*.primerclipped.bam\")    , emit: bam\n    tuple val(meta), path(\"*.primerclipped.bam.bai\"), emit: bai\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.0' // WARN: Version information not provided by tool on CLI\n    \"\"\"\n    bamclipper.sh \\\\\n        -b ${bam} \\\\\n        -p ${bedpe} \\\\\n        -n $task.cpus \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamclipper: $VERSION\n        samtools: \\$( samtools --version |& sed '1!d ; s/samtools //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.0'\n    \"\"\"\n    touch ${prefix}.primerclipped.bam\n    touch ${prefix}.primerclipped.bam.bai\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamclipper: $VERSION\n        samtools: \\$( samtools --version |& sed '1!d ; s/samtools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Demultiplex bgzip'd fastq files\nTags: demultiplex, fastq, bgzip", "answer": "process SGDEMUX {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sgdemux:1.1.1--ha982bd6_0' :\n        'biocontainers/sgdemux:1.1.1--ha982bd6_0' }\"\n\n    input:\n    // Input fastq's must be bgzipped for compatibility with sgdemux\n    tuple val(meta), path(sample_sheet), path(fastqs_dir)\n\n    output:\n    tuple val(meta), path('output/*_R*.fastq.gz')                   , emit: sample_fastq\n    tuple val(meta), path('output/metrics.tsv')                     , emit: metrics\n    tuple val(meta), path('output/most_frequent_unmatched.tsv')     , emit: most_frequent_unmatched\n    tuple val(meta), path('output/per_project_metrics.tsv')         , emit: per_project_metrics\n    tuple val(meta), path('output/per_sample_metrics.tsv')          , emit: per_sample_metrics\n    tuple val(meta), path('output/sample_barcode_hop_metrics.tsv')  , emit: sample_barcode_hop_metrics\n    path \"versions.yml\"                                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p output/\n    sgdemux \\\\\n        --sample-metadata ${sample_sheet} \\\\\n        --fastqs ${fastqs_dir} \\\\\n        --output-dir output \\\\\n        --demux-threads ${task.cpus} \\\\\n        --compressor-threads ${task.cpus} \\\\\n        --writer-threads ${task.cpus} \\\\\n        ${args}\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sgdemux: \\$(echo \\$(sgdemux --version 2>&1) | cut -d \" \" -f2)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: quickly annotate your VCF with any number of INFO fields from any number of VCFs or BED files\nTags: vcf, bed, annotate, variant, lua, toml", "answer": "process VCFANNO {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vcfanno:0.3.5--h9ee0642_0':\n        'biocontainers/vcfanno:0.3.5--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(specific_resources)\n    path toml\n    path lua\n    path resources\n\n    output:\n    tuple val(meta), path(\"*.vcf\")     , emit: vcf\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def lua_cmd = lua ? \"--lua ${lua}\" : \"\"\n    \"\"\"\n    vcfanno \\\\\n        -p ${task.cpus} \\\\\n        ${args} \\\\\n        ${lua_cmd} \\\\\n        ${toml} \\\\\n        ${vcf} \\\\\n        > ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcfanno: \\$(echo \\$(vcfanno 2>&1 | grep version | cut -f3 -d' ' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcfanno: \\$(echo \\$(vcfanno 2>&1 | grep version | cut -f3 -d' ' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: An nf-core module for the OATK\nTags: organelle, mitochondrion, plastid, PacBio, HiFi, assembly", "answer": "process OATK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/oatk:1.0':\n        'biocontainers/oatk:1.0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple path(mito_hmm), path(mito_hmm_h3f), path(mito_hmm_h3i), path(mito_hmm_h3m), path(mito_hmm_h3p)\n    tuple path(pltd_hmm), path(pltd_hmm_h3f), path(pltd_hmm_h3i), path(pltd_hmm_h3m), path(pltd_hmm_h3p)\n\n    output:\n    tuple val(meta), path(\"*mito.ctg.fasta\")    , emit: mito_fasta, optional: true\n    tuple val(meta), path(\"*pltd.ctg.fasta\")    , emit: pltd_fasta, optional: true\n    tuple val(meta), path(\"*mito.ctg.bed\")      , emit: mito_bed, optional: true\n    tuple val(meta), path(\"*pltd.ctg.bed\")      , emit: pltd_bed, optional: true\n    tuple val(meta), path(\"*mito.gfa\")          , emit: mito_gfa, optional: true\n    tuple val(meta), path(\"*pltd.gfa\")          , emit: pltd_gfa, optional: true\n    tuple val(meta), path(\"*annot_mito.txt\")    , emit: annot_mito_txt, optional: true\n    tuple val(meta), path(\"*annot_pltd.txt\")    , emit: annot_pltd_txt, optional: true\n    tuple val(meta), path(\"*utg.clean.gfa\")     , emit: clean_gfa, optional: true\n    tuple val(meta), path(\"*utg.final.gfa\")     , emit: final_gfa, optional: true\n    tuple val(meta), path(\"*utg.gfa\")           , emit: initial_gfa, optional: true\n    tuple val(meta), path(\"*utg.multiplex.gfa\") , emit: multiplex_gfa, optional: true\n    tuple val(meta), path(\"*utg.unzip.gfa\")     , emit: unzip_gfa, optional: true\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    mito_hmm_arg = ''\n    if (mito_hmm) {\n        mito_hmm_arg = '-m ' + mito_hmm\n    }\n    pltd_hmm_arg = ''\n    if (pltd_hmm) {\n        pltd_hmm_arg = '-p ' + pltd_hmm\n    }\n    \"\"\"\n    oatk \\\\\n        $args \\\\\n        $mito_hmm_arg \\\\\n        $pltd_hmm_arg \\\\\n        -t $task.cpus \\\\\n        -o ${prefix} \\\\\n        $reads\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        oatk : \\$(oatk --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Annotation of eukaryotic metagenomes using MetaEuk\nTags: genomics, annotation, fasta", "answer": "process METAEUK_EASYPREDICT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metaeuk:6.a5d39d9--pl5321hf1761c0_2':\n        'biocontainers/metaeuk:6.a5d39d9--pl5321hf1761c0_2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path(database)\n\n    output:\n    tuple val(meta), path(\"${prefix}.fas\")      , emit: faa\n    tuple val(meta), path(\"${prefix}.codon.fas\"), emit: codon\n    tuple val(meta), path(\"*.tsv\")              , emit: tsv\n    tuple val(meta), path(\"*.gff\")              , emit: gff\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    if [ -d ${database} ]; then\n        ## if supplying an mmseqs database as a directory, metaeuk requires the basename of the database\n        DBBASE=`find ${database}/ -name \"*.version\" -exec sh -c 'file=\\$(basename {}); echo \\${file%%.*}' \\\\;`\n        DB=`echo \"${database}/\\${DBBASE}\"`\n    else\n        DB=${database}\n    fi\n\n    metaeuk easy-predict \\\\\n        ${fasta} \\\\\n        \\${DB} \\\\\n        ${prefix} \\\\\n        tmp/ \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metaeuk: \\$(metaeuk | grep 'Version' | sed 's/metaeuk Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fas\n    touch ${prefix}.codon.fas\n    touch ${prefix}.headersMap.tsv\n    touch ${prefix}.gff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metaeuk: \\$(metaeuk | grep 'Version' | sed 's/metaeuk Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NVIDIA Clara Parabricks GPU-accelerated gvcf indexing tool.\nTags: vcf, gvcf, tbi, idx, index, GPU-accelerated", "answer": "process PARABRICKS_INDEXGVCF {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nvcr.io/nvidia/clara/clara-parabricks:4.3.0-1\"\n\n    input:\n    tuple val(meta), path(gvcf, stageAs:'')\n\n    output:\n    // This tool outputs g.vcf.idx if input is uncompressed, g.vcf.gz.tbi if input is compressed\n    tuple val(meta), path(\"*.g.vcf*\") , emit: gvcf_index\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    pbrun \\\\\n        indexgvcf \\\\\n        --input $gvcf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    # Different outputs generated depending if file is gzipped\n    case $gvcf in\n    *.gz )\n        touch ${prefix}.g.vcf.gz.tbi\n        ;;\n    * )\n        touch ${prefix}.g.vcf.idx\n        ;;\n    esac\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NVIDIA Clara Parabricks GPU-accelerated alignment, sorting, BQSR calculation, and duplicate marking. Note this nf-core module requires files to be copied into the working directory and not symlinked.\nTags: align, sort, bqsr, duplicates", "answer": "process PARABRICKS_FQ2BAM {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nvcr.io/nvidia/clara/clara-parabricks:4.3.0-1\"\n\n    input:\n    tuple val(meta), path(reads), path(interval_file)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(index)\n    path known_sites\n\n    output:\n    tuple val(meta), path(\"*.bam\")                , emit: bam\n    tuple val(meta), path(\"*.bai\")                , emit: bai\n    path \"versions.yml\"                           , emit: versions\n    path \"qc_metrics\", optional:true              , emit: qc_metrics\n    path(\"*.table\"), optional:true                , emit: bqsr_table\n    path(\"duplicate-metrics.txt\"), optional:true  , emit: duplicate_metrics\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def in_fq_command = meta.single_end ? \"--in-se-fq $reads\" : \"--in-fq $reads\"\n    def known_sites_command = known_sites ? known_sites.collect{\"--knownSites $it\"}.join(' ') : \"\"\n    def known_sites_output = known_sites ? \"--out-recal-file ${prefix}.table\" : \"\"\n    def interval_file_command = interval_file ? interval_file.collect{\"--interval-file $it\"}.join(' ') : \"\"\n    \"\"\"\n\n    INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n    mv $fasta \\$INDEX\n\n    pbrun \\\\\n        fq2bam \\\\\n        --ref \\$INDEX \\\\\n        $in_fq_command \\\\\n        --read-group-sm $meta.id \\\\\n        --out-bam ${prefix}.bam \\\\\n        $known_sites_command \\\\\n        $known_sites_output \\\\\n        $interval_file_command \\\\\n        --num-gpus $task.accelerator.request \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def in_fq_command = meta.single_end ? \"--in-se-fq $reads\" : \"--in-fq $reads\"\n    def known_sites_command = known_sites ? known_sites.collect{\"--knownSites $it\"}.join(' ') : \"\"\n    def known_sites_output = known_sites ? \"--out-recal-file ${prefix}.table\" : \"\"\n    def interval_file_command = interval_file ? interval_file.collect{\"--interval-file $it\"}.join(' ') : \"\"\n    def metrics_output_command = args = \"--out-duplicate-metrics duplicate-metrics.txt\" ? \"touch duplicate-metrics.txt\" : \"\"\n    def known_sites_output_command = known_sites ? \"touch ${prefix}.table\" : \"\"\n    def qc_metrics_output_command = args = \"--out-qc-metrics-dir qc_metrics \" ? \"mkdir qc_metrics && touch qc_metrics/alignment.txt\" : \"\"\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix}.bam.bai\n    $metrics_output_command\n    $known_sites_output_command\n    $qc_metrics_output_command\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NVIDIA Clara Parabricks GPU-accelerated germline variant calling, replicating GATK haplotypecaller.\nTags: variant, vcf, haplotypecaller, germline", "answer": "process PARABRICKS_HAPLOTYPECALLER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nvcr.io/nvidia/clara/clara-parabricks:4.3.0-1\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(interval_file)\n    tuple val(ref_meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\",            emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_file = args =~ \"gvcf\" ? \"${prefix}.g.vcf\" : \"${prefix}.vcf\"\n    def interval_file_command = interval_file ? interval_file.collect{\"--interval-file $it\"}.join(' ') : \"\"\n    \"\"\"\n\n    pbrun \\\\\n        haplotypecaller \\\\\n        --ref $fasta \\\\\n        --in-bam $input \\\\\n        --out-variants $output_file \\\\\n        $interval_file_command \\\\\n        --num-gpus $task.accelerator.request \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_file = args =~ \"gvcf\" ? \"${prefix}.g.vcf\" : \"${prefix}.vcf\"\n    \"\"\"\n    touch $output_file\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NVIDIA Clara Parabricks GPU-accelerated apply Base Quality Score Recalibration (BQSR).\nTags: bqsr, bam, GPU-accelerated, base quality score recalibration", "answer": "process PARABRICKS_APPLYBQSR {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nvcr.io/nvidia/clara/clara-parabricks:4.3.0-1\"\n\n    input:\n    tuple val(meta), path(bam), path(bam_index), path(bqsr_table), path(intervals)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path(\"*.bai\"), emit: bai\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals ? intervals.collect{\"--interval-file $it\"}.join(' ') : \"\"\n    def copy_index_command = bam_index ? \"cp -L $bam_index `readlink -f $bam`.bai\" : \"\"\n    \"\"\"\n    # parabricks complains when index is not a regular file in the same directory as the bam\n    # copy the index to this path.\n    $copy_index_command\n\n    pbrun \\\\\n        applybqsr \\\\\n        --ref $fasta \\\\\n        --in-bam $bam \\\\\n        --in-recal-file $bqsr_table \\\\\n        $interval_command \\\\\n        --out-bam ${prefix}.bam \\\\\n        --num-threads $task.cpus \\\\\n        --num-gpus $task.accelerator.request \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals ? intervals.collect{\"--interval-file $it\"}.join(' ') : \"\"\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix}.bam.bai\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NVIDIA Clara Parabricks GPU-accelerated joint genotyping, replicating GATK GenotypeGVCFs\nTags: joint-genotyping, gvcf, vcf, genotypegvcf, germline", "answer": "process PARABRICKS_GENOTYPEGVCF {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nvcr.io/nvidia/clara/clara-parabricks:4.3.0-1\"\n\n    input:\n    tuple val(meta), path(input)\n    tuple val(ref_meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\",            emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_file = \"${prefix}.vcf\"\n    \"\"\"\n\n    pbrun \\\\\n        genotypegvcf \\\\\n        --ref $fasta \\\\\n        --in-gvcf $input \\\\\n        --out-vcf $output_file \\\\\n        --num-threads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_file = \"${prefix}.vcf\"\n    \"\"\"\n    touch $output_file\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NVIDIA Clara Parabricks GPU-accelerated somatic variant calling, replicating GATK Mutect2.\nTags: variant, vcf, mutect2, mutect, somatic", "answer": "process PARABRICKS_MUTECTCALLER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nvcr.io/nvidia/clara/clara-parabricks:4.3.0-1\"\n\n    input:\n    tuple val(meta), path(tumor_bam), path(tumor_bam_index),  path(normal_bam), path(normal_bam_index), path(interval_file)\n    tuple val(ref_meta), path(fasta)\n    path panel_of_normals\n    path panel_of_normals_index\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"),       emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.stats\"), emit: stats\n    path \"versions.yml\",                     emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_file_command = interval_file ? interval_file.collect{\"--interval-file $it\"}.join(' ') : \"\"\n    def prepon_command = panel_of_normals ? \"cp -L $panel_of_normals_index `readlink -f $panel_of_normals`.tbi && pbrun prepon --in-pon-file $panel_of_normals\" : \"\"\n    def postpon_command = panel_of_normals ? \"pbrun postpon --in-vcf ${prefix}.vcf.gz --in-pon-file $panel_of_normals --out-vcf ${prefix}_annotated.vcf.gz\" : \"\"\n    \"\"\"\n\n    # if panel of normals specified, run prepon\n    $prepon_command\n\n    pbrun \\\\\n        mutectcaller \\\\\n        --ref $fasta \\\\\n        --in-tumor-bam $tumor_bam \\\\\n        --tumor-name ${meta.tumor_id} \\\\\n        --out-vcf ${prefix}.vcf.gz \\\\\n        $interval_file_command \\\\\n        --num-gpus $task.accelerator.request \\\\\n        $args\n\n    # if panel of normals specified, run postpon\n    $postpon_command\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def postpon_command = panel_of_normals ? \"touch ${prefix}_annotated.vcf.gz\" : \"\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.stats\n    $postpon_command\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NVIDIA Clara Parabricks GPU-accelerated variant calls annotation based on dbSNP database\nTags: annotation, dbsnp, vcf, germline", "answer": "process PARABRICKS_DBSNP {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nvcr.io/nvidia/clara/clara-parabricks:4.3.0-1\"\n\n    input:\n    tuple val(meta), path(vcf_file), path(dbsnp_file), path(tabix_file)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def ann_vcf = \"${prefix}.vcf\"\n    \"\"\"\n\n    pbrun \\\\\n        dbsnp \\\\\n        --in-vcf $vcf_file \\\\\n        --in-dbsnp-file $dbsnp_file \\\\\n        --out-vcf $ann_vcf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def ann_vcf = \"${prefix}.vcf\"\n    \"\"\"\n    touch $ann_vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NVIDIA Clara Parabricks GPU-accelerated germline variant calling, replicating deepvariant.\nTags: variant, deep variant, vcf, haplotypecaller, germline", "answer": "process PARABRICKS_DEEPVARIANT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nvcr.io/nvidia/clara/clara-parabricks:4.3.0-1\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(interval_file)\n    tuple val(ref_meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\",            emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"Parabricks module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_file = args =~ \"gvcf\" ? \"${prefix}.g.vcf\" : \"${prefix}.vcf\"\n    def interval_file_command = interval_file ? interval_file.collect{\"--interval-file $it\"}.join(' ') : \"\"\n    \"\"\"\n\n    pbrun \\\\\n        deepvariant \\\\\n        --ref $fasta \\\\\n        --in-bam $input \\\\\n        --out-variants $output_file \\\\\n        $interval_file_command \\\\\n        --num-gpus $task.accelerator.request \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_file = args =~ \"gvcf\" ? \"${prefix}.g.vcf\" : \"${prefix}.vcf\"\n    \"\"\"\n    touch $output_file\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n            pbrun: \\$(echo \\$(pbrun version 2>&1) | sed 's/^Please.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: DNA contaminant removal using NanoLyse\nTags: contaminant_removal", "answer": "process NANOLYSE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nanolyse:1.2.0--py_0' :\n        'biocontainers/nanolyse:1.2.0--py_0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n    path  fasta\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: fastq\n    path \"*.log\"                       , emit: log\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gunzip -c $fastq | NanoLyse -r $fasta | gzip > ${prefix}.fastq.gz\n    mv NanoLyse.log ${prefix}.nanolyse.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanolyse: \\$(NanoLyse --version 2>&1 | sed -e \"s/NanoLyse //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compare k-mer frequency in reads and assembly to devise the metrics K* and QV*\nTags: assembly, evaluation, quality, completeness", "answer": "process MERFIN_HIST {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/merfin:1.0--h4ac6f70_2':\n        'biocontainers/merfin:1.0--h4ac6f70_2' }\"\n\n    input:\n    tuple val(meta), path(fasta_assembly)   // Required Input -sequence files can be FASTA or FASTQ; uncompressed, gz compressed.\n    tuple val(meta1), path(meryl_db_reads)  // Required readmers (raw reads meryl db). As it comes from another tool, it might be relevant to mantain the meta.\n    path(lookup_table)                      // Optional input vector of probabilities (obtained by genomescope2 with parameter --fitted_hist).\n    path(seqmers)                           // Optional input for pre-built sequence meryl db (-seqmers).\n    val(peak)                               // Required input to hard set copy 1 and infer multiplicity to copy number.\n\n    output:\n    tuple val(meta), path(\"*.hist\")     , emit: hist\n    path(\"*.hist.stderr.log\")           , emit: log_stderr\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args                    = task.ext.args ?: ''\n    def prefix                  = task.ext.prefix ?: \"${meta.id}\"\n    def optional_lookup_table   = lookup_table ? \"-prob ${lookup_table}\" : \"\"\n    def optional_seqmers        = seqmers ? \"-seqmers ${seqmers}\" : \"\"\n    def mem_adjust              = \"${task.memory}\".replaceAll(' ', '')  // Memory parameter - essential to avoid crash\n    \"\"\"\n    merfin -hist \\\\\n        -threads $task.cpus \\\\\n        -memory $mem_adjust \\\\\n        $args \\\\\n        -sequence $fasta_assembly \\\\\n        -readmers $meryl_db_reads \\\\\n        -peak $peak \\\\\n        $optional_lookup_table \\\\\n        $optional_seqmers \\\\\n        -output ${prefix}.hist \\\\\n        2> >( tee ${prefix}.hist.stderr.log )\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        merfin: \\$( merfin --version |& sed 's/merfin //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args                    = task.ext.args ?: ''\n    def prefix                  = task.ext.prefix ?: \"${meta.id}\"\n    def optional_lookup_table   = lookup_table ? \"-prob ${lookup_table}\" : \"\"\n    def optional_seqmers        = seqmers ? \"-seqmers ${seqmers}\" : \"\"\n    \"\"\"\n    touch ${prefix}.hist\n    touch ${prefix}.hist.stderr.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        merfin: \\$( merfin --version |& sed 's/merfin //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Damage parameter estimation for ancient DNA\nTags: ancient DNA, aDNA, de novo assembly, filtering, damage, deamination, miscoding lesions, C to T, palaeogenomics, archaeogenomics, palaeogenetics, archaeogenetics", "answer": "process PYDAMAGE_ANALYZE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pydamage:0.70--pyhdfd78af_0' :\n        'biocontainers/pydamage:0.70--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path(\"pydamage_results/pydamage_results.csv\"), emit: csv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pydamage \\\\\n        analyze \\\\\n        $args \\\\\n        -p $task.cpus \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pydamage: \\$(echo \\$(pydamage --version 2>&1) | sed -e 's/pydamage, version //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Damage parameter estimation for ancient DNA\nTags: ancient DNA, aDNA, de novo assembly, filtering, damage, deamination, miscoding lesions, C to T, palaeogenomics, archaeogenomics, palaeogenetics, archaeogenetics", "answer": "process PYDAMAGE_FILTER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pydamage:0.70--pyhdfd78af_0' :\n        'biocontainers/pydamage:0.70--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(csv)\n\n    output:\n    tuple val(meta), path(\"pydamage_results/pydamage_filtered_results.csv\"), emit: csv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n\n    pydamage \\\\\n        filter \\\\\n        $args \\\\\n        $csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pydamage: \\$(echo \\$(pydamage --version 2>&1) | sed -e 's/pydamage, version //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assembles a de novo transcriptome from RNAseq reads\nTags: assembly, de novo assembler, fasta, fastq", "answer": "process TRINITY {\n    tag \"$meta.id\"\n    label 'process_high'\n    label 'process_high_memory'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/trinity:2.15.1--pl5321h146fbdb_3':\n        'biocontainers/trinity:2.15.1--pl5321h146fbdb_3' }\"\n\n    input:\n    tuple val(meta), path(reads, stageAs: \"input*/*\", arity: '1..*')\n\n    output:\n    tuple val(meta), path(\"*.fa.gz\")    , emit: transcript_fasta\n    tuple val(meta), path(\"*.log\")      , emit: log\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def reads1 = [], reads2 = []\n    meta.single_end ? reads1 = reads : reads.eachWithIndex{ v, ix -> ( ix & 1 ? reads2 : reads1) << v }\n\n    if (meta.single_end) {\n        reads_args = \"--single ${reads1.join(',')}\"\n    } else {\n        reads_args = \"--left ${reads1.join(',')} --right ${reads2.join(',')}\"\n    }\n\n    // --seqType argument, fasta or fastq. Exact pattern match .fasta or .fa suffix with optional .gz (gzip) suffix\n    seqType_args = reads1[0] ==~ /(.*fasta(.gz)?$)|(.*fa(.gz)?$)/ ? \"fa\" : \"fq\"\n\n    // Define the memory requirements. Trinity needs this as an option.\n    def avail_mem = 7\n    if (!task.memory) {\n        log.info '[Trinity] Available memory not known - defaulting to 7GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.giga*0.8).intValue()\n    }\n\n    \"\"\"\n    # Note that Trinity needs the word 'trinity' in the outdir\n\n    Trinity \\\\\n        --seqType ${seqType_args} \\\\\n        --max_memory ${avail_mem}G \\\\\n        ${reads_args} \\\\\n        --output ${prefix}_trinity \\\\\n        --CPU $task.cpus \\\\\n        $args \\\\\n        > >(tee ${prefix}.log)\n\n    gzip \\\\\n        -cf \\\\\n        ${prefix}_trinity.Trinity.fasta \\\\\n        > ${prefix}.fa.gz\n\n    rm ${prefix}_trinity.Trinity.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trinity: \\$(Trinity --version | grep 'Trinity version:' | sed 's/Trinity version: Trinity-//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fa\n    gzip ${prefix}.fa\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trinity: \\$(Trinity --version | grep 'Trinity version:' | sed 's/Trinity version: Trinity-//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: write your description here\nTags: qc, quality control, sequencing, nanopore", "answer": "process PYCOQC {\n    tag \"$summary\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pycoqc:2.5.2--py_0' :\n        'biocontainers/pycoqc:2.5.2--py_0' }\"\n\n    input:\n    tuple val(meta), path(summary)\n\n    output:\n    tuple val(meta), path(\"*.html\"), emit: html\n    tuple val(meta), path(\"*.json\"), emit: json\n    path  \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pycoQC \\\\\n        $args \\\\\n        -f $summary \\\\\n        -o ${prefix}.html \\\\\n        -j ${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pycoqc: \\$(pycoQC --version 2>&1 | sed 's/^.*pycoQC v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GenomeTools gt-gff3validator utility to strictly validate a GFF3 file\nTags: genome, gff3, annotation, validation", "answer": "process GT_GFF3VALIDATOR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genometools-genometools:1.6.5--py310h3db02ab_0':\n        'biocontainers/genometools-genometools:1.6.5--py310h3db02ab_0' }\"\n\n    input:\n    tuple val(meta), path(gff3)\n\n    output:\n    tuple val(meta), path('*.success.log')  , emit: success_log , optional: true\n    tuple val(meta), path('*.error.log')    , emit: error_log   , optional: true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gt \\\\\n        gff3validator \\\\\n        \"$gff3\" \\\\\n        > \"${prefix}.stdout\" \\\\\n        2> >(tee \"${prefix}.stderr\" >&2) \\\\\n        || echo \"Errors from gt-gff3validator printed to ${prefix}.error.log\"\n\n    if grep -q \"input is valid GFF3\" \"${prefix}.stdout\"; then\n        echo \"Validation successful...\"\n        # emit stdout to the success output channel\n        mv \\\\\n            \"${prefix}.stdout\" \\\\\n            \"${prefix}.success.log\"\n    else\n        echo \"Validation failed...\"\n        # emit stderr to the error output channel\n        mv \\\\\n            \"${prefix}.stderr\" \\\\\n            \"${prefix}.error.log\"\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.success.log\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GenomeTools gt-stat utility to show statistics about features contained in GFF3 files\nTags: genome, gff3, annotation, statistics, stats", "answer": "process GT_STAT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genometools-genometools:1.6.5--py310h3db02ab_0':\n        'biocontainers/genometools-genometools:1.6.5--py310h3db02ab_0' }\"\n\n    input:\n    tuple val(meta), path(gff3)\n\n    output:\n    tuple val(meta), path(\"${prefix}.yml\")  , emit: stats\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    prefix      = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gt \\\\\n        stat \\\\\n        $args \\\\\n        $gff3 \\\\\n        > ${prefix}.yml\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix      = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.yml\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes enhanced suffix array using GenomeTools gt-suffixerator utility\nTags: genomics, genome, fasta, index", "answer": "process GT_SUFFIXERATOR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genometools-genometools:1.6.5--py310h3db02ab_0':\n        'biocontainers/genometools-genometools:1.6.5--py310h3db02ab_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val mode\n\n    output:\n    tuple val(meta), path(\"$prefix\"), emit: index\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    if ( mode !in [ 'dna', 'protein' ] ) { error \"Mode must be one of 'dna', or 'protein'\" }\n    def args        = task.ext.args     ?: ''\n    prefix          = task.ext.prefix   ?: \"${meta.id}\"\n    \"\"\"\n    mkdir \\\\\n        \"$prefix\"\n\n    gt \\\\\n        suffixerator \\\\\n        \"-$mode\" \\\\\n        $args \\\\\n        -db $fasta \\\\\n        -indexname \"$prefix/suffixerator\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    if ( mode !in [ 'dna', 'protein' ] ) { error \"Mode must be one of 'dna', or 'protein'\" }\n    def args        = task.ext.args     ?: ''\n    prefix          = task.ext.prefix   ?: \"${meta.id}\"\n    def touch_ssp   = mode == \"protein\" ? \"touch $prefix/suffixerator.ssp\" : ''\n    \"\"\"\n    mkdir \\\\\n        \"$prefix\"\n\n    touch \"$prefix/suffixerator.esq\"\n    touch \"$prefix/suffixerator.prj\"\n    $touch_ssp\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Predicts LTR retrotransposons using GenomeTools gt-ltrharvest utility\nTags: genomics, genome, annotation, repeat, transposons, retrotransposons", "answer": "process GT_LTRHARVEST {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genometools-genometools:1.6.5--py310h3db02ab_0':\n        'biocontainers/genometools-genometools:1.6.5--py310h3db02ab_0' }\"\n\n    input:\n    tuple val(meta), path(index)\n\n    output:\n    tuple val(meta), path(\"*.tabout\")       , emit: tabout      , optional: true\n    tuple val(meta), path(\"*.gff3\")         , emit: gff3        , optional: true\n    tuple val(meta), path(\"$out_name\")      , emit: fasta       , optional: true    // When args has -out\n    tuple val(meta), path(\"$outinner_name\") , emit: inner_fasta , optional: true    // When args has -outinner\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args                 ?: ''\n    def prefix      = task.ext.prefix               ?: \"${meta.id}\"\n    def extension   = args.contains(\"-tabout no\")   ? \"gff3\" : \"tabout\"\n    out_name        = (args.split('-').find { it =~ /out .*\\.(fa|fsa|fasta)/ } ?: 'out.fasta').replace('out ', '').trim()\n    outinner_name   = (args.split('-').find { it =~ /outinner .*\\.(fa|fsa|fasta)/ } ?: 'outinner.fasta').replace('outinner ', '').trim()\n    \"\"\"\n    gt \\\\\n        ltrharvest \\\\\n        -index \"$index/suffixerator\" \\\\\n        $args \\\\\n        > \"${prefix}.${extension}\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args        = task.ext.args                 ?: ''\n    def prefix      = task.ext.prefix               ?: \"${meta.id}\"\n    def extension   = args.contains(\"-tabout no\")   ? \"gff3\"                        : \"tabout\"\n\n    out_name        = (args.split('-').find { it =~ /out .*\\.(fa|fsa|fasta)/ } ?: 'out.fasta').replace('out ', '').trim()\n    outinner_name   = (args.split('-').find { it =~ /outinner .*\\.(fa|fsa|fasta)/ } ?: 'outinner.fasta').replace('outinner ', '').trim()\n\n    def touch_out   = args.contains(\"-out\")         ? \"touch $out_name\"             : ''\n    def touch_inner = args.contains(\"-outinner\")    ? \"touch $outinner_name\"        : ''\n    \"\"\"\n    touch \"${prefix}.${extension}\"\n    $touch_out\n    $touch_inner\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GenomeTools gt-gff3 utility to parse, possibly transform, and output GFF3 files\nTags: genome, gff3, annotation", "answer": "process GT_GFF3 {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genometools-genometools:1.6.5--py310h3db02ab_0':\n        'biocontainers/genometools-genometools:1.6.5--py310h3db02ab_0' }\"\n\n    input:\n    tuple val(meta), path(gff3)\n\n    output:\n    tuple val(meta), path(\"*.gt.gff3\")  , emit: gt_gff3     , optional: true\n    tuple val(meta), path(\"*.error.log\"), emit: error_log   , optional: true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gt \\\\\n        gff3 \\\\\n        $args \\\\\n        \"$gff3\" \\\\\n        > \"${prefix}.gt.gff3\" \\\\\n        2> >(tee \"${prefix}.error.log\" >&2) \\\\\n        || echo \"Errors from gt-gff3 printed to ${prefix}.error.log\"\n\n    if grep -q \"gt gff3: error:\" \"${prefix}.error.log\"; then\n        echo \"gt-gff3 failed to parse $gff3\"\n\n        rm \\\\\n            \"${prefix}.gt.gff3\"\n    else\n        echo \"gt-gff3 successfully parsed $gff3\"\n\n        mv \\\\\n            \"${prefix}.error.log\" \\\\\n            gt_gff3.stderr\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genometools: \\$(gt --version | head -1 | sed 's/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compare, merge, annotate and estimate accuracy of generated gtf files\nTags: transcripts, gtf, merge, compare", "answer": "process GFFCOMPARE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gffcompare:0.12.6--h9f5acd7_0' :\n        'biocontainers/gffcompare:0.12.6--h9f5acd7_0' }\"\n\n    input:\n    tuple val(meta), path(gtfs)\n    tuple val(meta2), path(fasta), path(fai)\n    tuple val(meta3), path(reference_gtf)\n\n    output:\n    tuple val(meta), path(\"*.annotated.gtf\"), optional: true, emit: annotated_gtf\n    tuple val(meta), path(\"*.combined.gtf\") , optional: true, emit: combined_gtf\n    tuple val(meta), path(\"*.tmap\")         , optional: true, emit: tmap\n    tuple val(meta), path(\"*.refmap\")       , optional: true, emit: refmap\n    tuple val(meta), path(\"*.loci\")         , emit: loci\n    tuple val(meta), path(\"*.stats\")        , emit: stats\n    tuple val(meta), path(\"*.tracking\")     , emit: tracking\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def ref_fasta = fasta ? \"-s ${fasta}\" : ''\n    def ref_gtf = reference_gtf ? \"-r ${reference_gtf}\" : ''\n    \"\"\"\n    gffcompare \\\\\n        $args \\\\\n        $ref_fasta \\\\\n        $ref_gtf \\\\\n        -o $prefix \\\\\n        $gtfs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gffcompare: \\$(echo \\$(gffcompare --version 2>&1) | sed 's/^gffcompare v//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.annotated.gtf\n    touch ${prefix}.combined.gtf\n    touch ${prefix}.tmap\n    touch ${prefix}.refmap\n    touch ${prefix}.loci\n    touch ${prefix}.stats\n    touch ${prefix}.tracking\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gffcompare: \\$(echo \\$(gffcompare --version 2>&1) | sed 's/^gffcompare v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Downloads databases needed for running getorganelle\nTags: assembly, organelle, mitochondria, download, database", "answer": "process GETORGANELLE_CONFIG {\n    tag \"${organelle_type}\"\n    label 'process_single'\n\n    conda \"bioconda::getorganelle=1.7.7.0\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/getorganelle:1.7.7.0--pyh7cba7a3_0':\n        'biocontainers/getorganelle:1.7.7.0--pyh7cba7a3_0' }\"\n\n    input:\n    val(organelle_type)\n\n    output:\n    tuple val(organelle_type), path(\"getorganelle\"), emit: db\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    get_organelle_config.py \\\\\n        $args \\\\\n        -a ${organelle_type} \\\\\n        --config-dir getorganelle\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        getorganelle: \\$(get_organelle_config.py --version | sed 's/^GetOrganelle v//g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir -p getorganelle/{LabelDatabase,SeedDatabase}\n    touch getorganelle/{LabelDatabase,SeedDatabase}/${organnel_type}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        getorganelle: \\$(get_organelle_config.py --version | sed 's/^GetOrganelle v//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assembles organelle genomes from genomic data\nTags: assembly, organelle, mitochondria, illumina", "answer": "process GETORGANELLE_FROMREADS {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"bioconda::getorganelle=1.7.7.0\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/getorganelle:1.7.7.0--pyh7cba7a3_0':\n        'biocontainers/getorganelle:1.7.7.0--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n    tuple val(organelle_type), path(db)  // getOrganelle has a database and config file\n\n    output:\n    tuple val(meta), path(\"results/${prefix}.${organelle_type}.fasta.gz\"), emit: fasta, optional: true\n    path \"results/*\"                                                     , emit: etc // the rest of the result files\n    path \"versions.yml\"                                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    get_organelle_from_reads.py \\\\\n        $args \\\\\n        --prefix ${meta.id}. \\\\\n        -F $organelle_type \\\\\n        --config-dir $db \\\\\n        -t $task.cpus \\\\\n        -1 ${fastq[0]} \\\\\n        -2 ${fastq[1]} \\\\\n        -o results\n\n    if [ -f \"\\$(find results -name ${prefix}.${organelle_type}*graph1.1*fasta )\" ]; then\n        cp results/${prefix}.${organelle_type}*graph1.1*fasta results/${prefix}.${organelle_type}.fasta\n        gzip results/${prefix}.${organelle_type}.fasta\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        getorganelle: \\$(get_organelle_from_reads.py --version | sed 's/^GetOrganelle v//g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch results/${prefix}.${organelle_type}.fasta.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        getorganelle: \\$(get_organelle_from_reads.py --version | sed 's/^GetOrganelle v//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Perform adapter/quality trimming on sequencing reads\nTags: trimming, adapter trimming, adapters, quality trimming", "answer": "process CUTADAPT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cutadapt:4.6--py39hf95cd2a_1' :\n        'biocontainers/cutadapt:4.6--py39hf95cd2a_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path('*.trim.fastq.gz'), emit: reads\n    tuple val(meta), path('*.log')          , emit: log\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def trimmed  = meta.single_end ? \"-o ${prefix}.trim.fastq.gz\" : \"-o ${prefix}_1.trim.fastq.gz -p ${prefix}_2.trim.fastq.gz\"\n    \"\"\"\n    cutadapt \\\\\n        -Z \\\\\n        --cores $task.cpus \\\\\n        $args \\\\\n        $trimmed \\\\\n        $reads \\\\\n        > ${prefix}.cutadapt.log\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cutadapt: \\$(cutadapt --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def trimmed = meta.single_end ? \"${prefix}.trim.fastq.gz\" : \"${prefix}_1.trim.fastq.gz ${prefix}_2.trim.fastq.gz\"\n    \"\"\"\n    touch ${prefix}.cutadapt.log\n    touch ${trimmed}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cutadapt: \\$(cutadapt --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Haplocheck detects contamination patterns in mtDNA AND WGS sequencing studies by analyzing\nthe mitochondrial DNA. Haplocheck also works as a proxy tool for nDNA studies and provides\nusers a graphical report to investigate the contamination further. Internally, it uses the\nHaplogrep tool, that supports rCRS and RSRS mitochondrial versions.\n\nTags: mitochondrial, mtDNA, contamination", "answer": "process HAPLOCHECK {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/haplocheck:1.3.3--h4a94de4_0':\n        'biocontainers/haplocheck:1.3.3--h4a94de4_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.txt\") , emit: txt\n    tuple val(meta), path(\"*.html\"), emit: html\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    haplocheck --raw --out $prefix $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        haplocheck: \\$(echo \\$(haplocheck --version 2>&1) | sed 's/.*\\\\([0-9].[0-9].[0-9]\\\\).*/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.raw.txt\n    touch ${prefix}.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        haplocheck: \\$(echo \\$(haplocheck --version 2>&1) | sed 's/.*\\\\([0-9].[0-9].[0-9]\\\\).*/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.\nTags: bamtools, bamtools/split, bam, split, chunk", "answer": "process BAMTOOLS_SPLIT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bamtools:2.5.2--hdcf5f25_2' :\n        'biocontainers/bamtools:2.5.2--hdcf5f25_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = bam.collect{\"-in $it\"}.join(' ')\n    \"\"\"\n    bamtools \\\\\n        merge \\\\\n        $input_list \\\\\n        | bamtools \\\\\n            split \\\\\n            -stub $prefix \\\\\n            $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamtools: \\$( bamtools --version | grep -e 'bamtools' | sed 's/^.*bamtools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.\nTags: bamtools, stats, bam", "answer": "process BAMTOOLS_STATS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bamtools:2.5.2--hdcf5f25_2' :\n        'biocontainers/bamtools:2.5.2--hdcf5f25_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.stats\"), emit: stats\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    bamtools \\\\\n        stats \\\\\n        -in $bam \\\\\n        >${prefix}.bam.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamtools: \\$( bamtools --version | grep -e 'bamtools' | sed 's/^.*bamtools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.\nTags: bamtools, bamtools/convert, bam, convert, bed, fasta, fastq, json, pileup, sam, yaml", "answer": "process BAMTOOLS_CONVERT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bamtools:2.5.2--hdcf5f25_2' :\n        'biocontainers/bamtools:2.5.2--hdcf5f25_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.{bed,fasta,fastq,json,pileup,sam,yaml}\"), emit: data\n    path \"versions.yml\"                                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def test = args ==~ /-format (bed|fasta|fastq|json|pileup|sam|yaml)/\n    if ( test == false ) error \"-format option must be provided in args. Possible values: bed fasta fastq json pileup sam yaml\"\n    m = args =~ /-format ([a-z]+)/\n    ext = m[0][1]\n\n    \"\"\"\n    bamtools \\\\\n        convert \\\\\n        $args \\\\\n        -in $bam \\\\\n        -out ${prefix}.${ext}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamtools: \\$( bamtools --version | grep -e 'bamtools' | sed 's/^.*bamtools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Aggregate results from bioinformatics analyses across many samples into a single report\nTags: QC, bioinformatics tools, Beautiful stand-alone HTML report", "answer": "process MULTIQC {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/multiqc:1.23--pyhdfd78af_0' :\n        'biocontainers/multiqc:1.23--pyhdfd78af_0' }\"\n\n    input:\n    path  multiqc_files, stageAs: \"?/*\"\n    path(multiqc_config)\n    path(extra_multiqc_config)\n    path(multiqc_logo)\n    path(replace_names)\n    path(sample_names)\n\n    output:\n    path \"*multiqc_report.html\", emit: report\n    path \"*_data\"              , emit: data\n    path \"*_plots\"             , optional:true, emit: plots\n    path \"versions.yml\"        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def config = multiqc_config ? \"--config $multiqc_config\" : ''\n    def extra_config = extra_multiqc_config ? \"--config $extra_multiqc_config\" : ''\n    def logo = multiqc_logo ? /--cl-config 'custom_logo: \"${multiqc_logo}\"'/ : ''\n    def replace = replace_names ? \"--replace-names ${replace_names}\" : ''\n    def samples = sample_names ? \"--sample-names ${sample_names}\" : ''\n    \"\"\"\n    multiqc \\\\\n        --force \\\\\n        $args \\\\\n        $config \\\\\n        $extra_config \\\\\n        $logo \\\\\n        $replace \\\\\n        $samples \\\\\n        .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        multiqc: \\$( multiqc --version | sed -e \"s/multiqc, version //g\" )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir multiqc_data\n    touch multiqc_plots\n    touch multiqc_report.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        multiqc: \\$( multiqc --version | sed -e \"s/multiqc, version //g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Aligns sequences using kalign\nTags: alignment, MSA, genomics", "answer": "process KALIGN_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-5cd0277547c6b33133225c8ce14c0cf2a4396ea2:0a70b6d89a3e06fbdc4a735461e8b98ff32ee5de-0':\n        'biocontainers/mulled-v2-5cd0277547c6b33133225c8ce14c0cf2a4396ea2:0a70b6d89a3e06fbdc4a735461e8b98ff32ee5de-0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"*.aln{.gz,}\"), emit: alignment\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def write_output = compress ? \">(pigz -cp ${task.cpus} > ${prefix}.aln.gz)\" : \"${prefix}.aln\"\n    \"\"\"\n    unpigz -cdf $fasta | \\\\\n    kalign \\\\\n        $args \\\\\n        -o ${write_output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kalign: \\$(echo \\$(kalign -v) | sed 's/kalign //g' )\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.aln${compress ? '.gz' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kalign : \\$(echo \\$(kalign -v) | sed 's/kalign //g' )\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SpatialLDA uses an LDA based approach for the identification of cellular neighborhoods, using cell type identities.\nTags: spatial_neighborhoods, scimap, spatial_omics", "answer": "process SCIMAP_SPATIALLDA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"docker.io/miguelib/scimap:0.0.3\"\n\n    input:\n    tuple val(meta), path(phenotyped)\n\n    output:\n    tuple val(meta), path(\"*.csv\") , emit: spatial_lda_output\n    tuple val(meta), path(\"*.png\") , emit: composition_plot\n    tuple val(meta), path(\"*.html\"), emit: motif_location_plot\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    python /scimap/scripts/spatialLDA.py \\\n        --input $phenotyped \\\n        --output \"${prefix}.csv\" \\\n        --neighborhood-composition-plot \"${prefix}.png\" \\\n        --motif-locations-plot \"${prefix}.html\" \\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        scimap/spatialLDA: \\$(python /scimap/scripts/spatialLDA.py --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch \"${prefix}.csv\"\n    touch \"${prefix}.png\"\n    touch \"${prefix}.html\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        scimap/spatialLDA: \\$(python /scimap/scripts/spatialLDA.py --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SCIMAP is a suite of tools that enables spatial single-cell analyses\nTags: sort, spatial, single cell", "answer": "process SCIMAP_MCMICRO {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"docker.io/labsyspharm/scimap:0.22.0\"\n\n    input:\n    tuple val(meta), path(cellbyfeature)\n\n    output:\n    tuple val(meta), path(\"*.csv\")      , emit: annotedDataCsv, optional:true\n    tuple val(meta), path(\"*.h5ad\")     , emit: annotedDataH5ad, optional:true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Scimap module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION='0.22.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping\n    \"\"\"\n    scimap-mcmicro $cellbyfeature -o .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        scimap: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: pmdtools command to filter ancient DNA molecules from others\nTags: pmdtools, aDNA, filter, damage", "answer": "process PMDTOOLS_FILTER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pmdtools:0.60--hdfd78af_5' :\n        'biocontainers/pmdtools:0.60--hdfd78af_5' }\"\n\n    input:\n    tuple val(meta), path(bam), path (bai)\n    val(threshold)\n    path(reference)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def split_cpus = Math.floor(task.cpus/2)\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"[pmdtools/filter] Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    //threshold and header flags activate filtering function of pmdtools\n    \"\"\"\n    samtools \\\\\n        calmd \\\\\n        $bam \\\\\n        $reference \\\\\n        $args \\\\\n        -@ ${split_cpus} \\\\\n    | pmdtools \\\\\n        --threshold $threshold \\\\\n        --header \\\\\n        $args2 \\\\\n    | samtools \\\\\n        view \\\\\n        $args3 \\\\\n        -Sb \\\\\n        - \\\\\n        -@ ${split_cpus} \\\\\n        -o ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pmdtools: \\$( pmdtools --version | cut -f2 -d ' ' | sed 's/v//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The Java port of the VarDict variant caller\nTags: variant calling, vcf, bam, snv, sv", "answer": "process VARDICTJAVA {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-731b8c4cf44d76e9aa181af565b9eee448d82a8c:edd70e76f3529411a748168f6eb1a61f29702123-0' :\n        'biocontainers/mulled-v2-731b8c4cf44d76e9aa181af565b9eee448d82a8c:edd70e76f3529411a748168f6eb1a61f29702123-0' }\"\n\n    input:\n    tuple val(meta), path(bams), path(bais), path(bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: '-c 1 -S 2 -E 3'\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def somatic = bams instanceof List && bams.size() == 2 ? true : false\n    def input = somatic ? \"-b \\\"${bams[0]}|${bams[1]}\\\"\" : \"-b ${bams}\"\n    def filter = somatic ? \"testsomatic.R\" : \"teststrandbias.R\"\n    def convert_to_vcf = somatic ? \"var2vcf_paired.pl\" : \"var2vcf_valid.pl\"\n    \"\"\"\n    export JAVA_OPTS='\"-Xms${task.memory.toMega()/4}m\" \"-Xmx${task.memory.toGiga()}g\" \"-Dsamjdk.reference_fasta=${fasta}\"'\n    vardict-java \\\\\n        ${args} \\\\\n        ${input} \\\\\n        -th ${task.cpus} \\\\\n        -G ${fasta} \\\\\n        ${bed} \\\\\n    | ${filter} \\\\\n    | ${convert_to_vcf} \\\\\n        ${args2} \\\\\n    | bgzip ${args3} --threads ${task.cpus} > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vardict-java: \\$( realpath \\$( command -v vardict-java ) | sed 's/.*java-//;s/-.*//' )\n        var2vcf_valid.pl: \\$( var2vcf_valid.pl -h | sed '2!d;s/.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: '-c 1 -S 2 -E 3'\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    echo '' | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vardict-java: \\$( realpath \\$( command -v vardict-java ) | sed 's/.*java-//;s/-.*//' )\n        var2vcf_valid.pl: \\$( var2vcf_valid.pl -h | sed '2!d;s/.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computational method for finding spa types.\nTags: fasta, spatype", "answer": "process SPATYPER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/spatyper:0.3.3--pyhdfd78af_3' :\n        'biocontainers/spatyper:0.3.3--pyhdfd78af_3' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path repeats\n    path repeat_order\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_args = repeats && repeat_order ? \"-r ${repeats} -o ${repeat_order}\" : \"\"\n    \"\"\"\n    spaTyper \\\\\n        $args \\\\\n        $input_args \\\\\n        --fasta $fasta \\\\\n        --output ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spatyper: \\$( echo \\$(spaTyper --version 2>&1) | sed 's/^.*spaTyper //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool for converting 10x BAMs produced by Cell Ranger, Space Ranger, Cell Ranger ATAC, Cell Ranger DNA, and Long Ranger back to FASTQ files that can be used as inputs to re-run analysis\nTags: bam, convert, fastq, 10x", "answer": "process BAMTOFASTQ10X {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/10x_bamtofastq:1.4.1--hdbdd923_2':\n        'biocontainers/10x_bamtofastq:1.4.1--hdbdd923_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: fastq\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bamtofastq \\\\\n        $args \\\\\n        $bam \\\\\n        ${prefix}.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamtofastq10x: \\$(bamtofastq --version |& sed '1!d ; s/bamtofastq //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamtofastq10x: \\$(bamtofastq --version |& sed '1!d ; s/bamtofastq //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Epistasis in PLINK, analyzing how the effects of one gene depend on the presence of others.\nTags: interactions, variants, regression", "answer": "process PLINK_EPISTASIS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h031d066_5':\n        'biocontainers/plink:1.90b6.21--h031d066_5' }\"\n\n    input:\n    tuple val(meta), path(bed), path(bim), path(fam)\n    tuple val(meta2), path(vcf)\n    tuple val(meta3), path(bcf)\n    tuple val(meta4), path(phe)\n\n    output:\n    tuple val(meta), path(\"*.epi.cc\")        ,  emit: epi\n    tuple val(meta), path(\"*.epi.cc.summary\"),  emit: episummary, optional:true\n    tuple val(meta), path(\"*.log\")           ,  emit: log\n    tuple val(meta), path(\"*.nosex\")         ,  emit: nosex, optional:true\n    path \"versions.yml\"                      ,  emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf} --pheno ${phe}\"\n        prefix = task.ext.prefix ?: \"${meta2.id}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf} --pheno ${phe}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n    \"\"\"\n    plink \\\\\n        $input_command \\\\\n        --threads $task.cpus \\\\\n        --epistasis \\\\\n        $args \\\\\n        --out $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf}\"\n        prefix = task.ext.prefix ?: \"${meta2.id} --pheno ${pheno}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf} --pheno ${pheno}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n    \"\"\"\n    touch ${prefix}.epi\n    touch ${prefix}.episummary\n    touch ${prefix}.log\n    touch ${prefix}.nosex\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate Hardy-Weinberg statistics for provided input\nTags: hardy-weinberg, hwe statistics, hwe equilibrium", "answer": "process PLINK_HWE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h779adbc_1' :\n        'biocontainers/plink:1.90b6.21--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(bed),  path(bim), path(fam)\n    tuple val(meta2), path(vcf)\n    tuple val(meta3), path(bcf)\n\n\n    output:\n    tuple val(meta), path(\"*.hwe\")      , emit: hwe\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf}\"\n        prefix = task.ext.prefix ?: \"${meta2.id}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n\n    \"\"\"\n    plink \\\\\n        $input_command \\\\\n        --threads $task.cpus \\\\\n        --hardy \\\\\n        $args \\\\\n        --out $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf}\"\n        prefix = task.ext.prefix ?: \"${meta2.id}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n    \"\"\"\n    touch ${prefix}.hwe\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Analyses binary variant call format (BCF) files using plink\nTags: plink, bcf, bed, bim, fam", "answer": "process PLINK_BCF {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h779adbc_1' :\n        'biocontainers/plink:1.90b6.21--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(bcf)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed, optional: true\n    tuple val(meta), path(\"*.bim\"), emit: bim, optional: true\n    tuple val(meta), path(\"*.fam\"), emit: fam, optional: true\n\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    plink \\\\\n        --bcf ${bcf} \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --out ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version 2>&1) | sed 's/^PLINK v//' | sed 's/..-bit.*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produce a pruned subset of markers that are in approximate linkage equilibrium with each other. Pairs of variants in the current window with squared correlation greater than the threshold are noted and variants are greedily pruned from the window until no such pairs remain.\nTags: plink, indep pairwise, variant pruning, bim, fam", "answer": "\nprocess PLINK_INDEPPAIRWISE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h779adbc_1':\n        'biocontainers/plink:1.90b6.21--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(bed),  path(bim), path(fam)\n    val(window_size)\n    val(variant_count)\n    val(r2_threshold)\n\n    output:\n    tuple val(meta), path(\"*.prune.in\")                    , emit: prunein\n    tuple val(meta), path(\"*.prune.out\")    , optional:true, emit: pruneout\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    plink \\\\\n        --bed ${bed}  \\\\\n        --bim ${bim}  \\\\\n        --fam ${fam}  \\\\\n        --threads $task.cpus \\\\\n        --indep-pairwise ${window_size} ${variant_count} ${r2_threshold} \\\\\n        $args \\\\\n        --out $prefix\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: LD analysis in PLINK examines genetic variant associations within populations\nTags: genetics, associations, variants", "answer": "process PLINK_LD {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h031d066_5':\n        'biocontainers/plink:1.90b6.21--h031d066_5' }\"\n\n    input:\n    tuple val(meta), path(bed),  path(bim), path(fam)\n    tuple val(meta2), path(vcf)\n    tuple val(meta3), path(bcf)\n    tuple val(meta4), path(snpfile)\n\n    output:\n    tuple val(meta), path(\"*.ld\")   , emit: ld\n    tuple val(meta), path(\"*.log\")  , emit: log\n    tuple val(meta), path(\"*.nosex\"), emit: nosex, optional:true\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf}\"\n        prefix = task.ext.prefix ?: \"${meta2.id}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n\n    \"\"\"\n    plink \\\\\n        $input_command \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $snpfile \\\\\n        --r2 $args2 \\\\\n        --out $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n\n\n    stub:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf}\"\n        prefix = task.ext.prefix ?: \"${meta2.id}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n    \"\"\"\n    touch ${prefix}.ld\n    touch ${prefix}.log\n    touch ${prefix}.nosex\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Exclude variant identifiers from plink bfiles\nTags: exclude, plink", "answer": "process PLINK_EXCLUDE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h779adbc_1' :\n        'biocontainers/plink:1.90b6.21--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(bed), path(bim), path(fam), path(variants)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    tuple val(meta), path(\"*.bim\"), emit: bim\n    tuple val(meta), path(\"*.fam\"), emit: fam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$bed\" == \"${prefix}.bed\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    plink \\\\\n        --bfile ${meta.id} \\\\\n        $args \\\\\n        --exclude $variants \\\\\n        --threads $task.cpus \\\\\n        --make-bed \\\\\n        --out $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate GWAS association studies\nTags: association, GWAS, case/control", "answer": "process PLINK_GWAS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h031d066_5':\n        'biocontainers/plink:1.90b6.21--h031d066_5' }\"\n\n    input:\n    tuple val(meta),  path(bed), path(bim), path(fam)\n    tuple val(meta2), path(vcf)\n    tuple val(meta3), path(bcf)\n    tuple val(meta4), path(phe)\n\n    output:\n    tuple val(meta), path(\"*.assoc\"),  emit: assoc\n    tuple val(meta), path(\"*.log\")  ,  emit: log\n    tuple val(meta), path(\"*.nosex\"),  emit: nosex   , optional:true\n    path \"versions.yml\"             ,  emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf} --pheno ${phe}\"\n        prefix = task.ext.prefix ?: \"${meta2.id}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf} --pheno ${phe}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n\n    \"\"\"\n    plink \\\\\n        $input_command \\\\\n        --threads $task.cpus \\\\\n        --assoc \\\\\n        $args \\\\\n        --out $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf}\"\n        prefix = task.ext.prefix ?: \"${meta2.id} --pheno ${phe}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf} --pheno ${phe}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n    \"\"\"\n    touch ${prefix}.assoc\n    touch ${prefix}.nosex\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Recodes plink bfiles into a new text fileset applying different modifiers\nTags: recode", "answer": "process PLINK_RECODE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h779adbc_1':\n        'biocontainers/plink:1.90b6.21--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(bed),  path(bim), path(fam)\n\n    output:\n    tuple val(meta), path(\"*.ped\")                    , optional:true, emit: ped\n    tuple val(meta), path(\"*.map\")                    , optional:true, emit: map\n    tuple val(meta), path(\"*.txt\")                    , optional:true, emit: txt\n    tuple val(meta), path(\"*.raw\")                    , optional:true, emit: raw\n    tuple val(meta), path(\"*.traw\")                   , optional:true, emit: traw\n    tuple val(meta), path(\"*.beagle.dat\")             , optional:true, emit: beagledat\n    tuple val(meta), path(\"*.chr-*.dat\")              , optional:true, emit: chrdat\n    tuple val(meta), path(\".*chr-*.map\")              , optional:true, emit: chrmap\n    tuple val(meta), path(\"*.recode.geno.txt\")        , optional:true, emit: geno\n    tuple val(meta), path(\"*.recode.pheno.txt\")       , optional:true, emit: pheno\n    tuple val(meta), path(\"*.recode.pos.txt\")         , optional:true, emit: pos\n    tuple val(meta), path(\"*.recode.phase.inp\")       , optional:true, emit: phase\n    tuple val(meta), path(\"*.info\")                   , optional:true, emit: info\n    tuple val(meta), path(\"*.lgen\")                   , optional:true, emit: lgen\n    tuple val(meta), path(\"*.list\")                   , optional:true, emit: list\n    tuple val(meta), path(\"*.gen\")                    , optional:true, emit: gen\n    tuple val(meta), path(\"*.gen.gz\")                 , optional:true, emit: gengz\n    tuple val(meta), path(\"*.sample\")                 , optional:true, emit: sample\n    tuple val(meta), path(\"*.rlist\")                  , optional:true, emit: rlist\n    tuple val(meta), path(\"*.strct_in\")               , optional:true, emit: strctin\n    tuple val(meta), path(\"*.tped\")                   , optional:true, emit: tped\n    tuple val(meta), path(\"*.tfam\")                   , optional:true, emit: tfam\n    tuple val(meta), path(\"*.vcf\")                    , optional:true, emit: vcf\n    tuple val(meta), path(\"*.vcf.gz\")                 , optional:true, emit: vcfgz\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    plink \\\\\n        --bed ${bed}  \\\\\n        --bim ${bim}  \\\\\n        --fam ${fam}  \\\\\n        --threads $task.cpus \\\\\n        --recode \\\\\n        $args \\\\\n        --out $prefix\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Analyses variant calling files using plink\nTags: plink, vcf", "answer": "process PLINK_VCF {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h779adbc_1' :\n        'biocontainers/plink:1.90b6.21--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed, optional: true\n    tuple val(meta), path(\"*.bim\"), emit: bim, optional: true\n    tuple val(meta), path(\"*.fam\"), emit: fam, optional: true\n\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    plink \\\\\n        --vcf ${vcf} \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --out ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version 2>&1) | sed 's/^PLINK v//' | sed 's/..-bit.*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produce a pruned subset of markers that are in approximate linkage equilibrium with each other.\nTags: plink, indep, variant pruning, bim, fam", "answer": "\nprocess PLINK_INDEP {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h779adbc_1':\n        'biocontainers/plink:1.90b6.21--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(bed),  path(bim), path(fam)\n    val(window_size)\n    val(variant_count)\n    val(variance_inflation_factor)\n\n    output:\n    tuple val(meta), path(\"*.prune.in\")                    , emit: prunein\n    tuple val(meta), path(\"*.prune.out\")    , optional:true, emit: pruneout\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    plink \\\\\n        --bed ${bed}  \\\\\n        --bim ${bim}  \\\\\n        --fam ${fam}  \\\\\n        --threads $task.cpus \\\\\n        --indep ${window_size} ${variant_count} ${variance_inflation_factor} \\\\\n        $args \\\\\n        --out $prefix\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Subset plink bfiles with a text file of variant identifiers\nTags: extract, plink", "answer": "process PLINK_EXTRACT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h779adbc_1' :\n        'biocontainers/plink:1.90b6.21--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(bed), path(bim), path(fam), path(variants)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    tuple val(meta), path(\"*.bim\"), emit: bim\n    tuple val(meta), path(\"*.fam\"), emit: fam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$bed\" == \"${prefix}.bed\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    plink \\\\\n        --bfile ${meta.id} \\\\\n        $args \\\\\n        --extract $variants \\\\\n        --threads $task.cpus \\\\\n        --make-bed \\\\\n        --out $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Fast Epistasis in PLINK, analyzing how the effects of one gene depend on the presence of others.\nTags: interactions, variants, regression", "answer": "process PLINK_FASTEPISTASIS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink:1.90b6.21--h031d066_5':\n        'biocontainers/plink:1.90b6.21--h031d066_5' }\"\n\n    input:\n    tuple val(meta), path(bed), path(bim), path(fam)\n    tuple val(meta2), path(vcf)\n    tuple val(meta3), path(bcf)\n    tuple val(meta4), path(phe)\n\n    output:\n    tuple val(meta), path(\"*.epi.cc\")        ,  emit: fepi\n    tuple val(meta), path(\"*.epi.cc.summary\"),  emit: fepisummary, optional:true\n    tuple val(meta), path(\"*.log\")           ,  emit: flog\n    tuple val(meta), path(\"*.nosex\")         ,  emit: fnosex,      optional:true\n    path \"versions.yml\"                      ,  emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf} --pheno ${phe}\"\n        prefix = task.ext.prefix ?: \"${meta2.id}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf} --pheno ${phe}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n    \"\"\"\n    plink \\\\\n        $input_command \\\\\n        --threads $task.cpus \\\\\n        --fast-epistasis \\\\\n        $args \\\\\n        --out $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = \"\"\n    // define input string based on provided input files\n    // in hierarchical order\n    def input_command = \"\"\n    def outmeta = \"\"\n    if (bed){\n        input_command = \"--bed ${bed} --bim ${bim} --fam ${fam}\"\n        prefix = task.ext.prefix ?: \"${meta.id}\"\n    } else if (vcf) {\n        input_command = \"--vcf ${vcf}\"\n        prefix = task.ext.prefix ?: \"${meta2.id} --pheno ${pheno}\"\n        meta = meta2\n    } else if (bcf) {\n        input_command = \"--bcf ${bcf} --pheno ${pheno}\"\n        prefix = task.ext.prefix ?: \"${meta3.id}\"\n        meta = meta3\n    } else {\n        log.error 'ERROR: the input should be either plink native binary format, VCF or BCF'\n    }\n    \"\"\"\n    touch ${prefix}.fepi\n    touch ${prefix}.fepisummary\n    touch ${prefix}.flog\n    touch ${prefix}.fnosex\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink: \\$(echo \\$(plink --version) | sed 's/^PLINK v//;s/64.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: \"This package computes informative enrichment and quality measures\nfor ChIP-seq/DNase-seq/FAIRE-seq/MNase-seq data. It can also be used\nto obtain robust estimates of the predominant fragment length or\ncharacteristic tag shift values in these assays.\"\n\nTags: ChIP-Seq, QC, phantom peaks", "answer": "process PHANTOMPEAKQUALTOOLS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/phantompeakqualtools:1.2.2--50be7727b2a72700' :\n        'community.wave.seqera.io/library/phantompeakqualtools:1.2.2--f8026fe2526a5e18' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.out\")  , emit: spp\n    tuple val(meta), path(\"*.pdf\")  , emit: pdf\n    tuple val(meta), path(\"*.Rdata\"), emit: rdata\n    path  \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def args2  = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    RUN_SPP=`which run_spp.R`\n    Rscript $args -e \"library(caTools); source(\\\\\"\\$RUN_SPP\\\\\")\" -c=\"$bam\" -savp=\"${prefix}.spp.pdf\" -savd=\"${prefix}.spp.Rdata\" -out=\"${prefix}.spp.out\" $args2\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        phantompeakqualtools: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.spp.pdf\n    touch ${prefix}.spp.Rdata\n    touch ${prefix}.spp.out\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        phantompeakqualtools: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Bamcmp (Bam Compare) is a tool for assigning reads between a primary genome and a contamination genome. For instance, filtering out mouse reads from patient derived xenograft mouse models (PDX).\nTags: filter, xenograft, host, graft, contamination, mouse", "answer": "process BAMCMP {\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bamcmp:2.2--h05f6578_0' :\n        'biocontainers/bamcmp:2.2--h05f6578_0' }\"\n\n    input:\n    tuple val(meta), path(primary_aligned_bam), path(contaminant_aligned_bam)\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\") , emit: primary_filtered_bam\n    tuple val(meta), path(\"${prefix2}.bam\"), emit: contamination_bam\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}_primary\"\n    prefix2 = task.ext.prefix2 ?: \"${meta.id}_contaminant\"\n\n    if (\"$primary_aligned_bam\" == \"${prefix}.bam\"  | \"$contaminant_aligned_bam\" == \"${prefix}.bam\"  ) {\n        error \"Input and output names for the primary-genome bam file are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    }\n    if (\"$primary_aligned_bam\" == \"${prefix2}.bam\" | \"$contaminant_aligned_bam\" == \"${prefix2}.bam\" ) {\n        error \"Input and output names for the contaminant-genome bam file are the same, use \\\"task.ext.prefix2\\\" to disambiguate!\"\n    }\n    if (\"primary_aligned_bam\"    == \"contaminant_aligned_bam\" ) {\n        error \"Input file names for the two bam files are the same, ensure they are renamed upstream.\"\n    }\n    if (\"${prefix}.bam\"    == \"${prefix2}.bam\" ) {\n        error \"Output names for the two bam files are identical, use \\\"task.ext.prefix\\\" and \\\"task.ext.prefix2\\\" to disambiguate!\"\n    }\n\n    def VERSION = '2.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    bamcmp \\\\\n        -1 $primary_aligned_bam \\\\\n        -2 $contaminant_aligned_bam \\\\\n        -A ${prefix}.bam \\\\\n        -B ${prefix2}.bam \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamcmp: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}_primary\"\n    prefix2 = task.ext.prefix2 ?: \"${meta.id}_contaminant\"\n\n    if (\"$primary_aligned_bam\" == \"${prefix}.bam\"  | \"$contaminant_aligned_bam\" == \"${prefix}.bam\"  )\n        error \"Input and output names for the primary-genome bam file are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    if (\"$primary_aligned_bam\" == \"${prefix2}.bam\" | \"$contaminant_aligned_bam\" == \"${prefix2}.bam\" )\n        error \"Input and output names for the contaminant-genome bam file are the same, use \\\"task.ext.prefix2\\\" to disambiguate!\"\n    if (\"primary_aligned_bam\"    == \"contaminant_aligned_bam\" )\n        error \"Input file names for the two bam files are the same, ensure they are renamed upstream.\"\n    if (\"${prefix}.bam\"    == \"${prefix2}.bam\" )\n        error \"Output names for the two bam files are identical, use \\\"task.ext.prefix\\\" and \\\"task.ext.prefix2\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix2}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Strain-level metagenomic assignment\nTags: metamaps, long reads, metagenomics, taxonomy", "answer": "process METAMAPS_CLASSIFY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metamaps:0.1.633d2e0--h21ec9f0_0':\n        'biocontainers/metamaps:0.1.633d2e0--h21ec9f0_0' }\"\n\n    input:\n    tuple val(meta), path(classification_res), path(meta_file), path(meta_unmappedreadsLengths), path(para_file)\n    path database_folder\n\n\n    output:\n    tuple val(meta), path(\"*classification_res.EM.WIMP\")                              , emit: wimp\n    tuple val(meta), path(\"*classification_res.EM.evidenceUnknownSpecies\")            , emit: evidence_unknown_species\n    tuple val(meta), path(\"*classification_res.EM.reads2Taxon\")                       , emit: reads2taxon\n    tuple val(meta), path(\"*classification_res.EM\")                                   , emit: em\n    tuple val(meta), path(\"*classification_res.EM.contigCoverage\")                    , emit: contig_coverage\n    tuple val(meta), path(\"*classification_res.EM.lengthAndIdentitiesPerMappingUnit\") , emit: length_and_id\n    tuple val(meta), path(\"*classification_res.EM.reads2Taxon.krona\")                 , emit: krona\n    path \"versions.yml\"                                                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    metamaps \\\\\n        classify \\\\\n        $args \\\\\n        --mappings $classification_res \\\\\n        --threads $task.cpus \\\\\n        --DB $database_folder\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metamaps: \\$(metamaps | sed -n 2p | sed 's/^.*MetaMaps v //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_classification_res.EM.WIMP\n    touch ${prefix}_classification_res.EM.evidenceUnknownSpecies\n    touch ${prefix}_classification_res.EM.reads2Taxon\n    touch ${prefix}_classification_res.EM\n    touch ${prefix}_classification_res.EM.contigCoverage\n    touch ${prefix}_classification_res.EM.lengthAndIdentitiesPerMappingUnit\n    touch ${prefix}_classification_res.EM.reads2Taxon.krona\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metamaps: \\$(metamaps | sed -n 2p | sed 's/^.*MetaMaps v //')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Maps long reads to a metamaps database\nTags: metamaps, long reads, metagenomics, taxonomy", "answer": "process METAMAPS_MAPDIRECTLY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metamaps:0.1.633d2e0--h21ec9f0_0':\n        'biocontainers/metamaps:0.1.633d2e0--h21ec9f0_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path database\n\n    output:\n    tuple val(meta), path(\"*classification_res\")                          , emit: classification_res\n    tuple val(meta), path(\"*classification_res.meta\")                     , emit: meta_file\n    tuple val(meta), path(\"*classification_res.meta.unmappedReadsLengths\"), emit: meta_unmappedreadsLengths\n    tuple val(meta), path(\"*classification_res.parameters\")               , emit: para_file\n    path \"versions.yml\"                                                                                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    db=`find -L ${database} -name \"DB.fa\"`\n    metamaps \\\\\n        mapDirectly \\\\\n        $args \\\\\n        --all \\\\\n        --reference \\$db \\\\\n        --threads $task.cpus \\\\\n        --query $reads \\\\\n        --output ${prefix}.classification_res\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metamaps: \\$(metamaps | sed -n 2p | sed 's/^.*MetaMaps v //')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_classification_res\n    touch ${prefix}_classification_res.meta\n    touch ${prefix}_classification_res.meta.unmappedReadsLengths\n    touch ${prefix}_classification_res.parameters\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metamaps: \\$(metamaps | sed -n 2p | sed 's/^.*MetaMaps v //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Identifies LTR retrotransposons using LTR_retriever\nTags: genomics, annotation, repeat, long terminal repeat, retrotransposon", "answer": "process LTRRETRIEVER_LTRRETRIEVER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ltr_retriever:2.9.9--hdfd78af_0':\n        'biocontainers/ltr_retriever:2.9.9--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(genome)\n    path(harvest)\n    path(finder)\n    path(mgescan)\n    path(non_tgca)\n\n    output:\n    tuple val(meta), path(\"*.log\")              , emit: log\n    tuple val(meta), path(\"${prefix}.pass.list\"), emit: pass_list       , optional: true\n    tuple val(meta), path(\"*.pass.list.gff3\")   , emit: pass_list_gff   , optional: true\n    tuple val(meta), path(\"*.LTRlib.fa\")        , emit: ltrlib          , optional: true\n    tuple val(meta), path(\"${prefix}.out\")      , emit: annotation_out  , optional: true\n    tuple val(meta), path(\"*.out.gff3\")         , emit: annotation_gff  , optional: true\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args            = task.ext.args     ?: ''\n    prefix              = task.ext.prefix   ?: \"${meta.id}\"\n    def inharvest       = harvest           ? \"-inharvest $harvest\" : ''\n    def infinder        = finder            ? \"-infinder $finder\"   : ''\n    def inmgescan       = mgescan           ? \"-inmgescan $mgescan\" : ''\n    def non_tgca_file   = non_tgca          ? \"-nonTGCA $non_tgca\"  : ''\n    def writable_genome = \"${genome.baseName}.writable.${genome.extension}\"\n    // writable_genome:\n    // This is needed to avoid LTR_retriever:2.9.9 failure when the input `genome` is\n    // readonly. LTR_retriever triggers a 'die' if the genome is readonly.\n    // See: https://github.com/oushujun/LTR_retriever/blob/4039eb7778fd9cbc60021e99a8693285e0fa2daf/LTR_retriever#L312\n    //\n    // This copy with permissions logic can be removed once https://github.com/oushujun/LTR_retriever/issues/176\n    // has been resolved.\n    \"\"\"\n    cp \\\\\n        $genome \\\\\n        $writable_genome\n\n    chmod \\\\\n        a+w \\\\\n        $writable_genome\n\n    LTR_retriever \\\\\n        -genome $writable_genome \\\\\n        $inharvest \\\\\n        $infinder \\\\\n        $inmgescan \\\\\n        $non_tgca_file \\\\\n        -threads $task.cpus \\\\\n        $args \\\\\n        &> >(tee \"${prefix}.log\" 2>&1) \\\\\n        || echo \"Errors from LTR_retriever printed to ${prefix}.log\"\n\n    mv \"${writable_genome}.pass.list\"       \"${prefix}.pass.list\"       || echo \".pass.list was not produced\"\n    mv \"${writable_genome}.pass.list.gff3\"  \"${prefix}.pass.list.gff3\"  || echo \".pass.list.gff3 was not produced\"\n    mv \"${writable_genome}.LTRlib.fa\"       \"${prefix}.LTRlib.fa\"       || echo \".LTRlib.fa was not produced\"\n    mv \"${writable_genome}.out\"             \"${prefix}.out\"             || echo \".out was not produced\"\n    mv \"${writable_genome}.out.gff3\"        \"${prefix}.out.gff3\"        || echo \".out.gff3 was not produced\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        LTR_retriever: \\$(LTR_retriever -h 2>&1 | grep '### LTR_retriever' | sed 's/### LTR_retriever //; s/ ###//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args            = task.ext.args             ?: ''\n    prefix              = task.ext.prefix           ?: \"${meta.id}\"\n    def touch_out       = args.contains('-noanno')  ? ''            : \"touch ${prefix}.out\"\n    def touch_out_gff   = args.contains('-noanno')  ? ''            : \"touch ${prefix}.out.gff3\"\n    \"\"\"\n    touch \"${prefix}.log\"\n    touch \"${prefix}.pass.list\"\n    touch \"${prefix}.pass.list.gff3\"\n    touch \"${prefix}.LTRlib.fa\"\n    $touch_out\n    $touch_out_gff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        LTR_retriever: \\$(LTR_retriever -h 2>&1 | grep '### LTR_retriever' | sed 's/### LTR_retriever //; s/ ###//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Estimates the mean LTR sequence identity in the genome. The input genome fasta should\nhave short alphanumeric IDs without comments\n\nTags: genomics, annotation, repeat, long terminal retrotransposon, retrotransposon, stats, qc", "answer": "process LTRRETRIEVER_LAI {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ltr_retriever:2.9.9--hdfd78af_0':\n        'biocontainers/ltr_retriever:2.9.9--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path pass_list\n    path annotation_out\n    path monoploid_seqs\n\n    output:\n    tuple val(meta), path(\"*.LAI.log\")  , emit: log\n    tuple val(meta), path(\"*.LAI.out\")  , emit: lai_out     , optional: true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args            = task.ext.args     ?: ''\n    def prefix          = task.ext.prefix   ?: \"${meta.id}\"\n    def monoploid_param = monoploid_seqs    ? \"-mono $monoploid_seqs\"                       : ''\n    def lai_output_name = monoploid_seqs    ? \"${annotation_out}.${monoploid_seqs}.out.LAI\" : \"${annotation_out}.LAI\"\n    def VERSION         = 'beta3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    LAI \\\\\n        -genome $fasta \\\\\n        -intact $pass_list \\\\\n        -all $annotation_out \\\\\n        -t $task.cpus \\\\\n        $monoploid_param \\\\\n        $args \\\\\n        > >(tee \"${prefix}.LAI.log\") \\\\\n        || echo \"LAI failed! See ${prefix}.LAI.log\"\n\n    mv \\\\\n        $lai_output_name \\\\\n        \"${prefix}.LAI.out\" \\\\\n        || echo \"LAI failed to estimate assembly index. See ${prefix}.LAI.log\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lai: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args            = task.ext.args     ?: ''\n    def prefix          = task.ext.prefix   ?: \"${meta.id}\"\n    def monoploid_param = monoploid_seqs    ? \"-mono $monoploid_seqs\"                       : ''\n    def lai_output_name = monoploid_seqs    ? \"${annotation_out}.${monoploid_seqs}.out.LAI\" : \"${annotation_out}.LAI\"\n    def VERSION         = 'beta3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch \"${prefix}.LAI.log\"\n    touch \"$lai_output_name\"\n\n    mv \\\\\n        $lai_output_name \\\\\n        \"${prefix}.LAI.out\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lai: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assembles a small genome (bacterial, fungal, viral)\nTags: genome, assembly, genome assembler, small genome, de novo assembler", "answer": "process SPADES {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/spades:4.0.0--h5fb382e_1' :\n        'biocontainers/spades:4.0.0--h5fb382e_1' }\"\n\n    input:\n    tuple val(meta), path(illumina), path(pacbio), path(nanopore)\n    path yml\n    path hmm\n\n    output:\n    tuple val(meta), path('*.scaffolds.fa.gz')    , optional:true, emit: scaffolds\n    tuple val(meta), path('*.contigs.fa.gz')      , optional:true, emit: contigs\n    tuple val(meta), path('*.transcripts.fa.gz')  , optional:true, emit: transcripts\n    tuple val(meta), path('*.gene_clusters.fa.gz'), optional:true, emit: gene_clusters\n    tuple val(meta), path('*.assembly.gfa.gz')    , optional:true, emit: gfa\n    tuple val(meta), path('warnings.log')         , optional:true, emit: warnings\n    tuple val(meta), path('*.spades.log')         , emit: log\n    path  \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def maxmem = task.memory.toGiga()\n    def illumina_reads = illumina ? ( meta.single_end ? \"-s $illumina\" : \"-1 ${illumina[0]} -2 ${illumina[1]}\" ) : \"\"\n    def pacbio_reads = pacbio ? \"--pacbio $pacbio\" : \"\"\n    def nanopore_reads = nanopore ? \"--nanopore $nanopore\" : \"\"\n    def custom_hmms = hmm ? \"--custom-hmms $hmm\" : \"\"\n    def reads = yml ? \"--dataset $yml\" : \"$illumina_reads $pacbio_reads $nanopore_reads\"\n    \"\"\"\n    spades.py \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --memory $maxmem \\\\\n        $custom_hmms \\\\\n        $reads \\\\\n        -o ./\n    mv spades.log ${prefix}.spades.log\n\n    if [ -f scaffolds.fasta ]; then\n        mv scaffolds.fasta ${prefix}.scaffolds.fa\n        gzip -n ${prefix}.scaffolds.fa\n    fi\n    if [ -f contigs.fasta ]; then\n        mv contigs.fasta ${prefix}.contigs.fa\n        gzip -n ${prefix}.contigs.fa\n    fi\n    if [ -f transcripts.fasta ]; then\n        mv transcripts.fasta ${prefix}.transcripts.fa\n        gzip -n ${prefix}.transcripts.fa\n    fi\n    if [ -f assembly_graph_with_scaffolds.gfa ]; then\n        mv assembly_graph_with_scaffolds.gfa ${prefix}.assembly.gfa\n        gzip -n ${prefix}.assembly.gfa\n    fi\n\n    if [ -f gene_clusters.fasta ]; then\n        mv gene_clusters.fasta ${prefix}.gene_clusters.fa\n        gzip -n ${prefix}.gene_clusters.fa\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spades: \\$(spades.py --version 2>&1 | sed -n 's/^.*SPAdes genome assembler v//p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def maxmem = task.memory.toGiga()\n    def illumina_reads = illumina ? ( meta.single_end ? \"-s $illumina\" : \"-1 ${illumina[0]} -2 ${illumina[1]}\" ) : \"\"\n    def pacbio_reads = pacbio ? \"--pacbio $pacbio\" : \"\"\n    def nanopore_reads = nanopore ? \"--nanopore $nanopore\" : \"\"\n    def custom_hmms = hmm ? \"--custom-hmms $hmm\" : \"\"\n    def reads = yml ? \"--dataset $yml\" : \"$illumina_reads $pacbio_reads $nanopore_reads\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.scaffolds.fa.gz\n    echo \"\" | gzip > ${prefix}.contigs.fa.gz\n    echo \"\" | gzip > ${prefix}.transcripts.fa.gz\n    echo \"\" | gzip > ${prefix}.gene_clusters.fa.gz\n    echo \"\" | gzip > ${prefix}.assembly.gfa.gz\n    touch ${prefix}.spades.log\n    touch warnings.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spades: \\$(spades.py --version 2>&1 | sed -n 's/^.*SPAdes genome assembler v//p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Identify plasmids in bacterial sequences and assemblies\nTags: fasta, fastq, plasmid", "answer": "process PLASMIDFINDER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plasmidfinder:2.1.6--py310hdfd78af_1':\n        'biocontainers/plasmidfinder:2.1.6--py310hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(seqs)\n\n    output:\n    tuple val(meta), path(\"*.json\")                 , emit: json\n    tuple val(meta), path(\"*.txt\")                  , emit: txt\n    tuple val(meta), path(\"*.tsv\")                  , emit: tsv\n    tuple val(meta), path(\"*-hit_in_genome_seq.fsa\"), emit: genome_seq\n    tuple val(meta), path(\"*-plasmid_seqs.fsa\")     , emit: plasmid_seq\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.1.6' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    plasmidfinder.py \\\\\n        $args \\\\\n        -i $seqs \\\\\n        -o ./ \\\\\n        -x\n\n    # Rename hard-coded outputs with prefix to avoid name collisions\n    mv data.json ${prefix}.json\n    mv results.txt ${prefix}.txt\n    mv results_tab.tsv ${prefix}.tsv\n    mv Hit_in_genome_seq.fsa ${prefix}-hit_in_genome_seq.fsa\n    mv Plasmid_seqs.fsa ${prefix}-plasmid_seqs.fsa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plasmidfinder: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Search for protein structural hits against a foldseek database of protein structures\nTags: protein, structure, comparisons", "answer": "process FOLDSEEK_EASYSEARCH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/foldseek:9.427df8a--pl5321hb365157_0':\n        'biocontainers/foldseek:9.427df8a--pl5321hb365157_0' }\"\n\n    input:\n    tuple val(meta)   , path(pdb)\n    tuple val(meta_db), path(db)\n\n    output:\n    tuple val(meta), path(\"${meta.id}.m8\"), emit: aln\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    foldseek \\\\\n        easy-search \\\\\n        ${pdb} \\\\\n        ${db}/${meta_db.id} \\\\\n        ${prefix}.m8 \\\\\n        tmpFolder \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        foldseek: \\$(foldseek --help | grep Version | sed 's/.*Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.m8\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        foldseek: \\$(foldseek --help | grep Version | sed 's/.*Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a database from protein structures\nTags: protein, structure, comparisons", "answer": "process FOLDSEEK_CREATEDB {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/foldseek:9.427df8a--pl5321hb365157_0':\n        'biocontainers/foldseek:9.427df8a--pl5321hb365157_0' }\"\n\n    input:\n    tuple val(meta), path(pdb)\n\n    output:\n    tuple val(meta), path(\"${meta.id}\"), emit: db\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}\n    foldseek \\\\\n        createdb \\\\\n        ${pdb} \\\\\n        ${prefix}/${prefix} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        foldseek: \\$(foldseek --help | grep Version | sed 's/.*Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mkdir -p ${prefix}\n    touch ${prefix}/${prefix}\n    touch ${prefix}/${prefix}_ca\n    touch ${prefix}/${prefix}_ca.dbtype\n    touch ${prefix}/${prefix}_ca.index\n    touch ${prefix}/${prefix}_h\n    touch ${prefix}/${prefix}_h.dbtype\n    touch ${prefix}/${prefix}_h.index\n    touch ${prefix}/${prefix}_ss\n    touch ${prefix}/${prefix}_ss.dbtype\n    touch ${prefix}/${prefix}_ss.index\n    touch ${prefix}/${prefix}.dbtype\n    touch ${prefix}/${prefix}.index\n    touch ${prefix}/${prefix}.lookup\n    touch ${prefix}/${prefix}.source\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        foldseek: \\$(foldseek --help | grep Version | sed 's/.*Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MSIsensor-pro evaluates Microsatellite Instability (MSI) for cancer patients with next generation sequencing data. It accepts the whole genome sequencing, whole exome sequencing and target region (panel) sequencing data as input\nTags: micro-satellite-scan, msisensor-pro, scan", "answer": "process MSISENSORPRO_SCAN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/msisensor-pro:1.2.0--hfc31af2_0' :\n        'biocontainers/msisensor-pro:1.2.0--hfc31af2_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.list\"), emit: list\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    msisensor-pro \\\\\n        scan \\\\\n        -d $fasta \\\\\n        -o ${prefix}.msisensor_scan.list \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        msisensor-pro: \\$(msisensor-pro 2>&1 | sed -nE 's/Version:\\\\sv([0-9]\\\\.[0-9])/\\\\1/ p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MSIsensor-pro evaluates Microsatellite Instability (MSI) for cancer patients with next generation sequencing data. It accepts the whole genome sequencing, whole exome sequencing and target region (panel) sequencing data as input\nTags: micro-satellite-scan, msisensor-pro, msi, somatic", "answer": "process MSISENSORPRO_MSISOMATIC {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/msisensor-pro:1.2.0--hfc31af2_0' :\n        'biocontainers/msisensor-pro:1.2.0--hfc31af2_0' }\"\n\n    input:\n    tuple val(meta), path(normal), path(normal_index), path(tumor), path(tumor_index), path(intervals)\n    path (fasta)\n    path (msisensor_scan)\n\n    output:\n    tuple val(meta), path(\"${prefix}\")         , emit: output_report\n    tuple val(meta), path(\"${prefix}_dis\")     , emit: output_dis\n    tuple val(meta), path(\"${prefix}_germline\"), emit: output_germline\n    tuple val(meta), path(\"${prefix}_somatic\") , emit: output_somatic\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def fasta = fasta ? \"-g ${fasta}\" : \"\"\n    def intervals = intervals ? \" -e ${intervals} \" : \"\"\n    \"\"\"\n    msisensor-pro \\\\\n        msi \\\\\n        -d ${msisensor_scan} \\\\\n        -n ${normal} \\\\\n        -t ${tumor} \\\\\n        ${fasta} \\\\\n        -o $prefix \\\\\n        -b ${task.cpus} \\\\\n        ${intervals} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        msisensor-pro: \\$(msisensor-pro 2>&1 | sed -nE 's/Version:\\\\sv([0-9]\\\\.[0-9])/\\\\1/ p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Align reads to a reference genome using bowtie2\nTags: align, map, fasta, fastq, genome, reference", "answer": "process BOWTIE2_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-ac74a7f02cebcfcc07d8e8d1d750af9c83b4d45a:f70b31a2db15c023d641c32f433fb02cd04df5a6-0' :\n        'biocontainers/mulled-v2-ac74a7f02cebcfcc07d8e8d1d750af9c83b4d45a:f70b31a2db15c023d641c32f433fb02cd04df5a6-0' }\"\n\n    input:\n    tuple val(meta) , path(reads)\n    tuple val(meta2), path(index)\n    tuple val(meta3), path(fasta)\n    val   save_unaligned\n    val   sort_bam\n\n    output:\n    tuple val(meta), path(\"*.sam\")      , emit: sam     , optional:true\n    tuple val(meta), path(\"*.bam\")      , emit: bam     , optional:true\n    tuple val(meta), path(\"*.cram\")     , emit: cram    , optional:true\n    tuple val(meta), path(\"*.csi\")      , emit: csi     , optional:true\n    tuple val(meta), path(\"*.crai\")     , emit: crai    , optional:true\n    tuple val(meta), path(\"*.log\")      , emit: log\n    tuple val(meta), path(\"*fastq.gz\")  , emit: fastq   , optional:true\n    path  \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def args2 = task.ext.args2 ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def unaligned = \"\"\n    def reads_args = \"\"\n    if (meta.single_end) {\n        unaligned = save_unaligned ? \"--un-gz ${prefix}.unmapped.fastq.gz\" : \"\"\n        reads_args = \"-U ${reads}\"\n    } else {\n        unaligned = save_unaligned ? \"--un-conc-gz ${prefix}.unmapped.fastq.gz\" : \"\"\n        reads_args = \"-1 ${reads[0]} -2 ${reads[1]}\"\n    }\n\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    def extension_pattern = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher =  (args2 =~ extension_pattern)\n    def extension = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.rev.1.bt2\" | sed \"s/\\\\.rev.1.bt2\\$//\"`\n    [ -z \"\\$INDEX\" ] && INDEX=`find -L ./ -name \"*.rev.1.bt2l\" | sed \"s/\\\\.rev.1.bt2l\\$//\"`\n    [ -z \"\\$INDEX\" ] && echo \"Bowtie2 index files not found\" 1>&2 && exit 1\n\n    bowtie2 \\\\\n        -x \\$INDEX \\\\\n        $reads_args \\\\\n        --threads $task.cpus \\\\\n        $unaligned \\\\\n        $args \\\\\n        2> >(tee ${prefix}.bowtie2.log >&2) \\\\\n        | samtools $samtools_command $args2 --threads $task.cpus ${reference} -o ${prefix}.${extension} -\n\n    if [ -f ${prefix}.unmapped.fastq.1.gz ]; then\n        mv ${prefix}.unmapped.fastq.1.gz ${prefix}.unmapped_1.fastq.gz\n    fi\n\n    if [ -f ${prefix}.unmapped.fastq.2.gz ]; then\n        mv ${prefix}.unmapped.fastq.2.gz ${prefix}.unmapped_2.fastq.gz\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bowtie2: \\$(echo \\$(bowtie2 --version 2>&1) | sed 's/^.*bowtie2-align-s version //; s/ .*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args2 = task.ext.args2 ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension_pattern = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension = (args2 ==~ extension_pattern) ? (args2 =~ extension_pattern)[0][2].toLowerCase() : \"bam\"\n    def create_unmapped = \"\"\n    if (meta.single_end) {\n        create_unmapped = save_unaligned ? \"touch ${prefix}.unmapped.fastq.gz\" : \"\"\n    } else {\n        create_unmapped = save_unaligned ? \"touch ${prefix}.unmapped_1.fastq.gz && touch ${prefix}.unmapped_2.fastq.gz\" : \"\"\n    }\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    def create_index = \"\"\n    if (extension == \"cram\") {\n        create_index = \"touch ${prefix}.crai\"\n    } else if (extension == \"bam\") {\n        create_index = \"touch ${prefix}.csi\"\n    }\n\n    \"\"\"\n    touch ${prefix}.${extension}\n    ${create_index}\n    touch ${prefix}.bowtie2.log\n    ${create_unmapped}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bowtie2: \\$(echo \\$(bowtie2 --version 2>&1) | sed 's/^.*bowtie2-align-s version //; s/ .*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Builds bowtie index for reference genome\nTags: build, index, fasta, genome, reference", "answer": "process BOWTIE2_BUILD {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bowtie2:2.5.2--py39h6fed5c7_0' :\n        'biocontainers/bowtie2:2.5.2--py39h6fed5c7_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path('bowtie2')    , emit: index\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir bowtie2\n    bowtie2-build $args --threads $task.cpus $fasta bowtie2/${fasta.baseName}\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bowtie2: \\$(echo \\$(bowtie2 --version 2>&1) | sed 's/^.*bowtie2-align-s version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir bowtie2\n    touch bowtie2/${fasta.baseName}.{1..4}.bt2\n    touch bowtie2/${fasta.baseName}.rev.{1,2}.bt2\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bowtie2: \\$(echo \\$(bowtie2 --version 2>&1) | sed 's/^.*bowtie2-align-s version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: CheckM2 bin quality prediction\nTags: checkm, mag, metagenome, quality, completeness, contamination, bins", "answer": "process CHECKM2_PREDICT {\n    tag \"${meta.id}\"\n    label 'process_medium'\n\n    conda \"bioconda::checkm2=1.0.2\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/checkm2:1.0.2--pyh7cba7a3_0':\n        'biocontainers/checkm2:1.0.2--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(fasta, stageAs: \"input_bins/*\")\n    tuple val(dbmeta), path(db)\n\n    output:\n    tuple val(meta), path(\"${prefix}\")                   , emit: checkm2_output\n    tuple val(meta), path(\"${prefix}/quality_report.tsv\"), emit: checkm2_tsv\n    path(\"versions.yml\")                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    checkm2 \\\\\n        predict \\\\\n        --input ${fasta} \\\\\n        --output-directory ${prefix} \\\\\n        --threads ${task.cpus} \\\\\n        --database_path ${db} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkm2: \\$(checkm2 --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}/diamond_output ${prefix}/protein_files\n    touch ${prefix}/quality_report.tsv ${prefix}/checkm2.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkm2: \\$(checkm2 --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: CheckM2 database download\nTags: checkm, mag, metagenome, quality, completeness, contamination, bins", "answer": "import groovy.json.JsonSlurper\n\nprocess CHECKM2_DATABASEDOWNLOAD {\n    label 'process_single'\n\n    conda \"bioconda::checkm2=1.0.2\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/checkm2:1.0.2--pyh7cba7a3_0':\n        'biocontainers/checkm2:1.0.2--pyh7cba7a3_0' }\"\n\n    output:\n    tuple val(meta), path(\"checkm2_db_v${db_version}.dmnd\"), emit: database\n    path(\"versions.yml\")                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    zenodo_id = 5571251\n    def jsonSlurper = new JsonSlurper()\n    db_version = jsonSlurper.parseText(file(\"https://zenodo.org/api/records/${zenodo_id}\").text).metadata.version\n    meta = [id: 'checkm2_db', version: db_version]\n    \"\"\"\n    # Automatic download is broken when using singularity/apptainer (https://github.com/chklovski/CheckM2/issues/73)\n    # So we download the database manually\n    wget https://zenodo.org/records/${zenodo_id}/files/checkm2_database.tar.gz\n\n    tar -xzf checkm2_database.tar.gz\n    db_path=\\$(find -name *.dmnd)\n    MD5=\\$(grep -o '\\\\.dmnd\": \"[^\"]*\"' CONTENTS.json | cut -d '\"' -f 3)\n\n    md5sum -c <<< \"\\$MD5  \\$db_path\"\n    mv \\$db_path checkm2_db_v${db_version}.dmnd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkm2: \\$(checkm2 --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch checkm_db.dmnd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkm2: \\$(checkm2 --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Pre-compute the graph index structure.\nTags: hla, hlala, hla_typing, hlala_typing", "answer": "process HLALA_PREPAREGRAPH {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hla-la:1.0.3--hd03093a_0':\n        'biocontainers/hla-la:1.0.3--hd03093a_0' }\"\n\n    input:\n    tuple val(meta), path(graph)\n\n    output:\n    tuple val(meta), path(\"${graph}\")        , emit: graph\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"HLALA_PREPAREGRAPH module does not support Conda. Please use Docker or Singularity.\"\n    }\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    /usr/local/opt/hla-la/bin/HLA-LA \\\\\n        --action prepareGraph \\\\\n        --PRG_graph_dir $graph\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hlala: 1.0.3\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs HLA typing based on a population reference graph and employs a new linear projection method to align reads to the graph.\nTags: hla, hlala, hla_typing, hlala_typing", "answer": "process HLALA_TYPING {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hla-la:1.0.3--hd03093a_0':\n        'biocontainers/hla-la:1.0.3--hd03093a_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(graph)\n\n    output:\n    tuple val(meta), path(\"${meta.id}\")                             , emit: results\n    tuple val(meta), path(\"${meta.id}/extraction.bam*\")             , emit: extraction\n    tuple val(meta), path(\"${meta.id}/extraction_mapped.bam\")       , emit: extraction_mapped\n    tuple val(meta), path(\"${meta.id}/extraction_unmapped.bam\")     , emit: extraction_unmpapped\n    tuple val(meta), path(\"${meta.id}/hla/*\")                       , emit: hla\n    tuple val(meta), path(\"${meta.id}/*.fastq\")                     , emit: fastq\n    tuple val(meta), path(\"${meta.id}/reads_per_level.txt\")         , emit: reads_per_level\n    tuple val(meta), path(\"${meta.id}/remapped_with_a.bam*\")        , emit: remapped\n\n    path \"versions.yml\"                                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mkdir graphs\n    mv $graph graphs\n    mv graphs /usr/local/opt/hla-la/\n\n    mkdir $prefix\n\n    /usr/local/opt/hla-la/src/HLA-LA.pl \\\\\n        --BAM $bam \\\\\n        --graph ../graphs/$graph \\\\\n        --sampleID $prefix \\\\\n        --workingDir . \\\\\n        --maxThreads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hla-la: 1.0.3\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    mkdir ${prefix}/hla\n    echo stub > ${prefix}/extraction.bam\n    echo stub > ${prefix}/extraction.bam.bai\n    echo stub > ${prefix}/extraction_mapped.bam\n    echo stub > ${prefix}/extraction_unmapped.bam\n    echo stub > ${prefix}/remapped_with_a.bam\n    echo stub > ${prefix}/remapped_with_a.bam.bai\n    echo stub > ${prefix}/R_1.fastq\n    echo stub > ${prefix}/R_2.fastq\n    echo stub > ${prefix}/R_U.fastq\n    echo stub > ${prefix}/reads_per_level.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_DPA1.txt\n    echo stub > ${prefix}/hla/R1_pileup_G.txt\n    echo stub > ${prefix}/hla/R1_pileup_E.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_DRB3.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_DRB1.txt\n    echo stub > ${prefix}/hla/R1_readIDs_F.txt\n    echo stub > ${prefix}/hla/R1_PP_DPA1_pairs.txt\n    echo stub > ${prefix}/hla/R1_PP_DRB4_pairs.txt\n    echo stub > ${prefix}/hla/R1_pileup_C.txt\n    echo stub > ${prefix}/hla/R1_parameters.txt\n    echo stub > ${prefix}/hla/R1_readIDs_G.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_V.txt\n    echo stub > ${prefix}/hla/R1_readIDs_DRA.txt\n    echo stub > ${prefix}/hla/R1_pileup_DRB4.txt\n    echo stub > ${prefix}/hla/R1_pileup_DQB1.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_C.txt\n    echo stub > ${prefix}/hla/R1_pileup_DRB3.txt\n    echo stub > ${prefix}/hla/R1_readIDs_DRB4.txt\n    echo stub > ${prefix}/hla/R1_PP_F_pairs.txt\n    echo stub > ${prefix}/hla/R1_PP_E_pairs.txt\n    echo stub > ${prefix}/hla/R1_readIDs_DQB1.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_A.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_H.txt\n    echo stub > ${prefix}/hla/R1_readIDs_V.txt\n    echo stub > ${prefix}/hla/R1_PP_DRB3_pairs.txt\n    echo stub > ${prefix}/hla/R1_PP_A_pairs.txt\n    echo stub > ${prefix}/hla/R1_pileup_DPA1.txt\n    echo stub > ${prefix}/hla/R1_PP_G_pairs.txt\n    echo stub > ${prefix}/hla/R1_pileup_K.txt\n    echo stub > ${prefix}/hla/R1_PP_K_pairs.txt\n    echo stub > ${prefix}/hla/R1_pileup_F.txt\n    echo stub > ${prefix}/hla/R1_readIDs_K.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_K.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_DRB4.txt\n    echo stub > ${prefix}/hla/R1_pileup_B.txt\n    echo stub > ${prefix}/hla/R1_pileup_V.txt\n    echo stub > ${prefix}/hla/R1_pileup_H.txt\n    echo stub > ${prefix}/hla/R1_readIDs_E.txt\n    echo stub > ${prefix}/hla/R1_PP_DPB1_pairs.txt\n    echo stub > ${prefix}/hla/summaryStatistics.txt\n    echo stub > ${prefix}/hla/R1_readIDs_C.txt\n    echo stub > ${prefix}/hla/R1_PP_H_pairs.txt\n    echo stub > ${prefix}/hla/R1_pileup_DPB1.txt\n    echo stub > ${prefix}/hla/R1_readIDs_DQA1.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_DPB1.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_B.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_DQB1.txt\n    echo stub > ${prefix}/hla/R1_PP_V_pairs.txt\n    echo stub > ${prefix}/hla/R1_readIDs_H.txt\n    echo stub > ${prefix}/hla/R1_PP_DRB1_pairs.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_E.txt\n    echo stub > ${prefix}/hla/R1_bestguess.txt\n    echo stub > ${prefix}/hla/R1_PP_DRA_pairs.txt\n    echo stub > ${prefix}/hla/R1_readIDs_DRB1.txt\n    echo stub > ${prefix}/hla/R1_bestguess_G.txt\n    echo stub > ${prefix}/hla/R1_PP_DQB1_pairs.txt\n    echo stub > ${prefix}/hla/R1_readIDs_DRB3.txt\n    echo stub > ${prefix}/hla/R1_readIDs_A.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_DRA.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_G.txt\n    echo stub > ${prefix}/hla/R1_pileup_DRA.txt\n    echo stub > ${prefix}/hla/R1_readIDs_DPA1.txt\n    echo stub > ${prefix}/hla/R1_PP_B_pairs.txt\n    echo stub > ${prefix}/hla/R1_PP_DQA1_pairs.txt\n    echo stub > ${prefix}/hla/R1_pileup_A.txt\n    echo stub > ${prefix}/hla/R1_PP_C_pairs.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_F.txt\n    echo stub > ${prefix}/hla/R1_columnIncompatibilities_DQA1.txt\n    echo stub > ${prefix}/hla/R1_pileup_DRB1.txt\n    echo stub > ${prefix}/hla/R1_readIDs_B.txt\n    echo stub > ${prefix}/hla/histogram_matchesPerRead.txt\n    echo stub > ${prefix}/hla/R1_pileup_DQA1.txt\n    echo stub > ${prefix}/hla/R1_readIDs_DPB1.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hla-la: 1.0.3\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Unzip ZIP archive files\nTags: unzip, decompression, zip, archiving", "answer": "process UNZIPFILES {\n    tag \"$archive\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/p7zip:16.02' :\n        'biocontainers/p7zip:16.02' }\"\n\n    input:\n    tuple val(meta), path(archive)\n\n    output:\n    tuple val(meta), path(\"${prefix}/**\"), emit: files\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    if ( archive instanceof List && archive.name.size > 1 ) { error \"[UNZIP] error: 7za only accepts a single archive as input. Please check module input.\" }\n\n    prefix = task.ext.prefix ?: ( meta.id ? \"${meta.id}\" : archive.baseName)\n    \"\"\"\n    7za \\\\\n        x \\\\\n        -o\"${prefix}\"/ \\\\\n        $args \\\\\n        $archive\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        7za: \\$(echo \\$(7za --help) | sed 's/.*p7zip Version //; s/(.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: ( meta.id ? \"${meta.id}\" : archive.baseName)\n    \"\"\"\n    mkdir \"${prefix}\"\n    touch \"${prefix}/hello.txt\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        7za: \\$(echo \\$(7za --help) | sed 's/.*p7zip Version //; s/(.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A fast and user-friendly method to predict antimicrobial peptides (AMPs) from any given size protein dataset. ampir uses a supervised statistical machine learning approach to predict AMPs.\nTags: ampir, amp, antimicrobial peptide prediction", "answer": "process AMPIR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-ampir:1.1.0':\n        'biocontainers/r-ampir:1.1.0' }\"\n\n    input:\n    tuple val(meta), path(faa)\n    val model\n    val min_length\n    val min_probability\n\n    output:\n    tuple val(meta), path(\"*.faa\"), emit: amps_faa\n    tuple val(meta), path(\"*.tsv\"), emit: amps_tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$faa\" == \"${prefix}.faa\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    #!/usr/bin/env Rscript\n    library(ampir)\n\n    input_seqs <- read_faa('${faa}')\n    prediction <- predict_amps(input_seqs,${min_length},model = '${model}')\n    prediction <- prediction[which(prediction\\$prob_AMP >= as.numeric(${min_probability})), ]\n    output_seqs <- input_seqs[row.names(prediction), ]\n    write.table(prediction, file = \"${prefix}.tsv\", row.names = FALSE, sep = \"\\t\", quote = FALSE, dec = '.')\n    df_to_faa(output_seqs, \"${prefix}.faa\")\n\n    version_file_path <- \"versions.yml\"\n    version_ampir <- paste(unlist(packageVersion(\"ampir\")), collapse = \".\")\n    f <- file(version_file_path, \"w\")\n    writeLines('\"${task.process}\":', f)\n    writeLines(\"    ampir: \", f, sep = \"\")\n    writeLines(version_ampir, f)\n    close(f)\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$faa\" == \"${prefix}.faa\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    #!/usr/bin/env Rscript\n    library(ampir)\n\n    t <- file(\"${prefix}.tsv\", \"w\")\n    close(t)\n\n    a <- file(\"${prefix}.faa\", \"w\")\n    close(a)\n\n    version_file_path <- \"versions.yml\"\n    version_ampir <- paste(unlist(packageVersion(\"ampir\")), collapse = \".\")\n    f <- file(version_file_path, \"w\")\n    writeLines('\"${task.process}\":', f)\n    writeLines(\"    ampir: \", f, sep = \"\")\n    writeLines(version_ampir, f)\n    close(f)\n    \"\"\"\n}\n"}
{"question": "Description: Transcript assembly and quantification for RNA-Se\nTags: transcript, assembly, quantification, gtf", "answer": "process STRINGTIE_STRINGTIE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/stringtie:2.2.1--hecb563c_2' :\n        'biocontainers/stringtie:2.2.1--hecb563c_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  annotation_gtf\n\n    output:\n    tuple val(meta), path(\"*.transcripts.gtf\"), emit: transcript_gtf\n    tuple val(meta), path(\"*.abundance.txt\")  , emit: abundance\n    tuple val(meta), path(\"*.coverage.gtf\")   , optional: true, emit: coverage_gtf\n    tuple val(meta), path(\"*.ballgown\")       , optional: true, emit: ballgown\n    path  \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args ?: ''\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def reference = annotation_gtf ? \"-G $annotation_gtf\" : \"\"\n    def ballgown  = annotation_gtf ? \"-b ${prefix}.ballgown\" : \"\"\n    def coverage  = annotation_gtf ? \"-C ${prefix}.coverage.gtf\" : \"\"\n\n    def strandedness = ''\n    if (meta.strandedness == 'forward') {\n        strandedness = '--fr'\n    } else if (meta.strandedness == 'reverse') {\n        strandedness = '--rf'\n    }\n    \"\"\"\n    stringtie \\\\\n        $bam \\\\\n        $strandedness \\\\\n        $reference \\\\\n        -o ${prefix}.transcripts.gtf \\\\\n        -A ${prefix}.gene.abundance.txt \\\\\n        $coverage \\\\\n        $ballgown \\\\\n        -p $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stringtie: \\$(stringtie --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.transcripts.gtf\n    touch ${prefix}.gene.abundance.txt\n    touch ${prefix}.coverage.gtf\n    touch ${prefix}.ballgown\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stringtie: \\$(stringtie --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges the annotation gtf file and the stringtie output gtf files\nTags: merge, gtf, reference", "answer": "process STRINGTIE_MERGE {\n    label 'process_medium'\n\n    // Note: 2.7X indices incompatible with AWS iGenomes.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/stringtie:2.2.1--hecb563c_2' :\n        'biocontainers/stringtie:2.2.1--hecb563c_2' }\"\n\n    input:\n    path stringtie_gtf\n    path annotation_gtf\n\n    output:\n    path \"stringtie.merged.gtf\", emit: gtf\n    path  \"versions.yml\"       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args ?: ''\n    def reference = annotation_gtf ? \"-G $annotation_gtf\" : \"\"\n    \"\"\"\n    stringtie \\\\\n        --merge $stringtie_gtf \\\\\n        $reference \\\\\n        -o stringtie.merged.gtf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stringtie: \\$(stringtie --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch stringtie.merged.gtf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stringtie: \\$(stringtie --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extract files.\nTags: untar, uncompress, extract", "answer": "process UNTAR {\n    tag \"$archive\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:22.04' :\n        'nf-core/ubuntu:22.04' }\"\n\n    input:\n    tuple val(meta), path(archive)\n\n    output:\n    tuple val(meta), path(\"$prefix\"), emit: untar\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    prefix    = task.ext.prefix ?: ( meta.id ? \"${meta.id}\" : archive.baseName.toString().replaceFirst(/\\.tar$/, \"\"))\n\n    \"\"\"\n    mkdir $prefix\n\n    ## Ensures --strip-components only applied when top level of tar contents is a directory\n    ## If just files or multiple directories, place all in prefix\n    if [[ \\$(tar -taf ${archive} | grep -o -P \"^.*?\\\\/\" | uniq | wc -l) -eq 1 ]]; then\n        tar \\\\\n            -C $prefix --strip-components 1 \\\\\n            -xavf \\\\\n            $args \\\\\n            $archive \\\\\n            $args2\n    else\n        tar \\\\\n            -C $prefix \\\\\n            -xavf \\\\\n            $args \\\\\n            $archive \\\\\n            $args2\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        untar: \\$(echo \\$(tar --version 2>&1) | sed 's/^.*(GNU tar) //; s/ Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix    = task.ext.prefix ?: ( meta.id ? \"${meta.id}\" : archive.toString().replaceFirst(/\\.[^\\.]+(.gz)?$/, \"\"))\n    \"\"\"\n    mkdir ${prefix}\n    ## Dry-run untaring the archive to get the files and place all in prefix\n    if [[ \\$(tar -taf ${archive} | grep -o -P \"^.*?\\\\/\" | uniq | wc -l) -eq 1 ]]; then\n        for i in `tar -tf ${archive}`;\n        do\n            if [[ \\$(echo \"\\${i}\" | grep -E \"/\\$\") == \"\" ]];\n            then\n                touch \\${i}\n            else\n                mkdir -p \\${i}\n            fi\n        done\n    else\n        for i in `tar -tf ${archive}`;\n        do\n            if [[ \\$(echo \"\\${i}\" | grep -E \"/\\$\") == \"\" ]];\n            then\n                touch ${prefix}/\\${i}\n            else\n                mkdir -p ${prefix}/\\${i}\n            fi\n        done\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        untar: \\$(echo \\$(tar --version 2>&1) | sed 's/^.*(GNU tar) //; s/ Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: structural-variant calling with sniffles\nTags: sniffles, structural-variant calling, long-read", "answer": "process SNIFFLES {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sniffles:2.0.7--pyhdfd78af_0' :\n        'biocontainers/sniffles:2.0.7--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    tuple val(meta), path(\"*.snf\"), emit: snf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    sniffles \\\\\n        --input $bam \\\\\n        --vcf ${prefix}.vcf \\\\\n        --snf ${prefix}.snf \\\\\n        --reference $fasta \\\\\n        -t $task.cpus \\\\\n        $args\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sniffles: \\$(sniffles --help 2>&1 | grep Version |sed 's/^.*Version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf\n    touch ${prefix}.snf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sniffles: \\$(sniffles --help 2>&1 | grep Version |sed 's/^.*Version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run NCBI's FCS adaptor on assembled genomes\nTags: assembly, genomics, quality control, contamination, NCBI", "answer": "process FCS_FCSADAPTOR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://ftp.ncbi.nlm.nih.gov/genomes/TOOLS/FCS/releases/0.5.0/fcs-adaptor.sif':\n        'docker.io/ncbi/fcs-adaptor:0.5.0' }\"\n\n    input:\n    tuple val(meta), path(assembly)\n\n    output:\n    tuple val(meta), path(\"*.cleaned_sequences.fa.gz\"), emit: cleaned_assembly, optional: true\n    tuple val(meta), path(\"*.fcs_adaptor_report.txt\") , emit: adaptor_report\n    tuple val(meta), path(\"*.fcs_adaptor.log\")        , emit: log\n    tuple val(meta), path(\"*.pipeline_args.yaml\")     , emit: pipeline_args\n    tuple val(meta), path(\"*.skipped_trims.jsonl\")    , emit: skipped_trims\n    path \"versions.yml\"                               , emit: versions\n\n    // Downstream handling of optional cleaned_assembly\n    //\n    // ch_cleaned_assembly  = FCS_FCSADAPTOR ( ch_input_assembly ).cleaned_assembly\n\n    // ch_input_assembly\n    // | join (ch_cleaned_assembly, by:0, remainder:true )\n    // | map { meta, input, cleaned ->\n    //     [ meta, cleaned ?: input ]\n    // }\n    // | set { ch_downstream_channel }\n\n    // FCS_FCSGX ( ch_downstream_channel )\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"FCS_FCSADAPTOR module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: '--prok' // --prok || --euk\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FCSADAPTOR_VERSION = '0.5.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    av_screen_x \\\\\n        -o output/ \\\\\n        $args \\\\\n        $assembly\n\n    # compress and/or rename files with prefix\n    num_contamination_lines=\\$(cat \"output/fcs_adaptor_report.txt\" | wc -l)\n    if [[ \\$num_contamination_lines -gt 1 ]]; then\n        find output/cleaned_sequences/  -type f ! -name \"*.gz\" -exec gzip {} \\\\;\n        cp output/cleaned_sequences/*     \"${prefix}.cleaned_sequences.fa.gz\"\n    fi\n    cp \"output/fcs_adaptor_report.txt\"    \"${prefix}.fcs_adaptor_report.txt\"\n    cp \"output/fcs_adaptor.log\"           \"${prefix}.fcs_adaptor.log\"\n    cp \"output/pipeline_args.yaml\"        \"${prefix}.pipeline_args.yaml\"\n    cp \"output/skipped_trims.jsonl\"       \"${prefix}.skipped_trims.jsonl\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        FCS-adaptor: $FCSADAPTOR_VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"FCS_FCSADAPTOR module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FCSADAPTOR_VERSION = '0.5.0'\n\n    \"\"\"\n    touch ${prefix}.fcs_adaptor_report.txt\n    touch ${prefix}.fcs_adaptor.log\n    touch ${prefix}.pipeline_args.yaml\n    touch ${prefix}.skipped_trims.jsonl\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        FCS-adaptor: $FCSADAPTOR_VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run FCS-GX on assembled genomes. The contigs of the assembly are searched against a reference database excluding the given taxid.\nTags: assembly, genomics, quality control, contamination, NCBI", "answer": "process FCS_FCSGX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://ftp.ncbi.nlm.nih.gov/genomes/TOOLS/FCS/releases/0.4.0/fcs-gx.sif':\n        'docker.io/ncbi/fcs-gx:0.4.0' }\"\n\n    input:\n    tuple val(meta), path(assembly)\n    path gxdb\n\n    output:\n    tuple val(meta), path(\"out/*.fcs_gx_report.txt\"), emit: fcs_gx_report\n    tuple val(meta), path(\"out/*.taxonomy.rpt\")     , emit: taxonomy_report\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"FCS_FCSGX module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FCSGX_VERSION = '0.4.0'\n\n    \"\"\"\n    python3 /app/bin/run_gx \\\\\n        --fasta $assembly \\\\\n        --out-dir ./out \\\\\n        --gx-db ./${gxdb[0].baseName} \\\\\n        --tax-id ${meta.taxid} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        python: \\$(python3 --version 2>&1 | sed -e \"s/Python //g\")\n        FCS-GX: $FCSGX_VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"FCS_FCSGX module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FCSGX_VERSION = '0.4.0'\n\n    \"\"\"\n    mkdir -p out\n    touch out/${prefix}.fcs_gx_report.txt\n    touch out/${prefix}.taxonomy.rpt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        python: \\$(python3 --version 2>&1 | sed -e \"s/Python //g\")\n        FCS-GX: $FCSGX_VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: EMM typing of Streptococcus pyogenes assemblies\nTags: fasta, Streptococcus pyogenes, typing", "answer": "process EMMTYPER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/emmtyper:0.2.0--py_0' :\n        'biocontainers/emmtyper:0.2.0--py_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    emmtyper \\\\\n        $args \\\\\n        $fasta \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        emmtyper: \\$( echo \\$(emmtyper --version 2>&1) | sed 's/^.*emmtyper v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculates genome-wide sequencing coverage.\nTags: mosdepth, bam, cram, coverage", "answer": "process MOSDEPTH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mosdepth:0.3.8--hd299d5a_0' :\n        'biocontainers/mosdepth:0.3.8--hd299d5a_0'}\"\n\n    input:\n    tuple val(meta),  path(bam), path(bai), path(bed)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path('*.global.dist.txt')      , emit: global_txt\n    tuple val(meta), path('*.summary.txt')          , emit: summary_txt\n    tuple val(meta), path('*.region.dist.txt')      , optional:true, emit: regions_txt\n    tuple val(meta), path('*.per-base.d4')          , optional:true, emit: per_base_d4\n    tuple val(meta), path('*.per-base.bed.gz')      , optional:true, emit: per_base_bed\n    tuple val(meta), path('*.per-base.bed.gz.csi')  , optional:true, emit: per_base_csi\n    tuple val(meta), path('*.regions.bed.gz')       , optional:true, emit: regions_bed\n    tuple val(meta), path('*.regions.bed.gz.csi')   , optional:true, emit: regions_csi\n    tuple val(meta), path('*.quantized.bed.gz')     , optional:true, emit: quantized_bed\n    tuple val(meta), path('*.quantized.bed.gz.csi') , optional:true, emit: quantized_csi\n    tuple val(meta), path('*.thresholds.bed.gz')    , optional:true, emit: thresholds_bed\n    tuple val(meta), path('*.thresholds.bed.gz.csi'), optional:true, emit: thresholds_csi\n    path  \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--fasta ${fasta}\" : \"\"\n    def interval = bed ? \"--by ${bed}\" : \"\"\n    if (bed && args.contains(\"--by\")) {\n        error \"'--by' can only be specified once when running mosdepth! Either remove input BED file definition or remove '--by' from 'ext.args' definition\"\n    }\n    if (!bed && args.contains(\"--thresholds\")) {\n        error \"'--thresholds' can only be specified in conjunction with '--by'\"\n    }\n\n    \"\"\"\n    mosdepth \\\\\n        --threads $task.cpus \\\\\n        $interval \\\\\n        $reference \\\\\n        $args \\\\\n        $prefix \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mosdepth: \\$(mosdepth --version 2>&1 | sed 's/^.*mosdepth //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.global.dist.txt\n    touch ${prefix}.region.dist.txt\n    touch ${prefix}.summary.txt\n    touch ${prefix}.per-base.d4\n    echo \"\" | gzip > ${prefix}.per-base.bed.gz\n    touch ${prefix}.per-base.bed.gz.csi\n    echo \"\" | gzip > ${prefix}.regions.bed.gz\n    touch ${prefix}.regions.bed.gz.csi\n    echo \"\" | gzip > ${prefix}.quantized.bed.gz\n    touch ${prefix}.quantized.bed.gz.csi\n    echo \"\" | gzip > ${prefix}.thresholds.bed.gz\n    touch ${prefix}.thresholds.bed.gz.csi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mosdepth: \\$(mosdepth --version 2>&1 | sed 's/^.*mosdepth //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Normalize antibiotic resistance genes (ARGs) using the ARO ontology (developed by CARD).\nTags: amr, antimicrobial resistance, arg, antimicrobial resistance genes, genomics, metagenomics, normalization, drug categorization", "answer": "process ARGNORM {\n    tag \"$meta.id\"\n    label 'process_low'\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/argnorm:0.5.0--pyhdfd78af_0':\n        'biocontainers/argnorm:0.5.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input_tsv)\n    val tool\n    val db\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.5.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def db_args = db ? \"--db ${db}\" : \"\"\n    if (!tool) {\n        error 'Tool not provided.'\n    }\n    if ((tool in [\"abricate\"]) && !db) {\n        error \"$tool requires a database but <db> not provided.\"\n    }\n\n    \"\"\"\n    argnorm \\\\\n        $tool \\\\\n        -i $input_tsv \\\\\n        -o $prefix \\\\\n        $db_args \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        argnorm: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.5.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    if (!tool) {\n        error 'Tool not provided.'\n    }\n    if ((tool in [\"abricate\"]) && !db) {\n        error \"$tool requires a database but <db> not provided.\"\n    }\n\n    \"\"\"\n    touch ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        argnorm: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Extract UMI and cell barcodes\nTags: isoseq, tag, pacbio, UMI, cell_barcodes", "answer": "process ISOSEQ3_TAG {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/isoseq3:4.0.0--h9ee0642_0':\n        'biocontainers/isoseq3:4.0.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    val design\n\n    output:\n    tuple val(meta), path(\"*.flt.bam\")                  , emit: bam\n    tuple val(meta), path(\"*.flt.bam.pbi\")              , emit: pbi\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def valid_design = ~/^(?:\\d{1,2}[UBGX]-)+T$|^(?:\\d{1,2}[UBGX]-)+T(?:-\\d{1,2}[UBGX])+$|^T(?:-\\d{1,2}[UBGX])+$/\n    if ( !(design ==~ valid_design) )  { error \"Invalid UMI/barcode design. Check https://isoseq.how/umi/umi-barcode-design.html for how to specify the design\" }\n    \"\"\"\n    isoseq \\\\\n        tag \\\\\n        -j $task.cpus \\\\\n        --design $design \\\\\n        ${prefix}.5p--3p.bam \\\\\n        ${prefix}.flt.bam \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        isoseq3: \\$(isoseq tag --version | head -n 1 | sed 's/isoseq tag //g' | sed 's/ (.*//g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.flt.bam\n    touch ${prefix}.flt.bam.pbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        isoseq3: \\$(isoseq tag --version | head -n 1 | sed 's/isoseq tag //g' | sed 's/ (.*//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge a list of sorted bam files\nTags: merge, bam", "answer": "process BIOBAMBAM_BAMMERGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/biobambam:2.0.183--h9f5acd7_1':\n        'biocontainers/biobambam:2.0.183--h9f5acd7_1' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\")  ,emit: bam\n    tuple val(meta), path(\"*.bai\")          ,optional:true, emit: bam_index\n    tuple val(meta), path(\"*.md5\")          ,optional:true, emit: checksum\n    path \"versions.yml\"                     ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_string = bam.join(\" I=\")\n\n    \"\"\"\n    bammerge \\\\\n        I=${input_string} \\\\\n        $args \\\\\n        > ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bammerge: \\$( bammerge --version |& sed '1!d; s/.*version //; s/.\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Locate and tag duplicate reads in a BAM file\nTags: markduplicates, bam, cram", "answer": "process BIOBAMBAM_BAMMARKDUPLICATES2 {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ? 'https://depot.galaxyproject.org/singularity/biobambam:2.0.183--h9f5acd7_1' : 'biocontainers/biobambam:2.0.183--h9f5acd7_1'}\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\")        , emit: bam\n    tuple val(meta), path(\"*.metrics.txt\"), emit: metrics\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bammarkduplicates2 \\\\\n        $args \\\\\n        I=$bam \\\\\n        O=${prefix}.bam \\\\\n        M=${prefix}.metrics.txt \\\\\n        tmpfile=$prefix \\\\\n        markthreads=$task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bammarkduplicates2: \\$(echo \\$(bammarkduplicates2 --version 2>&1) | sed 's/^This is biobambam2 version //; s/..biobambam2 is .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Parallel sorting and duplicate marking\nTags: markduplicates, sort, bam, cram", "answer": "process BIOBAMBAM_BAMSORMADUP {\n    tag \"$meta.id\"\n    label \"process_medium\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ? 'https://depot.galaxyproject.org/singularity/biobambam:2.0.183--h9f5acd7_1' : 'biocontainers/biobambam:2.0.183--h9f5acd7_1'}\"\n\n    input:\n    tuple val(meta) , path(bams, stageAs: \"?/*\")\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\")              ,optional:true, emit: bam\n    tuple val(meta), path(\"*.bam.bai\")          ,optional:true, emit: bam_index\n    tuple val(meta), path(\"*.cram\")             ,optional:true, emit: cram\n    tuple val(meta), path(\"*.metrics.txt\")      ,emit: metrics\n    path \"versions.yml\"                         ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = args.contains(\"outputformat=cram\") ? \"cram\" : \"bam\"\n    def input_string = bams instanceof List ? bams.join(\" I=\") : bams\n    if (args.contains(\"outputformat=cram\") && reference == null) error \"Reference required for CRAM output.\"\n\n    \"\"\"\n    bamcat \\\\\n        I=${input_string} \\\\\n        level=0 \\\\\n    | bamcollate2 \\\\\n        level=0 \\\\\n        $args2 \\\\\n    | bamsormadup \\\\\n        $args \\\\\n        M=${prefix}.metrics.txt \\\\\n        tmpfile=$prefix \\\\\n        threads=$task.cpus \\\\\n        > ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamcat: \\$(echo \\$(bamcat --version 2>&1) | sed 's/^This is biobambam2 version //; s/..biobambam2 is .*\\$//' )\n        bamcollate2: \\$(echo \\$(bamcollate2 --version 2>&1) | sed 's/^This is biobambam2 version //; s/..biobambam2 is .*\\$//' )\n        bamsormadup: \\$(echo \\$(bamsormadup --version 2>&1) | sed 's/^This is biobambam2 version //; s/..biobambam2 is .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: uLTRA aligner - A wrapper around minimap2 to improve small exon detection\nTags: uLTRA, index, minimap2, long_read, isoseq, ont", "answer": "process ULTRA_PIPELINE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ultra_bioinformatics:0.1--pyh7cba7a3_1':\n        'biocontainers/ultra_bioinformatics:0.1--pyh7cba7a3_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path genome\n    path gtf\n\n    output:\n    tuple val(meta), path(\"*.sam\"), emit: sam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    uLTRA \\\\\n        pipeline \\\\\n        --t $task.cpus \\\\\n        --prefix $prefix \\\\\n        $args \\\\\n        $genome \\\\\n        $gtf \\\\\n        $reads \\\\\n        ./\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ultra: \\$( uLTRA --version|sed 's/uLTRA //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: uLTRA aligner - A wrapper around minimap2 to improve small exon detection - Map reads on genome\nTags: uLTRA, align, minimap2, long_read, isoseq, ont", "answer": "process ULTRA_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-4b749ef583d6de806ddbf51c2d235ac8c14763c6:c2c0cd48e7ed1cf3f365b421c7389d04e6bfa812-0':\n        'biocontainers/mulled-v2-4b749ef583d6de806ddbf51c2d235ac8c14763c6:c2c0cd48e7ed1cf3f365b421c7389d04e6bfa812-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path genome\n    tuple path(pickle), path(db)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    uLTRA \\\\\n        align \\\\\n        --t $task.cpus \\\\\n        --prefix $prefix \\\\\n        --index ./ \\\\\n        $args \\\\\n        $genome \\\\\n        $reads \\\\\n        ./\n\n    samtools \\\\\n        sort \\\\\n        --threads $task.cpus \\\\\n        -o ${prefix}.bam \\\\\n        -O BAM \\\\\n        $args2 \\\\\n        ${prefix}.sam\n\n    rm ${prefix}.sam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ultra: \\$( uLTRA --version|sed 's/uLTRA //g' )\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: uLTRA aligner - A wrapper around minimap2 to improve small exon detection - Index gtf file for reads alignment\nTags: uLTRA, index, minimap2, long_read, isoseq, ont", "answer": "process ULTRA_INDEX {\n    tag \"$gtf\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ultra_bioinformatics:0.1--pyh7cba7a3_1':\n        'biocontainers/ultra_bioinformatics:0.1--pyh7cba7a3_1' }\"\n\n    input:\n    path fasta\n    path gtf\n\n    output:\n    tuple path(\"*.pickle\"), path(\"*.db\"), emit: index\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}\"\n    \"\"\"\n    uLTRA \\\\\n        index \\\\\n        $args \\\\\n        $fasta \\\\\n        $gtf \\\\\n        ./\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ultra: \\$( uLTRA --version|sed 's/uLTRA //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Severus is a somatic structural variation (SV) caller for long reads (both PacBio and ONT)\nTags: structural, variation, somatic, germline, long-read", "answer": "process SEVERUS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/severus:1.1--pyhdfd78af_0':\n        'biocontainers/severus:1.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(target_input), path(target_index), path(control_input), path(control_index), path(vcf)\n    tuple val(meta2), path(bed)\n\n    output:\n    tuple val(meta), path(\"${prefix}/severus.log\")                              , emit: log\n    tuple val(meta), path(\"${prefix}/read_qual.txt\")                            , emit: read_qual\n    tuple val(meta), path(\"${prefix}/breakpoints_double.csv\")                   , emit: breakpoints_double\n    tuple val(meta), path(\"${prefix}/read_alignments\")                          , emit: read_alignments                  , optional: true\n    tuple val(meta), path(\"${prefix}/read_ids.csv\")                             , emit: read_ids                         , optional: true\n    tuple val(meta), path(\"${prefix}/severus_collaped_dup.bed\")                 , emit: collapsed_dup                    , optional: true\n    tuple val(meta), path(\"${prefix}/severus_LOH.bed\")                          , emit: loh                              , optional: true\n    tuple val(meta), path(\"${prefix}/all_SVs/severus_all.vcf\")                  , emit: all_vcf                          , optional: true\n    tuple val(meta), path(\"${prefix}/all_SVs/breakpoints_clusters_list.tsv\")    , emit: all_breakpoints_clusters_list    , optional: true\n    tuple val(meta), path(\"${prefix}/all_SVs/breakpoints_clusters.tsv\")         , emit: all_breakpoints_clusters         , optional: true\n    tuple val(meta), path(\"${prefix}/all_SVs/plots/severus_*.html\")             , emit: all_plots                        , optional: true\n    tuple val(meta), path(\"${prefix}/somatic_SVs/severus_all.vcf\")              , emit: somatic_vcf                      , optional: true\n    tuple val(meta), path(\"${prefix}/somatic_SVs/breakpoints_clusters_list.tsv\"), emit: somatic_breakpoints_clusters_list, optional: true\n    tuple val(meta), path(\"${prefix}/somatic_SVs/breakpoints_clusters.tsv\")     , emit: somatic_breakpoints_clusters     , optional: true\n    tuple val(meta), path(\"${prefix}/somatic_SVs/plots/severus_*.html\")         , emit: somatic_plots                    , optional: true\n    path \"versions.yml\"                                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def control = control_input ? \"--control-bam ${control_input}\" : \"\"\n    def vntr_bed = bed ? \"--vntr-bed ${bed}\" : \"\"\n    def phasing_vcf = vcf ? \"--phasing-vcf ${vcf}\" : \"\"\n    \"\"\"\n    severus \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --target-bam $target_input \\\\\n        $vntr_bed \\\\\n        $control \\\\\n        $phasing_vcf \\\\\n        --out-dir ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        severus: \\$(severus --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mkdir -p ${prefix}/all_SVs/plots\n    mkdir -p ${prefix}/somatic_SVs/plots\n\n    touch ${prefix}/severus_collaped_dup.bed\n    touch ${prefix}/severus.log\n    touch ${prefix}/severus_LOH.bed\n    touch ${prefix}/read_alignments\n    touch ${prefix}/read_ids.csv\n    touch ${prefix}/read_qual.txt\n    touch ${prefix}/breakpoints_double.csv\n    touch ${prefix}/all_SVs/severus_all.vcf\n    touch ${prefix}/all_SVs/breakpoints_clusters_list.tsv\n    touch ${prefix}/all_SVs/breakpoints_clusters.tsv\n    touch ${prefix}/all_SVs/plots/severus_0.html\n    touch ${prefix}/all_SVs/plots/severus_1.html\n    touch ${prefix}/somatic_SVs/severus_somatic.vcf\n    touch ${prefix}/somatic_SVs/breakpoints_clusters_list.tsv\n    touch ${prefix}/somatic_SVs/breakpoints_clusters.tsv\n    touch ${prefix}/somatic_SVs/plots/severus_0.html\n    touch ${prefix}/somatic_SVs/plots/severus_1.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        severus: \\$(severus --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The pbbam software package provides components to create, query, & edit PacBio BAM files and associated indices. These components include a core C++ library, bindings for additional languages, and command-line utilities.\nTags: pbbam, pbbam/pbmerge", "answer": "process PBBAM_PBMERGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pbbam:2.1.0--h3f0f298_2' :\n        'biocontainers/pbbam:2.1.0--h3f0f298_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path(\"*.pbi\"), emit: pbi\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pbmerge \\\\\n        -o ${prefix}.bam \\\\\n        $args \\\\\n        *.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pbbam: \\$( pbmerge --version | head -n1 | sed 's/pbmerge //' | sed -E 's/ .+//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Genotype structural variants using paragraph and grmpy\nTags: vcf, json, structural variants, graphs, genotyping", "answer": "process PARAGRAPH_MULTIGRMPY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/paragraph:2.3--h21f15d8_1':\n        'biocontainers/paragraph:2.3--h21f15d8_1' }\"\n\n    input:\n    tuple val(meta), path(variants), path(variants_index), path(reads), path(reads_index), path(manifest)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")   , emit: vcf\n    tuple val(meta), path(\"*.json.gz\")  , emit: json, optional:true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def check_vcf = variants.name.endsWith(\".vcf.gz\") ? \"variant=\\$(bgzip -d --threads ${task.cpus} --stdout ${variants} | awk '/^#/ {next} {print 1;exit}' || echo 0)\":\n                    variants.extension == \"vcf\" ? \"variant=\\$(cat ${variants} | awk '/^#/ {next} {print 1;exit}' || echo 0)\":\n                    \"variant=1\"\n\n    if (\"${variants}\" == \"${prefix}.vcf.gz\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    if (\"${variants}\" == \"${prefix}.json.gz\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    ${check_vcf}\n\n    if [ \\$variant -eq 1 ]\n    then\n        multigrmpy.py \\\\\n            --input ${variants} \\\\\n            --manifest ${manifest} \\\\\n            --output ${prefix} \\\\\n            --reference ${fasta} \\\\\n            --threads ${task.cpus} \\\\\n            ${args}\n\n        mv ${prefix}/genotypes.vcf.gz ${prefix}.vcf.gz\n        mv ${prefix}/genotypes.json.gz ${prefix}.json.gz\n    else\n        echo \"${variants} was empty, so the multigrmpy.py process was skipped.\"\n        cp ${variants} ${prefix}.vcf.gz\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paragraph: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    if (\"${variants}\" == \"${prefix}.vcf.gz\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    if (\"${variants}\" == \"${prefix}.json.gz\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.json.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paragraph: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert a VCF file to a JSON graph\nTags: vcf, json, structural_variants", "answer": "process PARAGRAPH_VCF2PARAGRAPH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/paragraph:2.3--h21f15d8_1':\n        'biocontainers/paragraph:2.3--h21f15d8_1' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.json.gz\")  , emit: graph\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def VERSION = '2.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    vcf2paragraph.py \\\\\n        ${args} \\\\\n        --reference-sequence ${fasta} \\\\\n        ${vcf} \\\\\n        ${prefix}.json\n\n    bgzip --threads ${task.cpus} ${args2} ${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paragraph: ${VERSION}\n        bgzip: \\$(echo \\$(bgzip -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def VERSION = '2.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.json.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paragraph: ${VERSION}\n        bgzip: \\$(echo \\$(bgzip -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Determines the depth in a BAM/CRAM file\nTags: bam, cram, depth, paragraph", "answer": "process PARAGRAPH_IDXDEPTH {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/paragraph:2.3--h8908b6f_0':\n        'biocontainers/paragraph:2.3--h8908b6f_0' }\"\n\n    input:\n    tuple val(meta) , path(input), path(input_index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.json\") , emit: depth\n    tuple val(meta), path(\"*.tsv\")  , emit: binned_depth, optional:true\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def VERSION = '2.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def type = input.extension\n    def output_bins = type == \"cram\" ? \"--output-bins ${prefix}.tsv\" : \"\"\n    \"\"\"\n    idxdepth \\\\\n        --bam ${input} \\\\\n        --reference ${fasta} \\\\\n        --threads ${task.cpus} \\\\\n        --output ${prefix}.json \\\\\n        ${output_bins} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paragraph: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def VERSION = '2.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def type = input.extension\n    def output_bins = type == \"cram\" ? \"touch ${prefix}.tsv\" : \"\"\n    \"\"\"\n    touch ${prefix}.json\n    ${output_bins}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paragraph: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: barrnap uses a hmmer profile to find rrnas in reads or contig fasta files\nTags: rrna, sequences, removal", "answer": "process BARRNAP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/barrnap:0.9--hdfd78af_4':\n        'biocontainers/barrnap:0.9--hdfd78af_4' }\"\n\n    input:\n    tuple val(meta), path(fasta), val(dbname)\n\n    output:\n    tuple val(meta), path(\"*.gff\"), emit: gff\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    db         = dbname ? \"${dbname}\" : 'bac'\n    input    = fasta =~ /\\.gz$/ ? fasta.name.take(fasta.name.lastIndexOf('.')) : fasta\n    gunzip   = fasta =~ /\\.gz$/ ? \"gunzip -c ${fasta} > ${input}\" : \"\"\n\n    \"\"\"\n    $gunzip\n\n    barrnap \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --kingdom $db \\\\\n        $input \\\\\n        > ${prefix}_${db}.gff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        barrnap: \\$(echo \\$(barrnap --version 2>&1) | sed 's/barrnap//; s/Using.*\\$//' )\n    END_VERSIONS\n\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    db = dbname ? \"${dbname}\" : 'bac'\n    \"\"\"\n    touch ${prefix}_${db}.gff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        barrnap: \\$(echo \\$(barrnap --version 2>&1) | sed 's/barrnap//; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Align RNA-Seq reads to a reference with HISAT2\nTags: align, fasta, genome, reference", "answer": "process HISAT2_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-a97e90b3b802d1da3d6958e0867610c718cb5eb1:2cdf6bf1e92acbeb9b2834b1c58754167173a410-0' :\n        'biocontainers/mulled-v2-a97e90b3b802d1da3d6958e0867610c718cb5eb1:2cdf6bf1e92acbeb9b2834b1c58754167173a410-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(index)\n    tuple val(meta3), path(splicesites)\n\n    output:\n    tuple val(meta), path(\"*.bam\")                   , emit: bam\n    tuple val(meta), path(\"*.log\")                   , emit: summary\n    tuple val(meta), path(\"*fastq.gz\"), optional:true, emit: fastq\n    path  \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.2.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def strandedness = ''\n    if (meta.strandedness == 'forward') {\n        strandedness = meta.single_end ? '--rna-strandness F' : '--rna-strandness FR'\n    } else if (meta.strandedness == 'reverse') {\n        strandedness = meta.single_end ? '--rna-strandness R' : '--rna-strandness RF'\n    }\n    ss = \"$splicesites\" ? \"--known-splicesite-infile $splicesites\" : ''\n    def seq_center = params.seq_center ? \"--rg-id ${prefix} --rg SM:$prefix --rg CN:${params.seq_center.replaceAll('\\\\s','_')}\" : \"--rg-id ${prefix} --rg SM:$prefix\"\n    if (meta.single_end) {\n        def unaligned = params.save_unaligned ? \"--un-gz ${prefix}.unmapped.fastq.gz\" : ''\n        \"\"\"\n        INDEX=`find -L ./ -name \"*.1.ht2\" | sed 's/\\\\.1.ht2\\$//'`\n        hisat2 \\\\\n            -x \\$INDEX \\\\\n            -U $reads \\\\\n            $strandedness \\\\\n            $ss \\\\\n            --summary-file ${prefix}.hisat2.summary.log \\\\\n            --threads $task.cpus \\\\\n            $seq_center \\\\\n            $unaligned \\\\\n            $args \\\\\n            | samtools view -bS -F 4 -F 256 - > ${prefix}.bam\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            hisat2: $VERSION\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        def unaligned = params.save_unaligned ? \"--un-conc-gz ${prefix}.unmapped.fastq.gz\" : ''\n        \"\"\"\n        INDEX=`find -L ./ -name \"*.1.ht2\" | sed 's/\\\\.1.ht2\\$//'`\n        hisat2 \\\\\n            -x \\$INDEX \\\\\n            -1 ${reads[0]} \\\\\n            -2 ${reads[1]} \\\\\n            $strandedness \\\\\n            $ss \\\\\n            --summary-file ${prefix}.hisat2.summary.log \\\\\n            --threads $task.cpus \\\\\n            $seq_center \\\\\n            $unaligned \\\\\n            --no-mixed \\\\\n            --no-discordant \\\\\n            $args \\\\\n            | samtools view -bS -F 4 -F 8 -F 256 - > ${prefix}.bam\n\n        if [ -f ${prefix}.unmapped.fastq.1.gz ]; then\n            mv ${prefix}.unmapped.fastq.1.gz ${prefix}.unmapped_1.fastq.gz\n        fi\n        if [ -f ${prefix}.unmapped.fastq.2.gz ]; then\n            mv ${prefix}.unmapped.fastq.2.gz ${prefix}.unmapped_2.fastq.gz\n        fi\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            hisat2: $VERSION\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def unaligned = params.save_unaligned ? \"echo '' | gzip >  ${prefix}.unmapped_1.fastq.gz \\n echo '' | gzip >  ${prefix}.unmapped_2.fastq.gz\" : ''\n    def VERSION = '2.2.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    ${unaligned}\n\n    touch ${prefix}.hisat2.summary.log\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hisat2: $VERSION\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n\n}\n"}
{"question": "Description: Builds HISAT2 index for reference genome\nTags: build, index, fasta, genome, reference", "answer": "process HISAT2_BUILD {\n    tag \"$fasta\"\n    label 'process_high'\n    label 'process_high_memory'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hisat2:2.2.1--h1b792b2_3' :\n        'biocontainers/hisat2:2.2.1--h1b792b2_3' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(gtf)\n    tuple val(meta3), path(splicesites)\n\n    output:\n    tuple val(meta), path(\"hisat2\") , emit: index\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def avail_mem = 0\n    if (!task.memory) {\n        log.info \"[HISAT2 index build] Available memory not known - defaulting to 0. Specify process memory requirements to change this.\"\n    } else {\n        log.info \"[HISAT2 index build] Available memory: ${task.memory}\"\n        avail_mem = task.memory.toGiga()\n    }\n\n    def ss = ''\n    def exon = ''\n    def extract_exons = ''\n    def hisat2_build_memory = params.hisat2_build_memory ? (params.hisat2_build_memory as nextflow.util.MemoryUnit).toGiga() : 0\n    if (avail_mem >= hisat2_build_memory) {\n        log.info \"[HISAT2 index build] At least ${hisat2_build_memory} GB available, so using splice sites and exons to build HISAT2 index\"\n        extract_exons = gtf ? \"hisat2_extract_exons.py $gtf > ${gtf.baseName}.exons.txt\" : \"\"\n        ss = splicesites ? \"--ss $splicesites\" : \"\"\n        exon = gtf ? \"--exon ${gtf.baseName}.exons.txt\" : \"\"\n    } else {\n        log.info \"[HISAT2 index build] Less than ${hisat2_build_memory} GB available, so NOT using splice sites and exons to build HISAT2 index.\"\n        log.info \"[HISAT2 index build] Use --hisat2_build_memory [small number] to skip this check.\"\n    }\n    def VERSION = '2.2.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    mkdir hisat2\n    $extract_exons\n    hisat2-build \\\\\n        -p $task.cpus \\\\\n        $ss \\\\\n        $exon \\\\\n        $args \\\\\n        $fasta \\\\\n        hisat2/${fasta.baseName}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hisat2: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def VERSION = '2.2.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    mkdir hisat2\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hisat2: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extracts splicing sites from a gtf files\nTags: splicing, gtf, genome, reference", "answer": "process HISAT2_EXTRACTSPLICESITES {\n    tag \"$gtf\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hisat2:2.2.1--h1b792b2_3' :\n        'biocontainers/hisat2:2.2.1--h1b792b2_3' }\"\n\n    input:\n    tuple val(meta), path(gtf)\n\n    output:\n    tuple val(meta), path(\"*.splice_sites.txt\"), emit: txt\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def VERSION = '2.2.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    hisat2_extract_splice_sites.py $gtf > ${gtf.baseName}.splice_sites.txt\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hisat2: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def VERSION = '2.2.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${gtf.baseName}.splice_sites.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hisat2: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: NCBI tool for detecting vector contamination in nucleic acid sequences. This tool is older than NCBI's FCS-adaptor, which is for the same purpose\nTags: assembly, genomics, quality control, contamination, vector, NCBI", "answer": "process NCBITOOLS_VECSCREEN {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"docker.io/biocontainers/ncbi-tools-bin:6.1.20170106-6-deb_cv2\"\n\n    input:\n    tuple val(meta), path(fasta_file)\n    tuple val(adapters_database_meta), path(adapters_database_directory)\n\n    output:\n    tuple val(meta), path(\"${meta.id}.vecscreen.out\")    , emit: vecscreen_output\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"The VecScreen module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // WARN: VecScreen doesn't output a version number and doesn't appear to have a Github repository. 1.0 is arbitrarily used here as the version number\n    \"\"\"\n    DB=`find -L ${adapters_database_directory} -maxdepth 1 -name \"*.nin\" | sed 's/\\\\.nin\\$//'`\n    vecscreen -d \\$DB ${args} -i ${fasta_file} -o ${prefix}.vecscreen.out\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vecscreen: 1.0\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // WARN: VecScreen doesn't output a version number and doesn't appear to have a Github repository. 1.0 is arbitrarily used here as the version number\n    \"\"\"\n    touch ${prefix}.vecscreen.out\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vecscreen: 1.0\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: smoove simplifies and speeds calling and genotyping SVs for short reads. It also improves specificity by removing many spurious alignment signals that are indicative of low-level noise and often contribute to spurious calls. Developped by Brent Pedersen.\nTags: structural variants, SV, vcf, wgs", "answer": "process SMOOVE_CALL {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/smoove:0.2.8--h9ee0642_1' :\n        'biocontainers/smoove:0.2.8--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(input), path(index), path(exclude_beds)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def exclude = exclude_beds ? \"--exclude ${exclude_beds}\" : \"\"\n    \"\"\"\n    smoove call \\\\\n        ${args} \\\\\n        --outdir . \\\\\n        --name ${prefix} \\\\\n        --fasta ${fasta} \\\\\n        ${exclude} \\\\\n        --processes ${task.cpus} \\\\\n        ${input}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        smoove: \\$(echo \\$(smoove -v) | sed 's/^.*version: //; s/ .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        smoove: \\$(echo \\$(smoove -v) | sed 's/^.*version: //; s/ .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This script merge different gff annotation files in one. It uses the AGAT parser that takes care of duplicated names and fixes other oddities met in those files.\n\nTags: genomics, gff, merge, combine", "answer": "process AGAT_SPMERGEANNOTATIONS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agat:1.4.0--pl5321hdfd78af_0':\n        'biocontainers/agat:1.4.0--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gffs)\n    path config\n\n    output:\n    tuple val(meta), path(\"*.gff\")  , emit: gff\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args            = task.ext.args ?: ''\n    def prefix          = task.ext.prefix ?: \"${meta.id}\"\n    def config_param    = config ? \"--config $config\" : ''\n    def file_names      = \"$gffs\".split(' ')\n    def gff_param       = file_names.collect { \"--gff $it\" }.join(' ')\n    if ( file_names.contains ( \"${prefix}.gff\" ) ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    agat_sp_merge_annotations.pl \\\\\n        $gff_param \\\\\n        $config_param \\\\\n        $args \\\\\n        --output ${prefix}.gff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sp_merge_annotations.pl -h | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def file_names      = \"$gffs\".split(' ')\n    if ( file_names.contains ( \"${prefix}.gff\" ) ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.gff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sp_merge_annotations.pl -h | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Fixes and standardizes GFF/GTF files and outputs a cleaned GFF/GTF file\n\nTags: genome, gff, gtf, conversion", "answer": "process AGAT_CONVERTSPGXF2GXF {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agat:1.4.0--pl5321hdfd78af_0' :\n        'biocontainers/agat:1.4.0--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gxf)\n\n    output:\n    tuple val(meta), path(\"*.agat.gff\") , emit: output_gff\n    tuple val(meta), path(\"*.log\")      , emit: log\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    agat_convert_sp_gxf2gxf.pl \\\\\n        --gxf $gxf \\\\\n        --output ${prefix}.agat.gff \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_convert_sp_gxf2gxf.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.agat.gff\n    touch ${gxf}.agat.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_convert_sp_gxf2gxf.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Provides different type of statistics in text format from a GFF/GTF annotation file\n\nTags: genome, gff, gtf, statistics", "answer": "process AGAT_SPSTATISTICS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agat:1.4.0--pl5321hdfd78af_0' :\n        'biocontainers/agat:1.4.0--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: stats_txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    agat_sp_statistics.pl \\\\\n        --gff $gff \\\\\n        --output ${prefix}.stats.txt \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sp_statistics.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.stats.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sp_statistics.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a GFF/GTF file into a TSV file\n\nTags: genome, gff, gtf, conversion, tsv", "answer": "process AGAT_CONVERTSPGFF2TSV {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agat:1.4.0--pl5321hdfd78af_0' :\n        'biocontainers/agat:1.4.0--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    agat_convert_sp_gff2tsv.pl \\\\\n        --gff $gff \\\\\n        --output ${prefix}.tsv \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_convert_sp_gff2tsv.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_convert_sp_gff2tsv.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a GFF/GTF file into a proper GTF file\n\nTags: genome, gff, gtf, conversion", "answer": "process AGAT_CONVERTSPGFF2GTF {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agat:1.4.0--pl5321hdfd78af_0' :\n        'biocontainers/agat:1.4.0--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff)\n\n    output:\n    tuple val(meta), path(\"*.agat.gtf\"), emit: output_gtf\n    tuple val(meta), path(\"*.log\"), emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    agat_convert_sp_gff2gtf.pl \\\\\n        --gff $gff \\\\\n        --output ${prefix}.agat.gtf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_convert_sp_gff2gtf.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.agat.gtf\n    touch ${gff}.agat.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_convert_sp_gff2gtf.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Add intron features to gtf/gff file without intron features.\nTags: gtf, gff, introns", "answer": "process AGAT_SPADDINTRONS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agat:1.4.0--pl5321hdfd78af_0':\n        'biocontainers/agat:1.4.0--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff)\n    path config\n\n    output:\n    tuple val(meta), path(\"${output}\"), emit: gff\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def config_param = config ? \"--config $config\" : \"\"\n    def prefix = meta.id ?: gff.getBaseName()\n    output = \"${prefix}.intron.gff\"\n    \"\"\"\n    agat_sp_add_introns.pl \\\\\n        --gff $gff \\\\\n        $config_param \\\\\n        --out $output \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sp_add_introns.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = meta.id ?: gff.getBaseName()\n    output = \"${prefix}.intron.gff\"\n    \"\"\"\n    touch ${output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sp_add_introns.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The script aims to remove features based on a kill list. The default behaviour is to look at the features's ID.\nIf the feature has an ID (case insensitive) listed among the kill list it will be removed. /!\\ Removing a level1\nor level2 feature will automatically remove all linked subfeatures, and removing all children of a feature will\nautomatically remove this feature too.\n\nTags: genomics, gff, remove, feature", "answer": "process AGAT_SPFILTERFEATUREFROMKILLLIST {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agat:1.4.0--pl5321hdfd78af_0':\n        'biocontainers/agat:1.4.0--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff)\n    path kill_list\n    path config\n\n    output:\n    tuple val(meta), path(\"*.gff\"), emit: gff\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args            = task.ext.args ?: ''\n    def prefix          = task.ext.prefix ?: \"${meta.id}\"\n    def config_param    = config ? \"--config $config\" : ''\n    if( \"$gff\" == \"${prefix}.gff\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    agat_sp_filter_feature_from_kill_list.pl \\\\\n        --gff $gff \\\\\n        --kill_list $kill_list \\\\\n        $config_param \\\\\n        $args \\\\\n        --output \"${prefix}.gff\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sp_filter_feature_from_kill_list.pl -h | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args            = task.ext.args ?: ''\n    def prefix          = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$gff\" == \"${prefix}.gff\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch \"${prefix}.gff\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sp_filter_feature_from_kill_list.pl -h | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Provides basic statistics in text format from a GFF/GTF annotation file\n\nTags: genome, gff, gtf, statistics", "answer": "process AGAT_SQSTATBASIC {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agat:1.4.0--pl5321hdfd78af_0' :\n        'biocontainers/agat:1.4.0--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: stats_txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    agat_sq_stat_basic.pl \\\\\n        -i $gff \\\\\n        --output ${prefix}.stats.txt \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sq_stat_basic.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.stats.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agat: \\$(agat_sq_stat_basic.pl --help | sed -n 's/.*(AGAT) - Version: \\\\(.*\\\\) .*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: run the Broad Gene Set Enrichment tool in GSEA mode\nTags: gene set analysis, enrichment, gsea, gene set", "answer": "process GSEA_GSEA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gsea:4.3.2--hdfd78af_0':\n        'biocontainers/gsea:4.3.2--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gct), path(cls), path(gene_sets)\n    tuple val(reference), val(target)\n    path(chip) // Optional identifier mapping file\n\n    output:\n    tuple val(meta), path(\"*.rpt\")                             , emit: rpt\n    tuple val(meta), path(\"*index.html\")                       , emit: index_html\n    tuple val(meta), path(\"*heat_map_corr_plot.html\")          , emit: heat_map_corr_plot\n    tuple val(meta), path(\"*gsea_report_for_${reference}.tsv\") , emit: report_tsvs_ref\n    tuple val(meta), path(\"*gsea_report_for_${reference}.html\"), emit: report_htmls_ref\n    tuple val(meta), path(\"*gsea_report_for_${target}.tsv\")    , emit: report_tsvs_target\n    tuple val(meta), path(\"*gsea_report_for_${target}.html\")   , emit: report_htmls_target\n    tuple val(meta), path(\"*ranked_gene_list*.tsv\")            , emit: ranked_gene_list\n    tuple val(meta), path(\"*gene_set_sizes.tsv\")               , emit: gene_set_sizes\n    tuple val(meta), path(\"*global_es_histogram.png\")          , emit: histogram\n    tuple val(meta), path(\"*heat_map_1.png\")                   , emit: heatmap\n    tuple val(meta), path(\"*pvalues_vs_nes_plot.png\")          , emit: pvalues_vs_nes_plot\n    tuple val(meta), path(\"*ranked_list_corr_2.png\")           , emit: ranked_list_corr\n    tuple val(meta), path(\"*butterfly_plot.png\")               , emit: butterfly_plot, optional: true\n    tuple val(meta), path(\"*[!gene_set_size|gsea_report|ranked_gene_list]*.tsv\"), emit: gene_set_tsv, optional: true\n    tuple val(meta), path(\"*[!gsea_report|heat_map_corr_plot|index|pos_snapshot|neg_snapshot]*.html\"), emit: gene_set_html, optional: true\n    tuple val(meta), path(\"*[!butterfly|enplot|global_es_histogram|gset_rnd_es_dist|heat_map|pvalues_vs_nes_plot|ranked_list_corr]*.png\"), emit: gene_set_heatmap, optional: true\n    tuple val(meta), path(\"*_snapshot*.html\")                  , emit: snapshot, optional: true\n    tuple val(meta), path(\"*enplot*.png\")                      , emit: gene_set_enplot, optional: true\n    tuple val(meta), path(\"*gset_rnd_es_dist*.png\")            , emit: gene_set_dist, optional: true\n    tuple val(meta), path(\"*.zip\")                             , emit: archive, optional: true\n    path \"versions.yml\"                                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def VERSION = '4.3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    // Remove any trailing dots from prefix when passed as report label, so\n    // GSEA doesn't produce double-dotted top-level outputs\n    def rpt_label = prefix.replaceAll('\\\\.$', '')\n\n    def chip_command = chip ? \"-chip $chip -collapse true\" : ''\n    \"\"\"\n    # Run GSEA\n\n    gsea-cli GSEA \\\\\n        -res $gct \\\\\n        -cls ${cls}#${target}_versus_${reference} \\\\\n        -gmx $gene_sets \\\\\n        $chip_command \\\\\n        -out . \\\\\n        --rpt_label $rpt_label \\\\\n        $args\n\n    # Un-timestamp the outputs for path consistency\n    mv ${rpt_label}.Gsea.*/* .\n    timestamp=\\$(cat *.rpt | grep producer_timestamp | awk '{print \\$2}')\n\n    for pattern in _\\${timestamp} .\\${timestamp}; do\n        find . -name \"*\\${pattern}*\" | sed \"s|^\\\\./||\" | while read -r f; do\n            mv \\$f \\${f//\\$pattern/}\n        done\n    done\n    sed -i.bak \"s/[_\\\\.]\\$timestamp//g\" *.rpt *.html && rm *.bak\n\n    # Prefix files that currently lack it\n    ls -p | grep -v / | grep -v \"$prefix\" | while read -r f; do\n        mv \\$f ${prefix}\\${f}\n        sed -i.bak \"s/\\$f/${prefix}\\${f}/g\" *.rpt *.html && rm *.bak\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gsea: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Classifies metagenomic sequence data\nTags: classify, metagenomics, fastq, db", "answer": "process CENTRIFUGE_CENTRIFUGE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/centrifuge:1.0.4.1--hdcf5f25_1' :\n        'biocontainers/centrifuge:1.0.4.1--hdcf5f25_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path db\n    val save_unaligned\n    val save_aligned\n\n    output:\n    tuple val(meta), path('*report.txt')                 , emit: report\n    tuple val(meta), path('*results.txt')                , emit: results\n    tuple val(meta), path('*.{sam,tab}')                 , optional: true, emit: sam\n    tuple val(meta), path('*.mapped.fastq{,.1,.2}.gz')   , optional: true, emit: fastq_mapped\n    tuple val(meta), path('*.unmapped.fastq{,.1,.2}.gz') , optional: true, emit: fastq_unmapped\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def paired = meta.single_end ? \"-U ${reads}\" :  \"-1 ${reads[0]} -2 ${reads[1]}\"\n    def unaligned = ''\n    def aligned = ''\n    if (meta.single_end) {\n        unaligned = save_unaligned ? \"--un-gz ${prefix}.unmapped.fastq.gz\" : ''\n        aligned = save_aligned ? \"--al-gz ${prefix}.mapped.fastq.gz\" : ''\n    } else {\n        unaligned = save_unaligned ? \"--un-conc-gz ${prefix}.unmapped.fastq.gz\" : ''\n        aligned = save_aligned ? \"--al-conc-gz ${prefix}.mapped.fastq.gz\" : ''\n    }\n    \"\"\"\n    ## we add \"-no-name ._\" to ensure silly Mac OSX metafiles files aren't included\n    db_name=`find -L ${db} -name \"*.1.cf\" -not -name \"._*\"  | sed 's/\\\\.1.cf\\$//'`\n\n    ## make a directory for placing the pipe files in somewhere other than default /tmp\n    ## otherwise get pipefile name clashes when multiple centrifuge runs on same node\n    ## use /tmp at the same time\n    mkdir ./temp\n\n    centrifuge \\\\\n        -x \\$db_name \\\\\n        --temp-directory ./temp \\\\\n        -p $task.cpus \\\\\n        $paired \\\\\n        --report-file ${prefix}.report.txt \\\\\n        -S ${prefix}.results.txt \\\\\n        $unaligned \\\\\n        $aligned \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        centrifuge: \\$( centrifuge --version  | sed -n 1p | sed 's/^.*centrifuge-class version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def paired = meta.single_end ? \"-U ${reads}\" :  \"-1 ${reads[0]} -2 ${reads[1]}\"\n    def unaligned = ''\n    def aligned = ''\n    if (meta.single_end) {\n        unaligned = save_unaligned ? \"--un-gz ${prefix}.unmapped.fastq.gz\" : ''\n        aligned = save_aligned ? \"--al-gz ${prefix}.mapped.fastq.gz\" : ''\n    } else {\n        unaligned = save_unaligned ? \"--un-conc-gz ${prefix}.unmapped.fastq.gz\" : ''\n        aligned = save_aligned ? \"--al-conc-gz ${prefix}.mapped.fastq.gz\" : ''\n    }\n    \"\"\"\n    touch ${prefix}.report.txt\n    touch ${prefix}.results.txt\n    touch ${prefix}.sam\n    echo | gzip -n > ${prefix}.unmapped.fastq.gz\n    echo | gzip -n > ${prefix}.mapped.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        centrifuge: \\$( centrifuge --version  | sed -n 1p | sed 's/^.*centrifuge-class version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates Kraken-style reports from centrifuge out files\nTags: classify, metagenomics, fastq, db, report, kraken", "answer": "process CENTRIFUGE_KREPORT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/centrifuge:1.0.4.1--hdcf5f25_1' :\n        'biocontainers/centrifuge:1.0.4.1--hdcf5f25_1' }\"\n\n    input:\n    tuple val(meta), path(report)\n    path db\n\n    output:\n    tuple val(meta), path('*.txt'), emit: kreport\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    db_name=`find -L ${db} -name \"*.1.cf\" -not -name \"._*\"  | sed 's/\\\\.1.cf\\$//'`\n    centrifuge-kreport -x \\$db_name ${report} > ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        centrifuge: \\$( centrifuge --version  | sed -n 1p | sed 's/^.*centrifuge-class version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        centrifuge: \\$( centrifuge --version  | sed -n 1p | sed 's/^.*centrifuge-class version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Build centrifuge database for taxonomic profiling\nTags: database, metagenomics, build, db, fasta", "answer": "process CENTRIFUGE_BUILD {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/centrifuge:1.0.4.1--hdcf5f25_1' :\n        'biocontainers/centrifuge:1.0.4.1--hdcf5f25_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path conversion_table\n    path taxonomy_tree\n    path name_table\n    path size_table\n\n    output:\n    tuple val(meta), path(\"*.cf\") , emit: cf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def size_table_cmd = size_table ? \"--size_table ${size_table}\" : \"\"\n    \"\"\"\n    centrifuge-build \\\\\n        -p $task.cpus \\\\\n        $fasta \\\\\n        ${prefix} \\\\\n        --conversion-table $conversion_table \\\\\n        --taxonomy-tree $taxonomy_tree \\\\\n        --name-table $name_table \\\\\n        ${size_table_cmd}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        centrifuge: \\$( centrifuge --version | sed -n 1p | sed 's/^.*centrifuge-class version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.1.cf\n    touch ${prefix}.2.cf\n    touch ${prefix}.3.cf\n    touch ${prefix}.4.cf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        centrifuge: \\$( centrifuge --version | sed -n 1p | sed 's/^.*centrifuge-class version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: \"Python C-extension for a simple validator for fasta files. The module emits the validated file or an\nerror log upon validation failure.\"\n\nTags: fasta, validation, genome", "answer": "process FASTAVALIDATOR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/py_fasta_validator:0.6--py37h595c7a6_0':\n        'biocontainers/py_fasta_validator:0.6--py37h595c7a6_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path('*.success.log')  , emit: success_log , optional: true\n    tuple val(meta), path('*.error.log')    , emit: error_log   , optional: true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    py_fasta_validator \\\\\n        -f $fasta \\\\\n        2> \"${prefix}.error.log\" \\\\\n        || echo \"Errors from fasta_validate printed to ${prefix}.error.log\"\n\n    if [ \\$(cat \"${prefix}.error.log\" | wc -l) -gt 0 ]; then\n        echo \"Validation failed...\"\n\n        cat \\\\\n            \"${prefix}.error.log\"\n    else\n        echo \"Validation successful...\"\n\n        mv \\\\\n            \"${prefix}.error.log\" \\\\\n            fasta_validate.stderr\n\n        echo \"Validation successful...\" \\\\\n            > \"${prefix}.success.log\"\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        py_fasta_validator: \\$(py_fasta_validator -v | sed 's/.* version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"Validation successful...\" \\\\\n        > \"${prefix}.success.log\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        py_fasta_validator: \\$(py_fasta_validator -v | sed 's/.* version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Index chain files for lift over\nTags: leviosam2, index, lift", "answer": "process LEVIOSAM2_INDEX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/leviosam2:0.4.2--h4ac6f70_0':\n        'biocontainers/leviosam2:0.4.2--h4ac6f70_0' }\"\n\n    input:\n    tuple val(meta), path(fai)\n    path(chain)\n\n    output:\n    tuple val(meta), path(\"*.clft\"), emit: clft\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    leviosam2 \\\\\n        index \\\\\n        -c ${chain} \\\\\n        -p ${prefix} \\\\\n        -F ${fai}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        leviosam2: \\$(leviosam2 --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.clft\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        leviosam2: \\$(leviosam2 --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converting aligned short and long reads records from one reference to another\nTags: leviosam2, index, lift", "answer": "process LEVIOSAM2_LIFT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/leviosam2:0.4.2--h4ac6f70_0':\n        'biocontainers/leviosam2:0.4.2--h4ac6f70_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    tuple val(meta_ref), path(clft)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    leviosam2 \\\\\n        lift \\\\\n        -t ${task.cpus} \\\\\n        -C ${clft} \\\\\n        -a ${input} \\\\\n        -p ${prefix} \\\\\n        -O bam \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        leviosam2: \\$(leviosam2 --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        leviosam2: \\$(leviosam2 --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Randomly subsample sequencing reads to a specified coverage\nTags: coverage, depth, subsampling", "answer": "process RASUSA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rasusa:0.3.0--h779adbc_1' :\n        'biocontainers/rasusa:0.3.0--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(reads), val(genome_size)\n    val   depth_cutoff\n\n    output:\n    tuple val(meta), path('*.fastq.gz'), emit: reads\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output   = meta.single_end ? \"--output ${prefix}.fastq.gz\" : \"--output ${prefix}_1.fastq.gz ${prefix}_2.fastq.gz\"\n    \"\"\"\n    rasusa \\\\\n        $args \\\\\n        --coverage $depth_cutoff \\\\\n        --genome-size $genome_size \\\\\n        --input $reads \\\\\n        $output\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rasusa: \\$(rasusa --version 2>&1 | sed -e \"s/rasusa //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filter features in gzipped GFF3 format\nTags: gff3, filter, feature", "answer": "process DSHBIO_FILTERGFF3 {\n    tag \"${meta.id}\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/dsh-bio:2.4--hdfd78af_0' :\n        'biocontainers/dsh-bio:2.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff3)\n\n    output:\n    tuple val(meta), path(\"*.gff3.gz\"), emit: gff3\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    dsh-bio \\\\\n        filter-gff3 \\\\\n        $args \\\\\n        -i $gff3 \\\\\n        -o ${prefix}.gff3.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dshbio: \\$(dsh-bio --version 2>&1 | grep -o 'dsh-bio-tools .*' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split features in gzipped GFF3 format\nTags: gff3, split, feature", "answer": "process DSHBIO_SPLITGFF3 {\n    tag \"${meta.id}\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/dsh-bio:2.4--hdfd78af_0' :\n        'biocontainers/dsh-bio:2.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff3)\n\n    output:\n    tuple val(meta), path(\"*.gff3.gz\"), emit: gff3\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    dsh-bio \\\\\n        split-gff3 \\\\\n        $args \\\\\n        -p $prefix \\\\\n        -s '.gff3.gz' \\\\\n        -i $gff3\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dshbio: \\$(dsh-bio --version 2>&1 | grep -o 'dsh-bio-tools .*' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split features in gzipped BED format\nTags: bed, split, feature", "answer": "process DSHBIO_SPLITBED {\n    tag \"${meta.id}\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/dsh-bio:2.4--hdfd78af_0' :\n        'biocontainers/dsh-bio:2.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n\n    output:\n    tuple val(meta), path(\"*.bed.gz\"), emit: bed\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    dsh-bio \\\\\n        split-bed \\\\\n        $args \\\\\n        -p $prefix \\\\\n        -s '.bed.gz' \\\\\n        -i $bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dshbio: \\$(dsh-bio --version 2>&1 | grep -o 'dsh-bio-tools .*' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filter features in gzipped BED format\nTags: bed, filter, feature", "answer": "process DSHBIO_FILTERBED {\n    tag \"${meta.id}\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/dsh-bio:2.4--hdfd78af_0' :\n        'biocontainers/dsh-bio:2.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n\n    output:\n    tuple val(meta), path(\"*.bed.gz\"), emit: bed\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    dsh-bio \\\\\n        filter-bed \\\\\n        $args \\\\\n        -i $bed \\\\\n        -o ${prefix}.bed.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dshbio: \\$(dsh-bio --version 2>&1 | grep -o 'dsh-bio-tools .*' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Export assembly segment sequences in GFA 1.0 format to FASTA format\nTags: gfa, assembly, segment", "answer": "process DSHBIO_EXPORTSEGMENTS {\n    tag \"${meta.id}\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/dsh-bio:2.4--hdfd78af_0' :\n        'biocontainers/dsh-bio:2.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gfa)\n\n    output:\n    tuple val(meta), path(\"*.fa.gz\"), emit: fasta\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    dsh-bio \\\\\n        export-segments \\\\\n        $args \\\\\n        -i $gfa \\\\\n        -o ${prefix}.fa.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dshbio: \\$(dsh-bio --version 2>&1 | grep -o 'dsh-bio-tools .*' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Parse all the supporting reads of putative somatic SVs using nanomonsv.\nAfter successful completion, you will find supporting reads stratified by\ndeletions, insertions, and rearrangements.\nA precursor to \"nanomonsv get\"\n\nTags: structural variants, nanopore, cancer genome, somatic structural variations, mobile element insertions, long reads", "answer": "process NANOMONSV_PARSE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nanomonsv:0.5.0--pyhdfd78af_0':\n        'biocontainers/nanomonsv:0.5.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path(\"${prefix}.insertion.sorted.bed.gz\")          , emit: insertions\n    tuple val(meta), path(\"${prefix}.insertion.sorted.bed.gz.tbi\")      , emit: insertions_index\n    tuple val(meta), path(\"${prefix}.deletion.sorted.bed.gz\")           , emit: deletions\n    tuple val(meta), path(\"${prefix}.deletion.sorted.bed.gz.tbi\")       , emit: deletions_index\n    tuple val(meta), path(\"${prefix}.rearrangement.sorted.bedpe.gz\")    , emit: rearrangements\n    tuple val(meta), path(\"${prefix}.rearrangement.sorted.bedpe.gz.tbi\"), emit: rearrangements_index\n    tuple val(meta), path(\"${prefix}.bp_info.sorted.bed.gz\")            , emit: bp_info\n    tuple val(meta), path(\"${prefix}.bp_info.sorted.bed.gz.tbi\")        , emit: bp_info_index\n    path \"versions.yml\"                                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args = task.ext.args ?: ''\n    \"\"\"\n    nanomonsv parse ${args} ${bam} ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanomonsv: \\$(echo \\$(nanomonsv --version 2>&1) | sed 's/^nanomonsv //')\n        mafft: \\$(echo \\$(mafft --version 2>&1) | sed 's/^v//; s/ (.*//')\n        racon: \\$(echo \\$(racon --version 2>&1) | sed 's/^v//')\n        tabix: \\$(echo \\$(tabix --version 2>&1) | sed 's/^tabix (htslib) //; s/ Copyright.*//')\n        bgzip: \\$(echo \\$(bgzip --version 2>&1) | sed 's/^bgzip (htslib) //; s/ Copyright.*//')\n        python: \\$(python3 --version | sed 's/Python //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to build the reference needed by the 10x Genomics Cell Ranger tool. Uses the cellranger mkref command.\nTags: reference, mkref, index", "answer": "process CELLRANGER_MKREF {\n    tag \"$fasta\"\n    label 'process_high'\n\n    container \"nf-core/cellranger:8.0.0\"\n\n    input:\n    path fasta\n    path gtf\n    val reference_name\n\n    output:\n    path \"${reference_name}\", emit: reference\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_MKREF module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    // --localcores is passed to the martian runtime and specifies the number of allocated jobs\n    // --nthreads is passed to the STAR index generation.\n    // see also https://github.com/nf-core/scrnaseq/issues/329\n    \"\"\"\n    cellranger \\\\\n        mkref \\\\\n        --genome=$reference_name \\\\\n        --fasta=$fasta \\\\\n        --genes=$gtf \\\\\n        --localcores=${task.cpus} \\\\\n        --localmem=${task.memory.toGiga()} \\\\\n        --nthreads=${task.cpus} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_MKREF module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir $reference_name\n    touch ${reference_name}/empty_file\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Module to create FASTQs needed by the 10x Genomics Cell Ranger tool. Uses the cellranger mkfastq command.\nTags: reference, mkfastq, fastq, illumina, bcl2fastq", "answer": "process CELLRANGER_MKFASTQ {\n    tag {\"$meta.lane\" ? \"$meta.id\"+\".\"+\"$meta.lane\" : \"$meta.id\" }\n    label 'process_medium'\n\n    container \"nf-core/cellrangermkfastq:8.0.0\"\n\n    input:\n    tuple val(meta), path(csv), path(bcl)\n\n    output:\n    tuple val(meta), path(\"*_outs/outs/fastq_path/*.fastq.gz\"), emit: fastq\n    tuple val(meta), path(\"*_outs/outs/fastq_path/Reports\")   , emit: reports\n    tuple val(meta), path(\"*_outs/outs/fastq_path/Stats\")     , emit: stats\n    tuple val(meta), path(\"*_outs/outs/interop_path/*.bin\")   , emit: interop\n    path \"versions.yml\"                                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_MKFASTQ module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\" //run_dir (bcl) and id must be different because a folder is created with the id value\n    \"\"\"\n    cellranger \\\\\n        mkfastq \\\\\n        --id=${prefix}_outs \\\\\n        --run=$bcl \\\\\n        --csv=$csv \\\\\n        --localcores=${task.cpus} \\\\\n        --localmem=${task.memory.toGiga()} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_MKFASTQ module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p \"${prefix}_outs/outs/fastq_path/\"\n    # data with something to avoid breaking nf-test java I/O stream\n    cat <<-FAKE_FQ > ${prefix}_outs/outs/fastq_path/fake_file.fastq\n    @SEQ_ID\n    GATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT\n    +\n    !''*((((***+))%%%++)(%%%%).1***-+*''))**55CCF>>>>>>CCCCCCC65\n    FAKE_FQ\n    gzip -n ${prefix}_outs/outs/fastq_path/fake_file.fastq\n\n    # data for reports output channel\n    mkdir -p \"${prefix}_outs/outs/fastq_path/Reports\"\n\n    # data for stats output channel\n    mkdir -p \"${prefix}_outs/outs/fastq_path/Stats\"\n\n    # data for interops output channel\n    mkdir -p \"${prefix}_outs/outs/interop_path/\"\n    touch \"${prefix}_outs/outs/interop_path/IndexMetricsOut.bin\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to use Cell Ranger's pipelines to analyze sequencing data produced from various Chromium technologies, including Single Cell Gene Expression, Single Cell Immune Profiling, Feature Barcoding, and Cell Multiplexing.\nTags: align, reference, cellranger, multiomics, gene expression, vdj, antigen capture, antibody capture, crispr", "answer": "process CELLRANGER_MULTI {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nf-core/cellranger:8.0.0\"\n\n    input:\n    val meta\n    tuple val(meta_gex)        , path (gex_fastqs   , stageAs: \"fastqs/gex/fastq_???/*\")\n    tuple val(meta_vdj)        , path (vdj_fastqs   , stageAs: \"fastqs/vdj/fastq_???/*\")\n    tuple val(meta_ab)         , path (ab_fastqs    , stageAs: \"fastqs/ab/fastq_???/*\")\n    tuple val(meta_beam)       , path (beam_fastqs  , stageAs: \"fastqs/beam/fastq_???/*\")\n    tuple val(meta_cmo)        , path (cmo_fastqs   , stageAs: \"fastqs/cmo/fastq_???/*\")\n    tuple val(meta_crispr)     , path (crispr_fastqs, stageAs: \"fastqs/crispr/fastq_???/*\")\n    path gex_reference         , stageAs: \"references/gex/*\"\n    path gex_frna_probeset     , stageAs: \"references/gex/probeset/*\"\n    path gex_targetpanel       , stageAs: \"references/gex/targetpanel/*\"\n    path vdj_reference         , stageAs: \"references/vdj/*\"\n    path vdj_primer_index      , stageAs: \"references/vdj/primers/*\"\n    path fb_reference          , stageAs: \"references/fb/*\"\n    path beam_antigen_panel    , stageAs: \"references/beam/panel/antigens/*\"\n    path beam_control_panel    , stageAs: \"references/beam/panel/controls/*\"\n    path cmo_reference         , stageAs: \"references/cmo/*\"\n    path cmo_barcodes          , stageAs: \"references/cmo/barcodes/*\"\n    path cmo_barcode_assignment, stageAs: \"references/cmo/sample_barcode_assignment/*\"\n    path frna_sampleinfo       , stageAs: \"references/frna/*\"\n    val skip_renaming\n\n    output:\n    tuple val(meta), path(\"cellranger_multi_config.csv\"), emit: config\n    tuple val(meta), path(\"**/outs/**\")                 , emit: outs\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_MULTI module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    args   = task.ext.args   ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    // if references + FASTQ are empty, then don't run corresponding analyses\n    // get names of references, if they exist\n    // empty reference channels (all under references/) can stage as \"[]\" when skipped by the workflow\n    // empty FASTQ channels stage as \"fastqs\"\n    gex_reference_name      = gex_reference          ? gex_reference.getName()          : ''\n    gex_frna_probeset_name  = gex_frna_probeset      ? gex_frna_probeset.getName()      : ''\n    gex_targetpanel_name    = gex_targetpanel        ? gex_targetpanel.getName()        : ''\n    fb_reference_name       = fb_reference           ? fb_reference.getName()           : ''\n    vdj_reference_name      = vdj_reference          ? vdj_reference.getName()          : ''\n    cmo_reference_name      = cmo_reference          ? cmo_reference.getName()          : ''\n    cmo_sample_assignment   = cmo_barcode_assignment ? cmo_barcode_assignment.getName() : ''\n    beam_antigen_panel_name = beam_antigen_panel     ? beam_antigen_panel.getName()     : ''\n\n    include_gex  = gex_fastqs.first().getName() != 'fastqs' && gex_reference           ? '[gene-expression]'     : ''\n    include_vdj  = vdj_fastqs.first().getName() != 'fastqs' && vdj_reference           ? '[vdj]'                 : ''\n    include_beam = beam_fastqs.first().getName() != 'fastqs' && beam_control_panel     ? '[antigen-specificity]' : ''\n    include_cmo  = cmo_fastqs.first().getName() != 'fastqs' && cmo_barcodes            ? '[samples]'             : ''\n    include_fb   = ab_fastqs.first().getName() != 'fastqs' && fb_reference             ? '[feature]'             : ''\n    include_frna = gex_frna_probeset_name && frna_sampleinfo                           ? '[samples]'             : ''\n\n    gex_reference_path = include_gex ? \"reference,./${gex_reference_name}\" : ''\n    fb_reference_path  = include_fb  ? \"reference,./${fb_reference_name}\"  : ''\n    vdj_reference_path = include_vdj ? \"reference,./${vdj_reference_name}\" : ''\n\n    // targeted GEX panel goes under GEX section, not its own\n    target_panel = gex_targetpanel_name != '' ? \"target-panel,./$gex_targetpanel_name\" : ''\n\n    // fixed RNA reference (not sample info!) also goes under GEX section\n    frna_probeset = include_frna && gex_frna_probeset_name != '' ? \"probe-set,./$gex_frna_probeset_name\" : ''\n\n    // VDJ inner primer set\n    primer_index = vdj_primer_index ? \"inner-enrichment-primers,./references/primers/${vdj_primer_index.getName()}\" : ''\n\n    // BEAM antigen list, remember that this is a Feature Barcode file\n    beam_antigen_csv = include_beam && beam_antigen_panel_name != '' ? \"reference,./$beam_antigen_panel_name\" : ''\n\n    // pull CSV text from these reference panels\n    // these references get appended directly to config file\n    beam_csv_text  = include_beam && beam_control_panel.size() > 0 ? beam_control_panel : ''\n    cmo_csv_text   = include_cmo  && cmo_barcodes.size() > 0       ? cmo_barcodes       : ''\n    frna_csv_text  = include_frna && frna_sampleinfo.size() > 0    ? frna_sampleinfo    : ''\n\n    // the feature barcodes section get options for either CRISPR or antibody capture assays\n    fb_options     = meta_ab?.options ? meta_ab.options : (meta_crispr?.options ? meta_crispr.options : [])\n\n    // collect options for each section\n    // these are pulled from the meta maps\n    gex_options_use    = include_gex && meta_gex?.options   ? 'true' : null\n    vdj_options_use    = include_vdj && meta_vdj?.options   ? 'true' : null\n    ab_options_use     = include_fb && meta_ab?.options     ? 'true' : null\n    beam_options_use   = include_beam && meta_beam?.options ? 'true' : null\n    cmo_options_use    = include_cmo && meta_cmo?.options   ? 'true' : null\n    crispr_options_use = include_fb && meta_crispr?.options ? 'true' : null\n    fb_options_use     = include_fb && fb_options?.options  ? 'true' : null\n\n    gex_options_filter_probes = gex_options_use && meta_gex.options.containsKey(\"filter-probes\") ? \"filter-probes,${meta_gex.options[\"filter-probes\"]}\" : ''\n    gex_options_r1_length     = gex_options_use && meta_gex.options.containsKey(\"r1-length\")     ? \"r1-length,${meta_gex.options[\"r1-length\"]}\"         : ''\n    gex_options_r2_length     = gex_options_use && meta_gex.options.containsKey(\"r2-length\")     ? \"r2-length,${meta_gex.options[\"r2-length\"]}\"         : ''\n    gex_options_chemistry     = gex_options_use && meta_gex.options.containsKey(\"chemistry\")     ? \"chemistry,${meta_gex.options[\"chemistry\"]}\"         : ''\n    gex_options_expect_cells  = gex_options_use && meta_gex.options.containsKey(\"expect-cells\")  ? \"expect-cells,${meta_gex.options[\"expect-cells\"]}\"   : ''\n    gex_options_force_cells   = gex_options_use && meta_gex.options.containsKey(\"force-cells\")   ? \"force-cells,${meta_gex.options[\"force-cells\"]}\"     : ''\n    gex_options_no_secondary  = gex_options_use && meta_gex.options.containsKey(\"no-secondary\")  ? \"no-secondary,${meta_gex.options[\"no-secondary\"]}\"   : ''\n    gex_options_no_bam        = gex_options_use && meta_gex.options.containsKey(\"create-bam\")    ? \"create-bam,${meta_gex.options[\"create-bam\"]}\"           : ''\n    gex_options_no_target_umi_filter = gex_options_use && meta_gex.options.containsKey(\"no-target-umi-filter\") ? \"no-target-umi-filter,${meta_gex.options[\"no-target-umi-filter\"]}\" : ''\n    gex_options_include_introns      = gex_options_use && meta_gex.options.containsKey(\"include-introns\")      ? \"include-introns,${meta_gex.options[\"include-introns\"]}\"           : ''\n    gex_options_check_library_compatibility = gex_options_use && meta_gex.options.containsKey(\"check-library-compatibility\") ? \"check-library-compatibility,${meta_gex.options[\"check-library-compatibility\"]}\" : ''\n\n    cmo_reference_path = cmo_options_use && cmo_reference_name    ? \"cmo-set,./${cmo_reference_name}\"                      : ''\n    cmo_barcode_path   = cmo_options_use && cmo_sample_assignment ? \"barcode-sample-assignment,./${cmo_sample_assignment}\" : ''\n    cmo_options_min_assignment_confidence = cmo_options_use && meta_cmo.options.containsKey(\"min-assignment-confidence\") ? \"min-assignment-confidence,${meta_cmo.options[\"min-assignment-confidence\"]}\" : ''\n\n    vdj_options_r1_length = vdj_options_use && meta_vdj.options.containsKey(\"r1-length\") ? \"r1-length,${meta_vdj.options[\"r1-length\"]}\" : ''\n    vdj_options_r2_length = vdj_options_use && meta_vdj.options.containsKey(\"r2-length\") ? \"r2-length,${meta_vdj.options[\"r2-length\"]}\" : ''\n\n    fb_options_r1_length = fb_options_use && meta_fb.options.containsKey(\"r1-length\") ? \"r1-length,${meta_fb.options[\"r1-length\"]}\" : ''\n    fb_options_r2_length = fb_options_use && meta_fb.options.containsKey(\"r2-length\") ? \"r2-length,${meta_fb.options[\"r2-length\"]}\" : ''\n\n    // point config to FASTQs\n    // After renaming it gets in 'fastq_all' folder\n    fastq_gex      = include_gex                      ? \"${meta_gex.id},./fastq_all/gex,,Gene Expression\"            : ''\n    fastq_vdj      = include_vdj                      ? \"${meta_vdj.id},./fastq_all/vdj,,VDJ\"                        : ''\n    fastq_antibody = include_fb && ab_options_use     ? \"${meta_ab.id},./fastq_all/ab,,Antibody Capture\"             : ''\n    fastq_beam     = include_beam                     ? \"${meta_beam.id},./fastq_all/beam,,Antigen Capture\"         : ''\n    fastq_crispr   = include_fb && crispr_options_use ? \"${meta_crispr.id},./fastq_all/crispr,,CRISPR Guide Capture\" : ''\n    fastq_cmo      = include_cmo                      ? \"${meta_cmo.id},./fastq_all/cmo,,Multiplexing Capture\"       : ''\n\n    // name the config file\n    config = \"cellranger_multi_config.csv\"\n    template \"cellranger_multi.py\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p \"${prefix}/outs/\"\n    touch ${prefix}/outs/fake_file.txt\n    echo -n \"\" >> ${prefix}/outs/fake_file.txt\n    touch cellranger_multi_config.csv\n    echo -n \"\" >> cellranger_multi_config.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to build a filtered GTF needed by the 10x Genomics Cell Ranger tool. Uses the cellranger mkgtf command.\nTags: reference, mkref, index", "answer": "process CELLRANGER_MKGTF {\n    tag \"$gtf\"\n    label 'process_low'\n\n    container \"nf-core/cellranger:8.0.0\"\n\n    input:\n    path gtf\n\n    output:\n    path \"*.gtf\"         , emit: gtf\n    path \"versions.yml\"  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_MKGTF module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}.filtered\"\n    \"\"\"\n    cellranger \\\\\n        mkgtf \\\\\n        $gtf \\\\\n        ${prefix}.gtf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_MKGTF module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}.filtered\"\n    \"\"\"\n    touch ${prefix}.gtf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to use Cell Ranger's pipelines analyze sequencing data produced from Chromium Single Cell Gene Expression.\nTags: align, count, reference", "answer": "process CELLRANGER_COUNT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nf-core/cellranger:8.0.0\"\n\n    input:\n    tuple val(meta), path(reads, stageAs: \"fastq_???/*\")\n    path  reference\n\n    output:\n    tuple val(meta), path(\"**/outs/**\"), emit: outs\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_COUNT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    template \"cellranger_count.py\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_COUNT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p \"${prefix}/outs/\"\n    echo \"$prefix\" > ${prefix}/outs/fake_file.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to build the VDJ reference needed by the 10x Genomics Cell Ranger tool. Uses the cellranger mkvdjref command.\nTags: reference, mkvdjref, index, immunoprofiling, single-cell, cellranger", "answer": "process CELLRANGER_MKVDJREF {\n    tag \"$fasta\"\n    label 'process_high'\n\n    container \"nf-core/cellranger:8.0.0\"\n\n    input:\n    path fasta          // optional\n    path gtf            // optional\n    path seqs           // optional\n    val reference_name\n\n    output:\n    path \"${reference_name}\", emit: reference\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_MKVDJREF module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args        = task.ext.args ?: ''\n    def gtf_in      = gtf           ? \"--genes ${gtf}\"      : \"\"\n    def fasta_in    = fasta         ? \"--fasta ${fasta}\"    : \"\"\n    def seqs_in     = seqs          ? \"--seqs ${seqs}\"      : \"\"\n\n    \"\"\"\n    cellranger \\\\\n        mkvdjref \\\\\n        --genome=$reference_name \\\\\n        ${gtf_in} \\\\\n        ${fasta_in} \\\\\n        ${seqs_in} \\\\\n        --localcores=${task.cpus} \\\\\n        --localmem=${task.memory.toGiga()} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir ${reference_name}\n    mkdir ${reference_name}/fasta\n    echo stub > ${reference_name}/fasta/regions.fa\n    echo stub > ${reference_name}/reference.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to use Cell Ranger's pipelines analyze sequencing data produced from Chromium Single Cell Immune Profiling.\nTags: align, vdj, reference, immunoprofiling, single-cell, cellranger", "answer": "process CELLRANGER_VDJ {\n    tag \"${meta.id}\"\n    label 'process_high'\n\n    container \"nf-core/cellranger:8.0.0\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  reference\n\n    output:\n    tuple val(meta), path(\"**/outs/**\"), emit: outs\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_VDJ module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference_name = reference.name\n    \"\"\"\n    cellranger \\\\\n        vdj \\\\\n        --id='${prefix}' \\\\\n        --fastqs=. \\\\\n        --reference=$reference_name \\\\\n        --localcores=${task.cpus} \\\\\n        --localmem=${task.memory.toGiga()} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CELLRANGER_VDJ module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p \"${meta.id}/outs/\"\n    touch ${meta.id}/outs/fake_file.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger: \\$(echo \\$( cellranger --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run Torsten Seemann's classic MLST on a genome assembly\nTags: mlst, typing, bacteria, assembly", "answer": "process MLST {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mlst:2.23.0--hdfd78af_0' :\n        'biocontainers/mlst:2.23.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mlst \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        $fasta \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mlst: \\$( echo \\$(mlst --version 2>&1) | sed 's/mlst //' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: fq lint is a FASTQ file pair validator.\nTags: lint, fastq, validate", "answer": "process FQ_LINT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fq:0.9.1--h9ee0642_0':\n        'biocontainers/fq:0.9.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n\n    output:\n    tuple val(meta), path(\"*.fq_lint.txt\"), emit: lint\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    fq lint \\\\\n        $args \\\\\n        $fastq > ${prefix}.fq_lint.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fq: \\$(echo \\$(fq lint --version | sed 's/fq-lint //g'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: fq generate is a FASTQ file pair generator. It creates two reads, formatting names as described by Illumina. While generate creates \"valid\" FASTQ reads, the content of the files are completely random. The sequences do not align to any genome. This requires a seed (--seed) to be supplied in ext.args.\n\nTags: generate, fastq", "answer": "process FQ_GENERATE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fq:0.9.1--h9ee0642_0':\n        'biocontainers/fq:0.9.1--h9ee0642_0' }\"\n\n    input:\n    val meta\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: fastq\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    fq generate \\\\\n        $args \\\\\n        ${prefix}_R1.fastq.gz ${prefix}_R2.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fq: \\$(echo \\$(fq generate --version | sed 's/fq-generate //g'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: fq subsample outputs a subset of records from single or paired FASTQ files. This requires a seed (--seed) to be set in ext.args.\nTags: fastq, fq, subsample", "answer": "process FQ_SUBSAMPLE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fq:0.9.1--h9ee0642_0':\n        'biocontainers/fq:0.9.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: fastq\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    /* args requires:\n        --probability <f64>: Probability read is kept, between 0 and 1. Mutually exclusive with record-count.\n        --record-count <u64>: Number of records to keep. Mutually exclusive with probability\n    */\n    def args = task.ext.args ?: ''\n    def prob_exists = args =~ /-p|--probability/\n    def nrec_exists = args =~ /-n|--record-count/\n    if ( !(prob_exists || nrec_exists) ){\n        error \"FQ/SUBSAMPLE requires --probability (-p) or --record-count (-n) specified in task.ext.args!\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def n_fastq = fastq instanceof List ? fastq.size() : 1\n    log.debug \"FQ/SUBSAMPLE found ${n_fastq} FASTQ files\"\n    if ( n_fastq == 1 ){\n        fastq1_output = \"--r1-dst ${prefix}.fastq.gz\"\n        fastq2_output = \"\"\n    } else if ( n_fastq == 2 ){\n        fastq1_output = \"--r1-dst ${prefix}_R1.fastq.gz\"\n        fastq2_output = \"--r2-dst ${prefix}_R2.fastq.gz\"\n    } else {\n        error \"FQ/SUBSAMPLE only accepts 1 or 2 FASTQ files!\"\n    }\n    \"\"\"\n    fq subsample \\\\\n        $args \\\\\n        $fastq \\\\\n        $fastq1_output \\\\\n        $fastq2_output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fq: \\$(echo \\$(fq subsample --version | sed 's/fq-subsample //g'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo '' | gzip >  ${prefix}_R1.fastq.gz\n    echo '' | gzip >  ${prefix}_R2.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fq: \\$(echo \\$(fq subsample --version | sed 's/fq-subsample //g'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: build and deploy Shiny apps for interactively mining differential abundance data\nTags: differential, expression, rna-seq, deseq2", "answer": "\nprocess SHINYNGS_APP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // To be able to pass the necessary secrets for shinyapps.io deployment,\n    // this process must be configured by placing a statement like the\n    // following in the nextflow.config:\n    //\n    // withName: SHINYNGS_APP {\n    //     secret = [ 'SHINYAPPS_TOKEN', 'SHINYAPPS_SECRET' ]\n    // }\n    //\n    // Those values must then be set in your Nextflow secrets.\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-shinyngs:2.0.0--r43hdfd78af_0' :\n        'biocontainers/r-shinyngs:2.0.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(sample), path(feature_meta), path(assay_files)    // Experiment-level info\n    tuple val(meta2), path(contrasts), path(differential_results)           // Differential info: contrasts and differential stats\n    val(contrast_stats_assay)\n\n    output:\n    tuple val(meta), path(\"*/data.rds\"), path(\"*/app.R\")    , emit: app\n    path \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // For full list of available args see\n    // https://github.com/pinin4fjords/shinyngs/blob/develop/exec/make_app_from_files.R\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: meta.id\n\n    \"\"\"\n    make_app_from_files.R \\\\\n        --sample_metadata $sample \\\\\n        --feature_metadata $feature_meta \\\\\n        --assay_files ${assay_files.join(',')} \\\\\n        --contrast_file $contrasts \\\\\n        --contrast_stats_assay $contrast_stats_assay \\\\\n        --differential_results ${differential_results.join(',')} \\\\\n        --output_dir $prefix \\\\\n        $args \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        r-shinyngs: \\$(Rscript -e \"library(shinyngs); cat(as.character(packageVersion('shinyngs')))\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: meta.id\n\n    \"\"\"\n    mkdir -p $prefix\n    touch ${prefix}/data.rds\n    touch ${prefix}/app.R\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        r-shinyngs: \\$(Rscript -e \"library(shinyngs); cat(as.character(packageVersion('shinyngs')))\")\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: validate consistency of feature and sample annotations with matrices and contrasts\nTags: expression, features, observations, validation", "answer": "process SHINYNGS_VALIDATEFOMCOMPONENTS {\n    tag \"$sample\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-shinyngs:2.0.0--r43hdfd78af_0' :\n        'biocontainers/r-shinyngs:2.0.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta),  path(sample), path(assay_files)\n    tuple val(meta2), path(feature_meta)\n    tuple val(meta3), path(contrasts)\n\n    output:\n    tuple val(meta), path(\"*/*.sample_metadata.tsv\")   , emit: sample_meta\n    tuple val(meta), path(\"*/*.feature_metadata.tsv\")  , emit: feature_meta, optional: true\n    tuple val(meta), path(\"*/*.assay.tsv\")             , emit: assays\n    tuple val(meta), path(\"*/*.contrasts_file.tsv\")    , emit: contrasts\n    path \"versions.yml\"                                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // For full list of available args see\n    // https://github.com/pinin4fjords/shinyngs/blob/develop/exec/validate_fom_components.R\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: meta.id\n    def feature = feature_meta ? \"--feature_metadata '$feature_meta'\" : ''\n\n    \"\"\"\n    validate_fom_components.R \\\\\n        --sample_metadata \"$sample\" \\\\\n        $feature \\\\\n        --assay_files \"${assay_files.join(',')}\" \\\\\n        --contrasts_file \"$contrasts\" \\\\\n        --output_directory \"$prefix\" \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        r-base: \\$(echo \\$(R --version 2>&1) | sed 's/^.*R version //; s/ .*\\$//')\n        r-shinyngs: \\$(Rscript -e \"library(shinyngs); cat(as.character(packageVersion('shinyngs')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Make exploratory plots for analysis of matrix data, including PCA, Boxplots and density plots\nTags: exploratory, plot, boxplot, density, PCA", "answer": "process SHINYNGS_STATICEXPLORATORY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-shinyngs:2.0.0--r43hdfd78af_0' :\n        'biocontainers/r-shinyngs:2.0.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(sample), path(feature_meta), path(assay_files)\n\n    output:\n    tuple val(meta), path(\"*/png/boxplot.png\")                  , emit: boxplots_png\n    tuple val(meta), path(\"*/html/boxplot.html\")                , emit: boxplots_html, optional: true\n    tuple val(meta), path(\"*/png/density.png\")                  , emit: densities_png\n    tuple val(meta), path(\"*/html/density.html\")                , emit: densities_html, optional: true\n    tuple val(meta), path(\"*/png/pca2d.png\")                    , emit: pca2d_png\n    tuple val(meta), path(\"*/html/pca2d.html\")                  , emit: pca2d_html, optional: true\n    tuple val(meta), path(\"*/png/pca3d.png\")                    , emit: pca3d_png\n    tuple val(meta), path(\"*/html/pca3d.html\")                  , emit: pca3d_html, optional: true\n    tuple val(meta), path(\"*/png/mad_correlation.png\")          , emit: mad_png, optional: true\n    tuple val(meta), path(\"*/html/mad_correlation.html\")        , emit: mad_html, optional: true\n    tuple val(meta), path(\"*/png/sample_dendrogram.png\")        , emit: dendro\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // For full list of available args see\n    // https://github.com/pinin4fjords/shinyngs/blob/develop/exec/exploratory_plots.R\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: meta.id\n    \"\"\"\n    exploratory_plots.R \\\\\n        --sample_metadata \"$sample\" \\\\\n        --feature_metadata \"$feature_meta\" \\\\\n        --assay_files \"${assay_files.join(',')}\" \\\\\n        --contrast_variable \"${meta.id}\" \\\\\n        --outdir \"$prefix\" \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        r-shinyngs: \\$(Rscript -e \"library(shinyngs); cat(as.character(packageVersion('shinyngs')))\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: meta.id\n    \"\"\"\n    mkdir -p ${prefix}/png ${prefix}/html\n    touch ${prefix}/png/boxplot.png\n    touch ${prefix}/html/boxplot.html\n    touch ${prefix}/png/density.png\n    touch ${prefix}/html/density.html\n    touch ${prefix}/png/pca2d.png\n    touch ${prefix}/html/pca3d.html\n    touch ${prefix}/png/pca3d.png\n    touch ${prefix}/html/pca2d.html\n    touch ${prefix}/png/mad_correlation.png\n    touch ${prefix}/html/mad_correlation.html\n    touch ${prefix}/png/sample_dendrogram.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        r-shinyngs: \\$(Rscript -e \"library(shinyngs); cat(as.character(packageVersion('shinyngs')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Make plots for interpretation of differential abundance statistics\nTags: rnaseq, plot, differential, shinyngs", "answer": "process SHINYNGS_STATICDIFFERENTIAL {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-shinyngs:2.0.0--r43hdfd78af_0' :\n        'biocontainers/r-shinyngs:2.0.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(differential_result)                              // Differential info: contrast and differential stats\n    tuple val(meta2), path(sample), path(feature_meta), path(assay_file)    // Experiment-level info\n\n    output:\n    tuple val(meta), path(\"*/png/volcano.png\")      , emit: volcanos_png\n    tuple val(meta), path(\"*/html/volcano.html\")    , emit: volcanos_html, optional: true\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // For full list of available args see\n    // https://github.com/pinin4fjords/shinyngs/blob/develop/exec/differential_plots.R\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: meta.id\n    \"\"\"\n    differential_plots.R \\\\\n        --differential_file \"$differential_result\" \\\\\n        --feature_metadata \"$feature_meta\" \\\\\n        --outdir \"$prefix\" \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        r-base: \\$(echo \\$(R --version 2>&1) | sed 's/^.*R version //; s/ .*\\$//')\n        r-shinyngs: \\$(Rscript -e \"library(shinyngs); cat(as.character(packageVersion('shinyngs')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: grafts query sequences from phylogenetic placement on the reference tree\nTags: sort", "answer": "process GAPPA_EXAMINEGRAFT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gappa:0.8.0--h9a82719_0':\n        'biocontainers/gappa:0.8.0--h9a82719_0' }\"\n\n    input:\n    tuple val(meta), path(jplace)\n\n    output:\n    tuple val(meta), path(\"*.newick\"), emit: newick\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gappa \\\\\n        examine \\\\\n        graft \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --file-prefix ${prefix}. \\\\\n        --jplace-path $jplace\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gappa: \\$(echo \\$(gappa --version 2>&1 | sed 's/v//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: assigns taxonomy to query sequences in phylogenetic placement output\nTags: phylogeny, phylogenetic placement, classification, taxonomy", "answer": "process GAPPA_EXAMINEASSIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gappa:0.8.0--h9a82719_0':\n        'biocontainers/gappa:0.8.0--h9a82719_0' }\"\n\n    input:\n    tuple val(meta), path(jplace), path(taxonomy)\n\n    output:\n    tuple val(meta), path(\"./.\")                  , emit: examineassign\n    tuple val(meta), path(\"*profile.tsv\")         , emit: profile\n    tuple val(meta), path(\"*labelled_tree.newick\"), emit: labelled_tree\n    tuple val(meta), path(\"*per_query.tsv\")       , emit: per_query, optional: true\n    tuple val(meta), path(\"*krona.profile\")       , emit: krona    , optional: true\n    tuple val(meta), path(\"*sativa.tsv\")          , emit: sativa   , optional: true\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gappa \\\\\n        examine assign \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --jplace-path $jplace \\\\\n        --taxon-file $taxonomy \\\\\n        --file-prefix ${prefix}.\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gappa: \\$(echo \\$(gappa --version 2>&1 | sed 's/v//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: colours a phylogeny with placement densities\nTags: phylogeny, phylogenetic placement, heattree, visualisation", "answer": "process GAPPA_EXAMINEHEATTREE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gappa:0.8.0--h9a82719_0':\n        'biocontainers/gappa:0.8.0--h9a82719_0' }\"\n\n    input:\n    tuple val(meta), path(jplace)\n\n    output:\n    tuple val(meta), path(\"*.newick\")     , emit: newick  , optional: true\n    tuple val(meta), path(\"*.nexus\")      , emit: nexus   , optional: true\n    tuple val(meta), path(\"*.phyloxml\")   , emit: phyloxml, optional: true\n    tuple val(meta), path(\"*.svg\")        , emit: svg     , optional: true\n    tuple val(meta), path(\"*.colours.txt\"), emit: colours\n    tuple val(meta), path(\"*.log\")        , emit: log\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gappa \\\\\n        examine \\\\\n        heat-tree \\\\\n        --threads $task.cpus \\\\\n        --file-prefix ${prefix}. \\\\\n        --jplace-path $jplace \\\\\n        $args \\\\\n        --log-file ${prefix}.log\n\n    grep '^ *At' ${prefix}.log > ${prefix}.colours.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gappa: \\$(echo \\$(gappa --version 2>&1 | sed 's/v//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MALT, an acronym for MEGAN alignment tool, is a sequence alignment and analysis tool designed for processing high-throughput sequencing data, especially in the context of metagenomics.\nTags: malt, alignment, metagenomics, ancient DNA, aDNA, palaeogenomics, archaeogenomics, microbiome, database", "answer": "process MALT_BUILD {\n\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/malt:0.61--hdfd78af_0' :\n        'biocontainers/malt:0.61--hdfd78af_0' }\"\n\n    input:\n    path fastas\n    path gff\n    path mapping_db\n\n    output:\n    path \"malt_index/\"   , emit: index\n    path \"versions.yml\"  , emit: versions\n    path \"malt-build.log\", emit: log\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def igff = gff ? \"-igff ${gff}\" : \"\"\n\n    \"\"\"\n    malt-build \\\\\n        -v \\\\\n        --input ${fastas.join(' ')} \\\\\n        $igff \\\\\n        -d 'malt_index/' \\\\\n        -t $task.cpus \\\\\n        $args \\\\\n        -mdb ${mapping_db}/*.db |&tee malt-build.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        malt: \\$(malt-build --help |& tail -n 3 | head -n 1 | cut -f 2 -d'(' | cut -f 1 -d ',' | cut -d ' ' -f 2)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    touch malt-build.log\n    mkdir malt_index/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        malt: \\$(malt-run --help  2>&1 | grep -o 'version.* ' | cut -f 1 -d ',' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MALT, an acronym for MEGAN alignment tool, is a sequence alignment and analysis tool designed for processing high-throughput sequencing data, especially in the context of metagenomics.\nTags: malt, alignment, metagenomics, ancient DNA, aDNA, palaeogenomics, archaeogenomics, microbiome", "answer": "process MALT_RUN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/malt:0.61--hdfd78af_0' :\n        'biocontainers/malt:0.61--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fastqs)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.rma6\")                                , emit: rma6\n    tuple val(meta), path(\"*.{tab,text,sam,tab.gz,text.gz,sam.gz}\"),  optional:true, emit: alignments\n    tuple val(meta), path(\"*.log\")                                 , emit: log\n    path \"versions.yml\"                                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    malt-run \\\\\n        -t $task.cpus \\\\\n        -v \\\\\n        -o . \\\\\n        $args \\\\\n        --inFile ${fastqs.join(' ')} \\\\\n        --index $index/ |&tee ${prefix}-malt-run.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        malt: \\$(malt-run --help  2>&1 | grep -o 'version.* ' | cut -f 1 -d ',' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}-malt-run.log\n    touch ${prefix}.rma6\n    touch ${prefix}.sam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        malt: \\$(malt-run --help  2>&1 | grep -o 'version.* ' | cut -f 1 -d ',' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert taxon names to TaxIds\nTags: taxonomy, taxids, taxon name, conversion", "answer": "process TAXONKIT_NAME2TAXID {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/taxonkit:0.15.1--h9ee0642_0':\n        'biocontainers/taxonkit:0.15.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), val(name), path(names_txt)\n    path taxdb\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    assert (!name && names_txt) || (name && !names_txt)\n    \"\"\"\n    taxonkit \\\\\n        name2taxid \\\\\n        $args \\\\\n        --data-dir $taxdb \\\\\n        --threads $task.cpus \\\\\n        --out-file ${prefix}.tsv \\\\\n        ${name? \"<<< '$name'\": names_txt}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        taxonkit: \\$( taxonkit version | sed 's/.* v//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        taxonkit: \\$( taxonkit version | sed 's/.* v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A NATA accredited tool for reporting the presence of antimicrobial resistance genes in bacterial genomes\nTags: bacteria, fasta, antibiotic resistance", "answer": "process ABRITAMR_RUN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/abritamr:1.0.14--pyhdfd78af_0':\n        'biocontainers/abritamr:1.0.14--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${prefix}.summary_matches.txt\")  , emit: matches\n    tuple val(meta), path(\"${prefix}.summary_partials.txt\") , emit: partials\n    tuple val(meta), path(\"${prefix}.summary_virulence.txt\"), emit: virulence\n    tuple val(meta), path(\"${prefix}.amrfinder.out\")        , emit: out\n    tuple val(meta), path(\"${prefix}.abritamr.txt\")         , emit: txt, optional: true\n    path \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getName().endsWith(\".gz\") ? true : false\n    fasta_name = fasta.getName().replace(\".gz\", \"\")\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    abritamr run \\\\\n        --contigs $fasta_name \\\\\n        --prefix results \\\\\n        $args \\\\\n        --jobs $task.cpus\n\n    # Rename output files to prevent name collisions\n    mv results/summary_matches.txt ./${prefix}.summary_matches.txt\n    mv results/summary_partials.txt ./${prefix}.summary_partials.txt\n    mv results/summary_virulence.txt ./${prefix}.summary_virulence.txt\n    mv results/amrfinder.out ./${prefix}.amrfinder.out\n    if [ -f results/abritamr.txt ]; then\n        # This file is not always present\n        mv results/abritamr.txt ./${prefix}.abritamr.txt\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        abritamr: \\$(echo \\$(abritamr --version 2>&1) | sed 's/^.*abritamr //' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ./${prefix}.summary_matches.txt\n    touch ./${prefix}.summary_partials.txt\n    touch ./${prefix}.summary_virulence.txt\n    touch ./${prefix}.amrfinder.out\n    touch ./${prefix}.amrfinder.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        abritamr: \\$(echo \\$(abritamr --version 2>&1) | sed 's/^.*abritamr //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: split one ubam into multiple, per line, fast\nTags: long-read, bam, genomics", "answer": "process SPLITUBAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/splitubam:0.1.1--hc9368f3_0':\n        'biocontainers/splitubam:0.1.1--hc9368f3_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    splitubam \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        splitubam: \\$(splitubam --version | sed 's/splitubam //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def match = (args =~ /--split\\s+(\\d+)/)\n    def create_cmd = \"\"\n    if (match) {\n        def n_splits = match[0][1].toInteger()\n        (1..n_splits).each { i ->\n            def formattedIteration = String.format('%03d', i)\n            create_cmd += \"touch ${formattedIteration}.${bam}.bam\\n\"\n        }\n    } else { error(\"No `--split N` detected in args\") }\n    \"\"\"\n    $create_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        splitubam: \\$(splitubam --version | sed 's/splitubam //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A set of tools written in Perl and C++ for working with VCF files\nTags: VCFtools, VCF, sort", "answer": "process VCFTOOLS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vcftools:0.1.16--he513fc3_4' :\n        'biocontainers/vcftools:0.1.16--he513fc3_4' }\"\n\n    input:\n    // Owing to the nature of vcftools we here provide solutions to working with optional bed files and optional\n    // alternative variant files, for use with the 'diff' suite of tools.\n    // Other optional input files can be utilised in a similar way to below but we do not exhaustively itterate through all\n    // possible options. Instead we leave that to the user.\n    tuple val(meta), path(variant_file)\n    path  bed\n    path  diff_variant_file\n\n    output:\n    tuple val(meta), path(\"*.vcf\")                    , optional:true, emit: vcf\n    tuple val(meta), path(\"*.bcf\")                    , optional:true, emit: bcf\n    tuple val(meta), path(\"*.frq\")                    , optional:true, emit: frq\n    tuple val(meta), path(\"*.frq.count\")              , optional:true, emit: frq_count\n    tuple val(meta), path(\"*.idepth\")                 , optional:true, emit: idepth\n    tuple val(meta), path(\"*.ldepth\")                 , optional:true, emit: ldepth\n    tuple val(meta), path(\"*.ldepth.mean\")            , optional:true, emit: ldepth_mean\n    tuple val(meta), path(\"*.gdepth\")                 , optional:true, emit: gdepth\n    tuple val(meta), path(\"*.hap.ld\")                 , optional:true, emit: hap_ld\n    tuple val(meta), path(\"*.geno.ld\")                , optional:true, emit: geno_ld\n    tuple val(meta), path(\"*.geno.chisq\")             , optional:true, emit: geno_chisq\n    tuple val(meta), path(\"*.list.hap.ld\")            , optional:true, emit: list_hap_ld\n    tuple val(meta), path(\"*.list.geno.ld\")           , optional:true, emit: list_geno_ld\n    tuple val(meta), path(\"*.interchrom.hap.ld\")      , optional:true, emit: interchrom_hap_ld\n    tuple val(meta), path(\"*.interchrom.geno.ld\")     , optional:true, emit: interchrom_geno_ld\n    tuple val(meta), path(\"*.TsTv\")                   , optional:true, emit: tstv\n    tuple val(meta), path(\"*.TsTv.summary\")           , optional:true, emit: tstv_summary\n    tuple val(meta), path(\"*.TsTv.count\")             , optional:true, emit: tstv_count\n    tuple val(meta), path(\"*.TsTv.qual\")              , optional:true, emit: tstv_qual\n    tuple val(meta), path(\"*.FILTER.summary\")         , optional:true, emit: filter_summary\n    tuple val(meta), path(\"*.sites.pi\")               , optional:true, emit: sites_pi\n    tuple val(meta), path(\"*.windowed.pi\")            , optional:true, emit: windowed_pi\n    tuple val(meta), path(\"*.weir.fst\")               , optional:true, emit: weir_fst\n    tuple val(meta), path(\"*.het\")                    , optional:true, emit: heterozygosity\n    tuple val(meta), path(\"*.hwe\")                    , optional:true, emit: hwe\n    tuple val(meta), path(\"*.Tajima.D\")               , optional:true, emit: tajima_d\n    tuple val(meta), path(\"*.ifreqburden\")            , optional:true, emit: freq_burden\n    tuple val(meta), path(\"*.LROH\")                   , optional:true, emit: lroh\n    tuple val(meta), path(\"*.relatedness\")            , optional:true, emit: relatedness\n    tuple val(meta), path(\"*.relatedness2\")           , optional:true, emit: relatedness2\n    tuple val(meta), path(\"*.lqual\")                  , optional:true, emit: lqual\n    tuple val(meta), path(\"*.imiss\")                  , optional:true, emit: missing_individual\n    tuple val(meta), path(\"*.lmiss\")                  , optional:true, emit: missing_site\n    tuple val(meta), path(\"*.snpden\")                 , optional:true, emit: snp_density\n    tuple val(meta), path(\"*.kept.sites\")             , optional:true, emit: kept_sites\n    tuple val(meta), path(\"*.removed.sites\")          , optional:true, emit: removed_sites\n    tuple val(meta), path(\"*.singletons\")             , optional:true, emit: singeltons\n    tuple val(meta), path(\"*.indel.hist\")             , optional:true, emit: indel_hist\n    tuple val(meta), path(\"*.hapcount\")               , optional:true, emit: hapcount\n    tuple val(meta), path(\"*.mendel\")                 , optional:true, emit: mendel\n    tuple val(meta), path(\"*.FORMAT\")                 , optional:true, emit: format\n    tuple val(meta), path(\"*.INFO\")                   , optional:true, emit: info\n    tuple val(meta), path(\"*.012\")                    , optional:true, emit: genotypes_matrix\n    tuple val(meta), path(\"*.012.indv\")               , optional:true, emit: genotypes_matrix_individual\n    tuple val(meta), path(\"*.012.pos\")                , optional:true, emit: genotypes_matrix_position\n    tuple val(meta), path(\"*.impute.hap\")             , optional:true, emit: impute_hap\n    tuple val(meta), path(\"*.impute.hap.legend\")      , optional:true, emit: impute_hap_legend\n    tuple val(meta), path(\"*.impute.hap.indv\")        , optional:true, emit: impute_hap_indv\n    tuple val(meta), path(\"*.ldhat.sites\")            , optional:true, emit: ldhat_sites\n    tuple val(meta), path(\"*.ldhat.locs\")             , optional:true, emit: ldhat_locs\n    tuple val(meta), path(\"*.BEAGLE.GL\")              , optional:true, emit: beagle_gl\n    tuple val(meta), path(\"*.BEAGLE.PL\")              , optional:true, emit: beagle_pl\n    tuple val(meta), path(\"*.ped\")                    , optional:true, emit: ped\n    tuple val(meta), path(\"*.map\")                    , optional:true, emit: map_\n    tuple val(meta), path(\"*.tped\")                   , optional:true, emit: tped\n    tuple val(meta), path(\"*.tfam\")                   , optional:true, emit: tfam\n    tuple val(meta), path(\"*.diff.sites_in_files\")    , optional:true, emit: diff_sites_in_files\n    tuple val(meta), path(\"*.diff.indv_in_files\")     , optional:true, emit: diff_indv_in_files\n    tuple val(meta), path(\"*.diff.sites\")             , optional:true, emit: diff_sites\n    tuple val(meta), path(\"*.diff.indv\")              , optional:true, emit: diff_indv\n    tuple val(meta), path(\"*.diff.discordance.matrix\"), optional:true, emit: diff_discd_matrix\n    tuple val(meta), path(\"*.diff.switch\")            , optional:true, emit: diff_switch_error\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args_list = args.tokenize()\n\n    def bed_arg  = (args.contains('--bed')) ? \"--bed ${bed}\" :\n        (args.contains('--exclude-bed')) ? \"--exclude-bed ${bed}\" :\n        (args.contains('--hapcount')) ? \"--hapcount ${bed}\" :\n        (args.contains('--positions')) ? \"--positions ${bed}\" :\n        (args.contains('--exclude-positions')) ? \"--exclude-positions ${bed}\"  : ''\n    args_list.removeIf { it.contains('--bed') }\n    args_list.removeIf { it.contains('--exclude-bed') }\n    args_list.removeIf { it.contains('--hapcount') }\n    args_list.removeIf { it.contains('--positions') }\n    args_list.removeIf { it.contains('--exclude-positions') }\n\n    def diff_variant_arg = (args.contains('--diff')) ? \"--diff ${diff_variant_file}\" :\n        (args.contains('--gzdiff')) ? \"--gzdiff ${diff_variant_file}\" :\n        (args.contains('--diff-bcf')) ? \"--diff-bcf ${diff_variant_file}\" : ''\n    args_list.removeIf { it.contains('--diff') }\n    args_list.removeIf { it.contains('--gzdiff') }\n    args_list.removeIf { it.contains('--diff-bcf') }\n\n    def input_file = (\"$variant_file\".endsWith(\".vcf\")) ? \"--vcf ${variant_file}\" :\n        (\"$variant_file\".endsWith(\".vcf.gz\")) ? \"--gzvcf ${variant_file}\" :\n        (\"$variant_file\".endsWith(\".bcf\")) ? \"--bcf ${variant_file}\" : ''\n\n    \"\"\"\n    vcftools \\\\\n        $input_file \\\\\n        --out $prefix \\\\\n        ${args_list.join(' ')} \\\\\n        $bed_arg \\\\\n        $diff_variant_arg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcftools: \\$(echo \\$(vcftools --version 2>&1) | sed 's/^.*VCFtools (//;s/).*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf\n    touch ${prefix}.bcf\n    touch ${prefix}.frq\n    touch ${prefix}.frq.count\n    touch ${prefix}.idepth\n    touch ${prefix}.ldepth\n    touch ${prefix}.ldepth.mean\n    touch ${prefix}.gdepth\n    touch ${prefix}.hap.ld\n    touch ${prefix}.geno.ld\n    touch ${prefix}.geno.chisq\n    touch ${prefix}.list.hap.ld\n    touch ${prefix}.list.geno.ld\n    touch ${prefix}.interchrom.hap.ld\n    touch ${prefix}.interchrom.geno.ld\n    touch ${prefix}.TsTv\n    touch ${prefix}.TsTv.summary\n    touch ${prefix}.TsTv.count\n    touch ${prefix}.TsTv.qual\n    touch ${prefix}.FILTER.summary\n    touch ${prefix}.sites.pi\n    touch ${prefix}.windowed.pi\n    touch ${prefix}.weir.fst\n    touch ${prefix}.het\n    touch ${prefix}.hwe\n    touch ${prefix}.Tajima.D\n    touch ${prefix}.ifreqburden\n    touch ${prefix}.LROH\n    touch ${prefix}.relatedness\n    touch ${prefix}.relatedness2\n    touch ${prefix}.lqual\n    touch ${prefix}.imiss\n    touch ${prefix}.lmiss\n    touch ${prefix}.snpden\n    touch ${prefix}.kept.sites\n    touch ${prefix}.removed.sites\n    touch ${prefix}.singletons\n    touch ${prefix}.indel.hist\n    touch ${prefix}.hapcount\n    touch ${prefix}.mendel\n    touch ${prefix}.FORMAT\n    touch ${prefix}.INFO\n    touch ${prefix}.012\n    touch ${prefix}.012.indv\n    touch ${prefix}.012.pos\n    touch ${prefix}.impute.hap\n    touch ${prefix}.impute.hap.legend\n    touch ${prefix}.impute.hap.indv\n    touch ${prefix}.ldhat.sites\n    touch ${prefix}.ldhat.locs\n    touch ${prefix}.BEAGLE.GL\n    touch ${prefix}.BEAGLE.PL\n    touch ${prefix}.ped\n    touch ${prefix}.map\n    touch ${prefix}.tped\n    touch ${prefix}.tfam\n    touch ${prefix}.diff.sites_in_files\n    touch ${prefix}.diff.indv_in_files\n    touch ${prefix}.diff.sites\n    touch ${prefix}.diff.indv\n    touch ${prefix}.diff.discordance.matrix\n    touch ${prefix}.diff.switch\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcftools: \\$(echo \\$(vcftools --version 2>&1) | sed 's/^.*VCFtools (//;s/).*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Annotate peaks with HOMER suite\nTags: annotations, peaks, bed", "answer": "process HOMER_ANNOTATEPEAKS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/homer:4.11--pl526hc9558a2_3' :\n        'biocontainers/homer:4.11--pl526hc9558a2_3' }\"\n\n    input:\n    tuple val(meta), path(peak)\n    path  fasta\n    path  gtf\n\n    output:\n    tuple val(meta), path(\"*annotatePeaks.txt\"), emit: txt\n    tuple val(meta), path(\"*annStats.txt\"), emit: stats, optional: true\n    path  \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '4.11' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    annotatePeaks.pl \\\\\n        $peak \\\\\n        $fasta \\\\\n        $args \\\\\n        -gtf $gtf \\\\\n        -cpu $task.cpus \\\\\n        > ${prefix}.annotatePeaks.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        homer: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Find peaks with HOMER suite\nTags: annotation, peaks, enrichment", "answer": "process HOMER_FINDPEAKS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/homer:4.11--pl526hc9558a2_3' :\n        'biocontainers/homer:4.11--pl526hc9558a2_3' }\"\n\n    input:\n    tuple val(meta), path(tagDir)\n\n    output:\n    tuple val(meta), path(\"*.peaks.txt\"), emit: txt\n    path  \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '4.11' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n\n    findPeaks \\\\\n        $tagDir \\\\\n        $args \\\\\n        -o ${prefix}.peaks.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        homer: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '4.11' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.peaks.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        homer: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a UCSC bed graph with the HOMER suite\nTags: peaks, bed, bedGraph", "answer": "process HOMER_MAKEUCSCFILE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/homer:4.11--pl526hc9558a2_3' :\n        'biocontainers/homer:4.11--pl526hc9558a2_3' }\"\n\n    input:\n    tuple val(meta), path(tagDir)\n\n    output:\n    tuple val(meta), path(\"*.bedGraph.gz\"), emit: bedGraph\n    path  \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '4.11' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    makeUCSCfile \\\\\n        $tagDir \\\\\n        -o ${prefix}.bedGraph \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        homer: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a tag directory with the HOMER suite\nTags: peaks, bed, bam, sam", "answer": "\nprocess HOMER_MAKETAGDIRECTORY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-29293b111ffe5b4c1d1e14c711264aaed6b97b4a:594338b771cacf1623bd27772b5e12825f8835f2-0' :\n        'biocontainers/mulled-v2-29293b111ffe5b4c1d1e14c711264aaed6b97b4a:594338b771cacf1623bd27772b5e12825f8835f2-0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*_tagdir\")            , emit: tagdir\n    tuple val(meta), path(\"*_tagdir/tagInfo.txt\"), emit: taginfo\n    path  \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '4.11' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    makeTagDirectory \\\\\n        ${prefix}_tagdir \\\\\n        -genome $fasta \\\\\n        $args \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        homer: $VERSION\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Coverting from HOMER peak to BED file formats\nTags: peaks, bed, pos", "answer": "process HOMER_POS2BED {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/homer:4.11--pl526hc9558a2_3' :\n        'biocontainers/homer:4.11--pl526hc9558a2_3' }\"\n\n    input:\n    tuple val(meta), path(peaks)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '4.11' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    pos2bed.pl $peaks > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        homer: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: trims the end of reads in a SAM/BAM file, changing read ends to \u2018N\u2019 and quality to \u2018!\u2019, or by soft clipping\nTags: bam, trim, clipping, bamUtil, trimBam", "answer": "process BAMUTIL_TRIMBAM {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bamutil:1.0.15--h2e03b76_1' :\n        'biocontainers/bamutil:1.0.15--h2e03b76_1' }\"\n\n    input:\n    tuple val(meta), path(bam), val(trim_left), val(trim_right)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bam \\\\\n        trimBam \\\\\n        $bam \\\\\n        ${prefix}.bam \\\\\n        $args \\\\\n        -L $trim_left \\\\\n        -R $trim_right\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamutil: \\$( echo \\$( bam trimBam 2>&1 ) | sed 's/^Version: //;s/;.*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: call variant and sequencing depth information of the variant\nTags: variants, fasta, wastewater", "answer": "process FREYJA_VARIANTS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/freyja:1.5.0--pyhdfd78af_0':\n        'biocontainers/freyja:1.5.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*.variants.tsv\"), path(\"*.depth.tsv\"), emit: variants\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    freyja \\\\\n        variants \\\\\n        $args \\\\\n        --ref $fasta \\\\\n        --variants ${prefix}.variants.tsv \\\\\n        --depths ${prefix}.depth.tsv \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freyja: \\$(echo \\$(freyja --version 2>&1) | sed 's/^.*version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.variants.tsv\n    touch ${prefix}.depth.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freyja: \\$(echo \\$(freyja --version 2>&1) | sed 's/^.*version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Bootstrap sample demixing by resampling each site based on a multinomial distribution of read depth across all sites, where the event probabilities were determined by the fraction of the total sample reads found at each site, followed by a secondary resampling at each site according to a multinomial distribution (that is, binomial when there was only one SNV at a site), where event probabilities were determined by the frequencies of each base at the site, and the number of trials is given by the sequencing depth.\nTags: variants, fasta, deconvolution, wastewater, bootstrapping", "answer": "process FREYJA_BOOT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/freyja:1.5.0--pyhdfd78af_0':\n        'biocontainers/freyja:1.5.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(variants), path(depths)\n    val repeats\n    path barcodes\n    path lineages_meta\n\n    output:\n    tuple val(meta), path(\"*lineages.csv\")  , emit: lineages\n    tuple val(meta), path(\"*summarized.csv\"), emit: summarized\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    freyja \\\\\n        boot \\\\\n        $args \\\\\n        --nt $task.cpus \\\\\n        --nb $repeats \\\\\n        --output_base $prefix \\\\\n        --barcodes $barcodes \\\\\n        --meta $lineages_meta \\\\\n        $variants \\\\\n        $depths\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freyja: \\$(echo \\$(freyja --version 2>&1) | sed 's/^.*version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_lineage.csv\n    touch ${prefix}_summarized.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freyja: \\$(echo \\$(freyja --version 2>&1) | sed 's/^.*version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: downloads new versions of the curated SARS-CoV-2 lineage file and barcodes\nTags: database, variants, UShER", "answer": "process FREYJA_UPDATE {\n    tag \"$db_name\"\n    label 'process_single'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/freyja:1.5.0--pyhdfd78af_0':\n        'biocontainers/freyja:1.5.0--pyhdfd78af_0' }\"\n\n    input:\n    val db_name\n\n    output:\n    path \"${db_name}/usher_barcodes.csv\"   , emit: barcodes\n    path \"${db_name}/lineages.yml\"         , emit: lineages_topology\n    path \"${db_name}/curated_lineages.json\", emit: lineages_meta\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir -p $db_name\n    freyja \\\\\n        update \\\\\n        --outdir $db_name\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freyja: \\$(echo \\$(freyja --version 2>&1) | sed 's/^.*version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir $db_name\n\n    touch \"${db_name}/usher_barcodes.csv\"\n    touch \"${db_name}/lineages.yml\"\n    touch \"${db_name}/curated_lineages.json\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freyja: \\$(echo \\$(freyja --version 2>&1) | sed 's/^.*version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: specify the relative abundance of each known haplotype\nTags: variants, fasta, deconvolution, wastewater", "answer": "process FREYJA_DEMIX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/freyja:1.5.0--pyhdfd78af_0':\n        'biocontainers/freyja:1.5.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(variants), path(depths)\n    path barcodes\n    path lineages_meta\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: demix\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    freyja \\\\\n        demix \\\\\n        $args \\\\\n        --output ${prefix}.tsv \\\\\n        --barcodes $barcodes \\\\\n        --meta $lineages_meta \\\\\n        $variants \\\\\n        $depths\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freyja: \\$(echo \\$(freyja --version 2>&1) | sed 's/^.*version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freyja: \\$(echo \\$(freyja --version 2>&1) | sed 's/^.*version //' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: a tool for indexing and querying on a block-compressed text file\ncontaining pairs of genomic coordinates\n\nTags: index", "answer": "process PAIRIX {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pairix:0.3.7--py36h30a8e3e_3' :\n        'biocontainers/pairix:0.3.7--py36h30a8e3e_3' }\"\n\n    input:\n    tuple val(meta), path(pair)\n\n    output:\n    tuple val(meta), path(pair), path(\"*.px2\"), emit: index\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    pairix \\\\\n        $args \\\\\n        $pair\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pairix: \\$(echo \\$(pairix --help 2>&1) | sed 's/^.*Version: //; s/Usage.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: contiguate draft genome assembly\nTags: genome, assembly, contiguate", "answer": "process ABACAS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/abacas:1.3.1--pl526_0' :\n        'biocontainers/abacas:1.3.1--pl526_0' }\"\n\n    input:\n    tuple val(meta), path(scaffold)\n    path  fasta\n\n    output:\n    tuple val(meta), path('*.abacas*'), emit: results\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    abacas.pl \\\\\n        -r $fasta \\\\\n        -q $scaffold \\\\\n        $args \\\\\n        -o ${prefix}.abacas\n\n    mv nucmer.delta ${prefix}.abacas.nucmer.delta\n    mv nucmer.filtered.delta ${prefix}.abacas.nucmer.filtered.delta\n    mv nucmer.tiling ${prefix}.abacas.nucmer.tiling\n    mv unused_contigs.out ${prefix}.abacas.unused.contigs.out\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        abacas: \\$(echo \\$(abacas.pl -v 2>&1) | sed 's/^.*ABACAS.//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Render a Quarto notebook, including parametrization.\nTags: quarto, notebook, reports, python, r", "answer": "include { dumpParamsYaml; indentCodeBlock } from \"./parametrize\"\n\nprocess QUARTONOTEBOOK {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // NB: You'll likely want to override this with a container containing all\n    // required dependencies for your analyses. You'll at least need Quarto\n    // itself, Papermill and whatever language you are running your analyses on;\n    // you can see an example in this module's Dockerfile.\n    container \"docker.io/erikfas/quartonotebook\"\n\n    input:\n    tuple val(meta), path(notebook)\n    val parameters\n    path input_files\n    path extensions\n\n    output:\n    tuple val(meta), path(\"*.html\")     , emit: html\n    tuple val(meta), path(\"${notebook}\"), emit: notebook\n    tuple val(meta), path(\"artifacts/*\"), emit: artifacts, optional: true\n    tuple val(meta), path(\"params.yml\") , emit: params_yaml, optional: true\n    tuple val(meta), path(\"_extensions\"), emit: extensions, optional: true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    // This is because of issues with getting a homogenous environment across\n    // both AMD64 and ARM64 architectures; please find more information at\n    // https://github.com/nf-core/modules/pull/4876#discussion_r1483541037.\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"The QUARTONOTEBOOK module does not support Conda/Mamba, please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def parametrize = (task.ext.parametrize == null) ?  true : task.ext.parametrize\n    def implicit_params = (task.ext.implicit_params == null) ? true : task.ext.implicit_params\n    def meta_params = (task.ext.meta_params == null) ? true : task.ext.meta_params\n\n    // Dump parameters to yaml file.\n    // Using a YAML file over using the CLI params because\n    //  - No issue with escaping\n    //  - Allows passing nested maps instead of just single values\n    //  - Allows running with the language-agnostic `--execute-params`\n    def params_cmd = \"\"\n    def render_args = \"\"\n    if (parametrize) {\n        nb_params = [:]\n        if (implicit_params) {\n            nb_params[\"cpus\"] = task.cpus\n            nb_params[\"artifact_dir\"] = \"artifacts\"\n            nb_params[\"input_dir\"] = \"./\"\n        }\n        if (meta_params) {\n            nb_params[\"meta\"] = meta\n        }\n        nb_params += parameters\n        params_cmd = dumpParamsYaml(nb_params)\n        render_args = \"--execute-params params.yml\"\n    }\n    \"\"\"\n    # Dump .params.yml heredoc (section will be empty if parametrization is disabled)\n    ${indentCodeBlock(params_cmd, 4)}\n\n    # Create output directory\n    mkdir artifacts\n\n    # Set environment variables needed for Quarto rendering\n    export XDG_CACHE_HOME=\"./.xdg_cache_home\"\n    export XDG_DATA_HOME=\"./.xdg_data_home\"\n\n    # Set parallelism for BLAS/MKL etc. to avoid over-booking of resources\n    export MKL_NUM_THREADS=\"$task.cpus\"\n    export OPENBLAS_NUM_THREADS=\"$task.cpus\"\n    export OMP_NUM_THREADS=\"$task.cpus\"\n    export NUMBA_NUM_THREADS=\"$task.cpus\"\n\n    # Render notebook\n    quarto render \\\\\n        ${notebook} \\\\\n        ${render_args} \\\\\n        ${args} \\\\\n        --output ${prefix}.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        quarto: \\$(quarto -v)\n        papermill: \\$(papermill --version | cut -f1 -d' ')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        quarto: \\$(quarto -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Simulation tool to generate synthetic Illumina next-generation sequencing reads\nTags: fastq, fasta, illumina, simulate", "answer": "process ART_ILLUMINA {\n\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/art:2016.06.05--h589041f_9':\n        'biocontainers/art:2016.06.05--h589041f_9' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val(sequencing_system)\n    val(fold_coverage)\n    val(read_length)\n\n    output:\n    tuple val(meta), path(\"*.fq.gz\"), emit: fastq\n    tuple val(meta), path(\"*.aln\"), optional:true , emit: aln\n    tuple val(meta), path(\"*.sam\"), optional:true , emit: sam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2016.06.05' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    art_illumina \\\\\n        -ss $sequencing_system \\\\\n        -i $fasta \\\\\n        -l $read_length \\\\\n        -f $fold_coverage \\\\\n        -o $prefix \\\\\n        $args\n\n    gzip \\\\\n        --no-name \\\\\n        $args2 \\\\\n        $prefix*.fq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        art: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2016.06.05'\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.fq.gz\n    echo \"\" | gzip >  ${prefix}1.fq.gz\n    echo \"\" | gzip >  ${prefix}2.fq.gz\n    touch ${prefix}.aln\n    touch ${prefix}1.aln\n    touch ${prefix}2.aln\n    touch ${prefix}.sam\n    touch ${prefix}1.sam\n    touch ${prefix}2.sam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        art: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: runs a differential expression analysis with DESeq2\nTags: differential, expression, rna-seq, deseq2", "answer": "process DESEQ2_DIFFERENTIAL {\n    tag \"$meta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-deseq2:1.34.0--r41hc247a5b_3' :\n        'biocontainers/bioconductor-deseq2:1.34.0--r41hc247a5b_3' }\"\n\n    input:\n    tuple val(meta), val(contrast_variable), val(reference), val(target)\n    tuple val(meta2), path(samplesheet), path(counts)\n    tuple val(meta3), path(control_genes_file)\n    tuple val(meta4), path(transcript_lengths_file)\n\n    output:\n    tuple val(meta), path(\"*.deseq2.results.tsv\")              , emit: results\n    tuple val(meta), path(\"*.deseq2.dispersion.png\")           , emit: dispersion_plot\n    tuple val(meta), path(\"*.dds.rld.rds\")                     , emit: rdata\n    tuple val(meta), path(\"*.deseq2.sizefactors.tsv\")          , emit: size_factors\n    tuple val(meta), path(\"*.normalised_counts.tsv\")           , emit: normalised_counts\n    tuple val(meta), path(\"*.rlog.tsv\")                        , optional: true, emit: rlog_counts\n    tuple val(meta), path(\"*.vst.tsv\")                         , optional: true, emit: vst_counts\n    tuple val(meta), path(\"*.deseq2.model.txt\")                , emit: model\n    tuple val(meta), path(\"*.R_sessionInfo.log\")               , emit: session_info\n    path \"versions.yml\"                                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'deseq_de.R'\n\n    stub:\n    \"\"\"\n    touch ${meta.id}.deseq2.results.tsv\n    touch ${meta.id}.deseq2.dispersion.png\n    touch ${meta.id}.dds.rld.rds\n    touch ${meta.id}.deseq2.sizefactors.tsv\n    touch ${meta.id}.normalised_counts.tsv\n    touch ${meta.id}.rlog.tsv\n    touch ${meta.id}.deseq2.model.txt\n    touch ${meta.id}.R_sessionInfo.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bioconductor-deseq2: \\$(Rscript -e \"library(DESeq2); cat(as.character(packageVersion('DESeq2')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Evaluate microsattelite instability (MSI) using paired tumor-normal sequencing data\nTags: homoploymer,microsatellite", "answer": "process MSISENSOR_MSI {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/msisensor:0.5--hb3646a4_2' :\n        'biocontainers/msisensor:0.5--hb3646a4_2' }\"\n\n    input:\n    tuple val(meta), path(normal_bam), path(normal_bai), path(tumor_bam), path(tumor_bai), val(metascan), path(homopolymers)\n\n    output:\n    tuple val(meta), path(\"${prefix}\")         , emit: output\n    tuple val(meta), path(\"${prefix}_dis\")     , emit: output_dis\n    tuple val(meta), path(\"${prefix}_germline\"), emit: output_germline\n    tuple val(meta), path(\"${prefix}_somatic\") , emit: output_somatic\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    msisensor \\\\\n        msi \\\\\n        -d $homopolymers \\\\\n        -n $normal_bam \\\\\n        -t $tumor_bam \\\\\n        -o $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        msisensor: \\$(msisensor 2>&1 | sed -nE 's/Version:\\\\sv([0-9]\\\\.[0-9])/\\\\1/ p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Scan a reference genome to get microsatellite & homopolymer information\nTags: homoploymer,microsatellite", "answer": "process MSISENSOR_SCAN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/msisensor:0.5--hb3646a4_2' :\n        'biocontainers/msisensor:0.5--hb3646a4_2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tab\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    msisensor \\\\\n        scan \\\\\n        -d $fasta \\\\\n        -o ${prefix}.msisensor_scan.tab \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        msisensor: \\$(msisensor 2>&1 | sed -nE 's/Version:\\\\sv([0-9]\\\\.[0-9])/\\\\1/ p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: plots values produced by deeptools_computematrix as a profile plot\nTags: plot, profile, scores, matrix", "answer": "process DEEPTOOLS_PLOTPROFILE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeptools:3.5.5--pyhdfd78af_0':\n        'biocontainers/deeptools:3.5.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(matrix)\n\n    output:\n    tuple val(meta), path(\"*.pdf\"), emit: pdf\n    tuple val(meta), path(\"*.tab\"), emit: table\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    plotProfile \\\\\n        $args \\\\\n        --matrixFile $matrix \\\\\n        --outFileName ${prefix}.plotProfile.pdf \\\\\n        --outFileNameData ${prefix}.plotProfile.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotProfile --version | sed -e \"s/plotProfile //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.plotProfile.pdf\n    touch ${prefix}.plotProfile.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotProfile --version | sed -e \"s/plotProfile //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: calculates scores per genome regions for other deeptools plotting utilities\nTags: genome, regions, scores, matrix", "answer": "process DEEPTOOLS_COMPUTEMATRIX {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeptools:3.5.5--pyhdfd78af_0':\n        'biocontainers/deeptools:3.5.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bigwig)\n    path  bed\n\n    output:\n    tuple val(meta), path(\"*.mat.gz\") , emit: matrix\n    tuple val(meta), path(\"*.mat.tab\"), emit: table\n    path  \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    computeMatrix \\\\\n        $args \\\\\n        --regionsFileName $bed \\\\\n        --scoreFileName $bigwig \\\\\n        --outFileName ${prefix}.computeMatrix.mat.gz \\\\\n        --outFileNameMatrix ${prefix}.computeMatrix.vals.mat.tab \\\\\n        --numberOfProcessors $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(computeMatrix --version | sed -e \"s/computeMatrix //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.computeMatrix.mat.gz\n    touch ${prefix}.computeMatrix.vals.mat.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(computeMatrix --version | sed -e \"s/computeMatrix //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generates principal component analysis (PCA) plot using a compressed matrix generated by multibamsummary or multibigwigsummary as input.\nTags: PCA, matrix, bam, bigwig", "answer": "process DEEPTOOLS_PLOTPCA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeptools:3.5.5--pyhdfd78af_0':\n        'biocontainers/deeptools:3.5.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(matrix)\n\n    output:\n    tuple val(meta), path(\"*.pdf\"), emit: pdf\n    tuple val(meta), path(\"*.tab\"), emit: tab\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    plotPCA \\\\\n        $args \\\\\n        --corData $matrix \\\\\n        --plotFile ${prefix}.plotPCA.pdf \\\\\n        --outFileNameData ${prefix}.plotPCA.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotPCA --version | sed -e \"s/plotPCA //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.plotPCA.pdf\n    touch ${prefix}.plotPCA.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotPCA --version | sed -e \"s/plotPCA //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: plots values produced by deeptools_computematrix as a heatmap\nTags: plot, heatmap, scores, matrix", "answer": "process DEEPTOOLS_PLOTHEATMAP {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeptools:3.5.5--pyhdfd78af_0':\n        'biocontainers/deeptools:3.5.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(matrix)\n\n    output:\n    tuple val(meta), path(\"*.pdf\"), emit: pdf\n    tuple val(meta), path(\"*.tab\"), emit: table\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    plotHeatmap \\\\\n        $args \\\\\n        --matrixFile $matrix \\\\\n        --outFileName ${prefix}.plotHeatmap.pdf \\\\\n        --outFileNameMatrix ${prefix}.plotHeatmap.mat.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotHeatmap --version | sed -e \"s/plotHeatmap //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.plotHeatmap.pdf\n    touch ${prefix}.plotHeatmap.mat.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotFingerprint --version | sed -e \"s/plotFingerprint //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This tool takes an alignment of reads or fragments as input (BAM file) and generates a coverage track (bigWig or bedGraph) as output.\nTags: coverage, depth, track", "answer": "process DEEPTOOLS_BAMCOVERAGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-eb9e7907c7a753917c1e4d7a64384c047429618a:41defd13a6f2ce014549fcc05d0b051f655777f9-0':\n        'biocontainers/mulled-v2-eb9e7907c7a753917c1e4d7a64384c047429618a:41defd13a6f2ce014549fcc05d0b051f655777f9-0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    path(fasta)\n    path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.bigWig\")   , emit: bigwig, optional: true\n    tuple val(meta), path(\"*.bedgraph\") , emit: bedgraph, optional: true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args ?: ''\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--outFileFormat bedgraph\") || args.contains(\"-of bedgraph\") ? \"bedgraph\" : \"bigWig\"\n\n    // cram_input is currently not working with deeptools\n    // therefore it's required to convert cram to bam first\n    def is_cram = input.Extension == \"cram\" ? true : false\n    def input_out = is_cram ? input.BaseName + \".bam\" : \"${input}\"\n    def fai_reference = fasta_fai ? \"--fai-reference ${fasta_fai}\" : \"\"\n\n    if (is_cram){\n        \"\"\"\n        samtools view -T $fasta $input $fai_reference -@ $task.cpus -o $input_out\n        samtools index -b $input_out -@ $task.cpus\n\n        bamCoverage \\\\\n            --bam $input_out \\\\\n            $args \\\\\n            --numberOfProcessors ${task.cpus} \\\\\n            --outFileName ${prefix}.${extension}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n            deeptools: \\$(bamCoverage --version | sed -e \"s/bamCoverage //g\")\n        END_VERSIONS\n        \"\"\"\n    }\n    else {\n        \"\"\"\n        bamCoverage \\\\\n            --bam $input_out \\\\\n            $args \\\\\n            --numberOfProcessors ${task.cpus} \\\\\n            --outFileName ${prefix}.${extension}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            deeptools: \\$(bamCoverage --version | sed -e \"s/bamCoverage //g\")\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--outFileFormat bedgraph\") || args.contains(\"-of bedgraph\") ? \".bedgraph\" : \".bigWig\"\n    \"\"\"\n    touch ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(bamCoverage --version | sed -e \"s/bamCoverage //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Visualises sample correlations using a compressed matrix generated by mutlibamsummary or multibigwigsummary as input.\nTags: corrrelation, matrix, heatmap, scatterplot", "answer": "process DEEPTOOLS_PLOTCORRELATION {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeptools:3.5.5--pyhdfd78af_0':\n        'biocontainers/deeptools:3.5.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(matrix)\n    val(method)\n    val(plot_type)\n\n    output:\n    tuple val(meta), path(\"*.pdf\"), emit: pdf\n    tuple val(meta), path(\"*.tab\"), emit: matrix\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def resolved_method = method ?: 'spearman'\n    def resolved_plot_type = plot_type ?: 'heatmap'\n    \"\"\"\n    plotCorrelation \\\\\n        $args \\\\\n        --corData $matrix \\\\\n        --corMethod $resolved_method \\\\\n        --whatToPlot $resolved_plot_type \\\\\n        --plotFile ${prefix}.plotCorrelation.pdf \\\\\n        --outFileCorMatrix ${prefix}.plotCorrelation.mat.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotCorrelation --version | sed -e \"s/plotCorrelation //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.plotCorrelation.pdf\n    touch ${prefix}.plotCorrelation.mat.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotCorrelation --version | sed -e \"s/plotCorrelation //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: plots cumulative reads coverages by BAM file\nTags: plot, fingerprint, cumulative coverage, bam", "answer": "process DEEPTOOLS_PLOTFINGERPRINT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeptools:3.5.5--pyhdfd78af_0':\n        'biocontainers/deeptools:3.5.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bams), path(bais)\n\n    output:\n    tuple val(meta), path(\"*.pdf\")          , emit: pdf\n    tuple val(meta), path(\"*.raw.txt\")      , emit: matrix\n    tuple val(meta), path(\"*.qcmetrics.txt\"), emit: metrics\n    path  \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extend   = (meta.single_end && params.fragment_size > 0) ? \"--extendReads ${params.fragment_size}\" : ''\n    \"\"\"\n    plotFingerprint \\\\\n        $args \\\\\n        $extend \\\\\n        --bamfiles ${bams.join(' ')} \\\\\n        --plotFile ${prefix}.plotFingerprint.pdf \\\\\n        --outRawCounts ${prefix}.plotFingerprint.raw.txt \\\\\n        --outQualityMetrics ${prefix}.plotFingerprint.qcmetrics.txt \\\\\n        --numberOfProcessors $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotFingerprint --version | sed -e \"s/plotFingerprint //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.plotFingerprint.pdf\n    touch ${prefix}.plotFingerprint.raw.txt\n    touch ${prefix}.plotFingerprint.qcmetrics.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(plotFingerprint --version | sed -e \"s/plotFingerprint //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes read coverage for genomic regions (bins) across the entire genome.\nTags: bam, coverage, genome, bin", "answer": "process DEEPTOOLS_MULTIBAMSUMMARY {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeptools:3.5.5--pyhdfd78af_0':\n        'biocontainers/deeptools:3.5.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bams), path(bais), val(labels)\n\n    output:\n    tuple val(meta), path(\"*.npz\") , emit: matrix\n    path  \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"all_bam\"\n    def label  = labels ? \"--labels ${labels.join(' ')}\" : ''\n    \"\"\"\n    multiBamSummary bins \\\\\n        $args \\\\\n        $label \\\\\n        --bamfiles ${bams.join(' ')} \\\\\n        --numberOfProcessors $task.cpus \\\\\n        --outFileName ${prefix}.bamSummary.npz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(multiBamSummary --version | sed -e \"s/multiBamSummary //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"all_bam\"\n    \"\"\"\n    touch ${prefix}.bamSummary.npz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeptools: \\$(multiBamSummary --version | sed -e \"s/multiBamSummary //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Analyses a DAA file and exports information in text format\nTags: megan, diamond, daa, classification, conversion", "answer": "process MEGAN_DAA2INFO {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/megan:6.24.20--h9ee0642_0':\n        'biocontainers/megan:6.24.20--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(daa)\n    val(megan_summary)\n\n    output:\n    tuple val(meta), path(\"*.txt.gz\")               , emit: txt_gz\n    tuple val(meta), path(\"*.megan\"), optional: true, emit: megan\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def summary = megan_summary ? \"-es ${prefix}.megan\" : \"\"\n    \"\"\"\n    daa2info \\\\\n        -i ${daa} \\\\\n        -o ${prefix}.txt.gz \\\\\n        ${summary} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        megan: \\$(echo \\$(rma2info 2>&1) | grep version | sed 's/.*version //g;s/, built.*//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Analyses an RMA file and exports information in text format\nTags: megan, rma6, classification, conversion", "answer": "process MEGAN_RMA2INFO {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/megan:6.25.9--h9ee0642_0':\n        'biocontainers/megan:6.25.9--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(rma6)\n    val(megan_summary)\n\n    output:\n    tuple val(meta), path(\"*.txt.gz\")               , emit: txt\n    tuple val(meta), path(\"*.megan\"), optional: true, emit: megan_summary\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def summary = megan_summary ? \"-es ${prefix}.megan\" : \"\"\n    \"\"\"\n    rma2info \\\\\n        -i ${rma6} \\\\\n        -o ${prefix}.txt.gz \\\\\n        ${summary} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        megan: \\$(echo \\$(rma2info 2>&1) | grep version | sed 's/.*version //g;s/, built.*//g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def summary = megan_summary ? \"-es ${prefix}.megan\" : \"\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.txt.gz\n    touch ${prefix}.megan\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        megan: \\$(echo \\$(rma2info 2>&1) | grep version | sed 's/.*version //g;s/, built.*//g')\n    END_VERSIONSs\n    \"\"\"\n}\n"}
{"question": "Description: A tool to standardize VCF files from structural variant callers\nTags: structural variants, vcf, standardization, standardize, sv", "answer": "process SVYNC {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svync:0.1.2--h9ee0642_0':\n        'biocontainers/svync:0.1.2--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(config)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def args2  = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$vcf\" == \"${prefix}.vcf.gz\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    svync \\\\\n        $args \\\\\n        --config $config \\\\\n        --input $vcf \\\\\n        | bgzip --threads $task.cpus $args2 > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svync: \\$(svync --version | sed 's/svync version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$vcf\" == \"${prefix}.vcf.gz\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    echo | gzip -n > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svync: \\$(svync --version | sed 's/svync version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert VCF with structural variations to CytoSure format\nTags: structural_variants, array_cgh, vcf, cytosure", "answer": "process VCF2CYTOSURE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vcf2cytosure:0.9.1--pyh7cba7a3_1':\n        'biocontainers/vcf2cytosure:0.9.1--pyh7cba7a3_1' }\"\n\n    input:\n    tuple val(meta), path(sv_vcf)\n    tuple val(meta2), path(coverage_bed)\n    tuple val(meta3), path(cns)\n    tuple val(meta4), path(snv_vcf)\n    path(blacklist_bed)\n\n    output:\n    tuple val(meta), path(\"*.cgh\"), emit: cgh\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def coverage = coverage_bed ? \"--coverage ${coverage_bed}\" : ''\n    def cnvkit = cns ? ( coverage_bed ? '' : \"--cn ${cns}\" ) : ''\n    def snv = snv_vcf ? ( coverage_bed ? '' : \"--snv ${snv_vcf}\" ) : ''\n    def blacklist = blacklist_bed ? \"--blacklist ${blacklist_bed}\" : ''\n    def prefix = task.ext.prefix ?: sv_vcf ? \"${meta.id}\" : \"${meta3.id}\"\n\n    if ( cns && coverage_bed || snv_vcf && coverage_bed ) error \"Coverage_bed input is not compatible with cns and snv\"\n\n    \"\"\"\n    vcf2cytosure \\\\\n        --vcf $sv_vcf \\\\\n        --out ${prefix}.cgh \\\\\n        $coverage \\\\\n        $cnvkit \\\\\n        $snv \\\\\n        $blacklist \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcf2cytosure: \\$(echo \\$(vcf2cytosure --version 2>&1) | sed 's/^.* cytosure //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def coverage = coverage_bed ? \"--coverage ${coverage_bed}\" : ''\n    def cnvkit = cns ? ( coverage_bed ? '' : \"--cn ${cns}\" ) : ''\n    def snv = snv_vcf ? ( coverage_bed ? '' : \"--snv ${snv_vcf}\" ) : ''\n    def blacklist = blacklist_bed ? \"--blacklist ${blacklist_bed}\" : ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.cgh\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcf2cytosure: \\$(echo \\$(vcf2cytosure --version 2>&1) | sed 's/^.* cytosure //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Genomic island prediction in bacterial and archaeal genomes\nTags: genomes, genomic islands, prediction", "answer": "process ISLANDPATH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/islandpath:1.0.6--hdfd78af_0':\n        'biocontainers/islandpath:1.0.6--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(genome)\n\n    output:\n    tuple val(meta), path(\"*.gff\")        , emit: gff\n    path \"Dimob.log\"                      , emit: log\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def VERSION = '1.0.6'\n    \"\"\"\n    islandpath \\\\\n        $genome \\\\\n        ${prefix}.gff \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        islandpath: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Provide the SNP coverage of each individual in an eigenstrat formatted dataset.\nTags: coverage, eigenstrat, eigenstratdatabasetools, snp, snps", "answer": "process EIGENSTRATDATABASETOOLS_EIGENSTRATSNPCOVERAGE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/eigenstratdatabasetools:1.1.0--hdfd78af_0':\n        'biocontainers/eigenstratdatabasetools:1.1.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(geno), path(snp), path(ind)\n\n    output:\n    tuple val(meta), path(\"*.tsv\") , emit: tsv\n    tuple val(meta), path(\"*.json\"), emit: json, optional:true\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    eigenstrat_snp_coverage \\\\\n        $args \\\\\n        -g ${geno} \\\\\n        -s ${snp} \\\\\n        -i ${ind} \\\\\n        -o ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        eigenstratdatabasetools: \\$(echo \\$(eigenstrat_snp_coverage --version 2>&1) | sed 's/^.*eigenstrat_snp_coverage //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Efficient compression tool for protein structures\nTags: protein, structure, compression", "answer": "process FOLDCOMP_COMPRESS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/foldcomp:0.0.7--h43eeafb_0':\n        'biocontainers/foldcomp:0.0.7--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(pdb)\n\n    output:\n    tuple val(meta), path(\"*fcz\"), emit: fcz\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def ext = pdb.isDirectory() ? \"_fcz\" : \".fcz\"\n    \"\"\"\n    foldcomp \\\\\n        compress \\\\\n        -t ${task.cpus} \\\\\n        ${pdb} \\\\\n        ${prefix}${ext} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        foldcomp: \\$(foldcomp --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fcz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        foldcomp: \\$(foldcomp --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Decompression tool for foldcomp compressed structures\nTags: protein, structure, compression", "answer": "process FOLDCOMP_DECOMPRESS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/foldcomp:0.0.7--h43eeafb_0':\n        'biocontainers/foldcomp:0.0.7--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(fcz)\n\n    output:\n    tuple val(meta), path(\"{*pdb,*.cif}\"), emit: pdb\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    foldcomp \\\\\n        $args \\\\\n        decompress \\\\\n        -t ${task.cpus} \\\\\n        ${fcz}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        foldcomp: \\$(foldcomp --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.pdb\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        foldcomp: \\$(foldcomp --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: runs a differential expression analysis with Limma\nTags: differential, expression, microarray, limma", "answer": "process LIMMA_DIFFERENTIAL {\n    tag \"$meta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-limma:3.54.0--r42hc0cfd56_0' :\n        'biocontainers/bioconductor-limma:3.54.0--r42hc0cfd56_0' }\"\n\n    input:\n    tuple val(meta), val(contrast_variable), val(reference), val(target)\n    tuple val(meta2), path(samplesheet), path(intensities)\n\n    output:\n    tuple val(meta), path(\"*.limma.results.tsv\")          , emit: results\n    tuple val(meta), path(\"*.limma.mean_difference.png\")  , emit: md_plot\n    tuple val(meta), path(\"*.MArrayLM.limma.rds\")         , emit: rdata\n    tuple val(meta), path(\"*.limma.model.txt\")            , emit: model\n    tuple val(meta), path(\"*.R_sessionInfo.log\")          , emit: session_info\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'limma_de.R'\n}\n"}
{"question": "Description: Split a vcf file into files per chromosome\nTags: vcf, split, genomics", "answer": "process BCFTOOLS_SPLIT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")   , emit: split_vcf\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    bcftools index -s ${vcf} |\\\\\n    cut -f 1 | \\\\\n    while read C; do \\\\\n        bcftools view -O z -o ${prefix}.\\${C}.vcf.gz ${vcf} --regions \"\\${C}\" ;\\\\\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch \"${prefix}.chr1.vcf.gz\"\n    touch \"${prefix}.chr2.vcf.gz\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Concatenate VCF files\nTags: variant calling, concat, bcftools, VCF", "answer": "process BCFTOOLS_CONCAT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcfs), path(tbi)\n\n    output:\n    tuple val(meta), path(\"*.gz\") , emit: vcf\n    tuple val(meta), path(\"*.tbi\"), emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\"), emit: csi, optional: true\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    def prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bcftools concat \\\\\n        --output ${prefix}.vcf.gz \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        ${vcfs}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args   ?: ''\n    def prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n    def create_index = index.matches(\"csi|tbi\") ? \"touch ${prefix}.vcf.gz.${index}\" : \"\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compresses VCF files\nTags: variant calling, consensus, VCF", "answer": "process BCFTOOLS_CONSENSUS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(fasta)\n\n    output:\n    tuple val(meta), path('*.fa'), emit: fasta\n    path  \"versions.yml\"         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cat $fasta \\\\\n        | bcftools \\\\\n            consensus \\\\\n            $vcf \\\\\n            $args \\\\\n            > ${prefix}.fa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A program for detecting runs of homo/autozygosity. Only bi-allelic sites are considered.\nTags: roh, biallelic, homozygosity, autozygosity", "answer": "process BCFTOOLS_ROH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n    tuple path(af_file), path(af_file_tbi)\n    path genetic_map\n    path regions_file\n    path samples_file\n    path targets_file\n\n    output:\n    tuple val(meta), path(\"*.roh\"), emit: roh\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args   ?: ''\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def af_read   = af_file         ? \"--AF-file ${af_file}\"           : ''\n    def gen_map   = genetic_map     ? \"--genetic-map ${genetic_map}\"   : ''\n    def reg_file  = regions_file    ? \"--regions-file ${regions_file}\" : ''\n    def samp_file = samples_file    ? \"--samples-file ${samples_file}\" : ''\n    def targ_file = targets_file    ? \"--targets-file ${targets_file}\" : ''\n    \"\"\"\n    bcftools \\\\\n        roh \\\\\n        $args \\\\\n        $af_read \\\\\n        $gen_map \\\\\n        $reg_file \\\\\n        $samp_file \\\\\n        $targ_file \\\\\n        -o ${prefix}.roh \\\\\n        $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.roh\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sorts VCF files\nTags: sorting, VCF, variant calling", "answer": "process BCFTOOLS_SORT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,vcf.gz,bcf,bcf.gz}\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")                    , emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\")                    , emit: csi, optional: true\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: '--output-type z'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n\n    \"\"\"\n    bcftools \\\\\n        sort \\\\\n        --output ${prefix}.${extension} \\\\\n        --temp-dir . \\\\\n        $args \\\\\n        $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: '--output-type z'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n    def create_cmd = extension.endsWith(\".gz\") ? \"echo '' | gzip >\" : \"touch\"\n    def create_index = extension.endsWith(\".gz\") && index.matches(\"csi|tbi\") ? \"touch ${prefix}.${extension}.${index}\" : \"\"\n\n    \"\"\"\n    ${create_cmd} ${prefix}.${extension}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge VCF files\nTags: variant calling, merge, VCF", "answer": "process BCFTOOLS_MERGE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcfs), path(tbis)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    path(bed)\n\n    output:\n    tuple val(meta), path(\"*.{bcf,vcf}{,.gz}\"), emit: merged_variants\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    def prefix   = task.ext.prefix ?: \"${meta.id}\"\n\n    def regions = bed ? \"--regions-file $bed\" : \"\"\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n\n    \"\"\"\n    bcftools merge \\\\\n        $args \\\\\n        $regions \\\\\n        --threads $task.cpus \\\\\n        --output ${prefix}.${extension} \\\\\n        $vcfs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compresses VCF files\nTags: variant calling, mpileup, VCF", "answer": "process BCFTOOLS_MPILEUP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(intervals)\n    tuple val(meta2), path(fasta)\n    val save_mpileup\n\n    output:\n    tuple val(meta), path(\"*vcf.gz\")     , emit: vcf\n    tuple val(meta), path(\"*vcf.gz.tbi\") , emit: tbi\n    tuple val(meta), path(\"*stats.txt\")  , emit: stats\n    tuple val(meta), path(\"*.mpileup.gz\"), emit: mpileup, optional: true\n    path  \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def mpileup = save_mpileup ? \"| tee ${prefix}.mpileup\" : \"\"\n    def bgzip_mpileup = save_mpileup ? \"bgzip ${prefix}.mpileup\" : \"\"\n    def intervals = intervals ? \"-T ${intervals}\" : \"\"\n    \"\"\"\n    echo \"${meta.id}\" > sample_name.list\n\n    bcftools \\\\\n        mpileup \\\\\n        --fasta-ref $fasta \\\\\n        $args \\\\\n        $bam \\\\\n        $intervals \\\\\n        $mpileup \\\\\n        | bcftools call --output-type v $args2 \\\\\n        | bcftools reheader --samples sample_name.list \\\\\n        | bcftools view --output-file ${prefix}.vcf.gz --output-type z $args3\n\n    $bgzip_mpileup\n\n    tabix -p vcf -f ${prefix}.vcf.gz\n\n    bcftools stats ${prefix}.vcf.gz > ${prefix}.bcftools_stats.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bcftools_stats.txt\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.mpileup.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Reheader a VCF file\nTags: reheader, vcf, update header", "answer": "process BCFTOOLS_REHEADER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(header), path(samples)\n    tuple val(meta2), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,vcf.gz,bcf,bcf.gz}\"), emit: vcf\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def fai_argument      = fai ? \"--fai $fai\" : \"\"\n    def header_argument   = header ? \"--header $header\" : \"\"\n    def samples_argument  = samples ? \"--samples $samples\" : \"\"\n\n    def args2 = task.ext.args2 ?: '--output-type z'\n    def extension = args2.contains(\"--output-type b\") || args2.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args2.contains(\"--output-type u\") || args2.contains(\"-Ou\") ? \"bcf\" :\n                    args2.contains(\"--output-type z\") || args2.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args2.contains(\"--output-type v\") || args2.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    \"\"\"\n    bcftools \\\\\n        reheader \\\\\n        $fai_argument \\\\\n        $header_argument \\\\\n        $samples_argument \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        $vcf \\\\\n        | bcftools view \\\\\n        $args2 \\\\\n        --output ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args2 = task.ext.args2 ?: '--output-type z'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = args2.contains(\"--output-type b\") || args2.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args2.contains(\"--output-type u\") || args2.contains(\"-Ou\") ? \"bcf\" :\n                    args2.contains(\"--output-type z\") || args2.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args2.contains(\"--output-type v\") || args2.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Add or remove annotations.\nTags: bcftools, annotate, vcf, remove, add", "answer": "process BCFTOOLS_ANNOTATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(index)\n    path(annotations)\n    path(annotations_index)\n    path(header_lines)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,vcf.gz,bcf,bcf.gz}\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")                    , emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\")                    , emit: csi, optional: true\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def header_file = header_lines ? \"--header-lines ${header_lines}\" : ''\n    def annotations_file = annotations ? \"--annotations ${annotations}\" : ''\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    def index_command = !index ? \"bcftools index $input\" : ''\n\n    if (\"$input\" == \"${prefix}.${extension}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    $index_command\n\n    bcftools \\\\\n        annotate \\\\\n        $args \\\\\n        $annotations_file \\\\\n        $header_file \\\\\n        --output ${prefix}.${extension} \\\\\n        --threads $task.cpus \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$( bcftools --version |& sed '1!d; s/^.*bcftools //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n    def create_cmd = extension.endsWith(\".gz\") ? \"echo '' | gzip >\" : \"touch\"\n    def create_index = extension.endsWith(\".gz\") && index.matches(\"csi|tbi\") ? \"touch ${prefix}.${extension}.${index}\" : \"\"\n\n    \"\"\"\n    ${create_cmd} ${prefix}.${extension}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$( bcftools --version |& sed '1!d; s/^.*bcftools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Normalize VCF file\nTags: normalize, norm, variant calling, VCF", "answer": "process BCFTOOLS_NORM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,vcf.gz,bcf,bcf.gz}\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")                    , emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\")                    , emit: csi, optional: true\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: '--output-type z'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf.gz\"\n\n    \"\"\"\n    bcftools norm \\\\\n        --fasta-ref ${fasta} \\\\\n        --output ${prefix}.${extension}\\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        ${vcf}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: '--output-type z'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf.gz\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n    def create_cmd = extension.endsWith(\".gz\") ? \"echo '' | gzip >\" : \"touch\"\n    def create_index = extension.endsWith(\".gz\") && index.matches(\"csi|tbi\") ? \"touch ${prefix}.${extension}.${index}\" : \"\"\n\n    \"\"\"\n    ${create_cmd} ${prefix}.${extension}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split VCF by sample, creating single- or multi-sample VCFs.\nTags: split, vcf, genomics", "answer": "process BCFTOOLS_PLUGINSPLIT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n    path(samples)\n    path(groups)\n    path(regions)\n    path(targets)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,vcf.gz,bcf,bcf.gz}\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")                    , emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\")                    , emit: csi, optional: true\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def samples_arg = samples ? \"--samples-file ${samples}\" : \"\"\n    def groups_arg  = groups  ? \"--groups-file ${groups}\"   : \"\"\n    def regions_arg = regions ? \"--regions-file ${regions}\" : \"\"\n    def targets_arg = targets ? \"--targets-file ${targets}\" : \"\"\n\n    \"\"\"\n    bcftools plugin split \\\\\n        ${args} \\\\\n        ${vcf} \\\\\n        ${samples_arg} \\\\\n        ${groups_arg} \\\\\n        ${regions_arg} \\\\\n        ${targets_arg} \\\\\n        --output ${prefix}\n\n    mv ${prefix}/* .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                \"vcf\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n    def determination_file = samples ?: targets\n    def create_cmd = extension.matches(\"vcf|bcf\") ? \"touch \" : \"echo '' | gzip > \"\n    def create_files = \"cut -f 3 ${determination_file} | sed -e 's/\\$/.${extension}/' > files.txt; while IFS= read -r filename; do ${create_cmd} \\\"\\$filename\\\"; done < files.txt\"\n    def create_index = index.matches(\"csi|tbi\") ? \"cut -f 3 ${determination_file} | sed -e 's/\\$/.${extension}.${index}/' > indices.txt; touch \\$(<indices.txt)\" : \"\"\n    \"\"\"\n    ${create_files}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This command replaces the former bcftools view caller.\nSome of the original functionality has been temporarily lost in the process of transition under htslib, but will be added back on popular demand.\nThe original calling model can be invoked with the -c option.\n\nTags: variant calling, view, bcftools, VCF", "answer": "process BCFTOOLS_CALL {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(index)\n    path(regions)\n    path(targets)\n    path(samples)\n\n    output:\n    tuple val(meta), path(\"*.gz\") , emit: vcf\n    tuple val(meta), path(\"*.tbi\"), emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\"), emit: csi, optional: true\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions_file  = regions ? \"--regions-file ${regions}\" : \"\"\n    def targets_file = targets ? \"--targets-file ${targets}\" : \"\"\n    def samples_file =  samples ? \"--samples-file ${samples}\" : \"\"\n    \"\"\"\n    bcftools view \\\\\n        --output ${prefix}.vcf.gz \\\\\n        ${regions_file} \\\\\n        ${targets_file} \\\\\n        ${samples_file} \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        ${vcf}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n\n    def create_index = index.matches(\"csi|tbi\") ? \"touch ${prefix}.vcf.gz.${index}\" : \"\"\n\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: View, subset and filter VCF or BCF files by position and filtering expression. Convert between VCF and BCF\nTags: variant calling, view, bcftools, VCF", "answer": "process BCFTOOLS_VIEW {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(index)\n    path(regions)\n    path(targets)\n    path(samples)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,vcf.gz,bcf,bcf.gz}\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")                    , emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\")                    , emit: csi, optional: true\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions_file  = regions ? \"--regions-file ${regions}\" : \"\"\n    def targets_file = targets ? \"--targets-file ${targets}\" : \"\"\n    def samples_file =  samples ? \"--samples-file ${samples}\" : \"\"\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    \"\"\"\n    bcftools view \\\\\n        --output ${prefix}.${extension} \\\\\n        ${regions_file} \\\\\n        ${targets_file} \\\\\n        ${samples_file} \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        ${vcf}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n    def create_cmd = extension.endsWith(\".gz\") ? \"echo '' | gzip >\" : \"touch\"\n    def create_index = extension.endsWith(\".gz\") && index.matches(\"csi|tbi\") ? \"touch ${prefix}.${extension}.${index}\" : \"\"\n\n    \"\"\"\n    ${create_cmd} ${prefix}.${extension}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split VCF by chunks or regions, creating multiple VCFs.\nTags: scatter, vcf, bcf, genomics", "answer": "process BCFTOOLS_PLUGINSCATTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n    val(sites_per_chunk)\n    val(scatter)\n    path(scatter_file)\n    path(regions)\n    path(targets)\n\n    output:\n    tuple val(meta), path(\"*{vcf,vcf.gz,bcf,bcf.gz}\")   , emit: scatter\n    tuple val(meta), path(\"*.tbi\")                      , emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\")                      , emit: csi, optional: true\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def mandatory_arg = sites_per_chunk ? \"--nsites-per-chunk ${sites_per_chunk}\" : scatter ? \"--scatter ${scatter}\" : \"--scatter-file ${scatter_file}\"\n    def regions_arg = regions ? \"--regions-file ${regions}\" : \"\"\n    def targets_arg = targets ? \"--targets-file ${targets}\" : \"\"\n    \"\"\"\n    bcftools plugin scatter \\\\\n        ${vcf} \\\\\n        ${mandatory_arg} \\\\\n        ${regions_arg} \\\\\n        ${targets_arg} \\\\\n        --output ${prefix} \\\\\n        --prefix ${prefix} \\\\\n        --threads ${task.cpus} \\\\\n        ${args}\n\n    mv ${prefix}/* .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                \"vcf\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n    def create_cmd = extension.endsWith(\".gz\") ? \"echo '' | gzip >\" : \"touch\"\n    def create_index_1 = extension.endsWith(\".gz\") && index.matches(\"csi|tbi\") ? \"touch ${prefix}0.${extension}.${index}\" : \"\"\n    def create_index_2 = extension.endsWith(\".gz\") && index.matches(\"csi|tbi\") ? \"touch ${prefix}1.${extension}.${index}\" : \"\"\n    def create_index_3 = extension.endsWith(\".gz\") && index.matches(\"csi|tbi\") ? \"touch ${prefix}2.${extension}.${index}\" : \"\"\n\n    \"\"\"\n    ${create_cmd} ${prefix}0.${extension}\n    ${create_cmd} ${prefix}1.${extension}\n    ${create_cmd} ${prefix}2.${extension}\n\n    ${create_index_1}\n    ${create_index_2}\n    ${create_index_3}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Index VCF tools\nTags: vcf, index, bcftools, csi, tbi", "answer": "process BCFTOOLS_INDEX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.csi\"), optional:true, emit: csi\n    tuple val(meta), path(\"*.tbi\"), optional:true, emit: tbi\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    bcftools \\\\\n        index \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--tbi\") || args.contains(\"-t\") ? \"tbi\" :\n                    \"csi\"\n    \"\"\"\n    touch ${vcf}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filters VCF files\nTags: variant calling, filtering, VCF", "answer": "process BCFTOOLS_FILTER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.${extension}\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")         , emit: tbi, optional: true\n    tuple val(meta), path(\"*.csi\")         , emit: csi, optional: true\n    path  \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n\n    if (\"$vcf\" == \"${prefix}.${extension}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    bcftools filter \\\\\n        --output ${prefix}.${extension} \\\\\n        --threads ${task.cpus} \\\\\n        $args \\\\\n        $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf\"\n    def index = args.contains(\"--write-index=tbi\") || args.contains(\"-W=tbi\") ? \"tbi\" :\n                args.contains(\"--write-index=csi\") || args.contains(\"-W=csi\") ? \"csi\" :\n                args.contains(\"--write-index\") || args.contains(\"-W\") ? \"csi\" :\n                \"\"\n    def create_cmd = extension.endsWith(\".gz\") ? \"echo '' | gzip >\" : \"touch\"\n    def create_index = extension.endsWith(\".gz\") && index.matches(\"csi|tbi\") ? \"touch ${prefix}.${extension}.${index}\" : \"\"\n\n    if (\"$vcf\" == \"${prefix}.${extension}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    ${create_cmd} ${prefix}.${extension}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extracts fields from VCF or BCF files and outputs them in user-defined format.\nTags: query, variant calling, bcftools, VCF", "answer": "process BCFTOOLS_QUERY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n    path regions\n    path targets\n    path samples\n\n    output:\n    tuple val(meta), path(\"*.${suffix}\"), emit: output\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.suffix ?: \"txt\"\n    def regions_file = regions ? \"--regions-file ${regions}\" : \"\"\n    def targets_file = targets ? \"--targets-file ${targets}\" : \"\"\n    def samples_file =  samples ? \"--samples-file ${samples}\" : \"\"\n    \"\"\"\n    bcftools query \\\\\n        $regions_file \\\\\n        $targets_file \\\\\n        $samples_file \\\\\n        $args \\\\\n        $vcf \\\\\n        > ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.suffix ?: \"txt\"\n    \"\"\"\n    touch ${prefix}.${suffix} \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generates stats from VCF files\nTags: variant calling, stats, VCF", "answer": "process BCFTOOLS_STATS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta),  path(vcf), path(tbi)\n    tuple val(meta2), path(regions)\n    tuple val(meta3), path(targets)\n    tuple val(meta4), path(samples)\n    tuple val(meta5), path(exons)\n    tuple val(meta6), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*stats.txt\"), emit: stats\n    path  \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions_file = regions ? \"--regions-file ${regions}\" : \"\"\n    def targets_file = targets ? \"--targets-file ${targets}\" : \"\"\n    def samples_file =  samples ? \"--samples-file ${samples}\" : \"\"\n    def reference_fasta = fasta ? \"--fasta-ref ${fasta}\" : \"\"\n    def exons_file = exons      ? \"--exons ${exons}\" : \"\"\n    \"\"\"\n    bcftools stats \\\\\n        $args \\\\\n        $regions_file \\\\\n        $targets_file \\\\\n        $samples_file \\\\\n        $reference_fasta \\\\\n        $exons_file \\\\\n        $vcf > ${prefix}.bcftools_stats.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.bcftools_stats.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply set operations to VCF files\nTags: variant calling, intersect, union, complement, VCF, BCF", "answer": "process BCFTOOLS_ISEC {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(vcfs), path(tbis)\n\n    output:\n    tuple val(meta), path(\"${prefix}\", type: \"dir\"), emit: results\n    path  \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bcftools isec  \\\\\n        $args \\\\\n        -p $prefix \\\\\n        ${vcfs}\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    touch ${prefix}/README.txt\n    touch ${prefix}/sites.txt\n    echo \"\" | gzip > ${prefix}/0000.vcf.gz\n    touch ${prefix}/0000.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}/0001.vcf.gz\n    touch ${prefix}/0001.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts certain output formats to VCF\nTags: bcftools, convert, vcf, gvcf", "answer": "process BCFTOOLS_CONVERT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bcftools:1.20--h8b25389_0':\n        'biocontainers/bcftools:1.20--h8b25389_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    tuple val(meta2), path(fasta)\n    path(bed)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"),      optional:true , emit: vcf_gz\n    tuple val(meta), path(\"*.vcf\")   ,      optional:true , emit: vcf\n    tuple val(meta), path(\"*.bcf.gz\"),      optional:true , emit: bcf_gz\n    tuple val(meta), path(\"*.bcf\")   ,      optional:true , emit: bcf\n    tuple val(meta), path(\"*.hap.gz\"),      optional:true , emit: hap\n    tuple val(meta), path(\"*.legend.gz\"),   optional:true , emit: legend\n    tuple val(meta), path(\"*.samples\"),     optional:true , emit: samples\n    path \"versions.yml\",                                    emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def regions = bed ? \"--regions-file $bed\" : \"\"\n    def reference = fasta ?  \"--fasta-ref $fasta\" : \"\"\n    def extension = args.contains(\"--output-type b\")    || args.contains(\"-Ob\")    ? \"--output ${prefix}.bcf.gz\" :\n                    args.contains(\"--output-type u\")    || args.contains(\"-Ou\")    ? \"--output ${prefix}.bcf\" :\n                    args.contains(\"--output-type z\")    || args.contains(\"-Oz\")    ? \"--output ${prefix}.vcf.gz\" :\n                    args.contains(\"--output-type v\")    || args.contains(\"-Ov\")    ? \"--output ${prefix}.vcf\" :\n                    args.contains(\"--haplegendsample\")  || args.contains(\"-h\")     ? \"\" :\n                    \"--output ${prefix}.vcf.gz\"\n\n    \"\"\"\n    bcftools convert \\\\\n        $args \\\\\n        $regions \\\\\n        $extension \\\\\n        --threads $task.cpus \\\\\n        $reference \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = args.contains(\"--output-type b\") || args.contains(\"-Ob\") ? \"bcf.gz\" :\n                    args.contains(\"--output-type u\") || args.contains(\"-Ou\") ? \"bcf\" :\n                    args.contains(\"--output-type z\") || args.contains(\"-Oz\") ? \"vcf.gz\" :\n                    args.contains(\"--output-type v\") || args.contains(\"-Ov\") ? \"vcf\" :\n                    \"vcf.gz\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcftools: \\$(bcftools --version 2>&1 | head -n1 | sed 's/^.*bcftools //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A windowed adaptive trimming tool for FASTQ files using quality\nTags: fastq, sliding window, trimming", "answer": "process SICKLE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sickle-trim:1.33--h7132678_7':\n        'biocontainers/sickle-trim:1.33--h5bf99c6_6' }\"\n\n    input:\n    tuple val(meta), path(reads), val(qual_type)\n\n    output:\n    tuple val(meta), path(\"${prefix}.se.trimmed.fastq.gz\"),        optional:true, emit: single_trimmed\n    tuple val(meta), path(\"${prefix}.pe{1,2}.trimmed.fastq.gz\"),   optional:true, emit: paired_trimmed\n    tuple val(meta), path(\"${prefix}.singleton.trimmed.fastq.gz\"), optional:true, emit: singleton_trimmed\n    tuple val(meta), path(\"*.log\"), emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (meta.single_end){\n    \"\"\"\n    sickle \\\\\n        se \\\\\n        $args \\\\\n        -f $reads \\\\\n        -t $qual_type \\\\\n        -o ${prefix}.se.trimmed.fastq.gz \\\\\n        -g \\\\\n    >${prefix}.sickle.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sickle: \\$(sickle --version|awk 'NR==1{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n    }\n    else{\n    \"\"\"\n    sickle \\\\\n        pe \\\\\n        $args \\\\\n        -f ${reads[0]} \\\\\n        -r ${reads[1]} \\\\\n        -t $qual_type \\\\\n        -o ${prefix}.pe1.trimmed.fastq.gz \\\\\n        -p ${prefix}.pe2.trimmed.fastq.gz \\\\\n        -s ${prefix}.singleton.trimmed.fastq.gz \\\\\n        -g \\\\\n    >${prefix}.sickle.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sickle: \\$(sickle --version|awk 'NR==1{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n    }\n}\n"}
{"question": "Description: Perform adapter and quality trimming on sequencing reads with reporting\nTags: trimming, quality control, fastq, faqcs", "answer": "process FAQCS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/faqcs:2.10--r41h9a82719_2' :\n        'biocontainers/faqcs:2.10--r41h9a82719_2' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path('*.trimmed.fastq.gz')           , emit: reads         , optional: true\n    tuple val(meta), path('*.stats.txt')                  , emit: stats         , optional: true\n    tuple val(meta), path('./debug')                      , emit: debug         , optional: true\n    tuple val(meta), path('*_qc_report.pdf')              , emit: statspdf      , optional: true\n    tuple val(meta), path('*.discard.fastq.gz')           , emit: reads_fail    , optional: true\n    tuple val(meta), path('*.trimmed.unpaired.fastq.gz')  , emit: reads_unpaired, optional: true\n    tuple val(meta), path('*.log')                        , emit: log\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    // Added soft-links to original fastqs for consistent naming in MultiQC\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.single_end) {\n        \"\"\"\n        [ ! -f  ${prefix}.fastq.gz ] && ln -s $reads ${prefix}.fastq.gz\n        FaQCs \\\\\n            -d . \\\\\n            -u ${prefix}.fastq.gz \\\\\n            --prefix ${prefix} \\\\\n            -t $task.cpus \\\\\n            $args \\\\\n            2> >(tee ${prefix}.log >&2)\n\n\n        if [[ -f ${prefix}.unpaired.trimmed.fastq ]]; then\n            mv ${prefix}.unpaired.trimmed.fastq ${prefix}.trimmed.fastq\n            gzip ${prefix}.trimmed.fastq\n        fi\n        if [[ -f ${prefix}.discard.trimmed.fastq ]]; then\n            mv ${prefix}.discard.trimmed.fastq ${prefix}.trimmed.discard.fastq\n            gzip ${prefix}.trimmed.discard.fastq\n        fi\n\n        # Debug: collect all debug files in one directory (--debug)\n        if [[ -f ${prefix}.base.matrix ]]; then\n            mkdir debug\n            mv *.{base,for_qual_histogram,length_count,quality}*.* debug\n        fi\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            faqcs: \\$(echo \\$(FaQCs --version 2>&1) | sed 's/^.*Version: //;' )\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        [ ! -f  ${prefix}_1.fastq.gz ] && ln -s ${reads[0]} ${prefix}_1.fastq.gz\n        [ ! -f  ${prefix}_2.fastq.gz ] && ln -s ${reads[1]} ${prefix}_2.fastq.gz\n        FaQCs \\\\\n            -d . \\\\\n            -1 ${prefix}_1.fastq.gz \\\\\n            -2 ${prefix}_2.fastq.gz \\\\\n            --prefix ${meta.id} \\\\\n            -t $task.cpus \\\\\n            $args \\\\\n            2> >(tee ${prefix}.log >&2)\n\n        # Unpaired\n        if [[ -f ${prefix}.unpaired.trimmed.fastq ]]; then\n            # If it is empty remove it\n            if [[ ! -s ${prefix}.unpaired.trimmed.fastq ]]; then\n                rm ${prefix}.unpaired.trimmed.fastq\n            else\n                mv ${prefix}.unpaired.trimmed.fastq ${prefix}.trimmed.unpaired.fastq\n                gzip ${prefix}.trimmed.unpaired.fastq\n            fi\n        fi\n\n        # R1\n        if [[ -f ${prefix}.1.trimmed.fastq ]]; then\n            mv ${prefix}.1.trimmed.fastq ${prefix}_1.trimmed.fastq\n            gzip ${prefix}_1.trimmed.fastq\n        fi\n\n        # R2\n        if [[ -f ${prefix}.2.trimmed.fastq ]]; then\n            mv ${prefix}.2.trimmed.fastq ${prefix}_2.trimmed.fastq\n            gzip ${prefix}_2.trimmed.fastq\n        fi\n\n        # Discarded: Created if --discard argument is passed\n        if [[ -f ${prefix}.discard.trimmed.fastq ]]; then\n            mv ${prefix}.discard.trimmed.fastq ${prefix}.trimmed.discard.fastq\n            gzip ${prefix}.trimmed.discard.fastq\n        fi\n\n        # Debug: collect all debug files in one directory (--debug)\n        if [[ -f ${prefix}.base.matrix ]]; then\n            mkdir debug\n            mv *.{base,for_qual_histogram,length_count,quality}*.* debug\n        fi\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            faqcs: \\$(echo \\$(FaQCs --version 2>&1) | sed 's/^.*Version: //;' )\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: meta.id\n    \"\"\"\n    echo \"\" | gzip > \"${prefix}.trimmed.fastq.gz\"\n    touch \"${prefix}.stats.txt\"\n    touch \"${prefix}_qc_report.pdf\"\n    touch \"${prefix}.log\"\n    echo \"\" | gzip > \"${prefix}.discard.fastq.gz\"\n    echo \"\" | gzip > \"${prefix}.trimmed.unpaired.fastq.gz\"\n    mkdir debug\n    touch \"debug/${prefix}.for_qual_histogram.txt\"\n\n    cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            faqcs: \\$(echo \\$(FaQCs --version 2>&1) | sed 's/^.*Version: //;' )\n        END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Ultraplex is an all-in-one software package for processing and demultiplexing fastq files.\nTags: demultiplex, fastq, umi", "answer": "process ULTRAPLEX {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ultraplex:1.2.5--py38h4a8c8d9_0' :\n        'biocontainers/ultraplex:1.2.5--py38h4a8c8d9_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path(barcode_file)\n    val(adapter_seq)\n\n    output:\n    tuple val(meta), path(\"*[!no_match].fastq.gz\"),              emit: fastq\n    tuple val(meta), path(\"*no_match.fastq.gz\"), optional: true, emit: no_match_fastq\n    path \"*.log\",                                                emit: report\n    path \"versions.yml\",                                         emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def VERSION = \"1.2.5\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def args    = task.ext.args ?: ''\n    prefix      = task.ext.prefix ?: \"${meta.id}\"\n\n    def adapter_seq_command = ''\n    if(adapter_seq) {\n        adapter_seq_command = \"--adapter ${adapter_seq}\"\n    }\n\n    read_list = reads.collect{it.toString()}\n    if (read_list.size > 1){\n        ultraplex_command = \"\"\"ultraplex \\\\\n        --inputfastq ${read_list[0]} \\\\\n        --input_2 ${read_list[1]} \\\\\n        --barcodes $barcode_file \\\\\n        --threads $task.cpus $args $adapter_seq_command\"\"\"\n    } else {\n        ultraplex_command = \"\"\"ultraplex \\\\\n        --inputfastq ${read_list[0]} \\\\\n        --barcodes $barcode_file \\\\\n        --threads $task.cpus $args $adapter_seq_command\"\"\"\n    }\n\n    \"\"\"\n    ${ultraplex_command}\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ultraplex: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: DeepBGC detects BGCs in bacterial and fungal genomes using deep learning.\nTags: BGC, biosynthetic gene cluster, deep learning, neural network, random forest, genomes, bacteria, fungi", "answer": "process DEEPBGC_PIPELINE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deepbgc:0.1.31--pyhca03a8a_0':\n        'biocontainers/deepbgc:0.1.31--pyhca03a8a_0' }\"\n\n    input:\n    tuple val(meta), path(genome)\n    path(db)\n\n    output:\n    tuple val(meta), path(\"${prefix}/README.txt\")                    ,   optional: true, emit: readme\n    tuple val(meta), path(\"${prefix}/LOG.txt\")                       ,   emit: log\n    tuple val(meta), path(\"${prefix}/${prefix}.antismash.json\")      ,   optional: true, emit: json\n    tuple val(meta), path(\"${prefix}/${prefix}.bgc.gbk\")             ,   optional: true, emit: bgc_gbk\n    tuple val(meta), path(\"${prefix}/${prefix}.bgc.tsv\")             ,   optional: true, emit: bgc_tsv\n    tuple val(meta), path(\"${prefix}/${prefix}.full.gbk\")            ,   optional: true, emit: full_gbk\n    tuple val(meta), path(\"${prefix}/${prefix}.pfam.tsv\")            ,   optional: true, emit: pfam_tsv\n    tuple val(meta), path(\"${prefix}/evaluation/${prefix}.bgc.png\")  ,   optional: true, emit: bgc_png\n    tuple val(meta), path(\"${prefix}/evaluation/${prefix}.pr.png\")   ,   optional: true, emit: pr_png\n    tuple val(meta), path(\"${prefix}/evaluation/${prefix}.roc.png\")  ,   optional: true, emit: roc_png\n    tuple val(meta), path(\"${prefix}/evaluation/${prefix}.score.png\"),   optional: true, emit: score_png\n    path \"versions.yml\"                                                                    ,   emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    export DEEPBGC_DOWNLOADS_DIR=${db}\n\n    deepbgc \\\\\n        pipeline \\\\\n        $args \\\\\n        $genome\n\n    if [[ \"${genome.baseName}/\" != \"${prefix}/\" ]]; then\n        mv \"${genome.baseName}/\" \"${prefix}/\"\n    fi\n\n    for i in \\$(find -name '${genome.baseName}*' -type f); do\n        mv \\$i \\${i/${genome.baseName}/${prefix}};\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deepbgc: \\$(echo \\$(deepbgc info 2>&1 /dev/null/ | grep 'version' | cut -d \" \" -f3) )\n        prodigal: \\$(prodigal -v 2>&1 | sed -n 's/Prodigal V\\\\(.*\\\\):.*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}/evaluation\n    touch ${prefix}/README.txt\n    touch ${prefix}/LOG.txt\n    touch ${prefix}/${prefix}.antismash.json\n    touch ${prefix}/${prefix}.bgc.gbk\n    touch ${prefix}/${prefix}.bgc.tsv\n    touch ${prefix}/${prefix}.full.gbk\n    touch ${prefix}/${prefix}.pfam.tsv\n    touch ${prefix}/evaluation/${prefix}.bgc.png\n    touch ${prefix}/evaluation/${prefix}.pr.png\n    touch ${prefix}/evaluation/${prefix}.roc.png\n    touch ${prefix}/evaluation/${prefix}.score.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deepbgc: \\$(echo \\$(deepbgc info 2>&1 /dev/null/ | grep 'version' | cut -d \" \" -f3) )\n        prodigal: \\$(prodigal -v 2>&1 | sed -n 's/Prodigal V\\\\(.*\\\\):.*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Database download module for DeepBGC which detects BGCs in bacterial and fungal genomes using deep learning.\nTags: database, download, BGC, biosynthetic gene cluster, deep learning, neural network, random forest, genomes, bacteria, fungi", "answer": "process DEEPBGC_DOWNLOAD {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deepbgc:0.1.31--pyhca03a8a_0':\n        'biocontainers/deepbgc:0.1.31--pyhca03a8a_0' }\"\n\n    output:\n    path \"deepbgc_db/\"  , emit: db\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    export DEEPBGC_DOWNLOADS_DIR='./deepbgc_db'\n\n    deepbgc \\\\\n        download\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deepbgc: \\$(echo \\$(deepbgc info 2>&1 /dev/null/ | grep 'version' | cut -d \" \" -f3) )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Unzip ZIP archive files\nTags: unzip, decompression, zip, archiving", "answer": "process UNZIP {\n    tag \"$archive\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/p7zip:16.02' :\n        'biocontainers/p7zip:16.02' }\"\n\n    input:\n    tuple val(meta), path(archive)\n\n    output:\n    tuple val(meta), path(\"${prefix}/\"), emit: unzipped_archive\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    if ( archive instanceof List && archive.name.size > 1 ) { error \"[UNZIP] error: 7za only accepts a single archive as input. Please check module input.\" }\n    prefix = task.ext.prefix ?: ( meta.id ? \"${meta.id}\" : archive.baseName)\n    \"\"\"\n    7za \\\\\n        x \\\\\n        -o\"${prefix}\"/ \\\\\n        $args \\\\\n        $archive\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        7za: \\$(echo \\$(7za --help) | sed 's/.*p7zip Version //; s/(.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    if ( archive instanceof List && archive.name.size > 1 ) { error \"[UNZIP] error: 7za only accepts a single archive as input. Please check module input.\" }\n    prefix = task.ext.prefix ?: ( meta.id ? \"${meta.id}\" : archive.baseName)\n    \"\"\"\n    mkdir \"${prefix}\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        7za: \\$(echo \\$(7za --help) | sed 's/.*p7zip Version //; s/(.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download the mOTUs database\nTags: classify, metagenomics, fastq, taxonomic profiling, database, download", "answer": "process MOTUS_DOWNLOADDB {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/motus:3.0.3--pyhdfd78af_0':\n        'biocontainers/motus:3.0.3--pyhdfd78af_0' }\"\n\n    input:\n    path motus_downloaddb_script\n\n    output:\n    path \"db_mOTU/\"                , emit: db\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args     = task.ext.args ?: ''\n    def software = \"${motus_downloaddb_script.simpleName}_copy.py\"\n    \"\"\"\n    ## must copy script file to working directory,\n    ## otherwise the reference_db will be download to bin folder\n    ## other than current directory\n    cp $motus_downloaddb_script ${software}\n    python ${software} \\\\\n        $args \\\\\n        -t $task.cpus\n\n    ## mOTUs version number is not available from command line.\n    ## mOTUs save the version number in index database folder.\n    ## mOTUs will check the database version is same version as exec version.\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        motus: \\$(grep motus db_mOTU/db_mOTU_versions | sed 's/motus\\\\t//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Taxonomic meta-omics profiling using universal marker genes\nTags: classify, metagenomics, fastq, taxonomic profiling, merging, merge, otu table", "answer": "process MOTUS_MERGE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/motus:3.0.3--pyhdfd78af_0':\n        'biocontainers/motus:3.0.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path db // to stop docker saying it can't find it... would have to have the module in upstream steps anyway\n    path profile_version_yml, stageAs: 'profile_version.yml'\n\n    output:\n    tuple val(meta), path(\"*.txt\") , optional: true, emit: txt\n    tuple val(meta), path(\"*.biom\"), optional: true, emit: biom\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def cmd_input = input.size() > 1 ? \"-i ${input.join(',')}\" : input.isDirectory() ? \"-d ${input}\" : \"-i ${input}\"\n    def suffix = task.ext.args?.contains(\"-B\") ? \"biom\" : \"txt\"\n    \"\"\"\n    motus \\\\\n        merge \\\\\n        -db $db \\\\\n        ${cmd_input} \\\\\n        $args \\\\\n        -o ${prefix}.${suffix}\n\n    ## Take version from the mOTUs/profile module output, as cannot reconstruct\n    ## version without having database staged in this directory.\n    VERSION=\\$(cat ${profile_version_yml} | grep '/*motus:.*' | sed 's/.*otus: //g')\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        motus: \\$VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Taxonomic meta-omics profiling using universal marker genes\nTags: classify, metagenomics, fastq, taxonomic profiling", "answer": "process MOTUS_PROFILE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/motus:3.0.3--pyhdfd78af_0':\n        'biocontainers/motus:3.0.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path db\n\n    output:\n    tuple val(meta), path(\"*.out\"), emit: out\n    tuple val(meta), path(\"*.bam\"), optional: true, emit: bam\n    tuple val(meta), path(\"*.mgc\"), optional: true, emit: mgc\n    tuple val(meta), path(\"*.log\")                , emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def inputs = reads[0].getExtension() == 'bam' ?\n                    \"-i ${reads}\" :\n                    reads[0].getExtension() == 'mgc' ? \"-m $reads\" :\n                        meta.single_end ?\n                            \"-s $reads\" : \"-f ${reads[0]} -r ${reads[1]}\"\n    def refdb = db ? \"-db ${db}\" : \"\"\n    \"\"\"\n    motus profile \\\\\n        $args \\\\\n        $inputs \\\\\n        $refdb \\\\\n        -t $task.cpus \\\\\n        -n $prefix \\\\\n        -o ${prefix}.out \\\\\n        2> >(tee ${prefix}.log >&2)\n\n    ## mOTUs version number is not available from command line.\n    ## mOTUs save the version number in index database folder.\n    ## mOTUs will check the database version is same version as exec version.\n    if [ \"$db\" == \"\" ]; then\n        VERSION=\\$(echo \\$(motus -h 2>&1) | sed 's/^.*Version: //; s/References.*\\$//')\n    else\n        VERSION=\\$(grep motus $db/db_mOTU_versions | sed 's/motus\\\\t//g')\n    fi\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        motus: \\$VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A post sequencing QC tool for Oxford Nanopore sequencers\nTags: nanopore sequencing, quality control, genomics", "answer": "process TOULLIGQC {\n    label 'process_low'\n    tag \"$meta.id\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/toulligqc:2.5.6--pyhdfd78af_0':\n        'biocontainers/toulligqc:2.5.6--pyhdfd78af_0' }\"\n\n    input:\n\n    tuple val(meta), path(ontfile)\n\n\n    output:\n    tuple val(meta), path(\"*/*.data\")                   , emit: report_data\n    tuple val(meta), path(\"*/*.html\")                   , emit: report_html, optional: true\n    tuple val(meta), path(\"*/images/*.html\")            , emit: plots_html\n    tuple val(meta), path(\"*/images/plotly.min.js\")     , emit: plotly_js\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def input_file = (\"$ontfile\".endsWith(\".fastq\") || \"$ontfile\".endsWith(\".fastq.gz\") || \"$ontfile\".endsWith(\".fq\") || \"$ontfile\".endsWith(\".fq.gz\")) ? \"--fastq ${ontfile}\" :\n        (\"$ontfile\".endsWith(\".txt\") || \"$ontfile\".endsWith(\".txt.gz\")) ? \"--sequencing-summary-source ${ontfile}\" :\n        (\"$ontfile\".endsWith(\".bam\")) ? \"--bam ${ontfile}\" : ''\n\n    \"\"\"\n    toulligqc \\\\\n        $input_file \\\\\n        --output-directory ${prefix} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        toulligqc: \\$(toulligqc --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    mkdir ${prefix}/images\n    touch ${prefix}/report.data\n    touch ${prefix}/images/Correlation_between_read_length_and_PHRED_score.html\n    touch ${prefix}/images/Distribution_of_read_lengths.html\n    touch ${prefix}/images/PHRED_score_density_distribution.html\n    touch ${prefix}/images/Read_count_histogram.html\n    touch ${prefix}/images/plotly.min.js\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        toulligqc: \\$(toulligqc --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create BWA-MEME index for reference genome\nTags: index, fasta, genome, reference", "answer": "process BWAMEME_INDEX {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bwa-meme:1.0.6--hdcf5f25_2':\n        'biocontainers/bwa-meme:1.0.6--hdcf5f25_2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"bwameme\"), emit: index\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${fasta}\"\n    def VERSION = '1.0.6' // WARN: Version information provided by tool on CLI is incorrect. Please update this string when bumping container versions.\n    \"\"\"\n    mkdir bwameme\n\n    bwa-meme index \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        -p bwameme/$prefix \\\\\n        $fasta\n\n    build_rmis_dna.sh bwameme/$prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwameme: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${fasta}\"\n    def VERSION = '1.0.6' // WARN: Version information provided by tool on CLI is incorrect. Please update this string when bumping container versions.\n    \"\"\"\n    mkdir bwameme\n    touch bwameme/${prefix}.0123\n    touch bwameme/${prefix}.ann\n    touch bwameme/${prefix}.pac\n    touch bwameme/${prefix}.amb\n    touch bwameme/${prefix}.pos_packed\n    touch bwameme/${prefix}.suffixarray_uint64\n    touch bwameme/${prefix}.suffixarray_uint64_L0_PARAMETERS\n    touch bwameme/${prefix}.suffixarray_uint64_L1_PARAMETERS\n    touch bwameme/${prefix}.suffixarray_uint64_L2_PARAMETERS\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwameme: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs fastq alignment to a fasta reference using BWA-MEME\nTags: mem, bwa, bwamem2, bwameme, alignment, map, fastq, bam, sam, cram", "answer": "process BWAMEME_MEM {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-ed29b84fa94419f5a7bf6a841ddbcb964768825b:139b5e403886ad278b9ad139174967441c1c6ff3-0':\n        'biocontainers/mulled-v2-ed29b84fa94419f5a7bf6a841ddbcb964768825b:139b5e403886ad278b9ad139174967441c1c6ff3-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(index)\n    tuple val(meta3), path(fasta)\n    val   sort_bam\n    val   mbuffer\n    val   samtools_threads\n\n    output:\n    tuple val(meta), path(\"*.sam\")  , emit: sam , optional:true\n    tuple val(meta), path(\"*.bam\")  , emit: bam , optional:true\n    tuple val(meta), path(\"*.cram\") , emit: cram, optional:true\n    tuple val(meta), path(\"*.crai\") , emit: crai, optional:true\n    tuple val(meta), path(\"*.csi\")  , emit: csi , optional:true\n    path  \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    if (!mbuffer) {\n        log.info '[bwameme-mbuffer] Memory for mbuffer is not set - defaulting to 3GB for mbuffer.'\n        mbuffer_mem = 3072\n    } else {\n        mbuffer_mem = mbuffer\n    }\n    if (!samtools_threads) {\n        log.info 'Number of threads for samtools is not set - defaulting to 2 threads.'\n        threads = 2\n    } else {\n        threads = samtools_threads\n    }\n    mbuffer_command   = sort_bam ? \"| mbuffer -m ${mbuffer_mem}M\" : \"\"\n    mem_per_thread    = sort_bam ? \"-m \"+ (mbuffer_mem/threads).intValue()+\"M\" : \"\"\n    def extension_pattern = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher =  (args2 =~ extension_pattern)\n    def extension = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n    def VERSION = '1.0.6' // WARN: Version information provided by tool on CLI is incorrect. Please update this string when bumping container versions.\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n\n    bwa-meme \\\\\n        mem \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        \\$INDEX \\\\\n        $reads \\\\\n        $mbuffer_command \\\\\n        | samtools $samtools_command $args2 $mem_per_thread -@ $threads ${reference} -o ${prefix}.${extension} -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwameme: $VERSION\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    def extension_pattern = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher =  (args2 =~ extension_pattern)\n    def extension = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    def create_index = \"\"\n    if (extension == \"cram\") {\n        create_index = \"touch ${prefix}.crai\"\n    } else if (extension == \"bam\") {\n        create_index = \"touch ${prefix}.csi\"\n    }\n    def VERSION = '1.0.6' // WARN: Version information provided by tool on CLI is incorrect. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.${extension}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwameme: $VERSION\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A single fast and exhaustive tool for summary statistics and simultaneous *fa*\n(fasta, fastq, gfa [.gz]) genome assembly file manipulation.\n\nTags: gfastats, fasta, genome assembly, genome summary, genome manipulation, genome statistics", "answer": "process GFASTATS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gfastats:1.3.6--hdcf5f25_3':\n        'biocontainers/gfastats:1.3.6--hdcf5f25_3' }\"\n\n    input:\n    tuple val(meta), path(assembly)   // input.[fasta|fastq|gfa][.gz]\n    val out_fmt                       // output format (fasta/fastq/gfa)\n    val genome_size                   // estimated genome size for NG* statistics (optional).\n    val target                        // target specific sequence by header, optionally with coordinates (optional).\n    path agpfile                      // -a --agp-to-path <file> converts input agp to path and replaces existing paths.\n    path include_bed                  // -i --include-bed <file> generates output on a subset list of headers or coordinates in 0-based bed format.\n    path exclude_bed                  // -e --exclude-bed <file> opposite of --include-bed. They can be combined (no coordinates).\n    path instructions                 // -k --swiss-army-knife <file> set of instructions provided as an ordered list.\n\n    output:\n    tuple val(meta), path(\"*.assembly_summary\"), emit: assembly_summary\n    tuple val(meta), path(\"*.${out_fmt}.gz\")   , emit: assembly\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def agp  = agpfile ? \"--agp-to-path $agp\" : \"\"\n    def ibed = include_bed ? \"--include-bed $include_bed\" : \"\"\n    def ebed = exclude_bed ? \"--exclude-bed $exclude_bed\" : \"\"\n    def sak  = instructions ? \"--swiss-army-knife $instructions\" : \"\"\n    \"\"\"\n    gfastats \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        $agp \\\\\n        $ibed \\\\\n        $ebed \\\\\n        $sak \\\\\n        --out-format ${prefix}.${out_fmt}.gz \\\\\n        $assembly \\\\\n        $genome_size \\\\\n        $target \\\\\n        > ${prefix}.assembly_summary\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gfastats: \\$( gfastats -v | sed '1!d;s/.*v//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.${out_fmt}.gz\n    touch ${prefix}.assembly_summary\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gfastats: \\$( gfastats -v | sed '1!d;s/.*v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Parses a Thermo RAW file containing mass spectra to an open file format\nTags: raw, mzml, mgf, parquet, parser, proteomics", "answer": "process THERMORAWFILEPARSER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/thermorawfileparser:1.4.3--ha8f3691_0' :\n        'biocontainers/thermorawfileparser:1.4.3--ha8f3691_0' }\"\n\n    input:\n    tuple val(meta), path(raw)\n\n    output:\n    tuple val(meta), path(\"*.{mzML,mzML.gz,mgf,mgf.gz,parquet,parquet.gz}\"), emit: spectra\n    path \"versions.yml\"                                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = args.contains(\"--format 0\") || args.contains(\"-f 0\") ? \"mgf\" :\n                args.contains(\"--format 1\") || args.contains(\"-f 1\") ? \"mzML\" :\n                args.contains(\"--format 2\") || args.contains(\"-f 2\") ? \"mzML\" :\n                args.contains(\"--format 3\") || args.contains(\"-f 3\") ? \"parquet\" :\n                \"mzML\"\n    suffix = args.contains(\"--gzip\")? \"${suffix}.gz\" : \"${suffix}\"\n\n    \"\"\"\n    ThermoRawFileParser.sh \\\\\n        --input $raw \\\\\n        --output_file ${prefix}.${suffix} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        thermorawfileparser: \\$(ThermoRawFileParser.sh --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = args.contains(\"--format 0\") || args.contains(\"-f 0\") ? \"mgf\" :\n                args.contains(\"--format 1\") || args.contains(\"-f 1\") ? \"mzML\" :\n                args.contains(\"--format 2\") || args.contains(\"-f 2\") ? \"mzML\" :\n                args.contains(\"--format 3\") || args.contains(\"-f 3\") ? \"parquet\" :\n                \"mzML\"\n    suffix = args.contains(\"--gzip\")? \"${suffix}.gz\" : \"${suffix}\"\n\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        thermorawfileparser: \\$(ThermoRawFileParser.sh --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to reconstruct plasmids in bacterial assemblies\nTags: bacteria, plasmid", "answer": "process MOBSUITE_RECON {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mob_suite%3A3.0.3--pyhdfd78af_0':\n        'biocontainers/mob_suite:3.0.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"results/chromosome.fasta\")    , emit: chromosome\n    tuple val(meta), path(\"results/contig_report.txt\")   , emit: contig_report\n    tuple val(meta), path(\"results/plasmid_*.fasta\")     , emit: plasmids        , optional: true\n    tuple val(meta), path(\"results/mobtyper_results.txt\"), emit: mobtyper_results, optional: true\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getName().endsWith(\".gz\") ? true : false\n    def fasta_name = fasta.getName().replace(\".gz\", \"\")\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    mob_recon \\\\\n        --infile $fasta_name \\\\\n        $args \\\\\n        --num_threads $task.cpus \\\\\n        --outdir results \\\\\n        --sample_id $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mobsuite: \\$(echo \\$(mob_recon --version 2>&1) | sed 's/^.*mob_recon //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Estimating poly(A)-tail lengths from basecalled fast5 files produced by Nanopore sequencing of RNA and DNA\nTags: polya tail, fast5, nanopore", "answer": "process TAILFINDR {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-f24f1399a77784f913670cbb36a0f17b78e0631b:80e40d512cd5a71665e3e00e8d0ad1462fc58f76-0':\n        'biocontainers/mulled-v2-f24f1399a77784f913670cbb36a0f17b78e0631b:80e40d512cd5a71665e3e00e8d0ad1462fc58f76-0' }\"\n\n    input:\n    tuple val(meta), path(fast5)\n\n    output:\n    tuple val(meta), path(\"*.csv.gz\"), emit: csv_gz\n    path(\"versions.yml\"), emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ? \", ${task.ext.args}\": ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    R --vanilla --slave -e \"library(tailfindr);\n    find_tails(fast5_dir = './' ,\n    save_dir = './' ${args},\n    csv_filename = \\'${meta.id}.csv\\',\n    num_cores = ${task.cpus})\";\n    gzip ${meta.id}.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tailfindr: \\$(Rscript -e \"cat(paste(packageVersion('tailfindr'), collapse='.'))\")\n        ont-fast5-api: \\$(pip show ont-fast5-api | grep Version | awk '{print \\$2}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Proteinortho is a tool to detect orthologous genes within different species.\nTags: orthology, co-orthology, homology, sequence similarity, spectral clustering, comparative genomics, genomics", "answer": "process PROTEINORTHO {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/proteinortho:6.3.0--h70414c8_0':\n        'biocontainers/proteinortho:6.3.0--h70414c8_0' }\"\n\n    input:\n    tuple val(meta), path(fasta_files, stageAs: \"?/*\")\n\n    output:\n    tuple val(meta), path(\"${meta.id}.proteinortho.tsv\")                     , emit: orthologgroups\n    tuple val(meta), path(\"${meta.id}.proteinortho-graph\")                   , emit: orthologgraph\n    tuple val(meta), path(\"${meta.id}.blast-graph\")                          , emit: blastgraph\n    path \"versions.yml\"                                                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    proteinortho \\\\\n        $args \\\\\n        -cpus=$task.cpus \\\\\n        -project=$prefix \\\\\n        $fasta_files\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        proteinortho : \\$(echo \\$(proteinortho --version 2>&1) )\n        \\$(echo \\$( \"diamond:\"(diamond version 2>/dev/null | head -n1 | sed 's/^.*version //;' ) || echo \"\") )\n        \\$(echo \\$( \"blast:\"(blastp -version 2>/dev/null |head -n1 | sed 's/^.*: //;'  ) || echo \"\") )\n        \\$(echo \\$( \"mmseqs:\"(mmseqp version 2>/dev/null ) || echo \"\") )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.proteinortho.tsv\n    touch ${prefix}.proteinortho-graph\n    touch ${prefix}.blast-graph\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        proteinortho : \\$(echo \\$(proteinortho --version 2>&1) )\n        \\$(echo \\$( \"diamond:\"(diamond version 2>/dev/null | head -n1 | sed 's/^.*version //;' ) || echo \"\") )\n        \\$(echo \\$( \"blast:\"(blastp -version 2>/dev/null |head -n1 | sed 's/^.*: //;'  ) || echo \"\") )\n        \\$(echo \\$( \"mmseqs:\"(mmseqp version 2>/dev/null ) || echo \"\") )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compress files with crabz\nTags: compression, gzip, zlib", "answer": "process CRABZ_COMPRESS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/crabz:0.9.0':\n        'biocontainers/crabz:0.9.0' }\"\n\n    input:\n    tuple val(meta), path(file)\n\n    output:\n    tuple val(meta), path(\"*.gz\"), emit: archive\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${file}\"\n    \"\"\"\n    crabz \\\\\n        $args \\\\\n        -p $task.cpus \\\\\n        -o ${prefix}.gz \\\\\n        $file\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        crabz: \\$(crabz --version |& sed 's/[^:]*://')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${file}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        crabz: \\$(crabz --version |& sed 's/[^:]*://')\n\n\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Decompress files with crabz\nTags: decompression, gzip, zlib", "answer": "process CRABZ_DECOMPRESS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/crabz:0.9.0':\n        'biocontainers/crabz:0.9.0' }\"\n\n    input:\n    tuple val(meta), path(archive)\n\n    output:\n    tuple val(meta), path(\"*.*\"), emit: file\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${archive}\"\n    \"\"\"\n    crabz \\\\\n        $args \\\\\n        -p $task.cpus \\\\\n        -o ${prefix} \\\\\n        $archive\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        crabz: \\$(crabz --version |& sed 's/[^:]*://')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${archive}\"\n    \"\"\"\n    touch ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        crabz: \\$(crabz --version |& sed 's/[^:]*://')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Salmonella serotype prediction from reads and assemblies\nTags: fasta, fastq, salmonella, sertotype", "answer": "process SEQSERO2 {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqsero2:1.2.1--py_0' :\n        'biocontainers/seqsero2:1.2.1--py_0' }\"\n\n    input:\n    tuple val(meta), path(seqs)\n\n    output:\n    tuple val(meta), path(\"results/*_log.txt\")   , emit: log\n    tuple val(meta), path(\"results/*_result.tsv\"), emit: tsv\n    tuple val(meta), path(\"results/*_result.txt\"), emit: txt\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    SeqSero2_package.py \\\\\n        $args \\\\\n        -d results/ \\\\\n        -n $prefix \\\\\n        -p $task.cpus \\\\\n        -i $seqs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqsero2: \\$( echo \\$( SeqSero2_package.py --version 2>&1) | sed 's/^.*SeqSero2_package.py //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Somalier can extract informative sites, evaluate relatedness, and perform quality-control on BAM/CRAM/BCF/VCF/GVCF or from jointly-called VCFs\nTags: relatedness, QC, bam, cram, vcf, gvcf, ancestry, identity, kinship, informative sites, family", "answer": "\nprocess SOMALIER_ANCESTRY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/somalier:0.2.15--h37c5b7d_0':\n        'biocontainers/somalier:0.2.15--h37c5b7d_0' }\"\n\n    input:\n    tuple val(meta),  path(query_somalier_files, stageAs: \"query_files/*\")\n    tuple val(meta2), path(labels_tsv), path(labelled_somalier_files, stageAs: \"labelled_files/*\")\n\n    output:\n    tuple val(meta), path(\"*-ancestry.tsv\")     , emit: tsv\n    tuple val(meta), path(\"*-ancestry.html\")    , emit: html\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    somalier  \\\\\n        ancestry  \\\\\n        --labels $labels_tsv \\$(find -L labelled_files -type f -name \"*.somalier\")  \\\\\n        ++ $query_somalier_files  \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        somalier: \\$(echo \\$(somalier 2>&1) | sed 's/^.*somalier version: //; s/Commands:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Somalier can extract informative sites, evaluate relatedness, and perform quality-control on BAM/CRAM/BCF/VCF/GVCF or from jointly-called VCFs\nTags: relatedness, QC, bam, cram, vcf, gvcf, ancestry, identity, kinship, informative sites, family", "answer": "\nprocess SOMALIER_EXTRACT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/somalier:0.2.19--h0c29559_0':\n        'biocontainers/somalier:0.2.19--h0c29559_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(sites)\n\n    output:\n    tuple val(meta), path(\"*.somalier\") , emit: extract\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    somalier extract \\\\\n        --sites ${sites} \\\\\n        -f ${fasta} \\\\\n        ${input} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        somalier: \\$(echo \\$(somalier 2>&1) | sed 's/^.*somalier version: //; s/Commands:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.somalier\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        somalier: \\$(echo \\$(somalier 2>&1) | sed 's/^.*somalier version: //; s/Commands:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Somalier can extract informative sites, evaluate relatedness, and perform quality-control on BAM/CRAM/BCF/VCF/GVCF or from jointly-called VCFs\nTags: relatedness, QC, bam, cram, vcf, gvcf, ancestry, identity, kinship, informative sites, family", "answer": "\nprocess SOMALIER_RELATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/somalier:0.2.19--h0c29559_0':\n        'biocontainers/somalier:0.2.19--h0c29559_0' }\"\n\n    input:\n    tuple val(meta), path(extract), path(ped)\n    path(sample_groups)\n\n    output:\n    tuple val(meta), path(\"*.html\"),          emit: html\n    tuple val(meta), path(\"*.pairs.tsv\"),     emit: pairs_tsv\n    tuple val(meta), path(\"*.samples.tsv\"),   emit: samples_tsv\n    path \"versions.yml\",                      emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def input_list = extract.collect{\"$it\"}.join(' ')\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n    def sample_groups_command = sample_groups ? \"-g $sample_groups\" : \"\"\n    def ped_command = ped ? \"-p $ped\" : \"\"\n\n    \"\"\"\n    somalier relate \\\\\n        -o ${prefix} \\\\\n        ${input_list} \\\\\n        ${args} \\\\\n        ${sample_groups_command} \\\\\n        ${ped_command}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        somalier: \\$(echo \\$(somalier 2>&1) | sed 's/^.*somalier version: //; s/Commands:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n\n    \"\"\"\n    touch ${prefix}.html\n    touch ${prefix}.pairs.tsv\n    touch ${prefix}.samples.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        somalier: \\$(echo \\$(somalier 2>&1) | sed 's/^.*somalier version: //; s/Commands:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Serotyping of Neisseria meningitidis assemblies\nTags: fasta, Neisseria meningitidis, serotype", "answer": "process MENINGOTYPE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/meningotype:0.8.5--pyhdfd78af_0' :\n        'biocontainers/meningotype:0.8.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    meningotype \\\\\n        $args \\\\\n        $fasta \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        meningotype: \\$( echo \\$(meningotype --version 2>&1) | sed 's/^.*meningotype v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Fast, efficient, lossless compression of FASTQ files.\nTags: FASTQ, compression, lossless", "answer": "process SLIMFASTQ {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/slimfastq:2.04--h87f3376_2':\n        'biocontainers/slimfastq:2.04--h87f3376_2' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n\n    output:\n    tuple val(meta), path(\"*.sfq\"), emit: sfq\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.04' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    if (meta.single_end) {\n        \"\"\"\n        gzip -d -c '${fastq}' | slimfastq \\\\\n            $args \\\\\n            -f '${prefix}.sfq'\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            slimfastq: ${VERSION}\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        gzip -d -c '${fastq[0]}' | slimfastq \\\\\n            $args \\\\\n            -f '${prefix}_1.sfq'\n\n        gzip -d -c '${fastq[1]}' | slimfastq \\\\\n            $args \\\\\n            -f '${prefix}_2.sfq'\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            slimfastq: ${VERSION}\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: A versatile pairwise aligner for genomic and spliced nucleotide sequences\nTags: align, fasta, fastq, genome, reference", "answer": "process GRAPHMAP2_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n    tag \"$meta.id\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/graphmap:0.6.3--he513fc3_0' :\n        'biocontainers/graphmap:0.6.3--he513fc3_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  fasta\n    path  index\n\n    output:\n    tuple val(meta), path(\"*.sam\"), emit: sam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    graphmap2 \\\\\n        align \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        -i $index \\\\\n        -d $reads \\\\\n        -o ${prefix}.sam \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        graphmap2: \\$(echo \\$(graphmap2 align 2>&1) | sed 's/^.*Version: v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A versatile pairwise aligner for genomic and spliced nucleotide sequences\nTags: index, fasta, reference", "answer": "process GRAPHMAP2_INDEX {\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/graphmap:0.6.3--he513fc3_0' :\n        'biocontainers/graphmap:0.6.3--he513fc3_0' }\"\n\n    input:\n    path fasta\n\n    output:\n    path \"*.gmidx\"      , emit: index\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    graphmap2 \\\\\n        align \\\\\n        -t $task.cpus \\\\\n        -I \\\\\n        $args \\\\\n        -r $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        graphmap2: \\$(echo \\$(graphmap2 align 2>&1) | sed 's/^.*Version: v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: CLI Download utility\nTags: download, utility, http(s)", "answer": "process ARIA2 {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/aria2:1.36.0' :\n        'biocontainers/aria2:1.36.0' }\"\n\n    input:\n    tuple val(meta), val(source_url)\n\n    output:\n    tuple val(meta), path(\"$downloaded_file\"), emit: downloaded_file\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    downloaded_file = source_url.split(\"/\")[-1]\n\n    \"\"\"\n    aria2c \\\\\n        --check-certificate=false \\\\\n        $args \\\\\n        $source_url\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        aria2: \\$(echo \\$(aria2c --version 2>&1) | grep 'aria2 version' | cut -f3 -d ' ')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    downloaded_file = source_url.split(\"/\")[-1]\n\n    \"\"\"\n    touch ${downloaded_file}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        aria2: \\$(echo \\$(aria2c --version 2>&1) | grep 'aria2 version' | cut -f3 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Searches a term in a public NCBI database\nTags: public datasets, entrez, search, ncbi, database", "answer": "process ENTREZDIRECT_ESEARCH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/entrez-direct:16.2--he881be0_1':\n        'biocontainers/entrez-direct:16.2--he881be0_1' }\"\n\n    input:\n    tuple val(meta), val(term)\n    val database\n\n    output:\n    tuple val(meta), path(\"*.xml\") , emit: xml\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args = task.ext.args ?: ''\n    \"\"\"\n    esearch \\\\\n        -db $database \\\\\n        -query $term \\\\\n        $args > ${prefix}.xml\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        esearch: \\$(esearch -version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Queries an NCBI database using an UID\nTags: public datasets, entrez, search, ncbi, database", "answer": "process ENTREZDIRECT_XTRACT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n    'https://depot.galaxyproject.org/singularity/entrez-direct:16.2--he881be0_1':\n    'biocontainers/entrez-direct:16.2--he881be0_1' }\"\n\n    input:\n    tuple val(meta), path(xml_input)\n    val pattern\n    val element\n    val sep\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cat $xml_input | xtract \\\\\n        -pattern $pattern \\\\\n        -tab $sep \\\\\n        -element $element \\\\\n        $args \\\\\n        > ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        xtract: \\$(xtract -version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Queries an NCBI database using Unique Identifier(s)\nTags: public datasets, ncbi, entrez, metadata, query, database", "answer": "process ENTREZDIRECT_ESUMMARY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/entrez-direct:16.2--he881be0_1':\n        'biocontainers/entrez-direct:16.2--he881be0_1' }\"\n\n    input:\n    tuple val(meta), val(uid), path(uids_file)\n    val database\n\n    output:\n    tuple val(meta), path(\"*.xml\"), emit: xml\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    input = uids_file ? \"-input ${uids_file}\" : \"-id ${uid}\"\n    if (!uid && !uids_file) error \"No input. Valid input: an identifier or a .txt file with identifiers\"\n    if (uid && uids_file) error \"Only one input is required: a single identifier or a .txt file with identifiers\"\n    \"\"\"\n    esummary \\\\\n        $args \\\\\n        -db $database \\\\\n        $input > ${prefix}.xml\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        esummary: \\$(esummary -version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Transform the data matrix using centered logratio transformation (CLR) or additive logratio transformation (ALR)\nTags: alr, clr, logratio, boxcox, transformation, propr", "answer": "process PROPR_LOGRATIO {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-propr:4.2.6':\n        'biocontainers/r-propr:4.2.6' }\"\n\n    input:\n    tuple val(meta), path(count)\n\n    output:\n    tuple val(meta), path(\"*.logratio.tsv\"), emit: logratio\n    path \"*.R_sessionInfo.log\"             , emit: session_info\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'logratio.R'\n}\n"}
{"question": "Description: Perform logratio-based correlation analysis -> get proportionality & basis shrinkage partial correlation coefficients.\nOne can also compute standard correlation coefficients, if required.\n\nTags: coexpression, correlation, proportionality, logratio, propr, corpcor", "answer": "process PROPR_PROPR {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-propr:5.0.3':\n        'biocontainers/r-propr:5.0.3' }\"\n\n    input:\n    tuple val(meta), path(count)\n\n    output:\n    tuple val(meta), path(\"*.propr.rds\"), emit: propr\n    tuple val(meta), path(\"*.propr.tsv\"), emit: matrix\n    tuple val(meta), path(\"*.fdr.tsv\"),   emit: fdr         , optional:true\n    tuple val(meta), path(\"*.adj.csv\"),   emit: adj         , optional:true\n    path \"*.warnings.log\",                emit: warnings\n    path \"*.R_sessionInfo.log\",           emit: session_info\n    path \"versions.yml\",                  emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'propr.R'\n}\n"}
{"question": "Description: Perform differential proportionality analysis\nTags: differential, proportionality, logratio, expression, propr", "answer": "process PROPR_PROPD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-propr:5.0.3':\n        'biocontainers/r-propr:5.0.3' }\"\n\n    input:\n    tuple val(meta), path(count)\n    tuple val(meta2), path(samplesheet)\n\n    output:\n    tuple val(meta), path(\"*.propd.rds\"), emit: propd\n    tuple val(meta), path(\"*.propd.tsv\"), emit: results\n    tuple val(meta), path(\"*.fdr.tsv\")  , emit: fdr         , optional:true\n    tuple val(meta), path(\"*.adj.csv\"),   emit: adj         , optional:true\n    path \"*.warnings.log\",                emit: warnings\n    path \"*.R_sessionInfo.log\"          , emit: session_info\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'propd.R'\n}\n"}
{"question": "Description: Perform Gene Ratio Enrichment Analysis\nTags: logratio, differential, propr, grea, enrichment, expression", "answer": "process PROPR_GREA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-propr:5.0.4':\n        'biocontainers/r-propr:5.0.4' }\"\n\n    input:\n    tuple val(meta), path(adj)\n    tuple val(meta2), path(gmt)\n\n    output:\n    tuple val(meta), path(\"*.go.tsv\"),  emit: enrichedGO\n    path \"versions.yml\",                emit: versions\n    path \"*.R_sessionInfo.log\",         emit: session_info\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'grea.R'\n}\n"}
{"question": "Description: Spotiflow, accurate and efficient spot detection with stereographic flow.\nTags: imaging, spatial, spot, detection", "answer": "process SPOTIFLOW {\n    tag \"$meta.id\"\n    label 'process_medium'\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/spotiflow:77826b49fcab1875':\n        'community.wave.seqera.io/library/spotiflow:b300f293b176b30e' }\"\n\n    input:\n    tuple val(meta), path(image_2d)\n\n    output:\n    tuple val(meta), path(\"*.csv\"), emit: spots\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args   ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"0.0.3\"\n\n    \"\"\"\n    spotiflow-predict \\\\\n        ${image_2d} \\\\\n        --out-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spotiflow: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args    = task.ext.args   ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"0.0.3\"\n    \"\"\"\n    touch ${prefix}.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spotiflow: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Manta calls structural variants (SVs) and indels from mapped paired-end sequencing reads. It is optimized for analysis of germline variation in small sets of individuals and somatic variation in tumor/normal sample pairs.\nTags: somatic, wgs, wxs, panel, vcf, structural variants, small indels", "answer": "process MANTA_TUMORONLY {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'error_retry'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/manta:1.6.0--h9ee0642_1' :\n        'biocontainers/manta:1.6.0--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(target_bed), path(target_bed_tbi)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    path(config)\n\n    output:\n    tuple val(meta), path(\"*candidate_small_indels.vcf.gz\")    , emit: candidate_small_indels_vcf\n    tuple val(meta), path(\"*candidate_small_indels.vcf.gz.tbi\"), emit: candidate_small_indels_vcf_tbi\n    tuple val(meta), path(\"*candidate_sv.vcf.gz\")              , emit: candidate_sv_vcf\n    tuple val(meta), path(\"*candidate_sv.vcf.gz.tbi\")          , emit: candidate_sv_vcf_tbi\n    tuple val(meta), path(\"*tumor_sv.vcf.gz\")                  , emit: tumor_sv_vcf\n    tuple val(meta), path(\"*tumor_sv.vcf.gz.tbi\")              , emit: tumor_sv_vcf_tbi\n    path \"versions.yml\"                                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def options_manta = target_bed ? \"--callRegions $target_bed\" : \"\"\n    def config_option = config ? \"--config ${config}\" : \"\"\n    \"\"\"\n    configManta.py \\\\\n        --tumorBam $input \\\\\n        --reference $fasta \\\\\n        ${config_option} \\\\\n        --runDir manta \\\\\n        $options_manta \\\\\n        $args\n\n    python manta/runWorkflow.py -m local -j $task.cpus\n\n    mv manta/results/variants/candidateSmallIndels.vcf.gz \\\\\n        ${prefix}.candidate_small_indels.vcf.gz\n    mv manta/results/variants/candidateSmallIndels.vcf.gz.tbi \\\\\n        ${prefix}.candidate_small_indels.vcf.gz.tbi\n    mv manta/results/variants/candidateSV.vcf.gz \\\\\n        ${prefix}.candidate_sv.vcf.gz\n    mv manta/results/variants/candidateSV.vcf.gz.tbi \\\\\n        ${prefix}.candidate_sv.vcf.gz.tbi\n    mv manta/results/variants/tumorSV.vcf.gz \\\\\n        ${prefix}.tumor_sv.vcf.gz\n    mv manta/results/variants/tumorSV.vcf.gz.tbi \\\\\n        ${prefix}.tumor_sv.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        manta: \\$( configManta.py --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.candidate_small_indels.vcf.gz\n    touch ${prefix}.candidate_small_indels.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.candidate_sv.vcf.gz\n    touch ${prefix}.candidate_sv.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.tumor_sv.vcf.gz\n    touch ${prefix}.tumor_sv.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        manta: \\$( configManta.py --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Manta calls structural variants (SVs) and indels from mapped paired-end sequencing reads. This script reformats inversions into single inverted sequence junctions which was the format used in Manta versions <= 1.4.0.\nTags: structural variants, conversion, indels", "answer": "process MANTA_CONVERTINVERSION {\n    tag \"$meta.id\"\n    label 'process_low'\n    label 'error_retry'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-40295ae41112676b05b649e513fe7000675e9b84:a0332aa38645fbb8969567731ce68cfb7f830ec4-0':\n        'biocontainers/mulled-v2-40295ae41112676b05b649e513fe7000675e9b84:a0332aa38645fbb8969567731ce68cfb7f830ec4-0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")    , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\"), emit: tbi\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    convertInversion.py \\$(which samtools) $fasta $vcf | bgzip --threads $task.cpus > ${prefix}.vcf.gz\n    tabix ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        manta: \\$( configManta.py --version )\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        manta: \\$( configManta.py --version )\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Manta calls structural variants (SVs) and indels from mapped paired-end sequencing reads. It is optimized for analysis of germline variation in small sets of individuals and somatic variation in tumor/normal sample pairs.\nTags: somatic, wgs, wxs, panel, vcf, structural variants, small indels", "answer": "process MANTA_GERMLINE {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'error_retry'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/manta:1.6.0--h9ee0642_1' :\n        'biocontainers/manta:1.6.0--h9ee0642_1' }\"\n\n    input:\n    //Matching the target bed with the input sample allows to parallelize the same sample run across different intervals or a single bed file\n    tuple val(meta), path(input), path(index), path(target_bed), path(target_bed_tbi)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    path(config)\n\n    output:\n    tuple val(meta), path(\"*candidate_small_indels.vcf.gz\")    , emit: candidate_small_indels_vcf\n    tuple val(meta), path(\"*candidate_small_indels.vcf.gz.tbi\"), emit: candidate_small_indels_vcf_tbi\n    tuple val(meta), path(\"*candidate_sv.vcf.gz\")              , emit: candidate_sv_vcf\n    tuple val(meta), path(\"*candidate_sv.vcf.gz.tbi\")          , emit: candidate_sv_vcf_tbi\n    tuple val(meta), path(\"*diploid_sv.vcf.gz\")                , emit: diploid_sv_vcf\n    tuple val(meta), path(\"*diploid_sv.vcf.gz.tbi\")            , emit: diploid_sv_vcf_tbi\n    path \"versions.yml\"                                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_files = input.collect{\"--bam ${it}\"}.join(' ')\n    def options_manta = target_bed ? \"--callRegions $target_bed\" : \"\"\n    def config_option = config ? \"--config ${config}\" : \"\"\n    \"\"\"\n    configManta.py \\\\\n        ${input_files} \\\\\n        ${config_option} \\\\\n        --reference $fasta \\\\\n        --runDir manta \\\\\n        $options_manta \\\\\n        $args\n\n    python manta/runWorkflow.py -m local -j $task.cpus\n\n    mv manta/results/variants/candidateSmallIndels.vcf.gz \\\\\n        ${prefix}.candidate_small_indels.vcf.gz\n    mv manta/results/variants/candidateSmallIndels.vcf.gz.tbi \\\\\n        ${prefix}.candidate_small_indels.vcf.gz.tbi\n    mv manta/results/variants/candidateSV.vcf.gz \\\\\n        ${prefix}.candidate_sv.vcf.gz\n    mv manta/results/variants/candidateSV.vcf.gz.tbi \\\\\n        ${prefix}.candidate_sv.vcf.gz.tbi\n    mv manta/results/variants/diploidSV.vcf.gz \\\\\n        ${prefix}.diploid_sv.vcf.gz\n    mv manta/results/variants/diploidSV.vcf.gz.tbi \\\\\n        ${prefix}.diploid_sv.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        manta: \\$( configManta.py --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.candidate_small_indels.vcf.gz\n    touch ${prefix}.candidate_small_indels.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.candidate_sv.vcf.gz\n    touch ${prefix}.candidate_sv.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.diploid_sv.vcf.gz\n    touch ${prefix}.diploid_sv.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        manta: \\$( configManta.py --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Manta calls structural variants (SVs) and indels from mapped paired-end sequencing reads. It is optimized for analysis of germline variation in small sets of individuals and somatic variation in tumor/normal sample pairs.\nTags: somatic, wgs, wxs, panel, vcf, structural variants, small indels", "answer": "process MANTA_SOMATIC {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'error_retry'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/manta:1.6.0--h9ee0642_1' :\n        'biocontainers/manta:1.6.0--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(input_normal), path(input_index_normal), path(input_tumor), path(input_index_tumor), path(target_bed), path(target_bed_tbi)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    path(config)\n\n    output:\n    tuple val(meta), path(\"*.candidate_small_indels.vcf.gz\")     , emit: candidate_small_indels_vcf\n    tuple val(meta), path(\"*.candidate_small_indels.vcf.gz.tbi\") , emit: candidate_small_indels_vcf_tbi\n    tuple val(meta), path(\"*.candidate_sv.vcf.gz\")               , emit: candidate_sv_vcf\n    tuple val(meta), path(\"*.candidate_sv.vcf.gz.tbi\")           , emit: candidate_sv_vcf_tbi\n    tuple val(meta), path(\"*.diploid_sv.vcf.gz\")                 , emit: diploid_sv_vcf\n    tuple val(meta), path(\"*.diploid_sv.vcf.gz.tbi\")             , emit: diploid_sv_vcf_tbi\n    tuple val(meta), path(\"*.somatic_sv.vcf.gz\")                 , emit: somatic_sv_vcf\n    tuple val(meta), path(\"*.somatic_sv.vcf.gz.tbi\")             , emit: somatic_sv_vcf_tbi\n    path \"versions.yml\"                                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def options_manta = target_bed ? \"--callRegions $target_bed\" : \"\"\n    def config_option = config ? \"--config ${config}\" : \"\"\n    \"\"\"\n    configManta.py \\\\\n        --tumorBam $input_tumor \\\\\n        --normalBam $input_normal \\\\\n        --reference $fasta \\\\\n        ${config_option} \\\\\n        --runDir manta \\\\\n        $options_manta \\\\\n        $args\n\n    python manta/runWorkflow.py -m local -j $task.cpus\n\n    mv manta/results/variants/candidateSmallIndels.vcf.gz \\\\\n        ${prefix}.candidate_small_indels.vcf.gz\n    mv manta/results/variants/candidateSmallIndels.vcf.gz.tbi \\\\\n        ${prefix}.candidate_small_indels.vcf.gz.tbi\n    mv manta/results/variants/candidateSV.vcf.gz \\\\\n        ${prefix}.candidate_sv.vcf.gz\n    mv manta/results/variants/candidateSV.vcf.gz.tbi \\\\\n        ${prefix}.candidate_sv.vcf.gz.tbi\n    mv manta/results/variants/diploidSV.vcf.gz \\\\\n        ${prefix}.diploid_sv.vcf.gz\n    mv manta/results/variants/diploidSV.vcf.gz.tbi \\\\\n        ${prefix}.diploid_sv.vcf.gz.tbi\n    mv manta/results/variants/somaticSV.vcf.gz \\\\\n        ${prefix}.somatic_sv.vcf.gz\n    mv manta/results/variants/somaticSV.vcf.gz.tbi \\\\\n        ${prefix}.somatic_sv.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        manta: \\$( configManta.py --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.candidate_small_indels.vcf.gz\n    touch ${prefix}.candidate_small_indels.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.candidate_sv.vcf.gz\n    touch ${prefix}.candidate_sv.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.diploid_sv.vcf.gz\n    touch ${prefix}.diploid_sv.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.somatic_sv.vcf.gz\n    touch ${prefix}.somatic_sv.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        manta: \\$( configManta.py --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: TransDecoder identifies candidate coding regions within transcript sequences. It is used to build gff file. You can use this module after transdecoder_longorf\nTags: eukaryotes, gff", "answer": "process TRANSDECODER_PREDICT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/transdecoder:5.5.0--pl5262hdfd78af_4':\n        'quay.io/comp-bio-aging/transdecoder' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path(fold)\n\n    output:\n    tuple val(meta), path(\"*.transdecoder.pep\")  , emit: pep\n    tuple val(meta), path(\"*.transdecoder.gff3\") , emit: gff3\n    tuple val(meta), path(\"*.transdecoder.cds\")  , emit: cds\n    tuple val(meta), path(\"*.transdecoder.bed\")  , emit: bed\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    TransDecoder.Predict \\\\\n        $args \\\\\n        -O ${prefix} \\\\\n        -t \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        transdecoder: \\$(echo \\$(TransDecoder.Predict --version) | sed -e \"s/TransDecoder.Predict //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: TransDecoder itentifies candidate coding regions within transcript sequences. it is used to build gff file.\nTags: eucaryotes, gff", "answer": "process TRANSDECODER_LONGORF {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n    'https://depot.galaxyproject.org/singularity/transdecoder:5.5.0--pl5262hdfd78af_4' :\n    'quay.io/comp-bio-aging/transdecoder' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${meta.id}/*.pep\") , emit: pep\n    tuple val(meta), path(\"${meta.id}/*.gff3\"), emit: gff3\n    tuple val(meta), path(\"${meta.id}/*.cds\") , emit: cds\n    tuple val(meta), path(\"${meta.id}/*.dat\") , emit: dat\n    path(\"${meta.id}/\")                       , emit: folder\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    TransDecoder.LongOrfs \\\\\n        $args \\\\\n        -O $prefix \\\\\n        -t \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        transdecoder: \\$(echo \\$(TransDecoder.LongOrfs --version) | sed -e \"s/TransDecoder.LongOrfs //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cluster genome FASTA files by average nucleotide identity\nTags: genomics, cluster, genome, metagenomics", "answer": "process GALAH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/galah%3A0.3.1--h031d066_3':\n        'biocontainers/galah:0.3.1--h031d066_3' }\"\n\n    input:\n    tuple val(meta), path(bins), path(qc_table), val(qc_format)\n\n    output:\n    tuple val(meta), path(\"*.tsv\")                    , emit: tsv\n    tuple val(meta), path(\"${prefix}-dereplicated/*\") , emit: dereplicated_bins\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def qc_args = (qc_format == \"checkm\") ? \"--checkm-tab-table ${qc_table}\" : \"--genome-info ${qc_table}\"\n    def qc_input = qc_table ? qc_args : \"\"\n    def valid_qc_format = qc_format in [\"checkm\", \"genome_info\"]\n    if( qc_table && !valid_qc_format ) {\n        error \"Invalid qc_format supplied! qc_format should be either 'checkm' or 'genome_info'.\"\n    }\n    \"\"\"\n    mkdir ${prefix}-dereplicated\n\n    galah cluster \\\\\n        --threads ${task.cpus} \\\\\n        --genome-fasta-files ${bins} \\\\\n        ${qc_input} \\\\\n        --output-cluster-definition ${prefix}-dereplicated_bins.tsv \\\\\n        --output-representative-fasta-directory ${prefix}-dereplicated\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        galah: \\$(galah --version | sed 's/galah //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}-dereplicated/\n    touch ${prefix}-dereplicated/test.fa\n    touch ${prefix}-dereplicated_bins.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        galah: \\$(galah --version | sed 's/galah //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create BWA-mem2 index for reference genome\nTags: index, fasta, genome, reference", "answer": "process BWAMEM2_INDEX {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bwa-mem2:2.2.1--he513fc3_0' :\n        'biocontainers/bwa-mem2:2.2.1--he513fc3_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"bwamem2\"), emit: index\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${fasta}\"\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir bwamem2\n    bwa-mem2 \\\\\n        index \\\\\n        $args \\\\\n        $fasta -p bwamem2/${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwamem2: \\$(echo \\$(bwa-mem2 version 2>&1) | sed 's/.* //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${fasta}\"\n\n    \"\"\"\n    mkdir bwamem2\n    touch bwamem2/${prefix}.0123\n    touch bwamem2/${prefix}.ann\n    touch bwamem2/${prefix}.pac\n    touch bwamem2/${prefix}.amb\n    touch bwamem2/${prefix}.bwt.2bit.64\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwamem2: \\$(echo \\$(bwa-mem2 version 2>&1) | sed 's/.* //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs fastq alignment to a fasta reference using BWA\nTags: mem, bwa, alignment, map, fastq, bam, sam", "answer": "process BWAMEM2_MEM {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-e5d375990341c5aef3c9aff74f96f66f65375ef6:2d15960ccea84e249a150b7f5d4db3a42fc2d6c3-0' :\n        'biocontainers/mulled-v2-e5d375990341c5aef3c9aff74f96f66f65375ef6:2d15960ccea84e249a150b7f5d4db3a42fc2d6c3-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(index)\n    tuple val(meta3), path(fasta)\n    val   sort_bam\n\n    output:\n    tuple val(meta), path(\"*.sam\")  , emit: sam , optional:true\n    tuple val(meta), path(\"*.bam\")  , emit: bam , optional:true\n    tuple val(meta), path(\"*.cram\") , emit: cram, optional:true\n    tuple val(meta), path(\"*.crai\") , emit: crai, optional:true\n    tuple val(meta), path(\"*.csi\")  , emit: csi , optional:true\n    path  \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n\n    def extension_pattern = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher =  (args2 =~ extension_pattern)\n    def extension = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n\n    bwa-mem2 \\\\\n        mem \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        \\$INDEX \\\\\n        $reads \\\\\n        | samtools $samtools_command $args2 -@ $task.cpus ${reference} -o ${prefix}.${extension} -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwamem2: \\$(echo \\$(bwa-mem2 version 2>&1) | sed 's/.* //')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    def extension_pattern = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher =  (args2 =~ extension_pattern)\n    def extension = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    def create_index = \"\"\n    if (extension == \"cram\") {\n        create_index = \"touch ${prefix}.crai\"\n    } else if (extension == \"bam\") {\n        create_index = \"touch ${prefix}.csi\"\n    }\n\n    \"\"\"\n    touch ${prefix}.${extension}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwamem2: \\$(echo \\$(bwa-mem2 version 2>&1) | sed 's/.* //')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Splits CSV/TSV into multiple files according to column values\nTags: split, csv, tsv", "answer": "process CSVTK_SPLIT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/csvtk:0.30.0--h9ee0642_0' :\n        'biocontainers/csvtk:0.30.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(csv)\n    val in_format\n    val out_format\n\n    output:\n    tuple val(meta), path(\"*.${out_extension}\"), emit: split_csv\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def delimiter = in_format == \"tsv\" ? \"--tabs\" : (in_format == \"csv\" ? \"--delimiter ',' \" : in_format)\n    def out_delimiter = out_format == \"tsv\" ? \"--out-tabs\" : (out_format == \"csv\" ? \"--out-delimiter ',' \" : out_format)\n    out_extension = out_format == \"tsv\" ? 'tsv' : 'csv'\n    \"\"\"\n    sed -i.bak '/^##/d' $csv\n    csvtk \\\\\n        split \\\\\n        $args \\\\\n        --num-cpus $task.cpus \\\\\n        $delimiter \\\\\n        $out_delimiter \\\\\n        $csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        csvtk: \\$(echo \\$( csvtk version | sed -e 's/csvtk v//g' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    out_extension = args.contains('--out-delimiter \"\\t\"') || args.contains('-D \"\\t\"') || args.contains(\"-D \\$'\\t'\") ? \"tsv\" : \"csv\"\n    \"\"\"\n    touch ${prefix}.${out_extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        csvtk: \\$(echo \\$( csvtk version | sed -e \"s/csvtk v//g\" ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Concatenate two or more CSV (or TSV) tables into a single table\nTags: concatenate, tsv, csv", "answer": "process CSVTK_CONCAT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/csvtk:0.30.0--h9ee0642_0' :\n        'biocontainers/csvtk:0.30.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(csv)\n    val in_format\n    val out_format\n\n    output:\n    tuple val(meta), path(\"${prefix}.${out_extension}\"), emit: csv\n    path \"versions.yml\"                                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def delimiter = in_format == \"tsv\" ? \"\\t\" : (in_format == \"csv\" ? \",\" : in_format)\n    def out_delimiter = out_format == \"tsv\" ? \"\\t\" : (out_format == \"csv\" ? \",\" : out_format)\n    out_extension = out_format == \"tsv\" ? 'tsv' : 'csv'\n    \"\"\"\n    csvtk \\\\\n        concat \\\\\n        $args \\\\\n        --num-cpus $task.cpus \\\\\n        --delimiter \"${delimiter}\" \\\\\n        --out-delimiter \"${out_delimiter}\" \\\\\n        --out-file ${prefix}.${out_extension} \\\\\n        $csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        csvtk: \\$(echo \\$( csvtk version | sed -e \"s/csvtk v//g\" ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    out_extension = out_format == \"tsv\" ? 'tsv' : 'csv'\n    \"\"\"\n    touch ${prefix}.${out_extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        csvtk: \\$(echo \\$( csvtk version | sed -e \"s/csvtk v//g\" ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Join two or more CSV (or TSV) tables by selected fields into a single table\nTags: join, tsv, csv", "answer": "process CSVTK_JOIN {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/csvtk:0.30.0--h9ee0642_0':\n        'biocontainers/csvtk:0.30.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(csv)\n\n    output:\n    tuple val(meta), path(\"${prefix}.${out_extension}\"), emit: csv\n    path \"versions.yml\"                                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    out_extension = args.contains('--out-delimiter \"\\t\"') || args.contains('-D \"\\t\"') || args.contains(\"-D \\$'\\t'\") ? \"tsv\" : \"csv\"\n    \"\"\"\n    csvtk \\\\\n        join \\\\\n        $args \\\\\n        --num-cpus $task.cpus \\\\\n        --out-file ${prefix}.${out_extension} \\\\\n        $csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        csvtk: \\$(echo \\$( csvtk version | sed -e \"s/csvtk v//g\" ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    out_extension = args.contains('--out-delimiter \"\\t\"') || args.contains('-D \"\\t\"') || args.contains(\"-D \\$'\\t'\") ? \"tsv\" : \"csv\"\n    \"\"\"\n    touch ${prefix}.${out_extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        csvtk: \\$(echo \\$( csvtk version | sed -e \"s/csvtk v//g\" ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Use deamination patterns to estimate contamination in single-stranded libraries\nTags: authentict, ancientDNA, single-stranded, deamination, contamination, damage", "answer": "process AUTHENTICT_DEAM2CONT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/authentict:1.0.1--py311h9f5acd7_0':\n        'biocontainers/authentict:1.0.1--py311h9f5acd7_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(config)\n    tuple val(meta3), path(positions)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def config_file = config ? \"-c ${config}\" : \"\"\n    def positions_file = positions ? \"-p ${positions}\" : \"\"\n\n    \"\"\"\n    samtools view $args $bam | AuthentiCT \\\\\n        deam2cont \\\\\n        $args2 \\\\\n        $config_file \\\\\n        $positions_file \\\\\n        - \\\\\n        > ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        authentict: \\$(echo \\$(AuthentiCT --version 2>&1) )\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: k-mer based assembly evaluation.\nTags: k-mer, assembly, evaluation", "answer": "process MERQURY_MERQURY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/merqury:1.3--hdfd78af_1':\n        'biocontainers/merqury:1.3--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(meryl_db), path(assembly)\n\n    output:\n    tuple val(meta), path(\"*_only.bed\")          , emit: assembly_only_kmers_bed\n    tuple val(meta), path(\"*_only.wig\")          , emit: assembly_only_kmers_wig\n    tuple val(meta), path(\"*.completeness.stats\"), emit: stats\n    tuple val(meta), path(\"*.dist_only.hist\")    , emit: dist_hist\n    tuple val(meta), path(\"*.spectra-cn.fl.png\") , emit: spectra_cn_fl_png\n    tuple val(meta), path(\"*.spectra-cn.hist\")   , emit: spectra_cn_hist\n    tuple val(meta), path(\"*.spectra-cn.ln.png\") , emit: spectra_cn_ln_png\n    tuple val(meta), path(\"*.spectra-cn.st.png\") , emit: spectra_cn_st_png\n    tuple val(meta), path(\"*.spectra-asm.fl.png\"), emit: spectra_asm_fl_png\n    tuple val(meta), path(\"*.spectra-asm.hist\")  , emit: spectra_asm_hist\n    tuple val(meta), path(\"*.spectra-asm.ln.png\"), emit: spectra_asm_ln_png\n    tuple val(meta), path(\"*.spectra-asm.st.png\"), emit: spectra_asm_st_png\n    tuple val(meta), path(\"${prefix}.qv\")        , emit: assembly_qv\n    tuple val(meta), path(\"${prefix}.*.qv\")      , emit: scaffold_qv\n    tuple val(meta), path(\"*.hist.ploidy\")       , emit: read_ploidy\n    tuple val(meta), path(\"*.hapmers.blob.png\")  , emit: hapmers_blob_png           , optional: true\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = 1.3 // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    # Nextflow changes the container --entrypoint to /bin/bash (container default entrypoint: /usr/local/env-execute)\n    # Check for container variable initialisation script and source it.\n    if [ -f \"/usr/local/env-activate.sh\" ]; then\n        set +u  # Otherwise, errors out because of various unbound variables\n        . \"/usr/local/env-activate.sh\"\n        set -u\n    fi\n    # limit meryl to use the assigned number of cores.\n    export OMP_NUM_THREADS=$task.cpus\n\n    merqury.sh \\\\\n        $meryl_db \\\\\n        $assembly \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        merqury: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = 1.3 // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}_only.bed\n    touch ${prefix}_only.wig\n    touch ${prefix}.completeness.stats\n    touch ${prefix}.dist_only.hist\n    touch ${prefix}.spectra-cn.fl.png\n    touch ${prefix}.spectra-cn.hist\n    touch ${prefix}.spectra-cn.ln.png\n    touch ${prefix}.spectra-cn.st.png\n    touch ${prefix}.spectra-asm.fl.png\n    touch ${prefix}.spectra-asm.hist\n    touch ${prefix}.spectra-asm.ln.png\n    touch ${prefix}.spectra-asm.st.png\n    touch ${prefix}.qv\n    touch ${prefix}.${prefix}.qv\n    touch ${prefix}.hist.ploidy\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        merqury: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A script to generate hap-mer dbs for trios\nTags: genomics, quality check, qc, kmer", "answer": "process MERQURY_HAPMERS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/merqury:1.3--hdfd78af_1':\n        'biocontainers/merqury:1.3--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(child_meryl, stageAs: 'child.meryl')\n    path(maternal_meryl, stageAs: 'mat.meryl')\n    path(paternal_meryl, stageAs: 'pat.meryl')\n\n    output:\n    tuple val(meta), path('*_mat.hapmer.meryl')         , emit: mat_hapmer_meryl\n    tuple val(meta), path('*_pat.hapmer.meryl')         , emit: pat_hapmer_meryl\n    tuple val(meta), path('*_inherited_hapmers.fl.png') , emit: inherited_hapmers_fl_png\n    tuple val(meta), path('*_inherited_hapmers.ln.png') , emit: inherited_hapmers_ln_png\n    tuple val(meta), path('*_inherited_hapmers.st.png') , emit: inherited_hapmers_st_png\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = 1.3\n    \"\"\"\n    # Nextflow changes the container --entrypoint to /bin/bash (container default entrypoint: /usr/local/env-execute)\n    # Check for container variable initialisation script and source it.\n    if [ -f \"/usr/local/env-activate.sh\" ]; then\n        set +u  # Otherwise, errors out because of various unbound variables\n        . \"/usr/local/env-activate.sh\"\n        set -u\n    fi\n\n    \\$MERQURY/trio/hapmers.sh \\\\\n        mat.meryl \\\\\n        pat.meryl\\\\\n        child.meryl \\\\\n        $args\n\n    mv mat.hapmer.meryl             ${prefix}_mat.hapmer.meryl\n    mv pat.hapmer.meryl             ${prefix}_pat.hapmer.meryl\n    mv inherited_hapmers.fl.png     ${prefix}_inherited_hapmers.fl.png\n    mv inherited_hapmers.ln.png     ${prefix}_inherited_hapmers.ln.png\n    mv inherited_hapmers.st.png     ${prefix}_inherited_hapmers.st.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        merqury: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = 1.3\n    \"\"\"\n    # Nextflow changes the container --entrypoint to /bin/bash (container default entrypoint: /usr/local/env-execute)\n    # Check for container variable initialisation script and source it.\n    if [ -f \"/usr/local/env-activate.sh\" ]; then\n        set +u  # Otherwise, errors out because of various unbound variables\n        . \"/usr/local/env-activate.sh\"\n        set -u\n    fi\n\n    echo \\\\\n    \"\\$MERQURY/trio/hapmers.sh \\\\\n        mat.meryl \\\\\n        pat.meryl\\\\\n        child.meryl \\\\\n        $args\"\n\n    mkdir ${prefix}_mat.hapmer.meryl\n    touch ${prefix}_mat.hapmer.meryl/0x000000.merylData\n    touch ${prefix}_mat.hapmer.meryl/0x000000.merylIndex\n    touch ${prefix}_mat.hapmer.meryl/merylIndex\n\n    mkdir ${prefix}_pat.hapmer.meryl\n    touch ${prefix}_pat.hapmer.meryl/0x000000.merylData\n    touch ${prefix}_pat.hapmer.meryl/0x000000.merylIndex\n    touch ${prefix}_pat.hapmer.meryl/merylIndex\n\n    touch ${prefix}_inherited_hapmers.fl.png\n    touch ${prefix}_inherited_hapmers.ln.png\n    touch ${prefix}_inherited_hapmers.st.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        merqury: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SV callers like lumpy look at split-reads and pair distances to find structural variants. This tool is a fast way to add depth information to those calls. This can be used as additional information for filtering variants; for example we will be skeptical of deletion calls that do not have lower than average coverage compared to regions with similar gc-content.\nTags: sort", "answer": "process DUPHOLD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/duphold:0.2.1--h516909a_1':\n        'biocontainers/duphold:0.2.1--h516909a_1' }\"\n\n    input:\n    tuple val(meta), path(alignment_file), path(alignement_index), path(sv_variants), path(snp_variants), path(snp_variants_index)\n    path(fasta)\n    path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")   , emit: vcf\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def snp_annotation = snp_variants ? \"--snp ${snp_variants}\" : \"\"\n\n    \"\"\"\n    duphold \\\\\n        ${args} \\\\\n        --threads ${task.cpus} \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --vcf ${sv_variants} \\\\\n        --bam ${alignment_file} \\\\\n        --fasta ${fasta} \\\\\n        ${snp_annotation}\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        duphold: \\$(duphold -h | head -n 1 | sed -e \"s/^version: //\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generates methylation bias plots from alignments\nTags: methylation, 5mC, methylseq, bisulphite, bisulfite, methylation bias, mbias, qc, bam, cram", "answer": "process METHYLDACKEL_MBIAS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/methyldackel:0.6.0--h22771d5_0' :\n        'biocontainers/methyldackel:0.6.0--h22771d5_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path fasta\n    path fai\n\n    output:\n    tuple val(meta), path(\"*.mbias.txt\"), emit: txt\n    path  \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    MethylDackel mbias \\\\\n        $args \\\\\n        $fasta \\\\\n        $bam \\\\\n        $prefix \\\\\n        --txt \\\\\n        > ${prefix}.mbias.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        methyldackel: \\$(MethylDackel --version 2>&1 | cut -f1 -d\" \")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extracts per-base methylation metrics from alignments\nTags: methylation, 5mC, methylseq, bisulphite, bisulfite, consensus, bedGraph, bam, cram", "answer": "process METHYLDACKEL_EXTRACT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/methyldackel:0.6.0--h22771d5_0' :\n        'biocontainers/methyldackel:0.6.0--h22771d5_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path fasta\n    path fai\n\n    output:\n    tuple val(meta), path(\"*.bedGraph\") , optional: true, emit: bedgraph\n    tuple val(meta), path(\"*.methylKit\"), optional: true, emit: methylkit\n    path  \"versions.yml\"                                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    MethylDackel extract \\\\\n        $args \\\\\n        $fasta \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        methyldackel: \\$(MethylDackel --version 2>&1 | cut -f1 -d\" \")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Human mitochondrial variants annotation using HmtVar. Contains .plk file with annotation, so can be run offline\nTags: hmtnote, mitochondria, annotation", "answer": "process HMTNOTE_ANNOTATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmtnote:0.7.2--pyhdfd78af_1':\n        'biocontainers/hmtnote:0.7.2--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*_annotated.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    hmtnote \\\\\n        annotate \\\\\n        $vcf \\\\\n        ${prefix}_annotated.vcf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmtnote: \\$(echo \\$(hmtnote --version 2>&1) | sed 's/^.*hmtnote, version //; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_annotated.vcf\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmtnote: \\$(echo \\$(hmtnote --version 2>&1) | sed 's/^.*hmtnote, version //; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool to create a binary reference panel for quick reading time.\nTags: split, reference, phasing, imputation", "answer": "process GLIMPSE2_SPLITREFERENCE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    beforeScript  \"\"\"\n    if cat /proc/cpuinfo | grep avx2 -q\n    then\n        echo \"Feature AVX2 present\"\n    else\n        echo \"Feature AVX2 not present on node\"\n        exit 1\n    fi\n    \"\"\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:2.0.1--h46b9e50_1':\n        'biocontainers/glimpse-bio:2.0.1--h46b9e50_1' }\"\n\n    input:\n        tuple val(meta) , path(reference), path(reference_index), val(input_region), val(output_region)\n        tuple val(meta2), path(map)\n\n\n    output:\n        tuple val(meta), path(\"*.bin\"), emit: bin_ref\n        path \"versions.yml\"           , emit: versions\n\n    when:\n        task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args   ?: ''\n    def prefix      = task.ext.prefix ?: \"${meta.id}_${output_region.replace(\":\",\"_\")}\"\n    def map_command = map             ? \"--map $map\" : \"\"\n\n    \"\"\"\n    GLIMPSE2_split_reference \\\\\n        $args \\\\\n        --reference $reference \\\\\n        $map_command \\\\\n        --input-region $input_region \\\\\n        --output-region $output_region \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_split_reference --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_${output_region.replace(\":\",\"_\")}\"\n    \"\"\"\n    touch ${prefix}.bin\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_split_reference --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool for imputation and phasing from vcf file or directly from bam files.\nTags: phasing, low-coverage, imputation, glimpse", "answer": "process GLIMPSE2_PHASE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    beforeScript  \"\"\"\n    if cat /proc/cpuinfo | grep avx2 -q\n    then\n        echo \"Feature AVX2 present on host\"\n    else\n        echo \"Feature AVX2 not present on host\"\n        exit 1\n    fi\n    \"\"\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:2.0.1--h46b9e50_1':\n        'biocontainers/glimpse-bio:2.0.1--h46b9e50_1' }\"\n\n    input:\n        tuple val(meta) , path(input, arity: '1..*'), path(input_index), path(samples_file), val(input_region), val(output_region), path(reference), path(reference_index), path(map)\n        tuple val(meta2), path(fasta_reference), path(fasta_reference_index)\n\n    output:\n        tuple val(meta), path(\"*.{vcf,vcf.gz,bcf,bgen}\"), emit: phased_variants\n        tuple val(meta), path(\"*.txt.gz\")        , emit: stats_coverage, optional: true\n        path \"versions.yml\"                      , emit: versions\n\n    when:\n        task.ext.when == null || task.ext.when\n\n    script:\n    def region = input_region    ? \"${output_region.replace(\":\",\"_\")}\" : \"${reference}\"\n    def args   = task.ext.args   ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}_${region}\"\n    def suffix = task.ext.suffix ?: \"bcf\"\n\n    def map_command           = map                 ? \"--map $map\"                    : \"\"\n    def samples_file_command  = samples_file        ? \"--samples-file $samples_file\"  : \"\"\n    def fasta_command         = fasta_reference     ? \"--fasta $fasta_reference\"      : \"\"\n    def input_region_cmd      = input_region        ? \"--input-region $input_region\"  : \"\"\n    def output_region_cmd     = output_region       ? \"--output-region $output_region\": \"\"\n\n    def input_type            = input.collect{\n        it.toString().endsWithAny(\"cram\", \"bam\") ? \"bam\" :\n        it.toString().endsWithAny(\"vcf\", \"bcf\", \"vcf.gz\") ? \"gl\" :\n        it.getExtension()\n        }.unique()\n\n    if (input_type.size() > 1 | !(input_type.contains(\"gl\") | input_type.contains(\"bam\"))) {\n        error \"Input files must be of the same type and either .bam/.cram or .vcf/.vcf.gz/.bcf format. Found: ${input_type}\"\n    } else {\n        input_type = input_type[0]\n    }\n    if (input_type == \"gl\" & input.size() > 1) {\n        error \"Only one input .vcf/.vcf.gz/.bcf file can be provided\"\n    }\n    def input_list = input.size() > 1\n\n    \"\"\"\n    if $input_list ;\n    then\n        ls -1 | grep '\\\\.cram\\$\\\\|\\\\.bam\\$' > all_bam.txt\n        input_command=\"--bam-list all_bam.txt\"\n    else\n        if [ \"$input_type\" == \"bam\" ];\n        then\n            input_command=\"--bam-file $input\"\n        elif [ \"$input_type\" == \"gl\" ];\n        then\n            input_command=\"--input-gl $input\"\n        else\n            echo \"Input file type not recognised\"\n            echo \"$input_type\"\n            exit 1\n        fi\n    fi\n\n    GLIMPSE2_phase \\\\\n        $args \\\\\n        \\$input_command \\\\\n        --reference $reference \\\\\n        $map_command \\\\\n        $fasta_command \\\\\n        $samples_file_command \\\\\n        $input_region_cmd \\\\\n        $output_region_cmd \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_phase --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def region = input_region    ? \"${output_region.replace(\":\",\"_\")}\" : \"${reference}\"\n    def args   = task.ext.args   ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}_${region}\"\n    def suffix = task.ext.suffix ?: \"bcf\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_phase --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Ligatation of multiple phased BCF/VCF files into a single whole chromosome file.\nGLIMPSE2 is run in chunks that are ligated into chromosome-wide files maintaining the phasing.\n\nTags: ligate, low-coverage, glimpse, imputation", "answer": "process GLIMPSE2_LIGATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:2.0.1--h46b9e50_1':\n        'biocontainers/glimpse-bio:2.0.1--h46b9e50_1' }\"\n\n    input:\n    tuple val(meta), path(input_list), path(input_index)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,bcf,vcf.gz,bcf.gz}\"), emit: merged_variants\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    printf \"%s\\\\n\" $input_list | tr -d '[],' | sort -V > all_files.txt\n\n    GLIMPSE2_ligate \\\\\n        $args \\\\\n        --input all_files.txt \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_ligate --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_ligate --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Defines chunks where to run imputation\nTags: chunk, low-coverage, imputation, glimpse", "answer": "process GLIMPSE2_CHUNK {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    beforeScript  \"\"\"\n        if cat /proc/cpuinfo | grep avx2 -q\n        then\n            echo \"Feature AVX2 present on host\"\n        else\n            echo \"Feature AVX2 not present on host\"\n            exit 1\n        fi\n    \"\"\"\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:2.0.1--h46b9e50_1':\n        'biocontainers/glimpse-bio:2.0.1--h46b9e50_1' }\"\n\n    input:\n    tuple val(meta) , path(input), path(input_index), val(region)\n    tuple val(meta2), path(map)\n    val(model)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: chunk_chr\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def args      = task.ext.args   ?: \"\"\n    def map_cmd   = map ? \"--map ${map}\":\"\"\n\n    \"\"\"\n    GLIMPSE2_chunk \\\\\n        $args \\\\\n        $map_cmd \\\\\n        --${model} \\\\\n        --input $input \\\\\n        --region $region \\\\\n        --threads $task.cpus \\\\\n        --output ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_chunk --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def args      = task.ext.args   ?: \"\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_chunk --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Program to compute the genotyping error rate at the sample or marker level.\nTags: concordance, low-coverage, glimpse, imputation", "answer": "process GLIMPSE2_CONCORDANCE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:2.0.1--h46b9e50_1':\n        'biocontainers/glimpse-bio:2.0.1--h46b9e50_1' }\"\n\n    input:\n    tuple val(meta), path(estimate), path(estimate_index), path(truth), path(truth_index), path(freq), path(freq_index), path(samples), val(region)\n    tuple val(meta2), path(groups), val(bins), val(ac_bins), val(allele_counts)\n    val(min_val_gl)\n    val(min_val_dp)\n\n    output:\n    tuple val(meta), path(\"*.error.cal.txt.gz\")  , emit: errors_cal\n    tuple val(meta), path(\"*.error.grp.txt.gz\")  , emit: errors_grp\n    tuple val(meta), path(\"*.error.spl.txt.gz\")  , emit: errors_spl\n    tuple val(meta), path(\"*.rsquare.grp.txt.gz\"), emit: rsquare_grp\n    tuple val(meta), path(\"*.rsquare.spl.txt.gz\"), emit: rsquare_spl\n    tuple val(meta), path(\"*_r2_sites.txt.gz\")   , emit: rsquare_per_site, optional: true\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args         = task.ext.args          ?: ''\n    def prefix       = task.ext.prefix        ?: \"${meta.id}\"\n    def samples_cmd  = samples                ? \"--samples ${samples}\"             : \"\"\n    def groups_cmd   = groups                 ? \"--groups ${groups}\"               : \"\"\n    def bins_cmd     = bins                   ? \"--bins ${bins}\"                   : \"\"\n    def ac_bins_cmd  = ac_bins                ? \"--ac-bins ${ac_bins}\"             : \"\"\n    def ale_ct_cmd   = allele_counts          ? \"--allele-counts ${allele_counts}\" : \"\"\n    def region_str   = region instanceof List ? region.join('\\\\n')                 : region\n\n    if (((groups ? 1:0) + (bins ? 1:0) + (ac_bins ? 1:0) + (allele_counts ? 1:0)) != 1) error \"One and only one argument should be selected between groups, bins, ac_bins, allele_counts\"\n\n    \"\"\"\n    printf '$region_str' > regions.txt\n    sed 's/\\$/ $freq $truth $estimate/' regions.txt > input.txt\n    GLIMPSE2_concordance \\\\\n        $args \\\\\n        $samples_cmd \\\\\n        $groups_cmd \\\\\n        $bins_cmd \\\\\n        $ac_bins_cmd \\\\\n        $ale_ct_cmd \\\\\n        --min-val-gl $min_val_gl \\\\\n        --min-val-dp $min_val_dp \\\\\n        --input input.txt \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse2: \"\\$(GLIMPSE2_concordance --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]' | head -1)\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix               = task.ext.prefix                    ?: \"${meta.id}\"\n    def args                 = task.ext.args                      ?: \"\"\n    def rsquare_per_site_cmd = args.contains(\"--out-r2-per-site\") ? \"touch ${prefix}_r2_sites.txt.gz\" : \"\"\n    \"\"\"\n    touch ${prefix}.error.cal.txt.gz\n    touch ${prefix}.error.grp.txt.gz\n    touch ${prefix}.error.spl.txt.gz\n    touch ${prefix}.rsquare.grp.txt.gz\n    touch ${prefix}.rsquare.spl.txt.gz\n    ${rsquare_per_site_cmd}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_concordance --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Aggregates fastq files with demultiplexed reads\nTags: artic, aggregate, demultiplexed reads", "answer": "process ARTIC_GUPPYPLEX {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/artic:1.2.3--pyhdfd78af_0' :\n        'biocontainers/artic:1.2.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fastq_dir)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: fastq\n    path  \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2.3' // WARN: Version information provided by tool on CLI is incorrect. Please update this string when bumping container versions.\n    \"\"\"\n    artic \\\\\n        guppyplex \\\\\n        $args \\\\\n        --directory $fastq_dir \\\\\n        --output ${prefix}.fastq\n\n    pigz -p $task.cpus *.fastq\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        artic: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run the alignment/variant-call/consensus logic of the artic pipeline\n\nTags: artic, aggregate, demultiplexed reads", "answer": "process ARTIC_MINION {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/artic:1.2.3--pyhdfd78af_0' :\n        'biocontainers/artic:1.2.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n    path  fast5_dir\n    path  sequencing_summary\n    path  (\"primer-schemes/${scheme}/V${scheme_version}/${scheme}.reference.fasta\")\n    path  (\"primer-schemes/${scheme}/V${scheme_version}/${scheme}.scheme.bed\")\n    path  medaka_model_file\n    val   medaka_model_string\n    val   scheme\n    val   scheme_version\n\n    output:\n    tuple val(meta), path(\"${prefix}.*\")                              , emit: results\n    tuple val(meta), path(\"${prefix}.sorted.bam\")                     , emit: bam\n    tuple val(meta), path(\"${prefix}.sorted.bam.bai\")                 , emit: bai\n    tuple val(meta), path(\"${prefix}.trimmed.rg.sorted.bam\")          , emit: bam_trimmed\n    tuple val(meta), path(\"${prefix}.trimmed.rg.sorted.bam.bai\")      , emit: bai_trimmed\n    tuple val(meta), path(\"${prefix}.primertrimmed.rg.sorted.bam\")    , emit: bam_primertrimmed\n    tuple val(meta), path(\"${prefix}.primertrimmed.rg.sorted.bam.bai\"), emit: bai_primertrimmed\n    tuple val(meta), path(\"${prefix}.consensus.fasta\")                , emit: fasta\n    tuple val(meta), path(\"${prefix}.pass.vcf.gz\")                    , emit: vcf\n    tuple val(meta), path(\"${prefix}.pass.vcf.gz.tbi\")                , emit: tbi\n    tuple val(meta), path(\"*.json\"), optional:true                    , emit: json\n    path  \"versions.yml\"                                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def version  = scheme_version.toString().toLowerCase().replaceAll('v','')\n    def fast5    = fast5_dir ? \"--fast5-directory $fast5_dir\"             : \"\"\n    def summary  = sequencing_summary ? \"--sequencing-summary $sequencing_summary\" : \"\"\n    def model    = \"\"\n    if (args.tokenize().contains('--medaka')) {\n        fast5   = \"\"\n        summary = \"\"\n        model   = medaka_model_file ? \"--medaka-model ./$medaka_model_file\" : \"--medaka-model $medaka_model_string\"\n    }\n    def hd5_plugin_path = task.ext.hd5_plugin_path ? \"export HDF5_PLUGIN_PATH=\" + task.ext.hd5_plugin_path : \"export HDF5_PLUGIN_PATH=/usr/local/lib/python3.6/site-packages/ont_fast5_api/vbz_plugin\"\n    def VERSION = '1.2.3' // WARN: Version information provided by tool on CLI is incorrect. Please update this string when bumping container versions.\n    \"\"\"\n    $hd5_plugin_path\n\n    artic \\\\\n        minion \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --read-file $fastq \\\\\n        --scheme-directory ./primer-schemes \\\\\n        --scheme-version $version \\\\\n        $model \\\\\n        $fast5 \\\\\n        $summary \\\\\n        $scheme \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        artic: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extracts methylation information for individual cytosines from alignments.\nTags: bismark, consensus, map, methylation, 5mC, methylseq, bisulphite, bisulfite, bam, bedGraph", "answer": "process BISMARK_METHYLATIONEXTRACTOR {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bismark:0.24.0--hdfd78af_0' :\n        'biocontainers/bismark:0.24.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.bedGraph.gz\")         , emit: bedgraph\n    tuple val(meta), path(\"*.txt.gz\")              , emit: methylation_calls\n    tuple val(meta), path(\"*.cov.gz\")              , emit: coverage\n    tuple val(meta), path(\"*_splitting_report.txt\"), emit: report\n    tuple val(meta), path(\"*.M-bias.txt\")          , emit: mbias\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    // Assign sensible numbers for multicore and buffer_size based on bismark docs\n    if(!args.contains('--multicore') && task.cpus >= 6){\n        args += \" --multicore ${(task.cpus / 3) as int}\"\n    }\n    // Only set buffer_size when there are more than 6.GB of memory available\n    if(!args.contains('--buffer_size') && task.memory?.giga > 6){\n        args += \" --buffer_size ${task.memory.giga - 2}G\"\n    }\n\n    def seqtype  = meta.single_end ? '-s' : '-p'\n    \"\"\"\n    bismark_methylation_extractor \\\\\n        $bam \\\\\n        --bedGraph \\\\\n        --counts \\\\\n        --gzip \\\\\n        --report \\\\\n        $seqtype \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bismark: \\$(echo \\$(bismark -v 2>&1) | sed 's/^.*Bismark Version: v//; s/Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs alignment of BS-Seq reads using bismark\nTags: bismark, 3-letter genome, map, methylation, 5mC, methylseq, bisulphite, bisulfite, bam", "answer": "process BISMARK_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bismark:0.24.0--hdfd78af_0' :\n        'biocontainers/bismark:0.24.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path index\n\n    output:\n    tuple val(meta), path(\"*bam\")       , emit: bam\n    tuple val(meta), path(\"*report.txt\"), emit: report\n    tuple val(meta), path(\"*fq.gz\")     , optional:true, emit: unmapped\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    if(task.ext.prefix){\n        args += \" --prefix ${task.ext.prefix}\"\n    }\n    def fastq = meta.single_end ? reads : \"-1 ${reads[0]} -2 ${reads[1]}\"\n\n    // Try to assign sensible bismark --multicore if not already set\n    if(!args.contains('--multicore') && task.cpus){\n\n        // Numbers based on recommendation by Felix for a typical mouse genome\n        def ccore = 1\n        def cpu_per_multicore = 3\n        def mem_per_multicore = (13.GB).toBytes()\n        if(args.contains('--non_directional')){\n            cpu_per_multicore = 5\n            mem_per_multicore = (18.GB).toBytes()\n        }\n\n        // How many multicore splits can we afford with the cpus we have?\n        ccore = ((task.cpus as int) / cpu_per_multicore) as int\n\n        // Check that we have enough memory\n        try {\n            def tmem = (task.memory as nextflow.util.MemoryUnit).toBytes()\n            def mcore = (tmem / mem_per_multicore) as int\n            ccore = Math.min(ccore, mcore)\n        } catch (all) {\n            log.warn \"Not able to define bismark align multicore based on available memory\"\n        }\n        if(ccore > 1){\n            args += \" --multicore ${ccore}\"\n        }\n    }\n\n    \"\"\"\n    bismark \\\\\n        $fastq \\\\\n        --genome $index \\\\\n        --bam \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bismark: \\$(echo \\$(bismark -v 2>&1) | sed 's/^.*Bismark Version: v//; s/Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a specified reference genome into two different bisulfite\nconverted versions and indexes them for alignments.\n\nTags: bismark, 3-letter genome, index, methylation, 5mC, methylseq, bisulphite, bisulfite, fasta", "answer": "process BISMARK_GENOMEPREPARATION {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bismark:0.24.0--hdfd78af_0' :\n        'biocontainers/bismark:0.24.0--hdfd78af_0' }\"\n\n    input:\n    path fasta, stageAs: \"BismarkIndex/*\"\n\n    output:\n    path \"BismarkIndex\" , emit: index\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    bismark_genome_preparation \\\\\n        $args \\\\\n        BismarkIndex\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bismark: \\$(echo \\$(bismark -v 2>&1) | sed 's/^.*Bismark Version: v//; s/Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collects bismark alignment reports\nTags: bismark, qc, methylation, 5mC, methylseq, bisulphite, bisulfite, report", "answer": "process BISMARK_REPORT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bismark:0.24.0--hdfd78af_0' :\n        'biocontainers/bismark:0.24.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(align_report), path(dedup_report), path(splitting_report), path(mbias)\n\n    output:\n    tuple val(meta), path(\"*report.{html,txt}\"), emit: report\n    path  \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    bismark2report $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bismark: \\$(echo \\$(bismark -v 2>&1) | sed 's/^.*Bismark Version: v//; s/Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Removes alignments to the same position in the genome\nfrom the Bismark mapping output.\n\nTags: bismark, 3-letter genome, map, methylation, 5mC, methylseq, bisulphite, bisulfite, bam", "answer": "process BISMARK_DEDUPLICATE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bismark:0.24.0--hdfd78af_0' :\n        'biocontainers/bismark:0.24.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.deduplicated.bam\")        , emit: bam\n    tuple val(meta), path(\"*.deduplication_report.txt\"), emit: report\n    path  \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def seqtype    = meta.single_end ? '-s' : '-p'\n    \"\"\"\n    deduplicate_bismark \\\\\n        $args \\\\\n        $seqtype \\\\\n        --bam $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bismark: \\$(echo \\$(bismark -v 2>&1) | sed 's/^.*Bismark Version: v//; s/Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Relates methylation calls back to genomic cytosine contexts.\nTags: bismark, consensus, map, methylation, 5mC, methylseq, bisulphite, bisulfite, bam, bedGraph", "answer": "process BISMARK_COVERAGE2CYTOSINE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bismark:0.24.0--hdfd78af_0' :\n        'biocontainers/bismark:0.24.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(coverage_file)\n    path index\n\n    output:\n    tuple val(meta), path(\"*.cov.gz\"), optional: true      , emit: coverage\n    tuple val(meta), path(\"*report.txt.gz\")                , emit: report\n    tuple val(meta), path(\"*cytosine_context_summary.txt\") , emit: summary\n    path  \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    coverage2cytosine \\\\\n        $coverage_file \\\\\n        --genome $index \\\\\n        --output ${prefix} \\\\\n        --gzip \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bismark: \\$(echo \\$(bismark -v 2>&1) | sed 's/^.*Bismark Version: v//; s/Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Uses Bismark report files of several samples in a run folder\nto generate a graphical summary HTML report.\n\nTags: bismark, qc, methylation, 5mC, methylseq, bisulphite, bisulfite, report, summary", "answer": "process BISMARK_SUMMARY {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bismark:0.24.0--hdfd78af_0' :\n        'biocontainers/bismark:0.24.0--hdfd78af_0' }\"\n\n    input:\n    val(bam)\n    path(align_report)\n    path(dedup_report)\n    path(splitting_report)\n    path(mbias)\n\n    output:\n    path  \"*report.{html,txt}\", emit: summary\n    path  \"versions.yml\"      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    bismark2summary ${bam.join(' ')}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bismark: \\$(echo \\$(bismark -v 2>&1) | sed 's/^.*Bismark Version: v//; s/Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Velocyto is a library for the analysis of RNA velocity. velocyto.py CLI use\n`Path(resolve_path=True)` and breaks the nextflow logic of symbolic links.\nIf in the work dir velocyto find a file named EXACTLY `cellsorted_[ORIGINAL_BAM_NAME]`\nit will skip the samtools sort step.\nCellsorted bam file should be cell sorted with:\n```bash\n    samtools sort -t CB -O BAM -o cellsorted_input.bam input.bam\n```\nSee module test for an example with the SAMTOOLS_SORT nf-core module.\nConfig example to cellsort input bam using SAMTOOLS_SORT:\n```groovy\n    withName: SAMTOOLS_SORT {\n        ext.prefix = { \"cellsorted_${bam.baseName}\" }\n        ext.args = '-t CB -O BAM'\n    }\n```\nOptional mask must be passed with `ext.args` and option `--mask`\nThis is why I need to stage in the work dir 2 bam files (cellsorted and original).\nSee also [velocyto turorial](https://velocyto.org/velocyto.py/tutorial/cli.html#notes-on-first-runtime-and-parallelization)\n\nTags: count, rnaseq, rna velocity, bam", "answer": "process VELOCYTO {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/velocyto.py:0.17.17--py38h24c8ff8_6':\n        'biocontainers/velocyto.py:0.17.17--py38h24c8ff8_6' }\"\n\n    stageInMode 'copy'\n\n    input:\n    tuple val(meta), path(barcodes), path(bam), path(sorted_bam)\n    path gtf\n\n    output:\n    tuple val(meta), path(\"*.loom\"), path(\"*.velocyto.log\"), emit: loom\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    velocyto run $args -e ${meta.id} -b ${barcodes} -o . ${bam} ${gtf} > ${prefix}.velocyto.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        velocyto: \\$(echo \\$(velocyto --version) | sed 's/^.*version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.loom\n    touch ${prefix}.velocyto.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        velocyto: \\$(echo \\$(velocyto --version) | sed 's/^.*version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Fast lightweight accurate xenograft sorting\nTags: index, QC, reference, fasta, xenograft, sort, k-mer", "answer": "process XENGSORT_INDEX {\n    tag \"$host_fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/xengsort:2.0.5--pyhdfd78af_0':\n        'biocontainers/xengsort:2.0.5--pyhdfd78af_0' }\"\n\n    input:\n    path(host_fasta, stageAs: \"host/*\")\n    path(graft_fasta, stageAs: \"graft/*\")\n    val index\n    val nobjects\n    val mask\n\n    output:\n    path \"${index}.hash\"          , emit: hash\n    path \"${index}.info\"          , emit: info\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    xengsort \\\\\n        index \\\\\n        $args \\\\\n        --index $index \\\\\n        --host $host_fasta \\\\\n        --graft $graft_fasta \\\\\n        --nobjects $nobjects \\\\\n        --mask '$mask' \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        xengsort: \\$(xengsort --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    touch ${index}.info\n    touch ${index}.hash\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        xengsort: \\$(xengsort --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Annotation of bacterial genomes (isolates, MAGs) and plasmids\nTags: annotation, fasta, bacteria", "answer": "process BAKTA_BAKTA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bakta:1.9.3--pyhdfd78af_0' :\n        'biocontainers/bakta:1.9.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path db\n    path proteins\n    path prodigal_tf\n\n    output:\n    tuple val(meta), path(\"${prefix}.embl\")             , emit: embl\n    tuple val(meta), path(\"${prefix}.faa\")              , emit: faa\n    tuple val(meta), path(\"${prefix}.ffn\")              , emit: ffn\n    tuple val(meta), path(\"${prefix}.fna\")              , emit: fna\n    tuple val(meta), path(\"${prefix}.gbff\")             , emit: gbff\n    tuple val(meta), path(\"${prefix}.gff3\")             , emit: gff\n    tuple val(meta), path(\"${prefix}.hypotheticals.tsv\"), emit: hypotheticals_tsv\n    tuple val(meta), path(\"${prefix}.hypotheticals.faa\"), emit: hypotheticals_faa\n    tuple val(meta), path(\"${prefix}.tsv\")              , emit: tsv\n    tuple val(meta), path(\"${prefix}.txt\")              , emit: txt\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def proteins_opt = proteins ? \"--proteins ${proteins[0]}\" : \"\"\n    def prodigal_tf = prodigal_tf ? \"--prodigal-tf ${prodigal_tf[0]}\" : \"\"\n    \"\"\"\n    bakta \\\\\n        $fasta \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --prefix $prefix \\\\\n        $proteins_opt \\\\\n        $prodigal_tf \\\\\n        --db $db\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bakta: \\$(echo \\$(bakta --version) 2>&1 | cut -f '2' -d ' ')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.embl\n    touch ${prefix}.faa\n    touch ${prefix}.ffn\n    touch ${prefix}.fna\n    touch ${prefix}.gbff\n    touch ${prefix}.gff3\n    touch ${prefix}.hypotheticals.tsv\n    touch ${prefix}.hypotheticals.faa\n    touch ${prefix}.tsv\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bakta: \\$(echo \\$(bakta --version) 2>&1 | cut -f '2' -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Downloads BAKTA database from Zenodo\nTags: bakta, annotation, fasta, bacteria, database, download", "answer": "process BAKTA_BAKTADBDOWNLOAD {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bakta:1.9.3--pyhdfd78af_0' :\n        'biocontainers/bakta:1.9.3--pyhdfd78af_0' }\"\n\n    output:\n    path \"db*\"              , emit: db\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    bakta_db \\\\\n        download \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bakta: \\$(echo \\$(bakta_db --version) 2>&1 | cut -f '2' -d ' ')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    echo \"bakta_db \\\\\n        download \\\\\n        $args\"\n\n    mkdir db\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bakta: \\$(echo \\$(bakta_db --version) 2>&1 | cut -f '2' -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Phylogenetic Assignment of Named Global Outbreak LINeages\nTags: covid, pangolin, lineage", "answer": "process PANGOLIN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pangolin:4.2--pyhdfd78af_1' :\n        'biocontainers/pangolin:4.2--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path('*.csv'), emit: report\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pangolin \\\\\n        $fasta\\\\\n        --outfile ${prefix}.pangolin.csv \\\\\n        --threads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pangolin: \\$(pangolin --version | sed \"s/pangolin //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to build the reference needed by the 10x Genomics Space Ranger tool. Uses the spaceranger mkref command.\nTags: reference, mkref, index, spaceranger", "answer": "process SPACERANGER_MKREF {\n    tag \"$fasta\"\n    label 'process_high'\n\n    container \"nf-core/spaceranger:3.0.0\"\n\n    input:\n    path fasta\n    path gtf\n    val reference_name\n\n    output:\n    path \"${reference_name}\", emit: reference\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"SPACERANGER_MKREF module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    // --localcores is passed to the martian runtime and specifies the number of allocated jobs\n    // --nthreads is passed to the STAR index generation.\n    // see also https://github.com/nf-core/scrnaseq/issues/329\n    \"\"\"\n    spaceranger \\\\\n        mkref \\\\\n        --genome=$reference_name \\\\\n        --fasta=$fasta \\\\\n        --genes=$gtf \\\\\n        --localcores=${task.cpus} \\\\\n        --localmem=${task.memory.toGiga()} \\\\\n        --nthreads=${task.cpus} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spaceranger: \\$(spaceranger -V | sed -e \"s/spaceranger spaceranger-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to build a filtered GTF needed by the 10x Genomics Space Ranger tool. Uses the spaceranger mkgtf command.\nTags: reference, mkref, index, spaceranger", "answer": "process SPACERANGER_MKGTF {\n    tag \"$gtf\"\n    label 'process_low'\n\n    container \"nf-core/spaceranger:3.0.0\"\n\n    input:\n    path gtf\n\n    output:\n    path \"*.gtf\"         , emit: gtf\n    path \"versions.yml\"  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"SPACERANGER_MKGTF module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}.filtered\"\n    \"\"\"\n    spaceranger \\\\\n        mkgtf \\\\\n        $gtf \\\\\n        ${prefix}.gtf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spaceranger: \\$(spaceranger -V | sed -e \"s/spaceranger spaceranger-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to use the 10x Space Ranger pipeline to process 10x spatial transcriptomics data\nTags: align, count, spatial, spaceranger, imaging", "answer": "process SPACERANGER_COUNT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nf-core/spaceranger:3.0.0\"\n\n    input:\n    tuple val(meta), path(reads), path(image), path(cytaimage), path(darkimage), path(colorizedimage), path(alignment), path(slidefile)\n    path(reference)\n    path(probeset)\n\n    output:\n    tuple val(meta), path(\"outs/**\"), emit: outs\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"SPACERANGER_COUNT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // Add flags for optional inputs on demand.\n    def probeset = probeset ? \"--probe-set=\\\"${probeset}\\\"\" : \"\"\n    def alignment = alignment ? \"--loupe-alignment=\\\"${alignment}\\\"\" : \"\"\n    def slidefile = slidefile ? \"--slidefile=\\\"${slidefile}\\\"\" : \"\"\n    def image = image ? \"--image=\\\"${image}\\\"\" : \"\"\n    def cytaimage = cytaimage ? \"--cytaimage=\\\"${cytaimage}\\\"\" : \"\"\n    def darkimage = darkimage ? \"--darkimage=\\\"${darkimage}\\\"\" : \"\"\n    def colorizedimage = colorizedimage ? \"--colorizedimage=\\\"${colorizedimage}\\\"\" : \"\"\n    \"\"\"\n    spaceranger count \\\\\n        --id=\"${prefix}\" \\\\\n        --sample=\"${meta.id}\" \\\\\n        --fastqs=. \\\\\n        --slide=\"${meta.slide}\" \\\\\n        --area=\"${meta.area}\" \\\\\n        --transcriptome=\"${reference}\" \\\\\n        --localcores=${task.cpus} \\\\\n        --localmem=${task.memory.toGiga()} \\\\\n        $image $cytaimage $darkimage $colorizedimage \\\\\n        $probeset \\\\\n        $alignment \\\\\n        $slidefile \\\\\n        $args\n    mv ${prefix}/outs outs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spaceranger: \\$(spaceranger -V | sed -e \"s/spaceranger spaceranger-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"SPACERANGER_COUNT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    \"\"\"\n    mkdir -p outs/\n    touch outs/fake_file.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spaceranger: \\$(spaceranger -V | sed -e \"s/spaceranger spaceranger-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Serotyping Neisseria gonorrhoeae assemblies\nTags: fasta, Neisseria gonorrhoeae, serotype", "answer": "process NGMASTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ngmaster:0.5.8--pyhdfd78af_1' :\n        'biocontainers/ngmaster:0.5.8--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ngmaster \\\\\n        $args \\\\\n        $fasta \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngmaster: \\$( echo \\$(ngmaster --version 2>&1) | sed 's/^.*ngmaster //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: ALE: assembly likelihood estimator.\nTags: reference-independent, assembly, evaluation", "answer": "process ALE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ale:20180904--py27ha92aebf_0':\n        'biocontainers/ale:20180904--py27ha92aebf_0' }\"\n\n    input:\n    tuple val(meta), path(asm), path(bam)\n\n    output:\n    tuple val(meta), path(\"*_ALEoutput.txt\"), emit: ale\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '20180904' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    ALE \\\\\n        $args \\\\\n        $bam \\\\\n        $asm \\\\\n        ${prefix}_ALEoutput.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ale: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '20180904' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}_ALEoutput.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ale: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: QUILT is an R and C++ program for rapid genotype imputation from low-coverage sequence using a large reference panel.\nTags: imputation, low-coverage, genotype, genomics, vcf", "answer": "process QUILT_QUILT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-quilt:1.0.5--r43h06b5641_0':\n        'biocontainers/r-quilt:1.0.5--r43h06b5641_0' }\"\n\n    input:\n    tuple val(meta), path(bams), path(bais), path(reference_haplotype_file), path(reference_legend_file), val(chr), val(regions_start), val(regions_end), val(ngen), val(buffer), path(genetic_map_file)\n    tuple val(meta2), path(posfile), path(phasefile)\n    tuple val(meta3), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"),              emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\"),          emit: tbi,   optional:true\n    tuple val(meta), path(\"RData\", type: \"dir\"),    emit: rdata, optional:true\n    tuple val(meta), path(\"plots\", type: \"dir\"),    emit: plots, optional:true\n    path \"versions.yml\",                            emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args                        =   task.ext.args ?: ''\n    def prefix                      =   task.ext.prefix ?: \"${meta.id}\"\n    def extensions                  =   bams.collect { it.extension }\n    def extension                   =   extensions.flatten().unique()\n    def list_command                =   extension == [\"bam\"]  ? \"--bamlist=\"                       :\n                                        extension == [\"cram\"] ? \"--reference=${fasta} --cramlist=\" : \"\"\n    def genetic_map_file_command    =   genetic_map_file      ? \"--genetic_map_file=${genetic_map_file}\"     : \"\"\n    def posfile_command             =   posfile               ? \"--posfile=${posfile}\"                       : \"\"\n    def phasefile_command           =   phasefile             ? \"--phasefile=${phasefile}\"                   : \"\"\n    if (!(args ==~ /.*--seed.*/)) {args += \" --seed=1\"}\n\n    \"\"\"\n    printf \"%s\\\\n\" $bams | tr -d '[],' > all_files.txt\n\n    QUILT.R \\\\\n        ${list_command}all_files.txt \\\\\n        $genetic_map_file_command \\\\\n        $posfile_command \\\\\n        $phasefile_command \\\\\n        --chr=$chr \\\\\n        --regionStart=$regions_start \\\\\n        --regionEnd=$regions_end \\\\\n        --nGen=$ngen \\\\\n        --buffer=$buffer \\\\\n        --nCores=$task.cpus \\\\\n        --outputdir=\".\" \\\\\n        --reference_haplotype_file=$reference_haplotype_file \\\\\n        --reference_legend_file=$reference_legend_file \\\\\n        $args\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        r-base: \\$(Rscript -e \"cat(strsplit(R.version[['version.string']], ' ')[[1]][3])\")\n        r-quilt: \\$(Rscript -e \"cat(as.character(utils::packageVersion(\\\\\"QUILT\\\\\")))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SvABA is an efficient and accurate method for detecting SVs from short-read sequencing data using genome-wide local assembly with low memory and computing requirements\nTags: sv, structural variants, detecting svs, short-read sequencing", "answer": "\nprocess SVABA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svaba:1.1.0--h7d7f7ad_2':\n        'biocontainers/svaba:1.1.0--h7d7f7ad_2' }\"\n\n    input:\n    tuple val(meta), path(tumorbam), path(tumorbai), path(normalbam), path(normalbai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta2), path(fasta_fai)\n    tuple val(meta3), path(bwa_index)\n    tuple val(meta4), path(dbsnp)\n    tuple val(meta4), path(dbsnp_tbi)\n    tuple val(meta5), path(regions)\n\n    output:\n    tuple val(meta), path(\"*.svaba.sv.vcf.gz\")                        , emit: sv, optional: true\n    tuple val(meta), path(\"*.svaba.indel.vcf.gz\")                     , emit: indel, optional: true\n    tuple val(meta), path(\"*.svaba.germline.indel.vcf.gz\")            , emit: germ_indel, optional: true\n    tuple val(meta), path(\"*.svaba.germline.sv.vcf.gz\")               , emit: germ_sv, optional: true\n    tuple val(meta), path(\"*.svaba.somatic.indel.vcf.gz\")             , emit: som_indel,  optional: true\n    tuple val(meta), path(\"*.svaba.somatic.sv.vcf.gz\")                , emit: som_sv, optional: true\n    tuple val(meta), path(\"*.svaba.unfiltered.sv.vcf.gz\")             , emit: unfiltered_sv, optional: true\n    tuple val(meta), path(\"*.svaba.unfiltered.indel.vcf.gz\")          , emit: unfiltered_indel, optional: true\n    tuple val(meta), path(\"*.svaba.unfiltered.germline.indel.vcf.gz\") , emit: unfiltered_germ_indel, optional: true\n    tuple val(meta), path(\"*.svaba.unfiltered.germline.sv.vcf.gz\")    , emit: unfiltered_germ_sv, optional: true\n    tuple val(meta), path(\"*.svaba.unfiltered.somatic.indel.vcf.gz\")  , emit: unfiltered_som_indel,  optional: true\n    tuple val(meta), path(\"*.svaba.unfiltered.somatic.sv.vcf.gz\")     , emit: unfiltered_som_sv, optional: true\n    tuple val(meta), path(\"*.bps.txt.gz\")                             , emit: raw_calls\n    tuple val(meta), path(\"*.discordants.txt.gz\")                     , emit: discordants, optional: true\n    tuple val(meta), path(\"*.log\")                                    , emit: log\n    path \"versions.yml\"                                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def bamlist = normalbam ? \"-t ${tumorbam} -n ${normalbam}\" : \"-t ${tumorbam}\"\n    def dbsnp   = dbsnp ? \"--dbsnp-vcf ${dbsnp}\" : \"\"\n    def regions = regions ? \"--region ${regions}\" : \"\"\n    def bwa     = bwa_index ? \"cp -s ${bwa_index}/* .\" : \"\"\n\n    \"\"\"\n    ${bwa}\n\n    svaba \\\\\n        run \\\\\n        $bamlist \\\\\n        --threads $task.cpus \\\\\n        $dbsnp \\\\\n        --id-string $meta.id \\\\\n        --reference-genome $fasta \\\\\n        --g-zip \\\\\n        $regions \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svaba: \\$(echo \\$(svaba --version 2>&1) | sed 's/[^0-9.]*\\\\([0-9.]*\\\\).*/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bps.txt.gz\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svaba: \\$(echo \\$(svaba --version 2>&1) | sed 's/[^0-9.]*\\\\([0-9.]*\\\\).*/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Serotype prediction of Haemophilus parasuis assemblies\nTags: bacteria, fasta, haemophilus", "answer": "process HPSUISSERO {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hpsuissero%3A1.0.1--hdfd78af_0':\n        'biocontainers/hpsuissero:1.0.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getName().endsWith(\".gz\") ? true : false\n    def fasta_name = fasta.getName().replace(\".gz\", \"\")\n    def VERSION = '1.0.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    HpsuisSero.sh \\\\\n        -i $fasta_name \\\\\n        -o ./ \\\\\n        -s $prefix \\\\\n        -x fasta \\\\\n        -t $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hpsuissero: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: PRINSEQ++ is a C++ implementation of the prinseq-lite.pl program. It can be used to filter, reformat or trim genomic and metagenomic sequence data\nTags: fastq, fasta, filter, trim", "answer": "process PRINSEQPLUSPLUS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/prinseq-plus-plus:1.2.3--hc90279e_1':\n        'biocontainers/prinseq-plus-plus:1.2.3--hc90279e_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*_good_out*.fastq.gz\")                  , emit: good_reads\n    tuple val(meta), path(\"*_single_out*.fastq.gz\"), optional: true, emit: single_reads\n    tuple val(meta), path(\"*_bad_out*.fastq.gz\")   , optional: true, emit: bad_reads\n    tuple val(meta), path(\"*.log\")                                 , emit: log\n    path \"versions.yml\"                                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (meta.single_end) {\n        \"\"\"\n        prinseq++ \\\\\n            -threads $task.cpus \\\\\n            -fastq ${reads} \\\\\n            -out_name ${prefix} \\\\\n            -out_gz \\\\\n            -VERBOSE 1 \\\\\n            $args \\\\\n            | tee ${prefix}.log\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            prinseqplusplus: \\$(echo \\$(prinseq++ --version | cut -f 2 -d ' ' ))\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        prinseq++ \\\\\n            -threads $task.cpus \\\\\n            -fastq ${reads[0]} \\\\\n            -fastq2 ${reads[1]} \\\\\n            -out_name ${prefix} \\\\\n            -out_gz \\\\\n            -VERBOSE 1 \\\\\n            $args \\\\\n            | tee ${prefix}.log\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            prinseqplusplus: \\$(echo \\$(prinseq++ --version | cut -f 2 -d ' ' ))\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: DAS Tool binning step.\nTags: binning, das tool, table, de novo, bins, contigs, assembly, das_tool", "answer": "process DASTOOL_DASTOOL {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/das_tool:1.1.6--r42hdfd78af_0' :\n        'biocontainers/das_tool:1.1.6--r42hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(contigs), path(bins)\n    path(proteins)\n    path(db_directory)\n\n    output:\n    tuple val(meta), path(\"*.log\")                                      , emit: log\n    tuple val(meta), path(\"*_summary.tsv\")              , optional: true, emit: summary\n    tuple val(meta), path(\"*_DASTool_contig2bin.tsv\")   , optional: true, emit: contig2bin\n    tuple val(meta), path(\"*.eval\")                     , optional: true, emit: eval\n    tuple val(meta), path(\"*_DASTool_bins/*.fa\")        , optional: true, emit: bins\n    tuple val(meta), path(\"*.pdf\")                      , optional: true, emit: pdfs\n    tuple val(meta), path(\"*.candidates.faa\")           , optional: true, emit: fasta_proteins\n    tuple val(meta), path(\"*.faa\")                      , optional: true, emit: candidates_faa\n    tuple val(meta), path(\"*.archaea.scg\")              , optional: true, emit: fasta_archaea_scg\n    tuple val(meta), path(\"*.bacteria.scg\")             , optional: true, emit: fasta_bacteria_scg\n    tuple val(meta), path(\"*.b6\")                       , optional: true, emit: b6\n    tuple val(meta), path(\"*.seqlength\")                , optional: true, emit: seqlength\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bin_list = bins instanceof List ? bins.join(\",\") : \"$bins\"\n    def db_dir = db_directory ? \"--db_directory $db_directory\" : \"\"\n    def clean_contigs = contigs.toString() - \".gz\"\n    def decompress_contigs = contigs.toString() == clean_contigs ? \"\" : \"gunzip -q -f $contigs\"\n    def clean_proteins = proteins ? proteins.toString() - \".gz\" : \"\"\n    def decompress_proteins = proteins ? \"gunzip -f $proteins\" : \"\"\n    def proteins_pred = proteins ? \"-p $clean_proteins\" : \"\"\n\n    \"\"\"\n    $decompress_proteins\n    $decompress_contigs\n\n    DAS_Tool \\\\\n        $args \\\\\n        $proteins_pred \\\\\n        $db_dir \\\\\n        -t $task.cpus \\\\\n        -i $bin_list \\\\\n        -c $clean_contigs \\\\\n        -o $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dastool: \\$( DAS_Tool --version 2>&1 | grep \"DAS Tool\" | sed 's/DAS Tool //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Helper script to convert a set of bins in fasta format to tabular scaffolds2bin format\nTags: binning, das tool, table, de novo, bins, contigs, assembly, das_tool", "answer": "process DASTOOL_SCAFFOLDS2BIN {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // Do not bump! This is the 'old name' of contigs2bin which is only available up until 1.1.3!\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/das_tool:1.1.3--r41hdfd78af_0' :\n        'biocontainers/das_tool:1.1.3--r41hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val(extension)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: scaffolds2bin\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def file_extension = extension ? extension : \"fasta\"\n    def clean_fasta = fasta.toString() - \".gz\"\n    def decompress_fasta = fasta.toString() == clean_fasta ? \"\" : \"gunzip -q -f $fasta\"\n    \"\"\"\n    $decompress_fasta\n\n    Fasta_to_Scaffolds2Bin.sh \\\\\n        $args \\\\\n        -i . \\\\\n        -e $file_extension \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dastool: \\$( DAS_Tool --version 2>&1 | grep \"DAS Tool\" | sed 's/DAS Tool version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Helper script to convert a set of bins in fasta format to tabular scaffolds2bin format\nTags: binning, das tool, table, de novo, bins, contigs, assembly, das_tool", "answer": "process DASTOOL_FASTATOCONTIG2BIN {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/das_tool:1.1.6--r42hdfd78af_0' :\n        'biocontainers/das_tool:1.1.6--r42hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val(extension)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: fastatocontig2bin\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def file_extension = extension ? extension : \"fasta\"\n    def clean_fasta = fasta.toString() - \".gz\"\n    def decompress_fasta = fasta.toString() == clean_fasta ? \"\" : \"gunzip -q -f $fasta\"\n    \"\"\"\n    $decompress_fasta\n\n    Fasta_to_Contig2Bin.sh \\\\\n        $args \\\\\n        -i . \\\\\n        -e $file_extension \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dastool: \\$( DAS_Tool --version 2>&1 | grep \"DAS Tool\" | sed 's/DAS Tool //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Align reads to a reference genome using YARA\nTags: align, genome, reference", "answer": "process YARA_MAPPER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-f13549097a0d1ca36f9d4f017636fb3609f6c083:de7982183b85634270540ac760c2644f16e0b6d1-0' :\n        'biocontainers/mulled-v2-f13549097a0d1ca36f9d4f017636fb3609f6c083:de7982183b85634270540ac760c2644f16e0b6d1-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(index)\n\n    output:\n    tuple val(meta), path(\"*.mapped.bam\"), emit: bam\n    tuple val(meta), path(\"*.mapped.bam.bai\"), emit: bai\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def index_prefix = index[0].baseName.substring(0,index[0].baseName.lastIndexOf('.'))\n    if (meta.single_end) {\n        \"\"\"\n        yara_mapper \\\\\n            $args \\\\\n            -t $task.cpus \\\\\n            -f bam \\\\\n            ${index_prefix} \\\\\n            $reads | samtools view -@ $task.cpus -hb -F4 | samtools sort -@ $task.cpus > ${prefix}.mapped.bam\n\n        samtools index -@ $task.cpus ${prefix}.mapped.bam\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            yara: \\$(echo \\$(yara_mapper --version 2>&1) | sed 's/^.*yara_mapper version: //; s/ .*\\$//')\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        yara_mapper \\\\\n            $args \\\\\n            -t $task.cpus \\\\\n            -f bam \\\\\n            ${index_prefix} \\\\\n            ${reads[0]} \\\\\n            ${reads[1]} > output.bam\n\n        samtools view -@ $task.cpus -hF 4 -f 0x40 -b output.bam | samtools sort -@ $task.cpus > ${prefix}_1.mapped.bam\n        samtools view -@ $task.cpus -hF 4 -f 0x80 -b output.bam | samtools sort -@ $task.cpus > ${prefix}_2.mapped.bam\n\n        samtools index -@ $task.cpus ${prefix}_1.mapped.bam\n        samtools index -@ $task.cpus ${prefix}_2.mapped.bam\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            yara: \\$(echo \\$(yara_mapper --version 2>&1) | sed 's/^.*yara_mapper version: //; s/ .*\\$//')\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Builds a YARA index for a reference genome\nTags: build, index, fasta, genome, reference", "answer": "process YARA_INDEX {\n    tag \"$fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/yara:1.0.2--2' :\n        'biocontainers/yara:1.0.2--2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${fasta}*\")   , emit: index\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n\n    \"\"\"\n    yara_indexer \\\\\n        $fasta \\\\\n        -o ${fasta}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        yara: \\$(echo \\$(yara_indexer --version 2>&1) | sed 's/^.*yara_indexer version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Trim FastQ files using Trim Galore!\nTags: trimming, adapters, sequencing adapters, fastq", "answer": "process TRIMGALORE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/trim-galore:0.6.7--hdfd78af_0' :\n        'biocontainers/trim-galore:0.6.7--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*{3prime,5prime,trimmed,val}*.fq.gz\"), emit: reads\n    tuple val(meta), path(\"*report.txt\")                        , emit: log     , optional: true\n    tuple val(meta), path(\"*unpaired*.fq.gz\")                   , emit: unpaired, optional: true\n    tuple val(meta), path(\"*.html\")                             , emit: html    , optional: true\n    tuple val(meta), path(\"*.zip\")                              , emit: zip     , optional: true\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    // Calculate number of --cores for TrimGalore based on value of task.cpus\n    // See: https://github.com/FelixKrueger/TrimGalore/blob/master/Changelog.md#version-060-release-on-1-mar-2019\n    // See: https://github.com/nf-core/atacseq/pull/65\n    def cores = 1\n    if (task.cpus) {\n        cores = (task.cpus as int) - 4\n        if (meta.single_end) cores = (task.cpus as int) - 3\n        if (cores < 1) cores = 1\n        if (cores > 8) cores = 8\n    }\n\n    // Added soft-links to original fastqs for consistent naming in MultiQC\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.single_end) {\n        def args_list = args.split(\"\\\\s(?=--)\").toList()\n        args_list.removeAll { it.toLowerCase().contains('_r2 ') }\n        \"\"\"\n        [ ! -f  ${prefix}.fastq.gz ] && ln -s $reads ${prefix}.fastq.gz\n        trim_galore \\\\\n            ${args_list.join(' ')} \\\\\n            --cores $cores \\\\\n            --gzip \\\\\n            ${prefix}.fastq.gz\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            trimgalore: \\$(echo \\$(trim_galore --version 2>&1) | sed 's/^.*version //; s/Last.*\\$//')\n            cutadapt: \\$(cutadapt --version)\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        [ ! -f  ${prefix}_1.fastq.gz ] && ln -s ${reads[0]} ${prefix}_1.fastq.gz\n        [ ! -f  ${prefix}_2.fastq.gz ] && ln -s ${reads[1]} ${prefix}_2.fastq.gz\n        trim_galore \\\\\n            $args \\\\\n            --cores $cores \\\\\n            --paired \\\\\n            --gzip \\\\\n            ${prefix}_1.fastq.gz \\\\\n            ${prefix}_2.fastq.gz\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            trimgalore: \\$(echo \\$(trim_galore --version 2>&1) | sed 's/^.*version //; s/Last.*\\$//')\n            cutadapt: \\$(cutadapt --version)\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.single_end) {\n        output_command = \"echo '' | gzip > ${prefix}_trimmed.fq.gz ;\"\n        output_command += \"touch ${prefix}.fastq.gz_trimming_report.txt\"\n    } else {\n        output_command = \"echo '' | gzip > ${prefix}_1_trimmed.fq.gz ;\"\n        output_command += \"touch ${prefix}_1.fastq.gz_trimming_report.txt ;\"\n        output_command += \"echo '' | gzip > ${prefix}_2_trimmed.fq.gz ;\"\n        output_command += \"touch ${prefix}_2.fastq.gz_trimming_report.txt\"\n    }\n    \"\"\"\n    ${output_command}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trimgalore: \\$(echo \\$(trim_galore --version 2>&1) | sed 's/^.*version //; s/Last.*\\$//')\n        cutadapt: \\$(cutadapt --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A versatile pairwise aligner for genomic and spliced nucleotide sequences\nTags: align, fasta, fastq, genome, paf, reference", "answer": "process MINIMAP2_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    // Note: the versions here need to match the versions used in the mulled container below and minimap2/index\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-66534bcbb7031a148b13e2ad42583020b9cd25c4:3161f532a5ea6f1dec9be5667c9efc2afdac6104-0' :\n        'biocontainers/mulled-v2-66534bcbb7031a148b13e2ad42583020b9cd25c4:3161f532a5ea6f1dec9be5667c9efc2afdac6104-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(reference)\n    val bam_format\n    val bam_index_extension\n    val cigar_paf_format\n    val cigar_bam\n\n    output:\n    tuple val(meta), path(\"*.paf\")                       , optional: true, emit: paf\n    tuple val(meta), path(\"*.bam\")                       , optional: true, emit: bam\n    tuple val(meta), path(\"*.bam.${bam_index_extension}\"), optional: true, emit: index\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def args4 = task.ext.args4 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bam_index = bam_index_extension ? \"${prefix}.bam##idx##${prefix}.bam.${bam_index_extension} --write-index\" : \"${prefix}.bam\"\n    def bam_output = bam_format ? \"-a | samtools sort -@ ${task.cpus-1} -o ${bam_index} ${args2}\" : \"-o ${prefix}.paf\"\n    def cigar_paf = cigar_paf_format && !bam_format ? \"-c\" : ''\n    def set_cigar_bam = cigar_bam && bam_format ? \"-L\" : ''\n    def bam_input = \"${reads.extension}\".matches('sam|bam|cram')\n    def samtools_reset_fastq = bam_input ? \"samtools reset --threads ${task.cpus-1} $args3 $reads | samtools fastq --threads ${task.cpus-1} $args4 |\" : ''\n    def query = bam_input ? \"-\" : reads\n    def target = reference ?: (bam_input ? error(\"BAM input requires reference\") : reads)\n\n    \"\"\"\n    $samtools_reset_fastq \\\\\n    minimap2 \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        $target \\\\\n        $query \\\\\n        $cigar_paf \\\\\n        $set_cigar_bam \\\\\n        $bam_output\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        minimap2: \\$(minimap2 --version 2>&1)\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_file = bam_format ? \"${prefix}.bam\" : \"${prefix}.paf\"\n    def bam_index = bam_index_extension ? \"touch ${prefix}.bam.${bam_index_extension}\" : \"\"\n    def bam_input = \"${reads.extension}\".matches('sam|bam|cram')\n    def target = reference ?: (bam_input ? error(\"BAM input requires reference\") : reads)\n\n    \"\"\"\n    touch $output_file\n    ${bam_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        minimap2: \\$(minimap2 --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Provides fasta index required by minimap2 alignment.\nTags: index, fasta, reference", "answer": "process MINIMAP2_INDEX {\n    label 'process_low'\n\n    // Note: the versions here need to match the versions used in minimap2/align\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/minimap2:2.28--he4a0461_0' :\n        'biocontainers/minimap2:2.28--he4a0461_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.mmi\"), emit: index\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    minimap2 \\\\\n        -t $task.cpus \\\\\n        -d ${fasta.baseName}.mmi \\\\\n        $args \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        minimap2: \\$(minimap2 --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${fasta.baseName}.mmi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        minimap2: \\$(minimap2 --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: PureCLIP is a tool to detect protein-RNA interaction footprints from single-nucleotide CLIP-seq data, such as iCLIP and eCLIP.\nTags: iCLIP, eCLIP, CLIP", "answer": "process PURECLIP {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pureclip:1.3.1--0':\n        'biocontainers/pureclip:1.3.1--0' }\"\n\n    input:\n    tuple val(meta), path(ipbam), path(controlbam)\n    tuple val(meta), path(ipbai), path(controlbai)\n    tuple val(meta2), path(genome_fasta)\n    val input_control\n\n    output:\n    tuple val(meta), path(\"${crosslinks_output_name}\"), emit: crosslinks\n    tuple val(meta), path(\"${peaks_output_name}\")     , emit: peaks\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    crosslinks_output_name = \"${prefix}_pureclip_crosslinks.bed\"\n    peaks_output_name      = \"${prefix}_pureclip_peaks.bed\"\n\n    if(input_control){\n        control_bam   = \"-ibam $controlbam\"\n        control_bai   = \"-ibai $controlbai\"\n    } else {\n        control_bam   = \"\"\n        control_bai   = \"\"\n    }\n\n    \"\"\"\n    pureclip \\\n        -i $ipbam \\\n        -bai $ipbai \\\n        -g $genome_fasta \\\n        -nt ${task.cpus} \\\n        -o $crosslinks_output_name \\\n        -or $peaks_output_name \\\n        ${control_bam} \\\n        ${control_bai} \\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pureclip: \\$(echo \\$(pureclip --version 2>&1) | sed 's/^.*pureclip //; s/Using.*\\$//; s/version: //; s/ Seq.*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}_pureclip_crosslinks.bed\n    touch ${prefix}_pureclip_peaks.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pureclip: \\$(echo \\$(pureclip --version 2>&1) | sed 's/^.*pureclip //; s/Using.*\\$//; s/version: //; s/ Seq.*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produces annotation using kofamscan against a Profile database and a KO list\nTags: fasta, kegg, kofamscan", "answer": "process KOFAMSCAN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kofamscan:1.3.0--hdfd78af_2':\n        'biocontainers/kofamscan:1.3.0--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path profiles\n    path ko_list\n\n    output:\n    tuple val(meta), path('*.txt'), optional: true, emit: txt\n    tuple val(meta), path('*.tsv'), optional: true, emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--format detail-tsv\") ? \"tsv\" :\n                    \"txt\"\n    \"\"\"\n    exec_annotation \\\\\n        -p $profiles \\\\\n        -k $ko_list \\\\\n        $args \\\\\n        --cpu $task.cpus \\\\\n        -o ${prefix}.${extension} \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kofamscan: \\$(echo \\$(exec_annotation --version 2>&1) | sed 's/^.*exec_annotation //;')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Using the fgbio tools, converts FASTQ files sequenced into unaligned BAM or CRAM files possibly moving the UMI barcode into the RX field of the reads\n\nTags: unaligned, bam, cram", "answer": "process FGBIO_FASTQTOBAM {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fgbio:2.2.1--hdfd78af_0' :\n        'biocontainers/fgbio:2.2.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.bam\") , emit: bam , optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram, optional: true\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"bam\"\n    def sample_name = args.contains(\"--sample\") ? \"\" : \"--sample ${prefix}\"\n    def library_name = args.contains(\"--library\") ? \"\" : \"--library ${prefix}\"\n\n    def mem_gb = 8\n    if (!task.memory) {\n        log.info '[fgbio FastqToBam] Available memory not known - defaulting to 8GB. Specify process memory requirements to change this.'\n    } else if (mem_gb > task.memory.giga) {\n        if (task.memory.giga < 2) {\n            mem_gb = 1\n        } else {\n            mem_gb = task.memory.giga - 1\n        }\n    }\n\n    \"\"\"\n    fgbio \\\\\n        -Xmx${mem_gb}g \\\\\n        --tmp-dir=. \\\\\n        --async-io=true \\\\\n        FastqToBam \\\\\n        ${args} \\\\\n        --input ${reads} \\\\\n        --output ${prefix}.${suffix} \\\\\n        ${sample_name} \\\\\n        ${library_name}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"bam\"\n\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Uses FGBIO CallDuplexConsensusReads to call duplex consensus sequences from reads generated from the same double-stranded source molecule.\nTags: umi, duplex, fgbio", "answer": "process FGBIO_CALLDUPLEXCONSENSUSREADS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fgbio:2.2.1--hdfd78af_0' :\n        'biocontainers/fgbio:2.2.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(grouped_bam)\n    val min_reads\n    val min_baseq\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\"), emit: bam\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}_consensus_unmapped\"\n\n    def mem_gb = 8\n    if (!task.memory) {\n        log.info '[fgbio CallDuplexConsensusReads] Available memory not known - defaulting to 8GB. Specify process memory requirements to change this.'\n    } else if (mem_gb > task.memory.giga) {\n        if (task.memory.giga < 2) {\n            mem_gb = 1\n        } else {\n            mem_gb = task.memory.giga - 1\n        }\n    }\n    if (\"$grouped_bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    fgbio \\\\\n        -Xmx${mem_gb}g \\\\\n        --tmp-dir=. \\\\\n        --async-io=true \\\\\n        --compression=1 \\\\\n        CallDuplexConsensusReads \\\\\n        --input $grouped_bam \\\\\n        --output ${prefix}.bam \\\\\n        --min-reads ${min_reads} \\\\\n        --min-input-base-quality ${min_baseq} \\\\\n        --threads ${task.cpus} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}_consensus_unmapped\"\n    if (\"$grouped_bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Sorts a SAM or BAM file. Several sort orders are available, including coordinate, queryname, random, and randomquery.\nTags: sort, bam, sam", "answer": "process FGBIO_SORTBAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fgbio:2.2.1--hdfd78af_0' :\n        'biocontainers/fgbio:2.2.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_sorted\"\n    def mem_gb = 8\n    if (!task.memory) {\n        log.info '[fgbio SortBam] Available memory not known - defaulting to 8GB. Specify process memory requirements to change this.'\n    } else if (mem_gb > task.memory.giga) {\n        if (task.memory.giga < 2) {\n            mem_gb = 1\n        } else {\n            mem_gb = task.memory.giga - 1\n        }\n    }\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    fgbio -Xmx${mem_gb}g \\\\\n        --async-io=true \\\\\n        --tmp-dir=. \\\\\n        SortBam \\\\\n        -i $bam \\\\\n        $args \\\\\n        -o ${prefix}.bam\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}_sorted\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calls consensus sequences from reads with the same unique molecular tag.\nTags: UMIs, consensus sequence, bam", "answer": "process FGBIO_CALLMOLECULARCONSENSUSREADS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fgbio:2.2.1--hdfd78af_0' :\n        'biocontainers/fgbio:2.2.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(grouped_bam)\n    val min_reads\n    val min_baseq\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_consensus_unmapped\"\n    def mem_gb = 8\n    if (!task.memory) {\n        log.info '[fgbio CallMolecularConsensusReads] Available memory not known - defaulting to 8GB. Specify process memory requirements to change this.'\n    } else {\n        mem_gb = task.memory.giga\n    }\n    if (\"$grouped_bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    fgbio \\\\\n        -Xmx${mem_gb}g \\\\\n        --tmp-dir=. \\\\\n        --async-io=true \\\\\n        --compression=1 \\\\\n        CallMolecularConsensusReads \\\\\n        --input $grouped_bam \\\\\n        --output ${prefix}.bam \\\\\n        --min-reads ${min_reads} \\\\\n        --min-input-base-quality ${min_baseq} \\\\\n        --threads ${task.cpus} \\\\\n        $args;\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}_consensus_unmapped\"\n    if (\"$grouped_bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Collects a suite of metrics to QC duplex sequencing data.\nTags: UMIs, QC, bam, duplex", "answer": "process FGBIO_COLLECTDUPLEXSEQMETRICS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-51891ad0b60843e4aade9cde2eb5d40c5ae92b80:72c944cdea5caff7f03b96034968ce2a4f1737bc-0':\n        'biocontainers/mulled-v2-51891ad0b60843e4aade9cde2eb5d40c5ae92b80:72c944cdea5caff7f03b96034968ce2a4f1737bc-0' }\"\n\n    input:\n    tuple val(meta), path(grouped_bam)\n    path interval_list\n\n    output:\n    tuple val(meta), path(\"**.family_sizes.txt\")        , emit: family_sizes\n    tuple val(meta), path(\"**.duplex_family_sizes.txt\") , emit: duplex_family_sizes\n    tuple val(meta), path(\"**.duplex_yield_metrics.txt\"), emit: duplex_yield_metrics\n    tuple val(meta), path(\"**.umi_counts.txt\")          , emit: umi_counts\n    tuple val(meta), path(\"**.duplex_qc.pdf\")           , emit: duplex_qc\n    tuple val(meta), path(\"**.duplex_umi_counts.txt\")   , emit: duplex_umi_counts, optional: true\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def intervals = interval_list ? \"--intervals ${bed}\" : \"\"\n    def mem_gb = 8\n\n    if (!task.memory) {\n        log.info '[fgbio CollectDuplexSeqMetrics] Available memory not known - defaulting to 8GB. Specify process memory requirements to change this.'\n    } else if (mem_gb > task.memory.giga) {\n        if (task.memory.giga < 2) {\n            mem_gb = 1\n        } else {\n            mem_gb = task.memory.giga - 1\n        }\n    }\n\n    \"\"\"\n    fgbio \\\\\n        -Xmx${mem_gb}g \\\\\n        --tmp-dir=. \\\\\n        --async-io=true \\\\\n        --compression=1 \\\\\n        CollectDuplexSeqMetrics \\\\\n        --input $grouped_bam \\\\\n        --output ${prefix} \\\\\n        $intervals \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n        ggplot2: \\$(Rscript -e \"library(ggplot2); cat(as.character(packageVersion('ggplot2')))\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def touch_duplex_umi = args.contains(\"--duplex-umi-counts\") || args.contains(\"-u\") ? \"touch ${prefix}.duplex_umi_counts.txt\" : \"\"\n\n    \"\"\"\n    touch ${prefix}.family_sizes.txt\n    touch ${prefix}.duplex_family_sizes.txt\n    touch ${prefix}.duplex_yield_metrics.txt\n    touch ${prefix}.umi_counts.txt\n    touch ${prefix}.duplex_qc.pdf\n    $touch_duplex_umi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n        ggplot2: \\$(Rscript -e \"library(ggplot2); cat(as.character(packageVersion('ggplot2')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Groups reads together that appear to have come from the same original molecule.\nReads are grouped by template, and then templates are sorted by the 5\u2019 mapping positions\nof the reads from the template, used from earliest mapping position to latest.\nReads that have the same end positions are then sub-grouped by UMI sequence.\n(!) Note: the MQ tag is required on reads with mapped mates (!)\nThis can be added using samblaster with the optional argument --addMateTags.\n\nTags: UMI, groupreads, fgbio", "answer": "process FGBIO_GROUPREADSBYUMI {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fgbio:2.2.1--hdfd78af_0' :\n        'biocontainers/fgbio:2.2.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    val(strategy)\n\n    output:\n    tuple val(meta), path(\"*.bam\")         , emit: bam\n    tuple val(meta), path(\"*histogram.txt\"), emit: histogram\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_umi-grouped\"\n    def mem_gb = 8\n    if (!task.memory) {\n        log.info '[fgbio FilterConsensusReads] Available memory not known - defaulting to 8GB. Specify process memory requirements to change this.'\n    } else if (mem_gb > task.memory.giga) {\n        if (task.memory.giga < 2) {\n            mem_gb = 1\n        } else {\n            mem_gb = task.memory.giga - 1\n        }\n    }\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    fgbio \\\\\n        -Xmx${mem_gb}g \\\\\n        --tmp-dir=. \\\\\n        GroupReadsByUmi \\\\\n        -s $strategy \\\\\n        $args \\\\\n        -i $bam \\\\\n        -o ${prefix}.bam \\\\\n        -f ${prefix}_histogram.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}_umi-grouped\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix}_histogram.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Uses FGBIO FilterConsensusReads to filter consensus reads generated by CallMolecularConsensusReads or CallDuplexConsensusReads.\nTags: fgbio, filter, consensus, umi, duplexumi", "answer": "process FGBIO_FILTERCONSENSUSREADS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fgbio:2.2.1--hdfd78af_0' :\n        'biocontainers/fgbio:2.2.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(fasta)\n    val(min_reads)\n    val(min_baseq)\n    val(max_base_error_rate)\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\"), emit: bam\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}_consensus_filtered\"\n\n    def mem_gb = 8\n    if (!task.memory) {\n        log.info '[fgbio FilterConsensusReads] Available memory not known - defaulting to 8GB. Specify process memory requirements to change this.'\n    } else if (mem_gb > task.memory.giga) {\n        if (task.memory.giga < 2) {\n            mem_gb = 1\n        } else {\n            mem_gb = task.memory.giga - 1\n        }\n    }\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    fgbio \\\\\n        -Xmx${mem_gb}g \\\\\n        --tmp-dir=. \\\\\n        --compression=0 \\\\\n        FilterConsensusReads \\\\\n        --input $bam \\\\\n        --output ${prefix}.bam \\\\\n        --ref ${fasta} \\\\\n        --min-reads ${min_reads} \\\\\n        --min-base-quality ${min_baseq} \\\\\n        --max-base-error-rate ${max_base_error_rate} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}_consensus_filtered\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: FGBIO tool to zip together an unmapped and mapped BAM to transfer metadata into the output BAM\nTags: fgbio, umi, unmapped, ubam, zipperbams", "answer": "process FGBIO_ZIPPERBAMS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fgbio:2.2.1--hdfd78af_0' :\n        'biocontainers/fgbio:2.2.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(unmapped_bam)\n    tuple val(meta2), path(mapped_bam)\n    tuple val(meta3), path(fasta)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\"), emit: bam\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def compression = task.ext.compression ?: '0'\n    prefix = task.ext.prefix ?: \"${meta.id}_zipped\"\n    def mem_gb = 8\n    if (!task.memory) {\n        log.info '[fgbio ZipperBams] Available memory not known - defaulting to 8GB. Specify process memory requirements to change this.'\n    } else if (mem_gb > task.memory.giga) {\n        if (task.memory.giga < 2) {\n            mem_gb = 1\n        } else {\n            mem_gb = task.memory.giga - 1\n        }\n    }\n\n    if (\"${unmapped_bam}\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    if (\"${mapped_bam}\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    fgbio -Xmx${mem_gb}g \\\\\n        --compression ${compression} \\\\\n        --async-io=true \\\\\n        ZipperBams \\\\\n        --unmapped ${unmapped_bam} \\\\\n        --input ${mapped_bam} \\\\\n        --ref ${fasta} \\\\\n        ${args} \\\\\n        --output ${prefix}.bam\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}_zipped\"\n    if (\"${unmapped_bam}\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    if (\"${mapped_bam}\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fgbio: \\$( echo \\$(fgbio --version 2>&1 | tr -d '[:cntrl:]' ) | sed -e 's/^.*Version: //;s/\\\\[.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: ResFinder identifies acquired antimicrobial resistance genes in total or partial sequenced isolates of bacteria\nTags: blastn, kma, microbes, resfinder, resistance genes", "answer": "process RESFINDER_RUN {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/resfinder:4.1.11--hdfd78af_0':\n        'biocontainers/resfinder:4.1.11--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fastq), path(fasta)\n    path db_point\n    path db_res\n\n    output:\n    tuple val(meta), path(\"*.json\")                           , emit: json\n    tuple val(meta), path(\"disinfinder_kma\")                  , optional: true, emit: disinfinder_kma\n    tuple val(meta), path(\"pheno_table_species.txt\")          , optional: true, emit: pheno_table_species\n    tuple val(meta), path(\"pheno_table.txt\")                  , optional: true, emit: pheno_table\n    tuple val(meta), path(\"pointfinder_kma\")                  , optional: true, emit: pointfinder_kma\n    tuple val(meta), path(\"PointFinder_prediction.txt\")       , optional: true, emit: pointfinder_prediction\n    tuple val(meta), path(\"PointFinder_results.txt\")          , optional: true, emit: pointfinder_results\n    tuple val(meta), path(\"PointFinder_table.txt\")            , optional: true, emit: pointfinder_table\n    tuple val(meta), path(\"ResFinder_Hit_in_genome_seq.fsa\")  , optional: true, emit: resfinder_hit_in_genome_seq\n    tuple val(meta), path(\"resfinder_blast\")                  , optional: true, emit: resfinder_blast\n    tuple val(meta), path(\"resfinder_kma\")                    , optional: true, emit: resfinder_kma\n    tuple val(meta), path(\"ResFinder_Resistance_gene_seq.fsa\"), optional: true, emit: resfinder_resistance_gene_seq\n    tuple val(meta), path(\"ResFinder_results_table.txt\")      , optional: true, emit: resfinder_results_table\n    tuple val(meta), path(\"ResFinder_results_tab.txt\")        , optional: true, emit: resfinder_results_tab\n    tuple val(meta), path(\"ResFinder_results.txt\")            , optional: true, emit: resfinder_results\n    path \"versions.yml\"                                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def input = \"\"\n    if (fastq) {\n        input = \"-ifq \" + fastq.join(\" \")\n    } else if (fasta) {\n        input = \"-ifa ${fasta}\"\n    }\n\n    def db = \"\"\n    if (db_res) {\n        db = \"-db_res ${db_res}\"\n    }\n    if (db_point) {\n        db = \"$db -db_point ${db_point}\"\n    }\n    \"\"\"\n    run_resfinder.py \\\\\n        $args \\\\\n        $input \\\\\n        $db\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        resfinder: \\$(run_resfinder.py -v)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir resfinder_kma\n    touch ${prefix}.json \\\\\n        pheno_table.txt \\\\\n        ResFinder_Hit_in_genome_seq.fsa \\\\\n        ResFinder_Resistance_gene_seq.fsa \\\\\n        ResFinder_results_table.txt \\\\\n        ResFinder_results_tab.txt \\\\\n        ResFinder_results.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        resfinder: \\$(run_resfinder.py -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Define the mappability of a reference\nTags: mappability, gem, index, reference", "answer": "process GEM2_GEMMAPPABILITY {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gem2:20200110--h9ee0642_1':\n        'biocontainers/gem2:20200110--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(index)\n    val(read_length)\n\n    output:\n    tuple val(meta), path(\"*.mappability\")  , emit: map\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '20200110' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    gem-mappability \\\\\n        -I ${index} \\\\\n        -o ${prefix} \\\\\n        -l ${read_length} \\\\\n        -T ${task.cpus} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem2: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '20200110' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.mappability\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem2: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert a mappability file to bedgraph format\nTags: mappability, bedgraph, index, gem", "answer": "process GEM2_GEM2BEDMAPPABILITY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gem2:20200110--h9ee0642_1':\n        'biocontainers/gem2:20200110--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta) , path(map)\n    tuple val(meta2), path(index)\n\n    output:\n    tuple val(meta), path(\"*.bg\")   , emit: bedgraph\n    tuple val(meta), path(\"*.sizes\"), emit: sizes\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '20200110' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    gem-2-bed mappability \\\\\n        --input ${map} \\\\\n        --index ${index} \\\\\n        --output ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem2: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '20200110' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.bg\n    touch ${prefix}.sizes\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem2: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a GEM index from a FASTA file\nTags: fasta, index, reference, mappability", "answer": "process GEM2_GEMINDEXER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gem2:20200110--h9ee0642_1':\n        'biocontainers/gem2:20200110--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.gem\"), emit: index\n    tuple val(meta), path(\"*.log\"), emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '20200110' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    gem-indexer \\\\\n        -i ${fasta} \\\\\n        -o ${prefix} \\\\\n        --threads ${task.cpus} \\\\\n        --mm-tmp-prefix ./tmp \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem2: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '20200110' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.gem\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem2: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate pairwise nucleotide identity with respect to a reference sequence\nTags: fasta, genome, qc, nucleotides", "answer": "process PRESIDENT {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/president:0.6.8--pyhdfd78af_0' :\n        'biocontainers/president:0.6.8--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(reference)\n    val compress\n\n    output:\n    tuple val(meta), path(\"${prefix}_valid.fasta*\")  , emit: valid_fasta\n    tuple val(meta), path(\"${prefix}_invalid.fasta*\"), emit: invalid_fasta\n    tuple val(meta), path(\"*.tsv\")                   , emit: report\n    tuple val(meta), path(\"*.log\")                   , emit: log\n    path \"versions.yml\"                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"${fasta}\" == \"${reference}\") error \"Input and reference names are the same!\"\n    if (\"${fasta}\" == \"${prefix}_valid.fasta\") error \"Input and output file names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    if (\"${fasta}\" == \"${prefix}_invalid.fasta\") error \"Input and output file names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    if (\"${fasta}\" == \"${prefix}_valid.fasta.gz\" && compress) error \"Input and output file names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    if (\"${fasta}\" == \"${prefix}_invalid.fasta.gz\" && compress) error \"Input and output file names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    president \\\\\n        --query $fasta \\\\\n        --reference $reference \\\\\n        --path . \\\\\n        --threads $task.cpus \\\\\n        --prefix \"${prefix}_\" \\\\\n        $args\n\n    if [ \"$compress\" = true ] ; then\n        gzip ${prefix}*.fasta;\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        president: \\$(president --version |& sed '1!d ; s/president v//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    compress_command = compress ? \"gzip ${prefix}*.fasta\" : \"\"\n\n    \"\"\"\n    touch ${prefix}_report.tsv\n    touch ${prefix}_president_logger.log\n    touch ${prefix}_valid.fasta\n    touch ${prefix}_invalid.fasta\n    $compress_command\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        president: \\$(president --version |& sed '1!d ; s/president v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: ADMIXTURE is a program for estimating ancestry in a model-based manner from large autosomal SNP genotype datasets, where the individuals are unrelated (for example, the individuals in a case-control association study).\nTags: ancestry, population genetics, admixture, reference panels, gwas", "answer": "process ADMIXTURE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/admixture:1.3.0--0':\n        'biocontainers/admixture:1.3.0--0' }\"\n\n    input:\n    tuple val(meta), path (bed_ped_geno), path(bim_map), path(fam)\n    val K\n\n\n    output:\n    tuple val(meta), path(\"*.Q\")    , emit: ancestry_fractions\n    tuple val(meta), path(\"*.P\")    , emit: allele_frequencies\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    admixture \\\\\n        $bed_ped_geno \\\\\n        $K \\\\\n        -j$task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        admixture: \\$(echo \\$(admixture 2>&1) | head -n 1 | grep -o \"ADMIXTURE Version [0-9.]*\" | sed 's/ADMIXTURE Version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.Q\"\n    touch \"${prefix}.P\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        admixture: \\$(echo \\$(admixture 2>&1) | head -n 1 | grep -o \"ADMIXTURE Version [0-9.]*\" | sed 's/ADMIXTURE Version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Print SHA256 (256-bit) checksums.\nTags: checksum, sha256, 256 bit", "answer": "process SHASUM {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:20.04' :\n        'nf-core/ubuntu:20.04' }\"\n\n    input:\n    tuple val(meta), path(file)\n\n    output:\n    tuple val(meta), path(\"*.sha256\"), emit: checksum\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    sha256sum \\\\\n        $args \\\\\n        ${file} \\\\\n        > ${file}.sha256\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sha256sum: \\$(echo \\$(sha256sum --version 2>&1 | head -n 1| sed 's/^.*) //;' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Software to pileup reads and corresponding base quality for each overlapping SNPs and each barcode.\nTags: popscle, demultiplexing, genotype-based deconvoltion, single cell, pile up", "answer": "process POPSCLE_DSCPILEUP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/popscle:0.1beta--h2c78cec_0' :\n        'biocontainers/popscle:0.1beta--h2c78cec_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(vcf)\n\n    output:\n    tuple val(meta), path('*.cel.gz'), emit: cel\n    tuple val(meta), path('*.plp.gz'), emit: plp\n    tuple val(meta), path('*.var.gz'), emit: var\n    tuple val(meta), path('*.umi.gz'), emit: umi\n    path 'versions.yml'              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1' // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n\n    \"\"\"\n    popscle dsc-pileup \\\\\n        --sam $bam \\\\\n        --vcf $vcf \\\\\n        --out $prefix \\\\\n        $args \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        popscle dsc-pileup: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1' // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.cel.gz\n    touch ${prefix}.var.gz\n    touch ${prefix}.plp.gz\n    touch ${prefix}.umi.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        popscle dsc-pileup: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Software to deconvolute sample identity and identify multiplets when multiple samples are pooled by barcoded single cell sequencing and external genotyping data for each sample is not available.\nTags: popscle, demultiplexing, genotype-based deconvoltion, single cell", "answer": "process POPSCLE_FREEMUXLET {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/popscle:0.1beta--h2c78cec_0' :\n        'biocontainers/popscle:0.1beta--h2c78cec_0' }\"\n\n    input:\n    tuple val(meta), path(plp), val(n_sample)\n\n    output:\n    tuple val(meta), path('*.clust1.samples.gz')  , emit: result\n    tuple val(meta), path('*.clust1.vcf.gz')      , emit: vcf\n    tuple val(meta), path('*.lmix')               , emit: lmix\n    tuple val(meta), path('*.clust0.samples.gz')  , emit: singlet_result   , optional: true\n    tuple val(meta), path('*.clust0.vcf.gz')      , emit: singlet_vcf      , optional: true\n    path 'versions.yml'                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1' // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    \"\"\"\n    popscle freemuxlet \\\\\n        --plp ${plp}/$prefix \\\\\n        --out $prefix \\\\\n        --nsample $n_sample \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        popscle: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1' // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.clust1.samples.gz\n    touch ${prefix}.clust1.vcf.gz\n    touch ${prefix}.lmix\n\n    if [[ \"$args\" == *\"--aux-files\"* ]]; then\n        touch ${prefix}.clust0.samples.gz\n        touch ${prefix}.clust0.vcf.gz\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        popscle: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Software to deconvolute sample identity and identify multiplets when multiple samples are pooled by barcoded single cell sequencing and external genotyping data for each sample is available.\nTags: popscle, demultiplexing, genotype-based deconvoltion, single cell", "answer": "process POPSCLE_DEMUXLET {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/popscle:0.1beta--h2c78cec_0' :\n        'biocontainers/popscle:0.1beta--h2c78cec_0' }\"\n\n    input:\n    tuple val(meta), val(plp_prefix), path(bam), path(donor_genotype)\n\n    output:\n    tuple val(meta), path('*.best'), emit: demuxlet_result\n    path 'versions.yml'            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input = plp_prefix ? \"--plp ${plp_prefix}\" : \"--sam $bam\"\n    def VERSION = '0.1' // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n\n    \"\"\"\n    popscle demuxlet \\\\\n        $input  \\\\\n        --vcf ${donor_genotype} \\\\\n        --out $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        popscle demuxlet: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input = plp_prefix ? \"--plp ${plp_prefix}\" : \"--sam $bam\"\n    def VERSION = '0.1' // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    \"\"\"\n    touch ${prefix}.best\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        popscle demuxlet: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A simple program to parse Illumina NGS data and check it for quality criteria\nTags: QC, Illumina, genomics", "answer": "process CHECKQC {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"community.wave.seqera.io/library/python_numpy_pip_checkqc_interop:b5301d9801b8e66b\"\n\n    input:\n    tuple val(meta), path(run_dir)\n    path(checkqc_config)\n\n    output:\n    tuple val(meta), path(\"*checkqc_report.json\"), emit: report\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"CheckQC module does not support Conda yet. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    def args = task.ext.args ?: ''\n    def config = checkqc_config ? \"--config $checkqc_config\" : ''\n\n    \"\"\"\n    checkqc \\\n        $args \\\n        $config \\\n        --json \\\n        $run_dir > checkqc_report.json || true\n\n    # Check if the output JSON file is empty\n    if [[ ! -s checkqc_report.json ]] ; then\n        echo \"Error: Empty JSON files. Most likely due to missing files in run directory. See .command.log file for errors.\"\n        exit 1\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkqc: \\$( checkqc --version | sed -e \"s/checkqc, version //g\" )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    touch checkqc_report.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkqc: \\$( checkqc --version | sed -e \"s/checkqc, version //g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: CADD is a tool for scoring the deleteriousness of single nucleotide variants as well as insertion/deletions variants in the human genome.\nTags: cadd, annotate, variants", "answer": "process CADD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container 'docker.io/biocontainers/cadd-scripts-with-envs:1.6.post1_cv1'\n\n    containerOptions {\n        (workflow.containerEngine == 'singularity') ?\n            \"-B ${annotation_dir}:/opt/CADD-scripts-1.6.post1/data/annotations\" :\n            \"-v ${annotation_dir}:/opt/CADD-scripts-1.6.post1/data/annotations\"\n        }\n\n    input:\n    tuple val(meta), path(vcf)\n    path(annotation_dir)\n\n    output:\n    tuple val(meta), path(\"*.tsv.gz\"), emit: tsv\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"1.6.post1\" // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    \"\"\"\n    cadd.sh \\\\\n        -o ${prefix}.tsv.gz \\\\\n        $args \\\\\n        $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cadd: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"1.6.post1\" // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    \"\"\"\n    touch ${prefix}.tsv.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cadd: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Domain-level classification of contigs to bacterial, archaeal, eukaryotic, or organelle\nTags: contigs, metagenomics, classify", "answer": "process TIARA_TIARA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/tiara:1.0.3' :\n        'biocontainers/tiara:1.0.3' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${prefix}.{txt,txt.gz}\")  , emit: classifications\n    tuple val(meta), path(\"log_*.{txt,txt.gz}\")      , emit: log\n    tuple val(meta), path(\"*.{fasta,fasta.gz}\")          , emit: fasta, optional: true\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    tiara -i ${fasta} \\\n        -o ${prefix}.txt \\\n        --threads ${task.cpus} \\\n        ${args}\n\n    ## fix gzip flag weirdness and ensure consistent .fasta filename output\n    ## check if fasta files are being output\n    if echo \"${args}\" | grep -qE \"tf|to-fasta\"; then\n        ## check if we've asked for gzip output, then rename files consistently\n        if echo \"${args}\" | grep -q \"gz\"; then\n            find . -name \"*_${fasta}*\" -exec sh -c 'file=`basename {}`; mv \"\\$file\" \"\\${file%%_*}_${prefix}.fasta.gz\"' \\\\;\n        else\n            find . -name \"*_${fasta}*\" -exec sh -c 'file=`basename {}`; mv \"\\$file\" \"\\${file%%_*}_${prefix}.fasta\"' \\\\;\n        fi\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tiara: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.out.txt\n    touch log_${prefix}.out.txt\n    touch bacteria_${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tiara: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Whole-genome assembly using PacBio HiFi reads\nTags: genome assembly, haplotype resolution, phasing, PacBio, HiFi, long reads", "answer": "process HIFIASM {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hifiasm:0.19.8--h43eeafb_0' :\n        'biocontainers/hifiasm:0.19.8--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  paternal_kmer_dump\n    path  maternal_kmer_dump\n    path  hic_read1\n    path  hic_read2\n\n    output:\n    tuple val(meta), path(\"*.r_utg.gfa\")       , emit: raw_unitigs\n    tuple val(meta), path(\"*.ec.bin\")          , emit: corrected_reads\n    tuple val(meta), path(\"*.ovlp.source.bin\") , emit: source_overlaps\n    tuple val(meta), path(\"*.ovlp.reverse.bin\"), emit: reverse_overlaps\n    tuple val(meta), path(\"*.bp.p_ctg.gfa\")    , emit: processed_contigs, optional: true\n    tuple val(meta), path(\"*.p_utg.gfa\")       , emit: processed_unitigs, optional: true\n    tuple val(meta), path(\"*.asm.p_ctg.gfa\")   , emit: primary_contigs  , optional: true\n    tuple val(meta), path(\"*.asm.a_ctg.gfa\")   , emit: alternate_contigs, optional: true\n    tuple val(meta), path(\"*.hap1.p_ctg.gfa\")  , emit: paternal_contigs , optional: true\n    tuple val(meta), path(\"*.hap2.p_ctg.gfa\")  , emit: maternal_contigs , optional: true\n    tuple val(meta), path(\"*.log\")             , emit: log\n    path  \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if ((paternal_kmer_dump) && (maternal_kmer_dump) && (hic_read1) && (hic_read2)) {\n        error \"Hifiasm Trio-binning and Hi-C integrated should not be used at the same time\"\n    } else if ((paternal_kmer_dump) && !(maternal_kmer_dump)) {\n        error \"Hifiasm Trio-binning requires maternal data\"\n    } else if (!(paternal_kmer_dump) && (maternal_kmer_dump)) {\n        error \"Hifiasm Trio-binning requires paternal data\"\n    } else if ((paternal_kmer_dump) && (maternal_kmer_dump)) {\n        \"\"\"\n        hifiasm \\\\\n            $args \\\\\n            -o ${prefix}.asm \\\\\n            -t $task.cpus \\\\\n            -1 $paternal_kmer_dump \\\\\n            -2 $maternal_kmer_dump \\\\\n            $reads \\\\\n            2> >( tee ${prefix}.stderr.log >&2 )\n\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            hifiasm: \\$(hifiasm --version 2>&1)\n        END_VERSIONS\n        \"\"\"\n    } else if ((hic_read1) && !(hic_read2)) {\n        error \"Hifiasm Hi-C integrated requires paired-end data (only R1 specified here)\"\n    } else if (!(hic_read1) && (hic_read2)) {\n        error \"Hifiasm Hi-C integrated requires paired-end data (only R2 specified here)\"\n    } else if ((hic_read1) && (hic_read2)) {\n        \"\"\"\n        hifiasm \\\\\n            $args \\\\\n            -o ${prefix}.asm \\\\\n            -t $task.cpus \\\\\n            --h1 $hic_read1 \\\\\n            --h2 $hic_read2 \\\\\n            $reads \\\\\n            2> >( tee ${prefix}.stderr.log >&2 )\n\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            hifiasm: \\$(hifiasm --version 2>&1)\n        END_VERSIONS\n        \"\"\"\n    } else { // Phasing with Hi-C data is not supported yet\n        \"\"\"\n        hifiasm \\\\\n            $args \\\\\n            -o ${prefix}.asm \\\\\n            -t $task.cpus \\\\\n            $reads \\\\\n            2> >( tee ${prefix}.stderr.log >&2 )\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            hifiasm: \\$(hifiasm --version 2>&1)\n        END_VERSIONS\n        \"\"\"\n    }\n        stub:\n        def args = task.ext.args ?: ''\n        def prefix = task.ext.prefix ?: \"${meta.id}\"\n        \"\"\"\n        touch ${prefix}.asm.r_utg.gfa\n        touch ${prefix}.asm.ec.bin\n        touch ${prefix}.asm.ovlp.source.bin\n        touch ${prefix}.asm.ovlp.reverse.bin\n        touch ${prefix}.asm.bp.p_ctg.gfa\n        touch ${prefix}.asm.p_utg.gfa\n        touch ${prefix}.asm.p_ctg.gfa\n        touch ${prefix}.asm.a_ctg.gfa\n        touch ${prefix}.asm.hap1.p_ctg.gfa\n        touch ${prefix}.asm.hap2.p_ctg.gfa\n        touch ${prefix}.stderr.log\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            hifiasm: \\$(hifiasm --version 2>&1)\n        END_VERSIONS\n        \"\"\"\n\n}\n"}
{"question": "Description: Identify mobile genetic elements present in genomic assemblies\nTags: metagenomics, genomad, database, download, phage, virus, plasmid", "answer": "process GENOMAD_ENDTOEND {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genomad:1.7.4--pyhdfd78af_0':\n        'biocontainers/genomad:1.7.4--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    path  genomad_db\n\n    output:\n    tuple val(meta), path(\"*_aggregated_classification/*_aggregated_classification.tsv\")    , emit: aggregated_classification   , optional: true\n    tuple val(meta), path(\"*_annotate/*_taxonomy.tsv\")                                      , emit: taxonomy\n    tuple val(meta), path(\"*_find_proviruses/*_provirus.tsv\")                               , emit: provirus\n    tuple val(meta), path(\"*_score_calibration/*_compositions.tsv\")                         , emit: compositions                , optional: true\n    tuple val(meta), path(\"*_score_calibration/*_calibrated_aggregated_classification.tsv\") , emit: calibrated_classification   , optional: true\n    tuple val(meta), path(\"*_summary/*_plasmid.fna.gz\")                                     , emit: plasmid_fasta\n    tuple val(meta), path(\"*_summary/*_plasmid_genes.tsv\")                                  , emit: plasmid_genes\n    tuple val(meta), path(\"*_summary/*_plasmid_proteins.faa.gz\")                            , emit: plasmid_proteins\n    tuple val(meta), path(\"*_summary/*_plasmid_summary.tsv\")                                , emit: plasmid_summary\n    tuple val(meta), path(\"*_summary/*_virus.fna.gz\")                                       , emit: virus_fasta\n    tuple val(meta), path(\"*_summary/*_virus_genes.tsv\")                                    , emit: virus_genes\n    tuple val(meta), path(\"*_summary/*_virus_proteins.faa.gz\")                              , emit: virus_proteins\n    tuple val(meta), path(\"*_summary/*_virus_summary.tsv\")                                  , emit: virus_summary\n    path \"versions.yml\"                                                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    genomad \\\\\n        end-to-end \\\\\n        $fasta \\\\\n        ./ \\\\\n        $genomad_db \\\\\n        --threads $task.cpus \\\\\n        $args\n\n    gzip ./**/*.fna\n    gzip ./**/*.faa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genomad: \\$(echo \\$(genomad --version 2>&1) | sed 's/^.*geNomad, version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def filename = \"${fasta}\"[0..<\"${fasta}\".lastIndexOf('.')]\n    \"\"\"\n    mkdir ${filename}_aggregated_classification\n    touch ${filename}_aggregated_classification/${filename}_aggregated_classification.tsv\n    mkdir ${filename}_annotate\n    touch ${filename}_annotate/${filename}_taxonomy.tsv\n    mkdir ${filename}_find_proviruses\n    touch ${filename}_find_proviruses/${filename}_provirus.tsv\n    mkdir ${filename}_marker_classification\n    mkdir ${filename}_nn_classification\n    mkdir ${filename}_score_calibration\n    touch ${filename}_score_calibration/${filename}_calibrated_aggregated_classification.tsv\n    touch ${filename}_score_calibration/${filename}_compositions.tsv\n    mkdir ${filename}_summary\n    touch ${filename}_summary/${filename}_plasmid.fna.gz\n    touch ${filename}_summary/${filename}_plasmid_genes.tsv\n    touch ${filename}_summary/${filename}_plasmid_proteins.faa.gz\n    touch ${filename}_summary/${filename}_plasmid_summary.tsv\n    touch ${filename}_summary/${filename}_virus.fna.gz\n    touch ${filename}_summary/${filename}_virus_genes.tsv\n    touch ${filename}_summary/${filename}_virus_proteins.faa.gz\n    touch ${filename}_summary/${filename}_virus_summary.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genomad: \\$(echo \\$(genomad --version 2>&1) | sed 's/^.*geNomad, version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download geNomad databases and related files\nTags: metagenomics, genomad, database, download, phage, virus, plasmid", "answer": "process GENOMAD_DOWNLOAD {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genomad:1.7.4--pyhdfd78af_0':\n        'biocontainers/genomad:1.7.4--pyhdfd78af_0' }\"\n\n    output:\n    path \"genomad_db/\"  , emit: genomad_db\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    genomad \\\\\n        download-database .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genomad: \\$(echo \\$(genomad --version 2>&1) | sed 's/^.*geNomad, version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir genomad_db\n    touch genomad_db/genomad_db\n    touch genomad_db/genomad_db.dbtype\n    touch genomad_db/genomad_db.index\n    touch genomad_db/genomad_db.lookup\n    touch genomad_db/genomad_db.source\n    touch genomad_db/genomad_db_h\n    touch genomad_db/genomad_db_h.dbtype\n    touch genomad_db/genomad_db_h.index\n    touch genomad_db/genomad_db_mapping\n    touch genomad_db/genomad_db_taxonomy\n    touch genomad_db/genomad_integrase_db\n    touch genomad_db/genomad_integrase_db.dbtype\n    touch genomad_db/genomad_integrase_db.index\n    touch genomad_db/genomad_integrase_db.lookup\n    touch genomad_db/genomad_integrase_db.source\n    touch genomad_db/genomad_integrase_db_h\n    touch genomad_db/genomad_integrase_db_h.dbtype\n    touch genomad_db/genomad_integrase_db_h.index\n    touch genomad_db/genomad_marker_metadata.tsv\n    touch genomad_db/genomad_mini_db\n    touch genomad_db/genomad_mini_db.dbtype\n    touch genomad_db/genomad_mini_db.index\n    touch genomad_db/genomad_mini_db.lookup\n    touch genomad_db/genomad_mini_db.source\n    touch genomad_db/genomad_mini_db_h\n    touch genomad_db/genomad_mini_db_h.dbtype\n    touch genomad_db/genomad_mini_db_h.index\n    touch genomad_db/genomad_mini_db_mapping\n    touch genomad_db/genomad_mini_db_taxonomy\n    touch genomad_db/mini_set_ids\n    touch genomad_db/names.dmp\n    touch genomad_db/nodes.dmp\n    touch genomad_db/plasmid_hallmark_annotation.txt\n    touch genomad_db/version.txt\n    touch genomad_db/virus_hallmark_annotation.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genomad: \\$(echo \\$(genomad --version 2>&1) | sed 's/^.*geNomad, version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Render jupyter (or jupytext) notebooks to HTML reports. Supports parametrization\nthrough papermill.\n\nTags: Python, Jupyter, jupytext, papermill, notebook, reports", "answer": "include { dump_params_yml; indent_code_block } from \"./parametrize\"\n\nprocess JUPYTERNOTEBOOK {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    //NB: You likely want to override this with a container containing all required\n    //dependencies for your analysis. The container at least needs to contain the\n    //ipykernel, jupytext, papermill and nbconvert Python packages.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-514b1a5d280c7043110b2a8d0a87b57ba392a963:879972fc8bdc81ee92f2bce3b4805d89a772bf84-0' :\n        'biocontainers/mulled-v2-514b1a5d280c7043110b2a8d0a87b57ba392a963:879972fc8bdc81ee92f2bce3b4805d89a772bf84-0' }\"\n\n    input:\n    tuple val(meta), path(notebook)\n    val parameters\n    path input_files\n\n    output:\n    tuple val(meta), path(\"*.html\"), emit: report\n    tuple val(meta), path(\"artifacts/\"), emit: artifacts, optional: true\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def parametrize = (task.ext.parametrize == null) ?  true : task.ext.parametrize\n    def implicit_params = (task.ext.implicit_params == null) ? true : task.ext.implicit_params\n    def meta_params = (task.ext.meta_params == null) ? true : task.ext.meta_params\n    def kernel   = task.ext.kernel ?: '-'\n\n    // Dump parameters to yaml file.\n    // Using a yaml file over using the CLI params because\n    //  * no issue with escaping\n    //  * allows to pass nested maps instead of just single values\n    def params_cmd = \"\"\n    def render_cmd = \"\"\n    if (parametrize) {\n        nb_params = [:]\n        if (implicit_params) {\n            nb_params[\"cpus\"] = task.cpus\n            nb_params[\"artifact_dir\"] = \"artifacts\"\n            nb_params[\"input_dir\"] = \"./\"\n        }\n        if (meta_params) {\n            nb_params[\"meta\"] = meta\n        }\n        nb_params += parameters\n        params_cmd = dump_params_yml(nb_params)\n        render_cmd = \"papermill -f .params.yml\"\n    } else {\n        render_cmd = \"papermill\"\n    }\n\n    \"\"\"\n    set -o pipefail\n\n    # Dump .params.yml heredoc (section will be empty if parametrization is disabled)\n    ${indent_code_block(params_cmd, 4)}\n\n    # Create output directory\n    mkdir artifacts\n\n    # Set parallelism for BLAS/MKL etc. to avoid over-booking of resources\n    export MKL_NUM_THREADS=\"$task.cpus\"\n    export OPENBLAS_NUM_THREADS=\"$task.cpus\"\n    export OMP_NUM_THREADS=\"$task.cpus\"\n    export NUMBA_NUM_THREADS=\"$task.cpus\"\n\n    # Convert notebook to ipynb using jupytext, execute using papermill, convert using nbconvert\n    jupytext --to notebook --output - --set-kernel ${kernel} ${notebook} > ${notebook}.ipynb\n    ${render_cmd} ${notebook}.ipynb ${notebook}.executed.ipynb\n    jupyter nbconvert --stdin --to html --output ${prefix}.html < ${notebook}.executed.ipynb\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        jupytext: \\$(jupytext --version)\n        ipykernel: \\$(python -c \"import ipykernel; print(ipykernel.__version__)\")\n        nbconvert: \\$(jupyter nbconvert --version)\n        papermill: \\$(papermill --version | cut -f1 -d' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates a FASTA file for each new cluster assigned by CONCOCT\nTags: contigs, fragment, mags, binning, fasta, cut, cut up, bins, merge", "answer": "process CONCOCT_EXTRACTFASTABINS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/concoct:1.1.0--py312h245ed52_6':\n        'biocontainers/concoct:1.1.0--py312h245ed52_6' }\"\n\n    input:\n    tuple val(meta), path(original_fasta), path(csv)\n\n    output:\n    tuple val(meta), path(\"${prefix}/*.fa.gz\"), emit: fasta\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n\n    extract_fasta_bins.py \\\\\n        $args \\\\\n        $original_fasta \\\\\n        $csv \\\\\n        --output_path ${prefix}\n\n    ## Add prefix to each file to disambiguate one sample's 1.fa, 2.fa from sample2\n    for i in ${prefix}/*.fa; do\n        mv \\${i} \\${i/\\\\///${prefix}_}\n        gzip \\${i/\\\\///${prefix}_}\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}\n    echo \"\" | gzip > ${prefix}/${prefix}.fa.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate the input coverage table for CONCOCT using a BEDFile\nTags: contigs, fragment, mags, binning, bed, bam, subcontigs, coverage", "answer": "\nprocess CONCOCT_CONCOCTCOVERAGETABLE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/concoct:1.1.0--py312h245ed52_6':\n        'biocontainers/concoct:1.1.0--py312h245ed52_6' }\"\n\n    input:\n    tuple val(meta), path(bed), path(bamfiles), path(baifiles)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    concoct_coverage_table.py \\\\\n        $args \\\\\n        $bed \\\\\n        $bamfiles \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Unsupervised binning of metagenomic contigs by using nucleotide composition - kmer frequencies - and coverage data for multiple samples\nTags: contigs, fragment, mags, binning, concoct, kmer, nucleotide composition, metagenomics, bins", "answer": "\nprocess CONCOCT_CONCOCT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/concoct:1.1.0--py312h245ed52_6':\n        'biocontainers/concoct:1.1.0--py312h245ed52_6' }\"\n\n    input:\n    tuple val(meta), path(coverage_file), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*_args.txt\")                         , emit: args_txt\n    tuple val(meta), path(\"*_clustering_gt1000.csv\")            , emit: clustering_csv\n    tuple val(meta), path(\"*_log.txt\")                          , emit: log_txt\n    tuple val(meta), path(\"*_original_data_gt1000.csv\")         , emit: original_data_csv\n    tuple val(meta), path(\"*_PCA_components_data_gt1000.csv\")   , emit: pca_components_csv\n    tuple val(meta), path(\"*_PCA_transformed_data_gt1000.csv\")  , emit: pca_transformed_csv\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    concoct \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --coverage_file ${coverage_file} \\\\\n        --composition_file ${fasta} \\\\\n        -b ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_args.txt\n    touch ${prefix}_clustering_gt1000.csv\n    touch ${prefix}_log.txt\n    touch ${prefix}_original_data_gt1000.csv\n    touch ${prefix}_PCA_components_data_gt1000.csv\n    touch ${prefix}_PCA_transformed_data_gt1000.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge consecutive parts of the original contigs original cut up by cut_up_fasta.py\nTags: contigs, fragment, mags, binning, fasta, cut, cut up, merge", "answer": "process CONCOCT_MERGECUTUPCLUSTERING {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/concoct:1.1.0--py312h245ed52_6':\n        'biocontainers/concoct:1.1.0--py312h245ed52_6' }\"\n\n    input:\n    tuple val(meta), path(clustering_csv)\n\n    output:\n    tuple val(meta), path(\"*.csv\"), emit: csv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$clustering_csv\" == \"${prefix}.csv\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    merge_cutup_clustering.py \\\\\n        $args \\\\\n        $clustering_csv \\\\\n        > ${prefix}.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$clustering_csv\" == \"${prefix}.csv\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cut up fasta file in non-overlapping or overlapping parts of equal length.\nTags: contigs, fragment, mags, binning, fasta, cut, cut up", "answer": "\nprocess CONCOCT_CUTUPFASTA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/concoct:1.1.0--py312h245ed52_6':\n        'biocontainers/concoct:1.1.0--py312h245ed52_6' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val(bed)\n\n    output:\n    tuple val(meta), path(\"*.fasta\"), emit: fasta\n    tuple val(meta), path(\"*.bed\")  , optional: true, emit: bed\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def bedfile    = bed ? \"-b ${prefix}.bed\" : \"\"\n    if (\"$fasta\" == \"${prefix}.fasta\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    cut_up_fasta.py \\\\\n        $fasta \\\\\n        $args \\\\\n        $bedfile \\\\\n        > ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def bedfile    = bed ? \"-b ${prefix}.bed\" : \"\"\n    if (\"$fasta\" == \"${prefix}.fasta\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        concoct: \\$(echo \\$(concoct --version 2>&1) | sed 's/concoct //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GECCO is a fast and scalable method for identifying putative novel Biosynthetic Gene Clusters (BGCs) in genomic and metagenomic data using Conditional Random Fields (CRFs).\nTags: bgc, detection, metagenomics, contigs", "answer": "process GECCO_RUN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gecco:0.9.10--pyhdfd78af_0':\n        'biocontainers/gecco:0.9.10--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(hmm)\n    path model_dir\n\n    output:\n    tuple val(meta), path(\"*.genes.tsv\")    , optional: true, emit: genes\n    tuple val(meta), path(\"*.features.tsv\")                 , emit: features\n    tuple val(meta), path(\"*.clusters.tsv\") , optional: true, emit: clusters\n    tuple val(meta), path(\"*_cluster_*.gbk\"), optional: true, emit: gbk\n    tuple val(meta), path(\"*.json\")         , optional: true, emit: json\n\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def custom_model = model_dir ? \"--model ${model_dir}\" : \"\"\n    def custom_hmm = hmm ? \"--hmm ${hmm}\" : \"\"\n    \"\"\"\n    gecco \\\\\n        run \\\\\n        $args \\\\\n        -j $task.cpus \\\\\n        -o ./ \\\\\n        -g ${input} \\\\\n        $custom_model \\\\\n        $custom_hmm\n\n    for i in \\$(find -name '${input.baseName}*' -type f); do\n        mv \\$i \\${i/${input.baseName}/${prefix}};\n    done\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gecco: \\$(echo \\$(gecco --version) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.genes.tsv\n    touch ${prefix}.features.tsv\n    touch ${prefix}.clusters.tsv\n    touch NC_018507.1_cluster_1.gbk\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gecco: \\$(echo \\$(gecco --version) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: find and mark duplicate reads in BAM file\nTags: markduplicates, duplicates, bam", "answer": "process SAMBAMBA_MARKDUP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sambamba:1.0.1--h6f6fda4_0':\n        'biocontainers/sambamba:1.0.1--h6f6fda4_0 ' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path(\"*.bai\"), emit: bai, optional: true\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    sambamba \\\\\n        markdup \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        --tmpdir ./ \\\\\n        $bam \\\\\n        ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sambamba: \\$(echo \\$(sambamba --version 2>&1) | awk '{print \\$2}' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Outputs some statistics drawn from read flags.\nTags: stats, flagstat, sambamba", "answer": "process SAMBAMBA_FLAGSTAT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sambamba:1.0.1--h6f6fda4_0':\n        'biocontainers/sambamba:1.0.1--h6f6fda4_0 ' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.stats\"), emit: stats\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    sambamba \\\\\n        flagstat \\\\\n        -t $task.cpus \\\\\n        $bam \\\\\n        > ${prefix}.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sambamba: \\$(echo \\$(sambamba --version 2>&1) | awk '{print \\$2}' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Typing of clinical and environmental isolates of Legionella pneumophila\nTags: bacteria, legionella", "answer": "process LEGSTA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/legsta%3A0.5.1--hdfd78af_2':\n        'biocontainers/legsta:0.5.1--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(seqs)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    legsta \\\\\n        $args \\\\\n        $seqs > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        legsta: \\$(echo \\$(legsta --version 2>&1) | sed 's/^.*legsta //; s/ .*\\$//;')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Rapidly extracts SNPs from a multi-FASTA alignment.\nTags: SNPs, invariant, constant", "answer": "process SNPSITES {\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snp-sites:2.5.1--hed695b0_0' :\n        'biocontainers/snp-sites:2.5.1--hed695b0_0' }\"\n\n    input:\n    path alignment\n\n    output:\n    path \"*.fas\"        , emit: fasta\n    path \"*.sites.txt\"  , emit: constant_sites\n    path \"versions.yml\" , emit: versions\n    env   CONSTANT_SITES, emit: constant_sites_string\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    snp-sites \\\\\n        $alignment \\\\\n        $args \\\\\n        > filtered_alignment.fas\n\n    echo \\$(snp-sites -C $alignment) > constant.sites.txt\n\n    CONSTANT_SITES=\\$(cat constant.sites.txt)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpsites: \\$(snp-sites -V 2>&1 | sed 's/snp-sites //')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    \"\"\"\n    touch filtered_alignment.fas\n    touch constant.sites.txt\n    CONSTANT_SITES=\\$(cat constant.sites.txt)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpsites: \\$(snp-sites -V 2>&1 | sed 's/snp-sites //')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Performs fastq alignment to a fasta reference using using gem3-mapper\nTags: fastq, genomics, mappability", "answer": "process GEM3_GEM3MAPPER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-240a9c1936dd6a68f46aa198b2629b6734a18428:543223d3cc2f69d86af72f7e9a3200812ae25327-0':\n        'biocontainers/mulled-v2-240a9c1936dd6a68f46aa198b2629b6734a18428:543223d3cc2f69d86af72f7e9a3200812ae25327-0' }\"\n\n    input:\n    tuple val(meta), path(gem)\n    tuple val(meta2), path(fastq)\n    val   sort_bam\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    \"\"\"\n    gem-mapper -F 'SAM' -I $gem -i $fastq -t $task.cpus $args | samtools $samtools_command $args2 -@ $task.cpus -o ${prefix}.bam -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem-mapper: \\$(echo \\$(gem-mapper --version 2>&1) | sed 's/v//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem-mapper: \\$(echo \\$(gem-mapper --version 2>&1) | sed 's/v//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a GEM index from a FASTA file\nTags: fastq, genomics, mappability", "answer": "process GEM3_GEM3INDEXER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gem3-mapper:3.6.1--h9d449c0_12':\n        'biocontainers/gem3-mapper:3.6.1--h9d449c0_12' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n\n    output:\n    tuple val(meta), path(\"*.gem\") , emit: index\n    tuple val(meta), path(\"*.info\"), emit: info\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    gem-indexer \\\\\n        -i ${fasta} \\\\\n        -o ${prefix} \\\\\n        --threads ${task.cpus} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem3-indexer: \\$(echo \\$(gem-indexer --version 2>&1) | sed 's/v//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.gem\n    touch ${prefix}.info\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gem3-indexer: \\$(echo \\$(gem-indexer --version 2>&1) | sed 's/v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Render an rmarkdown notebook. Supports parametrization.\nTags: R, notebook, reports", "answer": "include { dump_params_yml; indent_code_block } from \"./parametrize\"\n\nprocess RMARKDOWNNOTEBOOK {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    //NB: You likely want to override this with a container containing all required\n    //dependencies for your analysis. The container at least needs to contain the\n    //yaml and rmarkdown R packages.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-31ad840d814d356e5f98030a4ee308a16db64ec5:0e852a1e4063fdcbe3f254ac2c7469747a60e361-0' :\n        'biocontainers/mulled-v2-31ad840d814d356e5f98030a4ee308a16db64ec5:0e852a1e4063fdcbe3f254ac2c7469747a60e361-0' }\"\n\n    input:\n    tuple val(meta), path(notebook)\n    val parameters\n    path input_files\n\n    output:\n    tuple val(meta), path(\"*.html\")              , emit: report\n    tuple val(meta), path(\"*.parameterised.Rmd\") , emit: parameterised_notebook, optional: true\n    tuple val(meta), path (\"artifacts/*\")        , emit: artifacts, optional: true\n    tuple val(meta), path (\"session_info.log\")   , emit: session_info\n    path  \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def parametrize = (task.ext.parametrize == null) ?  true : task.ext.parametrize\n    def implicit_params = (task.ext.implicit_params == null) ? true : task.ext.implicit_params\n    def meta_params = (task.ext.meta_params == null) ? true : task.ext.meta_params\n\n    // Dump parameters to yaml file.\n    // Using a yaml file over using the CLI params because\n    //  * no issue with escaping\n    //  * allows to pass nested maps instead of just single values\n    def params_cmd = \"\"\n    def render_cmd = \"\"\n    if (parametrize) {\n        nb_params = [:]\n        if (implicit_params) {\n            nb_params[\"cpus\"] = task.cpus\n            nb_params[\"artifact_dir\"] = \"artifacts\"\n            nb_params[\"input_dir\"] = \"./\"\n        }\n        if (meta_params) {\n            nb_params[\"meta\"] = meta\n        }\n        nb_params += parameters\n        params_cmd = dump_params_yml(nb_params)\n        render_cmd = \"\"\"\\\n            params = yaml::read_yaml('.params.yml')\n\n            # Instead of rendering with params, produce a version of the R\n            # markdown with param definitions set, so the notebook itself can\n            # be reused\n            rmd_content <- readLines('${prefix}.Rmd')\n\n            # Extract YAML content between the first two '---'\n            start_idx <- which(rmd_content == \"---\")[1]\n            end_idx <- which(rmd_content == \"---\")[2]\n            rmd_yaml_content <- paste(rmd_content[(start_idx+1):(end_idx-1)], collapse = \"\\\\n\")\n            rmd_params <- yaml::yaml.load(rmd_yaml_content)\n\n            # Override the params\n            rmd_params[['params']] <- modifyList(rmd_params[['params']], params)\n\n            # Recursive function to add 'value' to list elements, except for top-level\n            add_value_recursively <- function(lst, is_top_level = FALSE) {\n                if (!is.list(lst)) {\n                    return(lst)\n                }\n\n                lst <- lapply(lst, add_value_recursively)\n                if (!is_top_level) {\n                    lst <- list(value = lst)\n                }\n                return(lst)\n            }\n\n            # Reformat nested lists under 'params' to have a 'value' key recursively\n            rmd_params[['params']] <- add_value_recursively(rmd_params[['params']], is_top_level = TRUE)\n\n            # Convert back to YAML string\n            updated_yaml_content <- as.character(yaml::as.yaml(rmd_params))\n\n            # Remove the old YAML content\n            rmd_content <- rmd_content[-((start_idx+1):(end_idx-1))]\n\n            # Insert the updated YAML content at the right position\n            rmd_content <- append(rmd_content, values = unlist(strsplit(updated_yaml_content, split = \"\\\\n\")), after = start_idx)\n\n            writeLines(rmd_content, '${prefix}.parameterised.Rmd')\n\n            # Render based on the updated file\n            rmarkdown::render('${prefix}.parameterised.Rmd', output_file='${prefix}.html', envir = new.env())\n        \"\"\"\n    } else {\n        render_cmd = \"rmarkdown::render('${prefix}.Rmd', output_file='${prefix}.html')\"\n    }\n\n    \"\"\"\n    # Dump .params.yml heredoc (section will be empty if parametrization is disabled)\n    ${indent_code_block(params_cmd, 4)}\n\n    # Create output directory\n    mkdir artifacts\n\n    # Set parallelism for BLAS/MKL etc. to avoid over-booking of resources\n    export MKL_NUM_THREADS=\"$task.cpus\"\n    export OPENBLAS_NUM_THREADS=\"$task.cpus\"\n    export OMP_NUM_THREADS=\"$task.cpus\"\n\n    # Work around  https://github.com/rstudio/rmarkdown/issues/1508\n    # If the symbolic link is not replaced by a physical file\n    # output- and temporary files will be written to the original directory.\n    mv \"${notebook}\" \"${notebook}.orig\"\n    cp -L \"${notebook}.orig\" \"${prefix}.Rmd\"\n\n    # Render notebook\n    Rscript - <<EOF\n        ${indent_code_block(render_cmd, 8)}\n        writeLines(capture.output(sessionInfo()), \"session_info.log\")\n    EOF\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rmarkdown: \\$(Rscript -e \"cat(paste(packageVersion('rmarkdown'), collapse='.'))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges several idXML files into one idXML file.\nTags: merge, idXML, openms, proteomics", "answer": "process OPENMS_IDMERGER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/openms:3.1.0--h8964181_3' :\n        'biocontainers/openms:3.1.0--h8964181_3' }\"\n\n    input:\n    tuple val(meta), path(idxmls)\n\n    output:\n    tuple val(meta), path(\"*.idXML\"), emit: idxml\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    IDMerger \\\\\n        -in $idxmls \\\\\n        -out ${prefix}.idXML \\\\\n        -threads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.idXML\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Refreshes the protein references for all peptide hits.\nTags: refresh, idXML, openms, proteomics", "answer": "process OPENMS_PEPTIDEINDEXER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/openms:3.1.0--h8964181_3':\n        'biocontainers/openms:3.1.0--h8964181_3' }\"\n\n    input:\n    tuple val(meta), path(id_file)\n    tuple val(meta), path(id_fasta)\n\n    output:\n    tuple val(meta), path(\"*.idXML\"), emit: id_file_pi\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_pi\"\n\n    \"\"\"\n    PeptideIndexer \\\\\n        -in $id_file \\\\\n        -fasta $id_fasta \\\\\n        -out ${prefix}.idXML \\\\\n        -threads $task.cpus \\\\\n        $args \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_pi\"\n\n    \"\"\"\n    touch ${prefix}.idXML\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a decoy peptide database from a standard FASTA database.\nTags: decoy, database, openms, proteomics, fasta", "answer": "process OPENMS_DECOYDATABASE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/openms:3.1.0--h8964181_3' :\n        'biocontainers/openms:3.1.0--h8964181_3' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.fasta\"), emit: decoy_fasta\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${fasta.baseName}_decoy\"\n\n    \"\"\"\n    DecoyDatabase \\\\\n        -in $fasta \\\\\n        -out ${prefix}.fasta \\\\\n        -threads $task.cpus \\\\\n        $args\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${fasta.baseName}_decoy\"\n\n    \"\"\"\n    touch ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split a merged identification file into their originating identification files\nTags: split, idXML, openms, proteomics", "answer": "process OPENMS_IDRIPPER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/openms:3.1.0--h8964181_3':\n        'biocontainers/openms:3.1.0--h8964181_3' }\"\n\n    input:\n    tuple val(meta), path(merged_idxml)\n\n    output:\n    tuple val(meta), path(\"*.idXML\"), emit: idxmls\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    IDRipper \\\\\n        -in $merged_idxml \\\\\n        -out . \\\\\n        -threads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}_1.idXML\n    touch ${prefix}_2.idXML\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool for peak detection in high-resolution profile data (Orbitrap or FTICR)\nTags: peak picking, mzml, openms, proteomics", "answer": "process OPENMS_PEAKPICKERHIRES {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/openms:3.1.0--h8964181_3' :\n        'biocontainers/openms:3.1.0--h8964181_3' }\"\n\n    input:\n    tuple val(meta), path(mzml)\n\n    output:\n    tuple val(meta), path(\"*.mzML\"), emit: mzml\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    PeakPickerHiRes \\\\\n        -in $mzml \\\\\n        -out ${prefix}.mzML \\\\\n        -threads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.mzML\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filters peptide/protein identification results by different criteria.\nTags: filter, idXML, openms, proteomics", "answer": "process OPENMS_IDFILTER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"bioconda::openms=3.1.0\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/openms:3.1.0--h8964181_3' :\n        'biocontainers/openms:3.1.0--h8964181_3' }\"\n\n    input:\n    tuple val(meta), path(id_file), path(filter_file)\n\n    output:\n    tuple val(meta), path(\"*.{idXML,consensusXML}\"), emit: filtered\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"${id_file.getExtension()}\"\n    // Optional filtering via filter_file\n    def filter_citerion = task.ext.args2 ?: \"-whitelist:peptides\"\n    def filter = filter_file ? \"${filter_citerion} ${filter_file}\" : \"\"\n\n    \"\"\"\n    IDFilter -in $id_file \\\\\n        -out ${prefix}.${suffix} \\\\\n        -threads $task.cpus \\\\\n        $filter \\\\\n        $args \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"${id_file.getExtension()}\"\n    // Optional filtering via filter_file\n    def filter_citerion = task.ext.args2 ?: \"-whitelist:peptides\"\n    def filter = filter_file ? \"${filter_citerion} ${filter_file}\" : \"\"\n\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Switches between different scores of peptide or protein hits in identification data\nTags: switch, score, idXML, openms, proteomics", "answer": "process OPENMS_IDSCORESWITCHER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/openms:3.1.0--h8964181_3':\n        'biocontainers/openms:3.1.0--h8964181_3' }\"\n\n    input:\n    tuple val(meta), path(idxml)\n\n    output:\n    tuple val(meta), path(\"*.idXML\"), emit: idxml\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$idxml\" == \"${prefix}.idXML\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    IDScoreSwitcher \\\\\n        -in $idxml \\\\\n        -out ${prefix}.idXML \\\\\n        -threads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$idxml\" == \"${prefix}.idXML\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    touch ${prefix}.idXML\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        openms: \\$(echo \\$(FileInfo --help 2>&1) | sed 's/^.*Version: //; s/-.*\\$//' | sed 's/ -*//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to build the reference needed by the 10x Genomics Cell Ranger Arc tool. Uses the cellranger-arc mkref command.\nTags: reference, mkref, index", "answer": "process CELLRANGERARC_MKREF {\n    tag \"$reference_name\"\n    label 'process_medium'\n\n    container \"nf-core/cellranger-arc:2.0.2\"\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"CELLRANGERARC_COUNT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    input:\n    path fasta\n    path gtf\n    path motifs\n    path reference_config\n    val reference_name\n\n    output:\n    path \"${reference_name}\", emit: reference\n    path \"config\"           , emit: config\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def fast_name = fasta.name\n    def gtf_name = gtf.name\n    def motifs_name = motifs.name\n    def reference_config = reference_config.name\n    def args = task.ext.args ?: ''\n\n    if ( !reference_name ){\n        reference_name = \"cellrangerarc_reference\"\n    }\n\n    // unlike cellranger mkref and spaceranger mkref, cellranger-arc mkref is not *yet* implemented in the\n    // 10x martian runtime. It is therefore not necessary to specify --localcores and --localmem\n    \"\"\"\n    python3 <<CODE\n\n    from os.path import exists\n    import shutil\n\n    fasta = \"${fast_name}\"\n    gtf = \"${gtf_name}\"\n    motifs = \"${motifs_name}\"\n    add = \"${args}\"\n    reference_config = \"${reference_config}\"\n\n    if ( reference_config == \"[]\" ):\n\n        config = open(\"config\", \"w\")\n        config.write(\"{\\\\n\")\n        config.write('\\\\torganism: \"{}\"\\\\n'.format(fasta.split(\".\")[0]))\n        config.write('\\\\tgenome: [\"cellrangerarc_reference\"]\\\\n')\n        config.write('\\\\tinput_fasta: [\"{}\"]\\\\n'.format(fasta))\n        config.write('\\\\tinput_gtf: [\"{}\"]\\\\n'.format(gtf))\n        if motifs != \"[]\":\n            config.write('\\tinput_motifs: \"{}\"\\\\n'.format(motifs))\n        if add != None:\n            config.write(add + \"\\\\n\")\n        config.write(\"}\")\n        config.close()\n\n        print(\"Wrote config file\")\n    else:\n        if ( not exists(\"config\") ):\n            shutil.move(reference_config, \"config\")\n\n    CODE\n\n    cellranger-arc \\\\\n        mkref \\\\\n        --config=config \\\\\n        --nthreads=${task.cpus} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangerarc: \\$(echo \\$( cellranger-arc --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to create fastqs needed by the 10x Genomics Cell Ranger Arc tool. Uses the cellranger-arc mkfastq command.\nTags: reference, mkfastq, fastq, illumina, bcl2fastq", "answer": "process CELLRANGERARC_MKFASTQ {\n    tag \"mkfastq\"\n    label 'process_medium'\n\n    container \"nf-core/cellranger-arc-mkfastq:2.0.2\"\n\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"CELLRANGERARC_MKFASTQ module does not support Conda. Please use docker or singularity containers.\"\n    }\n\n    input:\n    path bcl\n    path csv\n\n    output:\n    path \"versions.yml\", emit: versions\n    path \"${bcl.getSimpleName()}/outs/fastq_path/*.fastq.gz\"  , emit: fastq\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    cellranger-arc mkfastq --id=${bcl.getSimpleName()} \\\n        --run=$bcl \\\n        --csv=$csv \\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangerarc: \\$(echo \\$( cellranger-arc --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir -p \"${bcl.getSimpleName()}/outs/fastq_path/\"\n    touch ${bcl.getSimpleName()}/outs/fastq_path/fake_file.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangerarc: \\$(echo \\$( cellranger-arc --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to build a filtered gtf needed by the 10x Genomics Cell Ranger Arc tool. Uses the cellranger-arc mkgtf command.\nTags: reference, mkref, index", "answer": "process CELLRANGERARC_MKGTF {\n    tag \"$gtf\"\n    label 'process_low'\n\n    container \"nf-core/cellranger-arc:2.0.2\"\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"CELLRANGERARC_COUNT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    input:\n    path gtf\n\n    output:\n    path \"*.filtered.gtf\", emit: gtf\n    path \"versions.yml\"  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    cellranger-arc \\\\\n        mkgtf \\\\\n        $gtf \\\\\n        ${gtf.baseName}.filtered.gtf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangerarc: \\$(echo \\$( cellranger-arc --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to use Cell Ranger's ARC pipelines analyze sequencing data produced from Chromium Single Cell ARC. Uses the cellranger-arc count command.\nTags: align, count, reference", "answer": "process CELLRANGERARC_COUNT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"nf-core/cellranger-arc:2.0.2\"\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        exit 1, \"CELLRANGERARC_COUNT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    input:\n    tuple val(meta), val(sample_type), val(sub_sample), path(reads, stageAs: \"fastqs/*\")\n    path  reference\n\n    output:\n    tuple val(meta), path(\"${meta.id}/outs/**\"), emit: outs\n    path(\"${meta.id}_lib.csv\")                 , emit: lib\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def reference_name = reference.name\n    def sample_types = sample_type.join(\",\")\n    def sample_names = sub_sample.join(\",\")\n    def lib_csv = meta.id + \"_lib.csv\"\n\n    \"\"\"\n    fastq_folder=\\$(readlink -f fastqs)\n\n    python3 <<CODE\n\n    sample_types = \"${sample_types}\".split(\",\")\n    sample_names = \"${sample_names}\".split(\",\")\n    unique_samples_names = set(sample_names)\n\n    lib_csv = open(\"${lib_csv}\", \"w\")\n    lib_csv.write(\"fastqs,sample,library_type\")\n\n    for i in range(0, len(sample_types)):\n        if sample_names[i] in unique_samples_names:\n            unique_samples_names.remove(\n                sample_names[i]\n            )  # this has to be done to account for different Lane files (e.g., L002)\n            if sample_types[i] == \"gex\":\n                lib_csv.write(\"\\\\n{},{},{}\".format(\"\\${fastq_folder}\", sample_names[i], \"Gene Expression\"))\n            else:\n                lib_csv.write(\"\\\\n{},{},{}\".format(\"\\${fastq_folder}\", sample_names[i], \"Chromatin Accessibility\"))\n\n    lib_csv.close()\n\n    print(\"Wrote lib.csv file to {}\".format(\"${lib_csv}\"))\n\n    CODE\n\n    cellranger-arc \\\\\n        count \\\\\n        --id='${meta.id}' \\\\\n        --libraries=$lib_csv \\\\\n        --reference=$reference_name \\\\\n        --localcores=$task.cpus \\\\\n        --localmem=${task.memory.toGiga()} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangerarc: \\$(echo \\$( cellranger-arc --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir -p \"${meta.id}/outs/\"\n    touch ${meta.id}/outs/fake_file.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellrangerarc: \\$(echo \\$( cellranger-arc --version 2>&1) | sed 's/^.*[^0-9]\\\\([0-9]*\\\\.[0-9]*\\\\.[0-9]*\\\\).*\\$/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Unsupervised machine learning for cell type identification in multiplexed imaging using protein expression and cell neighborhood information without ground truth\nTags: highly_multiplexed_imaging, cell_type_identification, cell_phenotyping, image_analysis, mcmicro, machine_learning", "answer": "process CELESTA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    container \"ghcr.io/schapirolabor/mcmicro-celesta:v0.0.2\"\n\n    input:\n    tuple val(meta), path(img_data)\n    path(signature)\n    path(high_thresholds)\n    path(low_thresholds)\n\n    output:\n    tuple val(meta), path(\"*results.csv\"), emit: celltypes\n    path \"*quality.csv\"                  , emit: quality\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"celesta module was created only for Docker, Singularity or Podman. It does not support Conda!\"\n    }\n    def args               = task.ext.args ?: ''\n    def prefix             = task.ext.prefix ?: \"${meta.id}\"\n    def low_thresholds_cmd = low_thresholds ? \"--low $low_thresholds\" : \"\"\n    def VERSION = '1.0.0'\n\n    \"\"\"\n    Rscript /local/CELESTA_CLI.R \\\\\n        -i $img_data \\\\\n        -s $signature \\\\\n        --high $high_thresholds \\\\\n        $low_thresholds_cmd \\\\\n        -o . \\\\\n        -t $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        celesta: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"celesta module was created only for Docker, Singularity or Podman. It does not support Conda!\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.0'\n\n    \"\"\"\n    touch ${prefix}_celesta_stub_results.csv\n    touch ${prefix}_stub_quality.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        celesta: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Paraclu finds clusters in data attached to sequences.\nTags: sort", "answer": "process PARACLU {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/paraclu:10--h9a82719_1' :\n        'biocontainers/paraclu:10--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    val(min_cluster)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '10' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n\n    awk -F \"\\t\" '{print\\$1\"\\t\"\\$6\"\\t\"\\$2\"\\t\"\\$5}' < $bed > ${bed}_4P\n    sort -k1,1 -k3n ${bed}_4P > ${bed}_4Ps\n    paraclu $min_cluster ${bed}_4Ps > ${prefix}.clustered\n    paraclu-cut  ${prefix}.clustered >  ${prefix}.clustered.simplified\n    awk -F '\\t' '{print \\$1\"\\t\"\\$3\"\\t\"\\$4\"\\t\"\\$1\":\"\\$3\"..\"\\$4\",\"\\$2\"\\t\"\\$6\"\\t\"\\$2}' ${prefix}.clustered.simplified >  ${prefix}.clustered.simplified.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        paraclu: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs de novo transposable element (TE) family identification with RepeatModeler\nTags: genomics, fasta, repeat, transposable element", "answer": "process REPEATMODELER_REPEATMODELER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/repeatmodeler:2.0.5--pl5321hdfd78af_0':\n        'biocontainers/repeatmodeler:2.0.5--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(db)\n\n    output:\n    tuple val(meta), path(\"*.fa\") , emit: fasta\n    tuple val(meta), path(\"*.stk\"), emit: stk\n    tuple val(meta), path(\"*.log\"), emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def db_name = file(db[0]).getBaseName()\n    \"\"\"\n    RepeatModeler \\\\\n        -database $db_name \\\\\n        $args \\\\\n        -threads $task.cpus\n\n    mv ${db_name}-families.fa   ${prefix}.fa\n    mv ${db_name}-families.stk  ${prefix}.stk\n    mv ${db_name}-rmod.log      ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        repeatmodeler: \\$(RepeatModeler --version | sed 's/RepeatModeler version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fa\n    touch ${prefix}.stk\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        repeatmodeler: \\$(RepeatModeler --version | sed 's/RepeatModeler version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a database for RepeatModeler\nTags: genomics, fasta, repeat", "answer": "process REPEATMODELER_BUILDDATABASE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/repeatmodeler:2.0.5--pl5321hdfd78af_0':\n        'biocontainers/repeatmodeler:2.0.5--pl5321hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${prefix}.*\")    , emit: db\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    BuildDatabase \\\\\n        -name $prefix \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        repeatmodeler: \\$(RepeatModeler --version | sed 's/RepeatModeler version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.nhr\n    touch ${prefix}.nin\n    touch ${prefix}.njs\n    touch ${prefix}.nnd\n    touch ${prefix}.nni\n    touch ${prefix}.nog\n    touch ${prefix}.nsq\n    touch ${prefix}.translation\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        repeatmodeler: \\$(RepeatModeler --version | sed 's/RepeatModeler version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Identify cap locus serotype and structure in your Haemophilus influenzae assemblies\nTags: fasta, serotype, Haemophilus influenzae", "answer": "process HICAP {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hicap:1.0.3--py_0' :\n        'biocontainers/hicap:1.0.3--py_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path database_dir\n    path model_fp\n\n    output:\n    tuple val(meta), path(\"*.gbk\"), emit: gbk, optional: true\n    tuple val(meta), path(\"*.svg\"), emit: svg, optional: true\n    tuple val(meta), path(\"*.tsv\"), emit: tsv, optional: true\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def database_args = database_dir ? \"--database_dir ${database_dir}\" : \"\"\n    def model_args = model_fp ? \"--model_fp ${model_fp}\" : \"\"\n    def is_compressed = fasta.getName().endsWith(\".gz\") ? true : false\n    def fasta_name = fasta.getName().replace(\".gz\", \"\")\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n    hicap \\\\\n        --query_fp $fasta_name \\\\\n        $database_args \\\\\n        $model_args \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        -o ./\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hicap: \\$( echo \\$( hicap --version 2>&1 ) | sed 's/^.*hicap //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate the sequence-accessible coordinates in chromosomes from the given reference genome, output as a BED file.\nTags: cvnkit, access, fasta, copy number", "answer": "process CNVKIT_ACCESS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvkit:0.9.10--pyhdfd78af_0':\n        'biocontainers/cnvkit:0.9.10--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(exclude_bed)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def exclude_cmd = exclude_bed.collect{\"-x $it\"}.join(\" \")\n    \"\"\"\n    cnvkit.py \\\\\n        access \\\\\n        $fasta \\\\\n        $exclude_cmd \\\\\n        $args \\\\\n        --output ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvkit: \\$(cnvkit.py version | sed -e \"s/cnvkit v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Transform bait intervals into targets more suitable for CNVkit.\nTags: cnvkit, target, cnv, copy number", "answer": "process CNVKIT_TARGET {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvkit:0.9.10--pyhdfd78af_0':\n        'biocontainers/cnvkit:0.9.10--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(baits)\n    tuple val(meta2), path(annotation)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def annotate_cmd = annotation ? \"--annotate $annotation\" : \"\"\n    \"\"\"\n    cnvkit.py \\\\\n        target \\\\\n        $baits \\\\\n        $annotate_cmd \\\\\n        $args \\\\\n        --output ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvkit: \\$(cnvkit.py version | sed -e \"s/cnvkit v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Copy number variant detection from high-throughput sequencing data\nTags: cnvkit, bam, fasta, copy number", "answer": "process CNVKIT_GENEMETRICS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvkit:0.9.10--pyhdfd78af_0':\n        'biocontainers/cnvkit:0.9.10--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(cnr), path(cns)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    //tuple val(meta), path(\"*.cnn\"), emit: cnn\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def segments = cns ? \"--segment ${cns}\" : \"\"\n\n    \"\"\"\n    cnvkit.py \\\\\n        genemetrics \\\\\n        $cnr \\\\\n        $segments \\\\\n        --output ${prefix}.tsv \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvkit: \\$(cnvkit.py version | sed -e \"s/cnvkit v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Given segmented log2 ratio estimates (.cns), derive each segment\u2019s absolute integer copy number\nTags: cnvkit, bam, fasta, copy number", "answer": "process CNVKIT_CALL {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvkit:0.9.10--pyhdfd78af_0':\n        'biocontainers/cnvkit:0.9.10--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta) , path(cns), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.cns\"), emit: cns\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def vcf_cmd = vcf ? \"-v $vcf\" : \"\"\n    \"\"\"\n    cnvkit.py call \\\\\n        $cns \\\\\n        $vcf_cmd \\\\\n        $args \\\\\n        -o ${prefix}.cns\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvkit: \\$(cnvkit.py version | sed -e 's/cnvkit v//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Copy number variant detection from high-throughput sequencing data\nTags: cnvkit, bam, fasta, copy number", "answer": "process CNVKIT_BATCH {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-780d630a9bb6a0ff2e7b6f730906fd703e40e98f:c94363856059151a2974dc501fb07a0360cc60a3-0' :\n        'biocontainers/mulled-v2-780d630a9bb6a0ff2e7b6f730906fd703e40e98f:c94363856059151a2974dc501fb07a0360cc60a3-0' }\"\n\n    input:\n    tuple val(meta), path(tumor), path(normal)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n    tuple val(meta4), path(targets)\n    tuple val(meta5), path(reference)\n    val   panel_of_normals\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    tuple val(meta), path(\"*.cnn\"), emit: cnn, optional: true\n    tuple val(meta), path(\"*.cnr\"), emit: cnr, optional: true\n    tuple val(meta), path(\"*.cns\"), emit: cns, optional: true\n    tuple val(meta), path(\"*.pdf\"), emit: pdf, optional: true\n    tuple val(meta), path(\"*.png\"), emit: png, optional: true\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    def tumor_exists = tumor ? true : false\n    def normal_exists = normal ? true : false\n    def reference_exists = reference ? true : false\n\n    // execute samtools only when cram files are input, cnvkit runs natively on bam but is prohibitively slow\n    def tumor_cram = tumor_exists && tumor.Extension == \"cram\" ? true : false\n    def normal_cram = normal_exists && normal.Extension == \"cram\" ? true : false\n    def tumor_bam = tumor_exists && tumor.Extension == \"bam\" ? true : false\n    def normal_bam = normal_exists && normal.Extension == \"bam\" ? true : false\n\n    def tumor_out = tumor_cram ? tumor.BaseName + \".bam\" : \"${tumor}\"\n\n    // tumor_only mode does not need fasta & target\n    // instead it requires a pre-computed reference.cnn which is built from fasta & target\n    def (normal_out, normal_args, fasta_args) = [\"\", \"\", \"\"]\n    def fai_reference = fasta_fai ? \"--fai-reference ${fasta_fai}\" : \"\"\n\n    if (normal_exists){\n        def normal_prefix = normal.BaseName\n        normal_out = normal_cram ? \"${normal_prefix}\" + \".bam\" : \"${normal}\"\n        fasta_args = fasta ? \"--fasta $fasta\" : \"\"\n\n        // germline mode\n        // normal samples must be input without a flag\n        // requires flag --normal to be empty []\n        if(!tumor_exists){\n            tumor_out = \"${normal_prefix}\" + \".bam\"\n            normal_args = \"--normal \"\n        }\n        // somatic mode\n        else {\n            normal_args = normal_prefix ? \"--normal $normal_out\" : \"\"\n        }\n        if (reference_exists){\n            fasta_args = \"\"\n            normal_args = \"\"\n        }\n    }\n\n    // generation of panel of normals\n    def generate_pon = panel_of_normals ? true : false\n\n    if (generate_pon && !tumor_exists){\n        def pon_input = normal.join(' ')\n        normal_args = \"--normal $pon_input\"\n        tumor_out = \"\"\n    }\n\n    def target_args = targets && !reference_exists ? \"--targets $targets\" : \"\"\n    def reference_args = reference ? \"--reference $reference\" : \"\"\n\n    def samtools_cram_convert = ''\n    samtools_cram_convert += normal_cram ? \"    samtools view -T $fasta $fai_reference $normal -@ $task.cpus -o $normal_out\\n\" : ''\n    samtools_cram_convert += normal_cram ? \"    samtools index $normal_out\\n\" : ''\n    samtools_cram_convert += tumor_cram ? \"    samtools view -T $fasta $fai_reference $tumor -@ $task.cpus -o $tumor_out\\n\" : ''\n    samtools_cram_convert += tumor_cram ? \"    samtools index $tumor_out\\n\" : ''\n    def versions = normal_cram || tumor_cram ?\n        \"samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\\n        cnvkit: \\$(cnvkit.py version | sed -e 's/cnvkit v//g')\" :\n        \"cnvkit: \\$(cnvkit.py version | sed -e 's/cnvkit v//g')\"\n    \"\"\"\n    $samtools_cram_convert\n\n    cnvkit.py \\\\\n        batch \\\\\n        $tumor_out \\\\\n        $normal_args \\\\\n        $fasta_args \\\\\n        $reference_args \\\\\n        $target_args \\\\\n        --processes $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ${versions}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Derive off-target (\u201cantitarget\u201d) bins from target regions.\nTags: cvnkit, antitarget, cnv, copy number", "answer": "process CNVKIT_ANTITARGET {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvkit:0.9.11--pyhdfd78af_0':\n        'biocontainers/cnvkit:0.9.11--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(targets)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    cnvkit.py \\\\\n        antitarget \\\\\n        $targets \\\\\n        --output ${prefix}.antitarget.bed \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvkit: \\$(cnvkit.py version | sed -e \"s/cnvkit v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert copy number ratio tables (.cnr files) or segments (.cns) to another format.\nTags: cnvkit, copy number, export", "answer": "process CNVKIT_EXPORT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvkit:0.9.10--pyhdfd78af_0':\n        'biocontainers/cnvkit:0.9.10--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta) , path(cns)\n\n    output:\n    tuple val(meta), path(\"${prefix}.${suffix}\"), emit: output\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.args.tokenize(\" \")[0]\n    \"\"\"\n    cnvkit.py export \\\\\n        $args \\\\\n        $cns \\\\\n        -o ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvkit: \\$(cnvkit.py version | sed -e 's/cnvkit v//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compile a coverage reference from the given files (normal samples).\nTags: cnvkit, reference, cnv, copy number", "answer": "process CNVKIT_REFERENCE {\n    tag \"$fasta\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvkit:0.9.11--pyhdfd78af_0':\n        'biocontainers/cnvkit:0.9.11--pyhdfd78af_0' }\"\n\n    input:\n    path fasta\n    path targets\n    path antitargets\n\n    output:\n    path \"*.cnn\"       , emit: cnn\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: targets.BaseName\n\n    \"\"\"\n    cnvkit.py \\\\\n        reference \\\\\n        --fasta $fasta \\\\\n        --targets $targets \\\\\n        --antitargets $antitargets \\\\\n        --output ${prefix}.reference.cnn \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvkit: \\$(cnvkit.py version | sed -e \"s/cnvkit v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Mageck test performs a robust ranking aggregation (RRA) to identify positively or negatively selected genes in functional genomics screens.\nTags: sort, rra, CRISPR", "answer": "process MAGECK_TEST {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mageck:0.5.9.5--py39h1f90b4d_3':\n        'biocontainers/mageck:0.5.9.5--py39h1f90b4d_3' }\"\n\n    input:\n    tuple val(meta), path(count_table)\n\n    output:\n    tuple val(meta), path(\"*.gene_summary.txt\")  , emit: gene_summary\n    tuple val(meta), path(\"*.sgrna_summary.txt\") , emit: sgrna_summary\n    tuple val(meta), path(\"*.R\")                 , emit: r_script, optional: true\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mageck  \\\\\n        test \\\\\n        $args \\\\\n        -k $count_table \\\\\n        -n $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mageck: \\$(mageck -v)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.gene_summary.txt\n    touch ${prefix}.sgrna_summary.txt\n    touch ${prefix}.R\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mageck: \\$(mageck -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: mageck count for functional genomics, reads are usually mapped to a specific sgRNA\nTags: sort, functional genomics, sgRNA, CRISPR-Cas9", "answer": "process MAGECK_COUNT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mageck:0.5.9.5--py39h1f90b4d_3':\n        'biocontainers/mageck:0.5.9.5--py39h1f90b4d_3' }\"\n\n    input:\n    tuple val(meta), path(inputfile)\n    path(library)\n\n    output:\n    tuple val(meta), path(\"*count.txt\")           , emit: count\n    tuple val(meta), path(\"*.count_normalized.txt\"), emit: norm\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_file = (\"$inputfile\".endsWith(\".fastq.gz\")) ? \"--fastq ${inputfile}\" : \"-k ${inputfile}\"\n    def sample_label = (\"$inputfile\".endsWith(\".fastq.gz\") || \"$inputfile\".endsWith(\".fq.gz\")) ? \"--sample-label ${meta.id}\" : ''\n\n    \"\"\"\n    mageck \\\\\n        count \\\\\n        $args \\\\\n        -l $library \\\\\n        -n $prefix \\\\\n        $sample_label \\\\\n        $input_file \\\\\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mageck: \\$(mageck -v)\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_file = (\"$inputfile\".endsWith(\".fastq.gz\")) ? \"--fastq ${inputfile}\" : \"-k ${inputfile}\"\n    def sample_label = (\"$inputfile\".endsWith(\".fastq.gz\") || \"$inputfile\".endsWith(\".fq.gz\")) ? \"--sample-label ${meta.id}\" : ''\n    \"\"\"\n    touch ${prefix}.count.txt\n    touch ${prefix}.count_normalized.txt\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mageck: \\$(mageck -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: maximum-likelihood analysis of gene essentialities computation\nTags: sort, maximum-likelihood, CRISPR", "answer": "process MAGECK_MLE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mageck:0.5.9.5--py39h1f90b4d_3':\n        'biocontainers/mageck:0.5.9.5--py39h1f90b4d_3' }\"\n\n    input:\n    tuple val(meta), path(count_table)\n    path(design_matrix)\n\n    output:\n    tuple val(meta), path(\"*.gene_summary.txt\") , emit: gene_summary\n    tuple val(meta), path(\"*.sgrna_summary.txt\"), emit: sgrna_summary\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mageck \\\\\n        mle \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        -k $count_table \\\\\n        -d $design_matrix \\\\\n        -n $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mageck: \\$(mageck -v)\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.gene_summary.txt\n    touch ${prefix}.sgrna_summary.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mageck: \\$(mageck -v)\n    END_VERSIONS\n    \"\"\"\n\n\n}\n"}
{"question": "Description: Given baseline and comparison sets of variants, calculate the recall/precision/f-measure\nTags: structural variants, sv, vcf, benchmark, comparison", "answer": "process TRUVARI_BENCH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/truvari:4.1.0--pyhdfd78af_0':\n        'biocontainers/truvari:4.1.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(truth_vcf), path(truth_tbi), path(bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.fn.vcf.gz\")            , emit: fn_vcf\n    tuple val(meta), path(\"*.fn.vcf.gz.tbi\")        , emit: fn_tbi\n    tuple val(meta), path(\"*.fp.vcf.gz\")            , emit: fp_vcf\n    tuple val(meta), path(\"*.fp.vcf.gz.tbi\")        , emit: fp_tbi\n    tuple val(meta), path(\"*.tp-base.vcf.gz\")       , emit: tp_base_vcf\n    tuple val(meta), path(\"*.tp-base.vcf.gz.tbi\")   , emit: tp_base_tbi\n    tuple val(meta), path(\"*.tp-comp.vcf.gz\")       , emit: tp_comp_vcf\n    tuple val(meta), path(\"*.tp-comp.vcf.gz.tbi\")   , emit: tp_comp_tbi\n    tuple val(meta), path(\"*.summary.json\")         , emit: summary\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions = bed ? \"--includebed $bed\" : \"\"\n\n    \"\"\"\n    truvari bench \\\\\n        --base ${truth_vcf} \\\\\n        --comp ${vcf} \\\\\n        --reference ${fasta} \\\\\n        --output ${prefix} \\\\\n        ${regions} \\\\\n        ${args}\n\n    mv ${prefix}/fn.vcf.gz          ./${prefix}.fn.vcf.gz\n    mv ${prefix}/fn.vcf.gz.tbi      ./${prefix}.fn.vcf.gz.tbi\n    mv ${prefix}/fp.vcf.gz          ./${prefix}.fp.vcf.gz\n    mv ${prefix}/fp.vcf.gz.tbi      ./${prefix}.fp.vcf.gz.tbi\n    mv ${prefix}/tp-base.vcf.gz     ./${prefix}.tp-base.vcf.gz\n    mv ${prefix}/tp-base.vcf.gz.tbi ./${prefix}.tp-base.vcf.gz.tbi\n    mv ${prefix}/tp-comp.vcf.gz     ./${prefix}.tp-comp.vcf.gz\n    mv ${prefix}/tp-comp.vcf.gz.tbi ./${prefix}.tp-comp.vcf.gz.tbi\n    mv ${prefix}/summary.json       ./${prefix}.summary.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        truvari: \\$(echo \\$(truvari version 2>&1) | sed 's/^Truvari v//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.fn.vcf.gz\n    touch ${prefix}.fn.vcf.gz.tbi\n    touch ${prefix}.fp.vcf.gz\n    touch ${prefix}.fp.vcf.gz.tbi\n    touch ${prefix}.tp-base.vcf.gz\n    touch ${prefix}.tp-base.vcf.gz.tbi\n    touch ${prefix}.tp-comp.vcf.gz\n    touch ${prefix}.tp-comp.vcf.gz.tbi\n    touch ${prefix}.summary.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        truvari: \\$(echo \\$(truvari version 2>&1) | sed 's/^Truvari v//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Normalization of SVs into disjointed genomic regions\nTags: structural variants, sv, vcf, benchmark, normalization", "answer": "process TRUVARI_SEGMENT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/truvari:4.1.0--pyhdfd78af_0':\n        'biocontainers/truvari:4.1.0--pyhdfd78af_0' }\"\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    truvari \\\\\n        segment \\\\\n        -o ${prefix}.vcf \\\\\n        $args \\\\\n        $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        truvari: \\$(echo \\$(truvari version 2>&1) | sed 's/^Truvari v//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        truvari: \\$(echo \\$(truvari version 2>&1) | sed 's/^Truvari v//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Over multiple vcfs, calculate their intersection/consistency.\nTags: structural variants, sv, vcf, intersection, comparison", "answer": "\nprocess TRUVARI_CONSISTENCY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/truvari:4.1.0--pyhdfd78af_0':\n        'biocontainers/truvari:4.1.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcfs)\n\n    output:\n    tuple val(meta), path(\"*.{txt,json}\") , emit: consistency\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"-j\") ? \"json\" : \"txt\"\n\n    \"\"\"\n    truvari \\\\\n        consistency \\\\\n        $args \\\\\n        $vcfs > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        truvari: \\$(echo \\$(truvari version 2>&1) | sed 's/^Truvari v//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"-j\") ? \"json\" : \"txt\"\n\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        truvari: \\$(echo \\$(truvari version 2>&1) | sed 's/^Truvari v//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Query metadata for any taxon across the tree of life.\nTags: public datasets, ncbi, genomes on a tree", "answer": "process GOAT_TAXONSEARCH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/goat:0.2.5--h9d3141d_2':\n        'biocontainers/goat:0.2.5--h9d3141d_2' }\"\n\n    input:\n    tuple val(meta), val(taxon), path(taxa_file)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: taxonsearch\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    input = taxa_file ? \"-f ${taxa_file}\" : \"-t \\\"${taxon}\\\"\"\n    if (!taxon && !taxa_file) error \"No input. Valid input: single taxon identifier or a .txt file with identifiers\"\n    if (taxon && taxa_file ) error \"Only one input is required: a single taxon identifier or a .txt file with identifiers\"\n    \"\"\"\n    goat-cli taxon search \\\\\n        $args \\\\\n        $input > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        goat: \\$(goat-cli --version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: the revseq program from emboss reverse complements a nucleotide sequence\nTags: nucleotides, reverse complement, sequences", "answer": "process EMBOSS_REVSEQ {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/emboss:6.6.0--h86d058a_5':\n        'biocontainers/emboss:6.6.0--h86d058a_5' }\"\n\n    input:\n    tuple val(meta), path(sequences)\n\n    output:\n    tuple val(meta), path(\"*.${sequences.name - ~/.*\\./}\"), emit: revseq\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = sequences.name - ~/.*\\./\n    def outfile = \"${prefix}.rev.${suffix}\"\n    \"\"\"\n    revseq \\\\\n        $args \\\\\n        $sequences \\\\\n        $outfile\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        emboss: \\$(echo \\$(revseq -version 2>&1) | sed 's/EMBOSS://')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = sequences.name - ~/.*\\./\n    def outfile = \"${prefix}.rev.${suffix}\"\n    \"\"\"\n    touch ${outfile}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        emboss: \\$(echo \\$(revseq -version 2>&1) | sed 's/EMBOSS://')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Reads in one or more sequences, converts, filters, or transforms them and writes them out again\nTags: emboss, gff, embl, genbank, fasta, convert, swissprot", "answer": "process EMBOSS_SEQRET {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/emboss:6.6.0--hf657eab_5':\n        'biocontainers/emboss:6.6.0--h440b012_4' }\"\n\n    input:\n    tuple val(meta), path(sequence)\n    val out_ext\n\n    output:\n    tuple val(meta), path(\"*.${out_ext}\"), emit: outseq\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def osformat = args.contains('-osformat') ? '' : \"-osformat ${out_ext}\"\n    \"\"\"\n    seqret \\\\\n        ${args} \\\\\n        -sequence ${sequence} \\\\\n        ${osformat} \\\\\n        -outseq ${prefix}.${out_ext}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        emboss: \\$(echo \\$(seqret -version 2>&1) | sed 's/EMBOSS://')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: cons calculates a consensus sequence from a multiple sequence alignment. To obtain the consensus, the sequence weights and a scoring matrix are used to calculate a score for each amino acid residue or nucleotide at each position in the alignment.\nTags: emboss, consensus, fasta, multiple sequence alignment, MSA", "answer": "process EMBOSS_CONS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/emboss:6.6.0--h86d058a_5':\n        'biocontainers/emboss:6.6.0--h86d058a_5' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.fa\") , emit: consensus\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$fasta\" == \"${prefix}.fa\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    cons \\\\\n        ${args} \\\\\n        -name ${prefix} \\\\\n        -sequence $fasta \\\\\n        -outseq ${prefix}.fa \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        emboss: \\$(echo \\$(cons -version 2>&1) | sed 's/EMBOSS://')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n    if (\"$fasta\" == \"${prefix}.fa\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.fa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        emboss: \\$(echo \\$(cons -version 2>&1) | sed 's/EMBOSS://')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tools for population-scale genotyping using pangenome graphs.\nTags: combine, concatenate, variant, vcf", "answer": "process GRAPHTYPER_VCFCONCATENATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/graphtyper:2.7.2--h7d7f7ad_0':\n        'biocontainers/graphtyper:2.7.2--h7d7f7ad_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")                , emit: tbi\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$vcf\" == \"${prefix}.vcf.gz\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n    \"\"\"\n    graphtyper vcf_concatenate \\\\\n        $vcf \\\\\n        $args \\\\\n        --write_tbi \\\\\n        --output=${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        graphtyper: \\$(graphtyper --help | tail -n 1 | sed 's/^   //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tools for population-scale genotyping using pangenome graphs.\nTags: variant, vcf, bam, cram, pangenome", "answer": "process GRAPHTYPER_GENOTYPE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/graphtyper:2.7.2--h7d7f7ad_0':\n        'biocontainers/graphtyper:2.7.2--h7d7f7ad_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(ref)\n    tuple val(meta3), path(ref_fai)\n    path region_file  // can be empty if --region is supplied to task.ext.args\n\n    output:\n    tuple val(meta), path(\"results/*/*.vcf.gz\"), emit: vcf\n    tuple val(meta), path(\"results/*/*.vcf.gz.tbi\"), emit: tbi\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bam_path_text = bam.join('\\\\n')\n    def region_text = region_file.size() > 0 ? \"--region_file ${region_file}\" : \"\"\n    if (region_file.size() == 0 && ! args.contains(\"region\")) {\n        error \"GRAPHTYPER_GENOTYPE requires either a region file or a region specified using '--region' in ext.args\"\n    }\n    \"\"\"\n    printf \"$bam_path_text\" > bam_list.txt\n    graphtyper \\\\\n        genotype \\\\\n        $ref \\\\\n        $args \\\\\n        --sams bam_list.txt \\\\\n        --threads $task.cpus \\\\\n        $region_text\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        graphtyper: \\$(graphtyper --help | tail -n 1 | sed 's/^   //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Pixel-by-pixel channel subtraction scaled by exposure times of pre-stitched `tif` images.\nTags: background, cycif, autofluorescence, image_analysis, mcmicro, highly_multiplexed_imaging", "answer": "process BACKSUB {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"ghcr.io/schapirolabor/background_subtraction:v0.4.1\"\n\n    input:\n    tuple val(meta) , path(image)\n    tuple val(meta2), path(markerfile)\n\n    output:\n    tuple val(meta), path(\"*.ome.tif\"), emit: backsub_tif\n    tuple val(meta2), path(\"*.csv\")   , emit: markerout\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Backsub module in conda does not exist. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$image\" == \"${prefix}.ome.tif\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    python3 /background_subtraction/background_sub.py \\\n        -o \"${prefix}.ome.tif\" \\\n        -mo \"${prefix}.csv\" \\\n        -r $image \\\n        -m $markerfile \\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        backsub: \\$(python3 /background_subtraction/background_sub.py --version | sed 's/v//g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Backsub module in conda does not exist. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.ome.tif\"\n    touch \"${prefix}.csv\"\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        backsub: \\$(python3 /background_subtraction/background_sub.py --version | sed 's/v//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produces protein annotations and predictions from an amino acids FASTA file\nTags: annotation, fasta, protein, dna, interproscan", "answer": "process INTERPROSCAN {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/interproscan:5.59_91.0--hec16e2b_1' :\n        'biocontainers/interproscan:5.59_91.0--hec16e2b_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path(interproscan_database, stageAs: 'data')\n\n    output:\n    tuple val(meta), path('*.tsv') , optional: true, emit: tsv\n    tuple val(meta), path('*.xml') , optional: true, emit: xml\n    tuple val(meta), path('*.gff3'), optional: true, emit: gff3\n    tuple val(meta), path('*.json'), optional: true, emit: json\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.name.endsWith(\".gz\")\n    def fasta_name = fasta.name.replace(\".gz\", \"\")\n    \"\"\"\n    if [ -d 'data' ]; then\n        # Find interproscan.properties to link data/ from work directory\n        INTERPROSCAN_DIR=\"\\$( dirname \"\\$( dirname \"\\$( which interproscan.sh )\" )\" )\"\n        INTERPROSCAN_PROPERTIES=\"\\$( find \"\\$INTERPROSCAN_DIR/share\" -name \"interproscan.properties\" )\"\n        cp \"\\$INTERPROSCAN_PROPERTIES\" .\n        sed -i \"/^bin\\\\.directory=/ s|.*|bin.directory=\\$INTERPROSCAN_DIR/bin|\" interproscan.properties\n        export INTERPROSCAN_CONF=interproscan.properties\n    fi # else use sample DB included with conda ( testing only! )\n\n    if ${is_compressed} ; then\n        gzip -c -d ${fasta} > ${fasta_name}\n    fi\n\n    interproscan.sh \\\\\n        --cpu ${task.cpus} \\\\\n        --input ${fasta_name} \\\\\n        ${args} \\\\\n        --output-file-base ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        interproscan: \\$( interproscan.sh --version | sed '1!d; s/.*version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.{tsv,xml,json,gff3}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        interproscan: \\$( interproscan.sh --version | sed '1!d; s/.*version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Builds a classic bloom filter COBS index\nTags: COBS, index, k-mer index, bloom filter", "answer": "process COBS_CLASSICCONSTRUCT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cobs:0.3.0--hdcf5f25_1' :\n        'biocontainers/cobs:0.3.0--hdcf5f25_1'}\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.index.cobs_classic\")   , emit: index\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def task_memory_in_bytes = task.memory.toBytes()\n    \"\"\"\n    cobs \\\\\n        classic-construct \\\\\n        $args \\\\\n        --memory $task_memory_in_bytes \\\\\n        --threads $task.cpus \\\\\n        $input \\\\\n        ${prefix}.index.cobs_classic\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cobs: \\$(cobs version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.index.cobs_classic\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cobs: \\$(cobs version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Builds a compact bloom filter COBS index\nTags: COBS, index, k-mer index, bloom filter", "answer": "process COBS_COMPACTCONSTRUCT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cobs:0.3.0--hdcf5f25_1' :\n        'biocontainers/cobs:0.3.0--hdcf5f25_1'}\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.index.cobs_compact\"), emit: index\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def task_memory_in_bytes = task.memory.toBytes()\n    \"\"\"\n    cobs \\\\\n        compact-construct \\\\\n        $args \\\\\n        --memory $task_memory_in_bytes \\\\\n        --threads $task.cpus \\\\\n        $input \\\\\n        ${prefix}.index.cobs_compact\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cobs: \\$(cobs version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.index.cobs_compact\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cobs: \\$(cobs version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Mcquant extracts single-cell data given a multi-channel image and a segmentation mask.\nTags: quantification, image_analysis, mcmicro, highly_multiplexed_imaging", "answer": "process MCQUANT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container \"nf-core/quantification:1.5.4\"\n\n    input:\n    tuple val(meta), path(image)\n    tuple val(meta2), path(mask)\n    tuple val(meta3), path(markerfile)\n\n    output:\n    tuple val(meta), path(\"*.csv\"), emit: csv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.5.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    python /app/CommandSingleCellExtraction.py \\\n        --masks $mask \\\n        --image $image \\\n        --channel_names $markerfile \\\n        --output . \\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mcquant: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.5.4'\n    \"\"\"\n    touch ${prefix}.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mcquant: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A versatile pairwise aligner for genomic and spliced nucleotide sequences\nTags: align, fasta, protein, genome, paf, gff", "answer": "process MINIPROT_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/miniprot:0.11--he4a0461_2':\n        'biocontainers/miniprot:0.11--he4a0461_2' }\"\n\n    input:\n    tuple val(meta), path(pep)\n    tuple val(meta2), path(ref)\n\n    output:\n    tuple val(meta), path(\"*.paf\"), optional: true, emit: paf\n    tuple val(meta), path(\"*.gff\"), optional: true, emit: gff\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--gff\") ? \"gff\" : \"paf\"\n    \"\"\"\n    miniprot \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        ${ref} \\\\\n        ${pep} \\\\\n        > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        miniprot: \\$(miniprot --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--gff\") ? \"gff\" : \"paf\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        miniprot: \\$(miniprot --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Provides fasta index required by miniprot alignment.\nTags: index, fasta, genome, reference", "answer": "process MINIPROT_INDEX {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/miniprot:0.11--he4a0461_2':\n        'biocontainers/miniprot:0.11--he4a0461_2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.mpi\"), emit: index\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    miniprot \\\\\n        -t $task.cpus \\\\\n        -d ${fasta.baseName}.mpi \\\\\n        $args \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        miniprot: \\$(miniprot --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${fasta.baseName}.mpi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        miniprot: \\$(miniprot --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Call variants for a given scenario specified with the varlociraptor calling grammar, preprocessed by varlociraptor preprocessing\nTags: observations, variants, calling", "answer": "process VARLOCIRAPTOR_CALLVARIANTS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/varlociraptor:8.1.1--hc349b7f_0':\n        'biocontainers/varlociraptor:8.1.1--hc349b7f_0' }\"\n\n    input:\n    tuple val(meta), path(normal_vcf), path(tumor_vcf)\n    path (scenario)\n    val (scenario_sample_name)\n\n    output:\n    tuple val(meta), path(\"*.bcf.gz\"), emit: bcf_gz, optional: true\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf_gz, optional: true\n    tuple val(meta), path(\"*.bcf\")   , emit: bcf   , optional: true\n    tuple val(meta), path(\"*.vcf\")   , emit: vcf   , optional: true\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}.vcf.gz\"\n\n    //If we use a scenario file and if there is more than 1 normal vcf, then collect scenario_sample_name and normal vcf to scenario_sample_name_0=normal_vcf_0 scenario_sample_name_1=normal_vcf_1, etc\n    //If we use a scenario file and if there is exactly 1 normal vcf, then scenario_sample_name=normal_vcf\n    //Else do nothing\n    def scenario_samples = normal_vcf instanceof List &&  normal_vcf.size() > 1 ? [scenario_sample_name,normal_vcf].transpose().collect{\"${it[0]}=${it[1]}\"}.join(' ') : \"${scenario_sample_name}=${normal_vcf}\"\n\n    //If no scenario is provided, fall back to tumor-normal paired calling\n    def scenario_command =  scenario ? \"generic --scenario $scenario --obs ${scenario_samples}\" : \"tumor-normal --tumor ${tumor_vcf} --normal ${normal_vcf}\"\n\n    \"\"\"\n    varlociraptor call variants \\\\\n        --output ${prefix} \\\\\n        ${scenario_command} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        varlociraptor: \\$(echo \\$(varlociraptor --version 2>&1) | sed 's/^.*varlociraptor //; s/:.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Obtains per-sample observations for the actual calling process with varlociraptor calls\nTags: observations, variants, preprocessing", "answer": "process VARLOCIRAPTOR_PREPROCESS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/varlociraptor:8.1.1--hc349b7f_0':\n        'biocontainers/varlociraptor:8.1.1--hc349b7f_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(candidates), path(alignment_json)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.bcf.gz\"), emit: bcf_gz, optional: true\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf_gz, optional: true\n    tuple val(meta), path(\"*.bcf\")   , emit: bcf   , optional: true\n    tuple val(meta), path(\"*.vcf\")   , emit: vcf   , optional: true\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}.vcf.gz\"\n    def alignment_properties_json = alignment_json ? \"--alignment-properties ${alignment_json}\" : \"\"\n    \"\"\"\n    varlociraptor preprocess variants \\\\\n        $fasta \\\\\n        $alignment_properties_json \\\\\n        --bam $bam \\\\\n        --candidates $candidates \\\\\n        ${args} \\\\\n        > ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        varlociraptor: \\$(echo \\$(varlociraptor --version 2>&1) | sed 's/^.*varlociraptor //; s/:.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: In order to judge about candidate indel and structural variants, Varlociraptor needs to know about certain properties of the underlying sequencing experiment in combination with the used read aligner.\nTags: estimation, alignment, variants", "answer": "process VARLOCIRAPTOR_ESTIMATEALIGNMENTPROPERTIES {\n    tag \"$meta.id\"\n    label 'process_single'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/varlociraptor:8.1.1--hc349b7f_0':\n        'biocontainers/varlociraptor:8.1.1--hc349b7f_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.alignment-properties.json\"), emit: alignment_properties_json\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    varlociraptor estimate alignment-properties \\\\\n        $fasta \\\\\n        --bam $bam \\\\\n        $args \\\\\n        > ${prefix}.alignment-properties.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        varlociraptor: \\$(echo \\$(varlociraptor --version 2>&1) | sed 's/^.*varlociraptor //; s/:.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Transcript Selector for BRAKER TSEBRA combines gene predictions by selecing transcripts based on their extrisic evidence support\nTags: genomics, transcript, selector, gene, prediction, evidence", "answer": "process TSEBRA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/tsebra:1.1.2.5--pyhca03a8a_0':\n        'biocontainers/tsebra:1.1.2.5--pyhca03a8a_0' }\"\n\n    input:\n    tuple val(meta), path(gtfs)\n    path hints_files\n    path keep_gtfs\n    path config\n\n    output:\n    tuple val(meta), path(\"*.gtf\"), emit: tsebra_gtf\n    tuple val(meta), path(\"*.tsv\"), emit: tsebra_scores\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args                                     ?: ''\n    def prefix      = task.ext.prefix                                   ?: \"${meta.id}\"\n    def gtf_arg     = '-g ' + gtfs.collect { \"$it\" }.join(',')\n    def hints_arg   = '-e ' + hints_files.collect { \"$it\" }.join(',')\n    def keep_arg    = keep_gtfs                                         ? ( '-k ' + keep_gtfs.collect { \"$it\" }.join(',') ) : ''\n    def config_arg  = config                                            ? \"-c $config\"                                      : ''\n    def VERSION     = '1.1.2.5' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    tsebra.py \\\\\n        $gtf_arg \\\\\n        $hints_arg \\\\\n        $keep_arg \\\\\n        $config_arg \\\\\n        $args \\\\\n        -o ${prefix}.gtf \\\\\n        -s ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tsebra: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args        = task.ext.args     ?: ''\n    def prefix      = task.ext.prefix   ?: \"${meta.id}\"\n    def VERSION     = '1.1.2.5' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.gtf\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tsebra: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compresses files with xz.\nTags: xz, compression, archive", "answer": "process XZ_COMPRESS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-796b0610595ad1995b121d0b85375902097b78d4:a3a3220eb9ee55710d743438b2ab9092867c98c6-0' :\n        'biocontainers/mulled-v2-796b0610595ad1995b121d0b85375902097b78d4:a3a3220eb9ee55710d743438b2ab9092867c98c6-0' }\"\n\n    input:\n    tuple val(meta), path(raw_file)\n\n    output:\n    tuple val(meta), path(\"$archive\"), emit: archive\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    archive = raw_file.toString() + \".xz\"\n    \"\"\"\n    # needs --stdout for xz to avoid the following issue:\n    # xz: ${raw_file}: Is a symbolic link, skipping\n    xz -T $task.cpus --stdout ${args} ${raw_file} > ${archive}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        xz: \\$(xz --version | head -n1 | awk '{print \\$NF}')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    archive = raw_file.toString() + \".xz\"\n    \"\"\"\n    touch \"${archive}\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        xz: \\$(xz --version | head -n1 | awk '{print \\$NF}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Decompresses files with xz.\nTags: xz, decompression, compression", "answer": "process XZ_DECOMPRESS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-796b0610595ad1995b121d0b85375902097b78d4:a3a3220eb9ee55710d743438b2ab9092867c98c6-0' :\n        'biocontainers/mulled-v2-796b0610595ad1995b121d0b85375902097b78d4:a3a3220eb9ee55710d743438b2ab9092867c98c6-0' }\"\n\n    input:\n    tuple val(meta), path(archive)\n\n    output:\n    tuple val(meta), path(\"$decompressed_file\"), emit: file\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    decompressed_file = archive.toString().replaceAll(\".xz\\$\", \"\")\n    \"\"\"\n    # Note 1: needs --stdout for xz --decompress to avoid two issues:\n    #   1. xz: ${archive}: Is a symbolic link, skipping\n    #   2. xz: ${archive}: Cannot set the file group: Operation not permitted\n    # Note 2: using several threads in xz --decompress will only work on files that contain multiple blocks with size\n    # information in block headers.  All files compressed in multi-threaded mode meet this condition.\n    xz -T ${task.cpus} --decompress --stdout ${args} ${archive} > ${decompressed_file}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        xz: \\$(xz --version | head -n1 | awk '{print \\$NF}')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    decompressed_file = archive.toString().replaceAll(\".xz\\$\", \"\")\n    \"\"\"\n    touch \"${decompressed_file}\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        xz: \\$(xz --version | head -n1 | awk '{print \\$NF}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: gcCounter function from HMMcopy utilities, used to generate GC content in non-overlapping windows from a fasta reference\nTags: hmmcopy, gccounter, cnv", "answer": "process HMMCOPY_GCCOUNTER {\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmcopy:0.1.1--h2e03b76_7' :\n        'biocontainers/hmmcopy:0.1.1--h2e03b76_7' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.wig\"), emit: wig\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    gcCounter \\\\\n        $args \\\\\n        ${fasta} > ${prefix}.wig\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmcopy: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: readCounter function from HMMcopy utilities, used to generate read in windows\nTags: hmmcopy, readcounter, cnv", "answer": "process HMMCOPY_READCOUNTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmcopy:0.1.1--h2e03b76_7' :\n        'biocontainers/hmmcopy:0.1.1--h2e03b76_7' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path(\"*.wig\"), emit: wig\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    readCounter \\\\\n        $args \\\\\n        ${bam} > ${prefix}.wig\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmcopy: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Perl script (generateMap.pl) generates the mappability of a genome given a certain size of reads, for input to hmmcopy mapcounter. Takes a very long time on large genomes, is not parallelised at all.\nTags: hmmcopy, mapcounter, mappability", "answer": "process HMMCOPY_GENERATEMAP {\n    tag \"$bam\"\n    label 'process_long'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmcopy:0.1.1--h2e03b76_7':\n        'biocontainers/hmmcopy:0.1.1--h2e03b76_7' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bw\"), emit: bigwig\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    # build required indexes\n    generateMap.pl -b \\\\\n        $args \\\\\n        $fasta\n\n    # run\n    generateMap.pl \\\\\n        $args \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmcopy: \\$(echo $VERSION)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: mapCounter function from HMMcopy utilities, used to generate mappability in non-overlapping windows from a bigwig file\nTags: hmmcopy, mapcounter, cnv", "answer": "process HMMCOPY_MAPCOUNTER {\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmcopy:0.1.1--h2e03b76_7':\n        'biocontainers/hmmcopy:0.1.1--h2e03b76_7' }\"\n\n    input:\n    tuple val(meta), path(bigwig)\n\n    output:\n    tuple val(meta), path(\"*.wig\"), emit: wig\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    mapCounter \\\\\n        $args \\\\\n        $bigwig > ${prefix}.wig\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmcopy: \\$(echo $VERSION)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Screen assemblies for antimicrobial resistance against multiple databases\nTags: bacteria, assembly, antimicrobial resistance", "answer": "process ABRICATE_RUN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/abricate%3A1.0.1--ha8f3691_1':\n        'biocontainers/abricate:1.0.1--ha8f3691_1' }\"\n\n    input:\n    tuple val(meta), path(assembly)\n    path databasedir\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: report\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def datadir = databasedir ? \"--datadir ${databasedir}\" : ''\n    \"\"\"\n    abricate \\\\\n        $assembly \\\\\n        $args \\\\\n        $datadir \\\\\n        --threads $task.cpus \\\\\n        > ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        abricate: \\$(echo \\$(abricate --version 2>&1) | sed 's/^.*abricate //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def datadir = databasedir ? '--datadir ${databasedir}' : ''\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        abricate: \\$(echo \\$(abricate --version 2>&1) | sed 's/^.*abricate //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Screen assemblies for antimicrobial resistance against multiple databases\nTags: bacteria, assembly, antimicrobial reistance", "answer": "process ABRICATE_SUMMARY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/abricate%3A1.0.1--ha8f3691_1':\n        'biocontainers/abricate:1.0.1--ha8f3691_1' }\"\n\n    input:\n    tuple val(meta), path(reports)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: report\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    abricate \\\\\n        --summary \\\\\n        $reports > ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        abricate: \\$(echo \\$(abricate --version 2>&1) | sed 's/^.*abricate //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Bayesian reconstruction of ancient DNA fragments\nTags: ancient DNA, adapter removal, clipping, trimming, merging, collapsing, preprocessing, bayesian", "answer": "process LEEHOM {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/leehom:1.2.15--h29e30f7_1' :\n        'biocontainers/leehom:1.2.15--h29e30f7_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\")          , optional: true, emit: bam\n    tuple val(meta), path(\"${prefix}.fq.gz\")        , optional: true, emit: fq_pass\n    tuple val(meta), path(\"${prefix}.fail.fq.gz\")   , optional: true, emit: fq_fail\n    tuple val(meta), path(\"${prefix}_r1.fq.gz\")     , optional: true, emit: unmerged_r1_fq_pass\n    tuple val(meta), path(\"${prefix}_r1.fail.fq.gz\"), optional: true, emit: unmerged_r1_fq_fail\n    tuple val(meta), path(\"${prefix}_r2.fq.gz\")     , optional: true, emit: unmerged_r2_fq_pass\n    tuple val(meta), path(\"${prefix}_r2.fail.fq.gz\"), optional: true, emit: unmerged_r2_fq_fail\n    tuple val(meta), path(\"*.log\")                                  , emit: log\n    path \"versions.yml\"                                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2.15' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    if (reads.toString().endsWith('.bam')) {\n        \"\"\"\n        leeHom \\\\\n            $args \\\\\n            -t $task.cpus \\\\\n            -o ${prefix}.bam \\\\\n            --log ${prefix}.log \\\\\n            $reads\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            leehom: $VERSION\n        END_VERSIONS\n        \"\"\"\n    } else if (meta.single_end) {\n        \"\"\"\n        leeHom \\\\\n            $args \\\\\n            -t $task.cpus \\\\\n            -fq1 $reads \\\\\n            -fqo $prefix \\\\\n            --log ${prefix}.log\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            leehom: $VERSION\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        leeHom \\\\\n            $args \\\\\n            -t $task.cpus \\\\\n            -fq1 ${reads[0]} \\\\\n            -fq2 ${reads[1]} \\\\\n            -fqo $prefix \\\\\n            --log ${prefix}.log\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            leehom: $VERSION\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Tool to summarize and combine all hAMRonization reports into a single file\nTags: amr, antimicrobial resistance, reporting", "answer": "process HAMRONIZATION_SUMMARIZE {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hamronization:1.1.4--pyhdfd78af_0':\n        'biocontainers/hamronization:1.1.4--pyhdfd78af_0' }\"\n\n    input:\n    path(reports)\n    val(format)\n\n    output:\n    path(\"hamronization_combined_report.json\"), optional: true, emit: json\n    path(\"hamronization_combined_report.tsv\") , optional: true, emit: tsv\n    path(\"hamronization_combined_report.html\"), optional: true, emit: html\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def outformat = format == 'interactive' ? 'html' : format\n    \"\"\"\n    hamronize \\\\\n        summarize \\\\\n        ${reports.join(' ')} \\\\\n        -t ${format} \\\\\n        $args \\\\\n        -o hamronization_combined_report.${outformat}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def outformat = format == 'interactive' ? 'html' : format\n    \"\"\"\n    touch hamronization_combined_report.${outformat}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool to convert and summarize ABRicate outputs using the hAMRonization specification\nTags: amr, antimicrobial resistance, reporting, abricate", "answer": "process HAMRONIZATION_ABRICATE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hamronization:1.1.4--pyhdfd78af_0':\n        'biocontainers/hamronization:1.1.4--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(report)\n    val(format)\n    val(software_version)\n    val(reference_db_version)\n\n    output:\n    tuple val(meta), path(\"*.json\"), optional: true, emit: json\n    tuple val(meta), path(\"*.tsv\") , optional: true, emit: tsv\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    hamronize \\\\\n        abricate \\\\\n        ${report} \\\\\n        $args \\\\\n        --format ${format} \\\\\n        --analysis_software_version ${software_version} \\\\\n        --reference_database_version ${reference_db_version} \\\\\n        > ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool to convert and summarize DeepARG outputs using the hAMRonization specification\nTags: amr, antimicrobial resistance, reporting, deeparg", "answer": "process HAMRONIZATION_DEEPARG {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hamronization:1.1.4--pyhdfd78af_0':\n        'biocontainers/hamronization:1.1.4--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(report)\n    val(format)\n    val(software_version)\n    val(reference_db_version)\n\n    output:\n    tuple val(meta), path(\"*.json\"), optional: true, emit: json\n    tuple val(meta), path(\"*.tsv\") , optional: true, emit: tsv\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    hamronize \\\\\n        deeparg \\\\\n        ${report} \\\\\n        $args \\\\\n        --format ${format} \\\\\n        --analysis_software_version ${software_version} \\\\\n        --reference_database_version ${reference_db_version} \\\\\n        --input_file_name ${prefix} \\\\\n        > ${prefix}.${format}\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool to convert and summarize RGI outputs using the hAMRonization specification.\nTags: amr, antimicrobial resistance, arg, antimicrobial resistance genes, reporting, rgi", "answer": "process HAMRONIZATION_RGI {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hamronization:1.1.4--pyhdfd78af_0':\n        'biocontainers/hamronization:1.1.4--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(report)\n    val(format)\n    val(software_version)\n    val(reference_db_version)\n\n    output:\n    tuple val(meta), path(\"*.json\") , optional: true, emit: json\n    tuple val(meta), path(\"*.tsv\")  , optional: true, emit: tsv\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    hamronize \\\\\n        rgi \\\\\n        ${report} \\\\\n        $args \\\\\n        --format ${format} \\\\\n        --analysis_software_version ${software_version} \\\\\n        --reference_database_version ${reference_db_version} \\\\\n        --input_file_name ${prefix} \\\\\n        > ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool to convert and summarize AMRfinderPlus outputs using the hAMRonization specification.\nTags: amr, antimicrobial resistance, arg, antimicrobial resistance genes, reporting, amrfinderplus", "answer": "process HAMRONIZATION_AMRFINDERPLUS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hamronization:1.1.4--pyhdfd78af_0':\n        'biocontainers/hamronization:1.1.4--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(report)\n    val(format)\n    val(software_version)\n    val(reference_db_version)\n\n    output:\n    tuple val(meta), path(\"*.json\") , optional: true, emit: json\n    tuple val(meta), path(\"*.tsv\")  , optional: true, emit: tsv\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    hamronize \\\\\n        amrfinderplus \\\\\n        ${report} \\\\\n        $args \\\\\n        --format ${format} \\\\\n        --analysis_software_version ${software_version} \\\\\n        --reference_database_version ${reference_db_version} \\\\\n        --input_file_name ${prefix} \\\\\n        > ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool to convert and summarize fARGene outputs using the hAMRonization specification\nTags: amr, antimicrobial resistance, arg, antimicrobial resistance genes, reporting, fARGene", "answer": "process HAMRONIZATION_FARGENE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hamronization:1.1.4--pyhdfd78af_0':\n        'biocontainers/hamronization:1.1.4--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(report)\n    val(format)\n    val(software_version)\n    val(reference_db_version)\n\n    output:\n    tuple val(meta), path(\"*.json\") , optional: true, emit: json\n    tuple val(meta), path(\"*.tsv\")  , optional: true, emit: tsv\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    hamronize \\\\\n        fargene \\\\\n        ${report} \\\\\n        $args \\\\\n        --format ${format} \\\\\n        --analysis_software_version ${software_version} \\\\\n        --reference_database_version ${reference_db_version} \\\\\n        --input_file_name ${prefix} \\\\\n        > ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"stub\" > ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hamronization: \\$(echo \\$(hamronize --version 2>&1) | cut -f 2 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A bacteriophage lifestyle prediction tool\nTags: phage, lifestyle, temperate, virulent, bacphlip, hmmsearch", "answer": "process BACPHLIP {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-e16bfb0f667f2f3c236b32087aaf8c76a0cd2864:c64689d7d5c51670ff5841ec4af982edbe7aa406-0':\n        'biocontainers/mulled-v2-e16bfb0f667f2f3c236b32087aaf8c76a0cd2864:c64689d7d5c51670ff5841ec4af982edbe7aa406-0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bacphlip\")         , emit: bacphlip_results\n    tuple val(meta), path(\"*.hmmsearch.tsv\")    , emit: hmmsearch_results\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.9.6' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    bacphlip \\\\\n        -i $fasta \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bacphlip: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.9.6' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${fasta}.bacphlip\n    touch ${fasta}.hmmsearch.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bacphlip: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculates base frequency statistics across reference positions from BAM.\nTags: angsd, population genetics, allele counts, doCounts", "answer": "process ANGSD_DOCOUNTS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/angsd:0.939--h468462d_0':\n        'biocontainers/angsd:0.939--h468462d_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(minqfile)\n\n    output:\n    tuple val(meta), path(\"*.depthSample\"), optional: true, emit: depth_sample\n    tuple val(meta), path(\"*.depthGlobal\"), optional: true, emit: depth_global\n    tuple val(meta), path(\"*.qs\")         , optional: true, emit: qs\n    tuple val(meta), path(\"*.pos.gz\")     , optional: true, emit: pos\n    tuple val(meta), path(\"*.counts.gz\")  , optional: true, emit: counts\n    tuple val(meta), path(\"*.icnts.gz\")   , optional: true, emit: icounts\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def minq = minqfile ? \"-minQfile ${minqfile}\" : \"\"\n    \"\"\"\n    ls -1 *.bam > bamlist.txt\n\n    angsd \\\\\n        -nThreads ${task.cpus} \\\\\n        -doCounts 1 \\\\\n        $args \\\\\n        -bam bamlist.txt \\\\\n        -out ${prefix} \\\\\n        $minq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        angsd: \\$(echo \\$(angsd 2>&1) | grep version | head -n 1 | sed 's/.*version: //g;s/ .*//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculated genotype likelihoods from BAM files.\nTags: angsd, genotype likelihood, genomics", "answer": "process ANGSD_GL {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/angsd:0.940--hce60e53_2':\n        'biocontainers/angsd:0.940--hce60e53_2' }\"\n\n    input:\n    tuple val(meta),  path(bam)\n    tuple val(meta2), path(fasta)      //Optionally\n    tuple val(meta3), path(error_file) //Optionally. Used for SYK model only.\n\n    output:\n    tuple val(meta), path(\"*.{glf,beagle}.gz\"), emit: genotype_likelihood\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def GL_model = args.contains(\"-GL 1\") ? 1 : args.contains(\"-GL 2\") ? 2 : args.contains(\"-GL 3\") ? 3 : args.contains(\"-GL 4\") ? 4 : 0\n    def ref = fasta ? \"-ref ${fasta}\" : ''                     // Use reference fasta if provided\n    def errors = error_file ? \"-errors ${error_file}\" : ''     // Only applies to SYK model\n    def output_mode = args.contains(\"-doGlf\") ? \"\" : '-doGlf 1' // Default to outputting binary glf (10 log likelihoods) if not set in args\n    // NOTE: GL is specified within args, so is not provided as a separate argument\n\n    if (GL_model != 3 && GL_model != 4) {\n        \"\"\"\n        ls -1 *.bam > bamlist.txt\n\n        angsd \\\\\n            -nThreads ${task.cpus} \\\\\n            -bam bamlist.txt \\\\\n            $args \\\\\n            $ref \\\\\n            $output_mode \\\\\n            -out ${prefix}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            angsd: \\$(echo \\$(angsd 2>&1) | grep 'angsd version' | head -n 1 | sed 's/.*version: //g;s/ .*//g')\n        END_VERSIONS\n        \"\"\"\n    } else if (GL_model == 3) {\n        // No args for this part.\n        // GL is hardcoded to 3 here to avoid passing all other arguments to the calibration step\n        \"\"\"\n        ls -1 *.bam > bamlist.txt\n\n        ## SOAPsnp model\n        ## First get the calibration matrix. minQ MUST be 0 for this step. Will create the directory angsd_tmpdir/ with the required files for the next step.\n        angsd \\\\\n            -nThreads ${task.cpus} \\\\\n            -bam bamlist.txt \\\\\n            -minQ 0 \\\\\n            -GL 3 \\\\\n            $ref \\\\\n            -out ${prefix}\n\n        ## Then run the model\n        angsd \\\\\n            -nThreads ${task.cpus} \\\\\n            -bam bamlist.txt \\\\\n            $args \\\\\n            $ref \\\\\n            $output_mode \\\\\n            -out ${prefix}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            angsd: \\$(echo \\$(angsd 2>&1) | grep 'angsd version' | head -n 1 | sed 's/.*version: //g;s/ .*//g')\n        END_VERSIONS\n        \"\"\"\n    } else if (GL_model == 4) {\n        \"\"\"\n        ls -1 *.bam > bamlist.txt\n\n        ## SYK model\n        angsd \\\\\n            -nThreads ${task.cpus} \\\\\n            -bam bamlist.txt \\\\\n            $args \\\\\n            $ref \\\\\n            $output_mode \\\\\n            $errors \\\\\n            -doCounts 1 \\\\\n            -out ${prefix}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            angsd: \\$(echo \\$(angsd 2>&1) | grep 'angsd version' | head -n 1 | sed 's/.*version: //g;s/ .*//g')\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.glf\n    gzip ${prefix}.glf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        angsd: \\$(echo \\$(angsd 2>&1) | grep 'angsd version' | head -n 1 | sed 's/.*version: //g;s/ .*//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to estimate nuclear contamination in males based on heterozygosity in the female chromosome.\nTags: angsd, population genetics, nuclear contamination estimate", "answer": "process ANGSD_CONTAMINATION {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/angsd:0.939--h468462d_0':\n        'biocontainers/angsd:0.939--h468462d_0' }\"\n\n    input:\n    tuple val(meta), path(icounts)\n    tuple val(meta2), path(hapmap_file)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    contamination \\\n        ${args} \\\n        -a ${icounts} \\\n        -h ${hapmap_file} \\\n        -p ${task.cpus} \\\n        2> >(tee ${prefix}.txt >&2)\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        angsd: \\$(echo \\$(angsd 2>&1) | grep version | head -n 1 | sed 's/.*version: //g;s/ .*//g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: cellpose segments cells in images\nTags: segmentation, image, cellpose", "answer": "process CELLPOSE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    container \"docker.io/biocontainers/cellpose:3.0.1_cv1\"\n\n    input:\n    tuple val(meta), path(image)\n    path(model)\n\n    output:\n    tuple val(meta), path(\"*masks.tif\") ,   emit: mask\n    tuple val(meta), path(\"*flows.tif\") ,   emit: flows, optional: true\n    path \"versions.yml\"                 ,   emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"I did not manage to create a cellpose module in Conda that works in all OSes. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def model_command = model ? \"--pretrained_model $model\" : \"\"\n    def VERSION = '3.0.1'\n    \"\"\"\n    cellpose \\\\\n        --image_path $image \\\\\n        --save_tif \\\\\n        $model_command \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellpose: $VERSION\n    END_VERSIONS\n    \"\"\"\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"I did not manage to create a cellpose module in Conda that works in all OSes. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"3.0.1\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def name = image.name\n    def base = name.lastIndexOf('.') != -1 ? name[0..name.lastIndexOf('.') - 1] : name\n    \"\"\"\n    touch ${base}_cp_masks.tif\n\n        cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellpose: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: A Java based tool to determine damage patterns on ancient DNA as a replacement for mapDamage\nTags: damage, deamination, miscoding lesions, C to T, ancient DNA, aDNA, palaeogenomics, archaeogenomics, palaeogenetics, archaeogenetics", "answer": "process DAMAGEPROFILER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/damageprofiler:1.1--hdfd78af_2' :\n        'biocontainers/damageprofiler:1.1--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path fasta\n    path fai\n    path specieslist\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: results\n    path  \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def reference    = fasta ? \"-r $fasta\" : \"\"\n    def species_list = specieslist ? \"-sf $specieslist\" : \"\"\n    \"\"\"\n    damageprofiler \\\\\n        -i $bam \\\\\n        -o $prefix/ \\\\\n        $args \\\\\n        $reference \\\\\n        $species_list\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        damageprofiler: \\$(damageprofiler -v | sed 's/^DamageProfiler v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply a scoring system to each sample in a plink 2 fileset\nTags: plink2, score, scoring", "answer": "process PLINK2_SCORE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink2:2.00a2.3--h712d239_1' :\n        'biocontainers/plink2:2.00a2.3--h712d239_1' }\"\n\n    input:\n    tuple val(meta), path(pgen), path(psam), path(pvar)\n    path(scorefile)\n\n    output:\n    tuple val(meta), path(\"*.sscore\"), emit: score\n    path(\"versions.yml\")             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def mem_mb = task.memory.toMega() // plink is greedy\n    \"\"\"\n    plink2 \\\\\n        --threads $task.cpus \\\\\n        --memory $mem_mb \\\\\n        --pfile ${pgen.baseName} \\\\\n        --score ${scorefile} \\\\\n        $args \\\\\n        --out ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink2: \\$(plink2 --version 2>&1 | sed 's/^PLINK v//; s/ 64.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Import variant genetic data using plink2\nTags: plink2, import, variant genetic", "answer": "process PLINK2_VCF {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink2:2.00a2.3--h712d239_1' :\n        'biocontainers/plink2:2.00a2.3--h712d239_1' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.pgen\")    , emit: pgen\n    tuple val(meta), path(\"*.psam\")    , emit: psam\n    tuple val(meta), path(\"*.pvar\")    , emit: pvar\n    tuple val(meta), path(\"*.pvar.zst\"), emit: pvar_zst, optional: true\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def mem_mb = task.memory.toMega()\n    \"\"\"\n    plink2 \\\\\n        --threads $task.cpus \\\\\n        --memory $mem_mb \\\\\n        $args \\\\\n        --vcf $vcf \\\\\n        --out ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink2: \\$(plink2 --version 2>&1 | sed 's/^PLINK v//; s/ 64.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Subset plink pfiles with a text file of variant identifiers\nTags: plink2, extract, identifiers", "answer": "process PLINK2_EXTRACT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plink2:2.00a2.3--h712d239_1' :\n        'biocontainers/plink2:2.00a2.3--h712d239_1' }\"\n\n    input:\n    tuple val(meta), path(pgen), path(psam), path(pvar), path(variants)\n\n    output:\n    tuple val(meta), path(\"*.pgen\")    , emit: extract_pgen\n    tuple val(meta), path(\"*.psam\")    , emit: extract_psam\n    tuple val(meta), path(\"*.pvar.zst\"), emit: extract_pvar\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$pgen\" == \"${prefix}.pgen\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" in modules.config to disambiguate!\"\n    def mem_mb = task.memory.toMega()\n    \"\"\"\n    plink2 \\\\\n        --threads $task.cpus \\\\\n        --memory $mem_mb \\\\\n        --pfile ${pgen.baseName} \\\\\n        $args \\\\\n        --extract $variants \\\\\n        --make-pgen vzs \\\\\n        --out ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plink2: \\$(plink2 --version 2>&1 | sed 's/^PLINK v//; s/ 64.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: HiFi-based caller for highly homologous genes\nTags: paraphase, long-read, HiFi", "answer": "process PARAPHASE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-058de387f9917a7a63953f496cdd203bca83b790:86215829f86df9201683956877a19d025261ff66-0':\n        'biocontainers/mulled-v2-058de387f9917a7a63953f496cdd203bca83b790:86215829f86df9201683956877a19d025261ff66-0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(config)\n\n    output:\n    tuple val(meta), path(\"*.paraphase.json\")              , emit: json\n    tuple val(meta), path(\"*.paraphase.bam\")               , emit: bam\n    tuple val(meta), path(\"*.paraphase.bam.bai\")           , emit: bai\n    tuple val(meta), path(\"${prefix}_paraphase_vcfs/*.vcf\"), emit: vcf, optional: true\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def config_file = config ? \"--config $config\" : \"\"\n    \"\"\"\n    paraphase \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --bam $bam \\\\\n        --reference $fasta \\\\\n        --prefix $prefix \\\\\n        $config_file \\\\\n        --out .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        minimap2: \\$(minimap2 --version 2>&1)\n        paraphase: \\$(paraphase --version)\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}_paraphase_vcfs\n\n    touch ${prefix}.paraphase.json\n    touch ${prefix}.paraphase.bam\n    touch ${prefix}.paraphase.bam.bai\n    touch ${prefix}_paraphase_vcfs/${prefix}_stub.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        minimap2: \\$(minimap2 --version 2>&1)\n        paraphase: \\$(paraphase --version)\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This tools takes a background VCF, such as gnomad, that has full genome (though in some cases, users will instead want whole exome) coverage and uses that as an expectation of variants.\nTags: validation, check, variation", "answer": "process HTSNIMTOOLS_VCFCHECK {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hts-nim-tools:0.3.11--hbeb723e_0':\n        'biocontainers/hts-nim-tools:0.3.11--hbeb723e_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n    tuple val(meta2), path(background_vcf), path(background_tbi)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    hts_nim_tools \\\\\n        vcf-check \\\\\n        $args \\\\\n        $background_vcf \\\\\n        $vcf \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        htsnimtools: \\$(hts_nim_tools | grep \"version\" | sed -e 's/version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        htsnimtools: \\$(hts_nim_tools | grep \"version\" | sed -e 's/version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create visualizations from a tsv coverage histogram created with panacus.\nTags: statistics, pangenome, graph, visualization, tsv, genomics", "answer": "process PANACUS_VISUALIZE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/panacus:0.2.3--h031d066_0':\n        'biocontainers/panacus:0.2.3--h031d066_0' }\"\n\n    input:\n    tuple val(meta), path(tsv)\n\n    output:\n    tuple val(meta), path(\"*.{eps,jpg,jpeg,pdf,pgf,png,ps,raw,rgba,svg,svgz,tif,tiff,webp}\"), emit: image\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--format eps\") || args.contains(\"-f eps\") ? \"eps\" :\n                    args.contains(\"--format jpg\") || args.contains(\"-f jpg\") ? \"jpg\" :\n                    args.contains(\"--format jpeg\") || args.contains(\"-f jpeg\") ? \"jpeg\" :\n                    args.contains(\"--format pdf\") || args.contains(\"-f pdf\") ? \"pdf\" :\n                    args.contains(\"--format pgf\") || args.contains(\"-f pgf\") ? \"pgf\" :\n                    args.contains(\"--format png\") || args.contains(\"-f png\") ? \"png\" :\n                    args.contains(\"--format ps\") || args.contains(\"-f ps\") ? \"ps\" :\n                    args.contains(\"--format raw\") || args.contains(\"-f raw\") ? \"raw\" :\n                    args.contains(\"--format rgba\") || args.contains(\"-f rgba\") ? \"rgba\" :\n                    args.contains(\"--format svg\") || args.contains(\"-f svg\") ? \"svg\" :\n                    args.contains(\"--format svgz\") || args.contains(\"-f svgz\") ? \"svgz\" :\n                    args.contains(\"--format tif\") || args.contains(\"-f tif\") ? \"tif\" :\n                    args.contains(\"--format tiff\") || args.contains(\"-f tiff\") ? \"tiff\" :\n                    args.contains(\"--format webp\") || args.contains(\"-f webp\") ? \"webp\" :\n                    \"pdf\"\n    def output_pipe = args.contains(\"--split_subfigures\") ? \"\" : \"> ${prefix}.${extension}\"\n    \"\"\"\n    panacus-visualize \\\\\n        $args \\\\\n        $tsv \\\\\n        $output_pipe\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        panacus: \\$(echo \\$(panacus --version) | sed 's/^panacus //' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--format eps\") || args.contains(\"-f eps\") ? \"eps\" :\n                    args.contains(\"--format jpg\") || args.contains(\"-f jpg\") ? \"jpg\" :\n                    args.contains(\"--format jpeg\") || args.contains(\"-f jpeg\") ? \"jpeg\" :\n                    args.contains(\"--format pdf\") || args.contains(\"-f pdf\") ? \"pdf\" :\n                    args.contains(\"--format pgf\") || args.contains(\"-f pgf\") ? \"pgf\" :\n                    args.contains(\"--format png\") || args.contains(\"-f png\") ? \"png\" :\n                    args.contains(\"--format ps\") || args.contains(\"-f ps\") ? \"ps\" :\n                    args.contains(\"--format raw\") || args.contains(\"-f raw\") ? \"raw\" :\n                    args.contains(\"--format rgba\") || args.contains(\"-f rgba\") ? \"rgba\" :\n                    args.contains(\"--format svg\") || args.contains(\"-f svg\") ? \"svg\" :\n                    args.contains(\"--format svgz\") || args.contains(\"-f svgz\") ? \"svgz\" :\n                    args.contains(\"--format tif\") || args.contains(\"-f tif\") ? \"tif\" :\n                    args.contains(\"--format tiff\") || args.contains(\"-f tiff\") ? \"tiff\" :\n                    args.contains(\"--format webp\") || args.contains(\"-f webp\") ? \"webp\" :\n                    \"pdf\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        panacus: \\$(echo \\$(panacus --version) | sed 's/^panacus //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculates a coverage histogram from a GFA file and constructs a growth table from this as either a TSV or HTML file\nTags: statistics, pangenome, graph, gfa, genomics", "answer": "process PANACUS_HISTGROWTH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"bioconda::panacus=0.2.3\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/panacus:0.2.3--h031d066_0':\n        'biocontainers/panacus:0.2.3--h031d066_0' }\"\n\n    input:\n    tuple val(meta), path(gfa)\n    path(bed_subset)\n    path(bed_exclude)\n    path(tsv_groupby)\n\n    output:\n    tuple val(meta), path(\"*.{tsv, html}\"), emit: tsv\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-format table\") || args.contains(\"-o table\") ? \"tsv\" :\n                    args.contains(\"--output-format html\") || args.contains(\"-o html\") ? \"html\" :\n                    \"tsv\"\n    def subset_query  = bed_subset ? \"--subset ${bed_subset}\" : \"\"\n    def exclude_query = bed_exclude ? \"--exclude ${bed_exclude}\" : \"\"\n    def groupby_query = tsv_groupby ? \"--groupby ${tsv_groupby}\" : \"\"\n    \"\"\"\n    panacus \\\\\n        histgrowth \\\\\n        $args \\\\\n        $subset_query \\\\\n        $exclude_query \\\\\n        $groupby_query \\\\\n        --threads $task.cpus \\\\\n        $gfa > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        panacus: \\$(echo \\$(panacus --version) | sed 's/^panacus //' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-format table\") || args.contains(\"-o table\") ? \"tsv\" :\n                    args.contains(\"--output-format html\") || args.contains(\"-o html\") ? \"html\" :\n                    \"tsv\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        panacus: \\$(echo \\$(panacus --version) | sed 's/^panacus //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Ribosomal RNA extraction from a GTF file.\nTags: ribosomal, rna, genomics", "answer": "process RRNATRANSCRIPTS {\n    tag '$rrna'\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/python:3.12' :\n        'biocontainers/python:3.12' }\"\n\n    input:\n    path(gtf)\n\n    output:\n    path(\"*rrna_intervals.gtf\") , emit: rrna_gtf, optional: true\n    path \"versions.yml\"         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}\"\n    \"\"\"\n    grep -E '^#|rRNA' genome.gtf > ${prefix}_rrna_intervals.gtf || true\n    if [ !  -s ${prefix}_rrna_intervals.gtf ]; then\n        rm ${prefix}_rrna_intervals.gtf\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        python: \\$(python --version | sed -e \"s/Python //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}\"\n    \"\"\"\n    touch ${prefix}_rrna_intervals.gtf\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        python: \\$(python --version | sed -e \"s/Python //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Minia is a short-read assembler based on a de Bruijn graph\nTags: assembly", "answer": "process MINIA {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/minia:3.2.6--h9a82719_0' :\n        'biocontainers/minia:3.2.6--h9a82719_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path('*.contigs.fa'), emit: contigs\n    tuple val(meta), path('*.unitigs.fa'), emit: unitigs\n    tuple val(meta), path('*.h5')        , emit: h5\n    path  \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def read_list = reads.join(\",\")\n    \"\"\"\n    echo \"${read_list}\" | sed 's/,/\\\\n/g' > input_files.txt\n    minia \\\\\n        $args \\\\\n        -nb-cores $task.cpus \\\\\n        -in input_files.txt \\\\\n        -out $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        minia: \\$(echo \\$(minia --version 2>&1 | grep Minia) | sed 's/^.*Minia version //;')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Interleave pair-end reads from FastQ files\nTags: interleave, merge, fastx", "answer": "process SEQTK_MERGEPE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqtk:1.4--he4a0461_1' :\n        'biocontainers/seqtk:1.4--he4a0461_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\") , emit: reads\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.single_end) {\n        \"\"\"\n        ln -s ${reads} ${prefix}.fastq.gz\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        seqtk \\\\\n            mergepe \\\\\n            $args \\\\\n            ${reads} \\\\\n            | gzip -n >> ${prefix}.fastq.gz\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Common transformation operations on FASTA or FASTQ files.\nTags: seq, filter, transformation", "answer": "process SEQTK_SEQ {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqtk:1.4--he4a0461_1' :\n        'biocontainers/seqtk:1.4--he4a0461_1' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"*.gz\")     , emit: fastx\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz/ || \"$args\" ==~ /\\-[aA]/ ) {\n        extension = \"fasta\"\n    }\n    \"\"\"\n    seqtk \\\\\n        seq \\\\\n        $args \\\\\n        $fastx | \\\\\n        gzip -c > ${prefix}.seqtk-seq.${extension}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz/ || \"$args\" ==~ /\\-[aA]/ ) {\n        extension = \"fasta\"\n    }\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.seqtk-seq.${extension}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Trim low quality bases from FastQ files\nTags: trimfq, fastq, seqtk", "answer": "process SEQTK_TRIM {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqtk:1.4--he4a0461_1' :\n        'biocontainers/seqtk:1.4--he4a0461_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: reads\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    printf \"%s\\\\n\" $reads | while read f;\n    do\n        seqtk \\\\\n            trimfq \\\\\n            $args \\\\\n            \\$f \\\\\n            | gzip --no-name > ${prefix}_\\$(basename \\$f)\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generates a BED file containing genomic locations of lengths of N.\nTags: cut, fasta, seqtk", "answer": "process SEQTK_CUTN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqtk:1.4--he4a0461_1' :\n        'biocontainers/seqtk:1.4--he4a0461_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bed\")    , emit: bed\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    seqtk \\\\\n        cutN \\\\\n        $args \\\\\n        -g $fasta \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Select only sequences that match the filtering condition\nTags: filtering, selection, fastx", "answer": "process SEQTK_SUBSEQ {\n    tag \"$sequences\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqtk:1.4--he4a0461_1' :\n        'biocontainers/seqtk:1.4--he4a0461_1' }\"\n\n    input:\n    tuple val(meta), path(sequences)\n    path filter_list\n\n    output:\n    tuple val(meta), path(\"*.gz\"),  emit: sequences\n    path \"versions.yml\",            emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def ext = \"fa\"\n    if (\"$sequences\" ==~ /.+\\.fq|.+\\.fq.gz|.+\\.fastq|.+\\.fastq.gz/) {\n        ext = \"fq\"\n    }\n    \"\"\"\n    seqtk \\\\\n        subseq \\\\\n        $args \\\\\n        $sequences \\\\\n        $filter_list | \\\\\n        gzip --no-name > ${sequences}${prefix}.${ext}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def ext = \"fa\"\n    if (\"$sequences\" ==~ /.+\\.fq|.+\\.fq.gz|.+\\.fastq|.+\\.fastq.gz/) {\n        ext = \"fq\"\n    }\n    \"\"\"\n    echo \"\" | gzip > ${sequences}${prefix}.${ext}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Subsample reads from FASTQ files\nTags: sample, fastx, reads", "answer": "process SEQTK_SAMPLE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqtk:1.4--he4a0461_1' :\n        'biocontainers/seqtk:1.4--he4a0461_1' }\"\n\n    input:\n    tuple val(meta), path(reads), val(sample_size)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: reads\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (!(args ==~ /.*-s[0-9]+.*/)) {\n        args += \" -s100\"\n    }\n    if ( !sample_size ) {\n        error \"SEQTK/SAMPLE must have a sample_size value included\"\n    }\n    \"\"\"\n    printf \"%s\\\\n\" $reads | while read f;\n    do\n        seqtk \\\\\n            sample \\\\\n            $args \\\\\n            \\$f \\\\\n            $sample_size \\\\\n            | gzip --no-name > ${prefix}_\\$(basename \\$f)\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Rename sequence names in FASTQ or FASTA files.\nTags: rename, fastx, header", "answer": "process SEQTK_RENAME {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqtk:1.4--he4a0461_1' :\n        'biocontainers/seqtk:1.4--he4a0461_1' }\"\n\n    input:\n    tuple val(meta), path(sequences)\n\n    output:\n    tuple val(meta), path(\"*.gz\")     , emit: sequences\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = \"fasta\"\n    if (\"$sequences\" ==~ /.+\\.fq|.+\\.fq.gz|.+\\.fastq|.+\\.fastq.gz/) {\n        extension = \"fastq\"\n    }\n    \"\"\"\n    seqtk \\\\\n        rename \\\\\n        $args \\\\\n        $sequences \\\\\n        $prefix | \\\\\n        gzip -c --no-name > ${prefix}.renamed.${extension}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = \"fasta\"\n    if (\"$sequences\" ==~ /.+\\.fq|.+\\.fq.gz|.+\\.fastq|.+\\.fastq.gz/) {\n        extension = \"fastq\"\n    }\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.renamed.${extension}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqtk: \\$(echo \\$(seqtk 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Bioawk is an extension to Brian Kernighan's awk, adding the support of several common biological data formats.\nTags: bioawk, fastq, fasta, sam, file manipulation, awk", "answer": "process BIOAWK {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioawk:1.0--h5bf99c6_6':\n        'biocontainers/bioawk:1.0--h5bf99c6_6' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.gz\"), emit: output\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args ?: '' // args is used for the main arguments of the tool\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"${input}\" == \"${prefix}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    def VERSION = '1.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    bioawk \\\\\n        $args \\\\\n        $input \\\\\n        > ${prefix}\n\n    gzip ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bioawk: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: LongPhase is an ultra-fast program for simultaneously co-phasing SNPs, small indels, large SVs, and (5mC) modifications for Nanopore and PacBio platforms.\nTags: haplotag, long-read, genomics", "answer": "process LONGPHASE_HAPLOTAG {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/longphase:1.7.3--hf5e1c6e_0':\n        'biocontainers/longphase:1.7.3--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(snps), path(svs), path(mods)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n\n    output:\n    tuple val(meta), path(\"*.{bam,cram}\"), emit: bam\n    tuple val(meta), path(\"*.log\")       , emit: log , optional: true\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def sv_file = params.svs ? \"--sv-file ${svs}\" : \"\"\n    def mod_file = params.mods ? \"--mod-file ${mods}\" : \"\"\n\n    \"\"\"\n    longphase \\\\\n        haplotag \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        -o ${prefix} \\\\\n        --reference ${fasta} \\\\\n        --snp-file ${snps} \\\\\n        --bam ${bam} \\\\\n        ${sv_file} \\\\\n        ${mod_file}\n\n    if [ -f \"${prefix}.out\" ]; then\n        mv ${prefix}.out ${prefix}.log\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        longphase: \\$(longphase --version | head -n 1 | sed 's/Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = args.contains('--cram') ? \"cram\" : \"bam\"\n    def log = args.contains('--log') ? \"touch ${prefix}.log\" : ''\n    \"\"\"\n    touch ${prefix}.${suffix}\n    ${log}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        longphase: \\$(longphase --version | head -n 1 | sed 's/Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: LongPhase is an ultra-fast program for simultaneously co-phasing SNPs, small indels, large SVs, and (5mC) modifications for Nanopore and PacBio platforms.\nTags: phase, long-read, genomics", "answer": "process LONGPHASE_PHASE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d626bb8ec5a659accfbd8490bc1ac4a940722258:682e8c0cc0ceebf9bd38371a58249aabce93b1b3-0':\n        'biocontainers/mulled-v2-d626bb8ec5a659accfbd8490bc1ac4a940722258:682e8c0cc0ceebf9bd38371a58249aabce93b1b3-0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(snps), path(svs), path(mods)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def sv_file = params.svs ? \"--sv-file ${svs}\" : \"\"\n    def mod_file = params.mods ? \"--mod-file ${mods}\" : \"\"\n\n    def bamList = []\n    for (file in bam) {\n        bamList.add(\"-b\")\n        bamList.add(file)\n    }\n    \"\"\"\n    longphase \\\\\n        phase \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        -o ${prefix} \\\\\n        --reference ${fasta} \\\\\n        --snp-file ${snps} \\\\\n        ${bamList.join(\" \")} \\\\\n        ${sv_file} \\\\\n        ${mod_file} \\\\\n\n    bgzip \\\\\n        --threads $task.cpus \\\\\n        $args2 \\\\\n        ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        longphase: \\$(longphase --version | head -n 1 | sed 's/Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | bgzip -c > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        longphase: \\$(longphase --version | head -n 1 | sed 's/Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculates polymorphic site rates over protein coding genes\nTags: polymut, polymorphic, mags, assembly, polymorphic sites, estimation, protein coding genes, cmseq, bam, coverage", "answer": "process CMSEQ_POLYMUT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cmseq:1.0.4--pyhb7b1952_0' :\n        'biocontainers/cmseq:1.0.4--pyhb7b1952_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(gff), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: polymut\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def fasta_refid = fasta ? \"-c $fasta\" : \"\"\n    def sortindex = bai ? \"\" : \"--sortindex\"\n    def VERSION = '1.0.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    polymut.py \\\\\n        $args \\\\\n        $sortindex \\\\\n        $fasta_refid \\\\\n        --gff_file $gff \\\\\n        $bam > ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cmseq: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filter variants based on Ensembl Variant Effect Predictor (VEP) annotations.\nTags: annotation, vcf, tab, filter", "answer": "process ENSEMBLVEP_FILTERVEP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ensembl-vep:111.0--pl5321h2a3209d_0' :\n        'biocontainers/ensembl-vep:111.0--pl5321h2a3209d_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path (feature_file)\n\n    output:\n    tuple val(meta), path(\"*.${extension}\"), emit: output\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    extension  = task.ext.suffix ?: \"vcf\"\n    \"\"\"\n    filter_vep \\\\\n        $args \\\\\n        --input_file $input \\\\\n        --output_file ${prefix}.${extension} \\\\\n        --only_matched\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ensemblvep: \\$( echo \\$(vep --help 2>&1) | sed 's/^.*Versions:.*ensembl-vep : //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    extension  = task.ext.suffix ?: \"vcf\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ensemblvep: \\$( echo \\$(vep --help 2>&1) | sed 's/^.*Versions:.*ensembl-vep : //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Ensembl Variant Effect Predictor (VEP). The output-file-format is controlled through `task.ext.args`.\nTags: annotation, vcf, json, tab", "answer": "process ENSEMBLVEP_VEP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ensembl-vep:111.0--pl5321h2a3209d_0' :\n        'biocontainers/ensembl-vep:111.0--pl5321h2a3209d_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(custom_extra_files)\n    val   genome\n    val   species\n    val   cache_version\n    path  cache\n    tuple val(meta2), path(fasta)\n    path  extra_files\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")  , optional:true, emit: vcf\n    tuple val(meta), path(\"*.tab.gz\")  , optional:true, emit: tab\n    tuple val(meta), path(\"*.json.gz\") , optional:true, emit: json\n    path \"*.html\"                      , optional:true, emit: report\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def file_extension = args.contains(\"--vcf\") ? 'vcf' : args.contains(\"--json\")? 'json' : args.contains(\"--tab\")? 'tab' : 'vcf'\n    def compress_cmd = args.contains(\"--compress_output\") ? '' : '--compress_output bgzip'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def dir_cache = cache ? \"\\${PWD}/${cache}\" : \"/.vep\"\n    def reference = fasta ? \"--fasta $fasta\" : \"\"\n    \"\"\"\n    vep \\\\\n        -i $vcf \\\\\n        -o ${prefix}.${file_extension}.gz \\\\\n        $args \\\\\n        $compress_cmd \\\\\n        $reference \\\\\n        --assembly $genome \\\\\n        --species $species \\\\\n        --cache \\\\\n        --cache_version $cache_version \\\\\n        --dir_cache $dir_cache \\\\\n        --fork $task.cpus\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ensemblvep: \\$( echo \\$(vep --help 2>&1) | sed 's/^.*Versions:.*ensembl-vep : //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    echo \"\" | gzip > ${prefix}.tab.gz\n    echo \"\" | gzip > ${prefix}.json.gz\n    touch ${prefix}_summary.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ensemblvep: \\$( echo \\$(vep --help 2>&1) | sed 's/^.*Versions:.*ensembl-vep : //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Ensembl Variant Effect Predictor (VEP). The cache downloading options are controlled through `task.ext.args`.\nTags: annotation, cache, download", "answer": "process ENSEMBLVEP_DOWNLOAD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ensembl-vep:111.0--pl5321h2a3209d_0' :\n        'biocontainers/ensembl-vep:111.0--pl5321h2a3209d_0' }\"\n\n    input:\n    tuple val(meta), val(assembly), val(species), val(cache_version)\n\n    output:\n    tuple val(meta), path(prefix), emit: cache\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: 'vep_cache'\n    \"\"\"\n    vep_install \\\\\n        --CACHEDIR $prefix \\\\\n        --SPECIES $species \\\\\n        --ASSEMBLY $assembly \\\\\n        --CACHE_VERSION $cache_version \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ensemblvep: \\$( echo \\$(vep --help 2>&1) | sed 's/^.*Versions:.*ensembl-vep : //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: 'vep_cache'\n    \"\"\"\n    mkdir $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ensemblvep: \\$( echo \\$(vep --help 2>&1) | sed 's/^.*Versions:.*ensembl-vep : //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: BUSCO plot generation tool\nTags: genome, fasta, annotation, busco, transcriptome, quality control", "answer": "process BUSCO_GENERATEPLOT {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/busco:5.7.1--pyhdfd78af_0':\n        'biocontainers/busco:5.7.1--pyhdfd78af_0' }\"\n\n    input:\n    path short_summary_txt, stageAs: 'busco/*'\n\n    output:\n    path '*.png'        , emit: png\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args     ?: ''\n    def prefix  = task.ext.prefix   ?: 'busco_figure'\n    \"\"\"\n    generate_plot.py \\\\\n        $args \\\\\n        -wd busco\n\n    mv ./busco/busco_figure.png ${prefix}.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        busco: \\$( busco --version 2>&1 | sed 's/^BUSCO //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix   ?: 'busco_figure'\n    \"\"\"\n    touch ${prefix}.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        busco: \\$( busco --version 2>&1 | sed 's/^BUSCO //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Benchmarking Universal Single Copy Orthologs\nTags: quality control, genome, transcriptome, proteome", "answer": "process BUSCO_BUSCO {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/busco:5.7.1--pyhdfd78af_0':\n        'biocontainers/busco:5.7.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta, stageAs:'tmp_input/*')\n    val mode                              // Required:    One of genome, proteins, or transcriptome\n    val lineage                           // Required:    lineage to check against, \"auto\" enables --auto-lineage instead\n    path busco_lineages_path              // Recommended: path to busco lineages - downloads if not set\n    path config_file                      // Optional:    busco configuration file\n\n    output:\n    tuple val(meta), path(\"*-busco.batch_summary.txt\")                , emit: batch_summary\n    tuple val(meta), path(\"short_summary.*.txt\")                      , emit: short_summaries_txt   , optional: true\n    tuple val(meta), path(\"short_summary.*.json\")                     , emit: short_summaries_json  , optional: true\n    tuple val(meta), path(\"*-busco/*/run_*/full_table.tsv\")           , emit: full_table            , optional: true\n    tuple val(meta), path(\"*-busco/*/run_*/missing_busco_list.tsv\")   , emit: missing_busco_list    , optional: true\n    tuple val(meta), path(\"*-busco/*/run_*/single_copy_proteins.faa\") , emit: single_copy_proteins  , optional: true\n    tuple val(meta), path(\"*-busco/*/run_*/busco_sequences\")          , emit: seq_dir\n    tuple val(meta), path(\"*-busco/*/translated_proteins\")            , emit: translated_dir        , optional: true\n    tuple val(meta), path(\"*-busco\")                                  , emit: busco_dir\n    path \"versions.yml\"                                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    if ( mode !in [ 'genome', 'proteins', 'transcriptome' ] ) {\n        error \"Mode must be one of 'genome', 'proteins', or 'transcriptome'.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}-${lineage}\"\n    def busco_config = config_file ? \"--config $config_file\" : ''\n    def busco_lineage = lineage.equals('auto') ? '--auto-lineage' : \"--lineage_dataset ${lineage}\"\n    def busco_lineage_dir = busco_lineages_path ? \"--download_path ${busco_lineages_path}\" : ''\n    \"\"\"\n    # Nextflow changes the container --entrypoint to /bin/bash (container default entrypoint: /usr/local/env-execute)\n    # Check for container variable initialisation script and source it.\n    if [ -f \"/usr/local/env-activate.sh\" ]; then\n        set +u  # Otherwise, errors out because of various unbound variables\n        . \"/usr/local/env-activate.sh\"\n        set -u\n    fi\n\n    # If the augustus config directory is not writable, then copy to writeable area\n    if [ ! -w \"\\${AUGUSTUS_CONFIG_PATH}\" ]; then\n        # Create writable tmp directory for augustus\n        AUG_CONF_DIR=\\$( mktemp -d -p \\$PWD )\n        cp -r \\$AUGUSTUS_CONFIG_PATH/* \\$AUG_CONF_DIR\n        export AUGUSTUS_CONFIG_PATH=\\$AUG_CONF_DIR\n        echo \"New AUGUSTUS_CONFIG_PATH=\\${AUGUSTUS_CONFIG_PATH}\"\n    fi\n\n    # Ensure the input is uncompressed\n    INPUT_SEQS=input_seqs\n    mkdir \"\\$INPUT_SEQS\"\n    cd \"\\$INPUT_SEQS\"\n    for FASTA in ../tmp_input/*; do\n        if [ \"\\${FASTA##*.}\" == 'gz' ]; then\n            gzip -cdf \"\\$FASTA\" > \\$( basename \"\\$FASTA\" .gz )\n        else\n            ln -s \"\\$FASTA\" .\n        fi\n    done\n    cd ..\n\n    busco \\\\\n        --cpu $task.cpus \\\\\n        --in \"\\$INPUT_SEQS\" \\\\\n        --out ${prefix}-busco \\\\\n        --mode $mode \\\\\n        $busco_lineage \\\\\n        $busco_lineage_dir \\\\\n        $busco_config \\\\\n        $args\n\n    # clean up\n    rm -rf \"\\$INPUT_SEQS\"\n\n    # Move files to avoid staging/publishing issues\n    mv ${prefix}-busco/batch_summary.txt ${prefix}-busco.batch_summary.txt\n    mv ${prefix}-busco/*/short_summary.*.{json,txt} . || echo \"Short summaries were not available: No genes were found.\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        busco: \\$( busco --version 2>&1 | sed 's/^BUSCO //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix      = task.ext.prefix ?: \"${meta.id}-${lineage}\"\n    def fasta_name  = files(fasta).first().name - '.gz'\n    \"\"\"\n    touch ${prefix}-busco.batch_summary.txt\n    mkdir -p ${prefix}-busco/$fasta_name/run_${lineage}/busco_sequences\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        busco: \\$( busco --version 2>&1 | sed 's/^BUSCO //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Standardise and merge two or more taxonomic profiles into a single table\nTags: taxonomic profile, standardise, standardisation, metagenomics, taxonomic profiling, otu tables, taxon tables", "answer": "process TAXPASTA_MERGE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/taxpasta:0.7.0--pyhdfd78af_0':\n        'biocontainers/taxpasta:0.7.0--pyhdfd78af_0' }\"\n\n\n    input:\n    tuple val(meta), path(profiles)\n    val profiler\n    val format\n    path taxonomy\n    path samplesheet\n\n    output:\n    tuple val(meta), path(\"*.{tsv,csv,arrow,parquet,biom}\"), emit: merged_profiles\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def taxonomy_option = taxonomy ? \"--taxonomy ${taxonomy}\" : ''\n    def samplesheet_input = samplesheet ? \"-s ${samplesheet}\" : ''\n    \"\"\"\n    taxpasta merge \\\\\n        --profiler $profiler \\\\\n        --output ${prefix}.${format} \\\\\n        $args \\\\\n        $taxonomy_option \\\\\n        $samplesheet_input \\\\\n        $profiles\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        taxpasta: \\$(taxpasta --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def taxonomy_option = taxonomy ? \"--taxonomy ${taxonomy}\" : ''\n    def samplesheet_input = samplesheet ? \"-s ${samplesheet}\" : ''\n    \"\"\"\n    touch ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        taxpasta: \\$(taxpasta --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Standardise the output of a wide range of taxonomic profilers\nTags: taxonomic profile, standardise, standardisation, metagenomics, taxonomic profiling, otu tables, taxon tables", "answer": "process TAXPASTA_STANDARDISE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/taxpasta:0.7.0--pyhdfd78af_0':\n        'biocontainers/taxpasta:0.7.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(profile)\n    val profiler\n    val format\n    path taxonomy\n\n    output:\n    tuple val(meta), path(\"*.{tsv,csv,arrow,parquet,biom}\"), emit: standardised_profile\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def taxonomy_option = taxonomy ? \"--taxonomy ${taxonomy}\" : ''\n    \"\"\"\n    taxpasta standardise \\\\\n        --profiler $profiler \\\\\n        --output ${prefix}.${format} \\\\\n        $args \\\\\n        $taxonomy_option \\\\\n        $profile\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        taxpasta: \\$(taxpasta --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def taxonomy_option = taxonomy ? \"--taxonomy ${taxonomy}\" : ''\n    \"\"\"\n    touch ${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        taxpasta: \\$(taxpasta --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: miRanda is an algorithm for finding genomic targets for microRNAs\nTags: microrna, mirna, target prediction", "answer": "process MIRANDA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/miranda:3.3a--h779adbc_3':\n        'biocontainers/miranda:3.3a--h779adbc_3' }\"\n\n    input:\n    tuple val(meta), path(query)\n    path(mirbase)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    miranda \\\\\n        $mirbase \\\\\n        $query \\\\\n        $args \\\\\n        -out ${prefix}.out\n\n    echo \"miRNA\\tTarget\\tScore\\tEnergy_KcalMol\\tQuery_Start\\tQuery_End\\tSubject_Start\\tSubject_End\\tAln_len\\tSubject_Identity\\tQuery_Identity\" > ${prefix}.txt\n    grep -A 1 \"Scores for this hit:\" ${prefix}.out | sort | grep \">\"  | cut -c 2- | tr ' ' '\\t' >> ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        miranda: \\$(echo \\$(miranda -v | sed -n 4p | sed 's/^.*miranda v//; s/microRNA.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        miranda: \\$(echo \\$(miranda -v | sed -n 4p | sed 's/^.*miranda v//; s/microRNA.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Serotype STEC samples from paired-end reads or assemblies\nTags: serotype, Escherichia coli, fastq, fasta", "answer": "process STECFINDER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/stecfinder:1.1.0--pyhdfd78af_0':\n        'biocontainers/stecfinder:1.1.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(seqs)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    stecfinder \\\\\n        -i $seqs \\\\\n        $args \\\\\n        -t $task.cpus > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stecfinder: \\$(echo \\$(stecfinder --version 2>&1) | sed 's/^.*STECFinder version: //;' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split a file into consecutive or interleaved sections\nTags: gnu, split, coreutils, generic", "answer": "process GNU_SPLIT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/coreutils:9.3':\n        'biocontainers/coreutils:9.3' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path( \"*split*\" ), emit: split\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = input.extension\n    if (suffix == 'gz') {\n        def next_suffix = file(input.baseName).getExtension()\n        \"\"\"\n        gunzip -c ${input} | split ${args} --additional-suffix=.${next_suffix} - ${prefix}.split.\n        gzip ${prefix}.split.*\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            gnu: \\$(split --version |& sed '1!d ; s/split (GNU coreutils) //')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        split ${args} --additional-suffix=.${suffix} ${input} ${prefix}.split.\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            gnu: \\$(split --version |& sed '1!d ; s/split (GNU coreutils) //')\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.split.000.csv ${prefix}.split.001.csv ${prefix}.split.002.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gnu: \\$(split --version |& sed '1!d ; s/split (GNU coreutils) //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Writes a sorted concatenation of file/s\n\nTags: GNU, sort, merge compare", "answer": "process GNU_SORT {\n    tag \"$meta.id\"\n    label \"process_low\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/coreutils:9.3':\n        'biocontainers/coreutils:9.3' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), file( \"${output_file}\" )   , emit: sorted\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args     ?: ''\n    def prefix      = task.ext.prefix   ?: \"${meta.id}\"\n    suffix          = task.ext.suffix   ?: \"${input.extension}\"\n    output_file     = \"${prefix}.${suffix}\"\n    def VERSION     = \"9.3\"             // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    if (\"$input\" == \"$output_file\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    sort ${args} ${input} > ${output_file}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        coreutils: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix      = task.ext.prefix   ?: \"${meta.id}\"\n    suffix          = task.ext.suffix   ?: \"${input.extension}\"\n    output_file     = \"${prefix}.${suffix}\"\n    def VERSION     = \"9.3\"\n\n    if (\"$input\" == \"$output_file\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${output_file}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        coreutils: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: remove false positives of functional crispr genomics due to CNVs\nTags: sort, CNV, correction, CRISPR", "answer": "process CRISPRCLEANR_NORMALIZE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-crisprcleanr:3.0.0--r42hdfd78af_1':\n        'biocontainers/r-crisprcleanr:3.0.0--r42hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(count_file), path(library_file)\n    val(min_reads)\n    val(min_targeted_genes)\n\n    output:\n    tuple val(meta), path(\"*_norm_table.tsv\"), emit: norm_count_file\n    path \"versions.yml\",                       emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    #!/usr/bin/env Rscript\n    library(CRISPRcleanR)\n    library <- read.delim('${library_file}', header=T,sep=\"\\t\")\n    row.names(library) <- library[[\"CODE\"]]\n    normANDfcs <- ccr.NormfoldChanges('${count_file}',saveToFig = FALSE,min_reads=${min_reads},EXPname='${meta.id}', libraryAnnotation=library,display=FALSE)\n    gwSortedFCs <- ccr.logFCs2chromPos(normANDfcs[[\"logFCs\"]],library)\n    correctedFCs <- ccr.GWclean(gwSortedFCs,display=FALSE,label='${meta.id}')\n    correctedCounts <- ccr.correctCounts('${meta.id}',\n                            normANDfcs[[\"norm_counts\"]],\n                            correctedFCs,\n                            library,\n                            minTargetedGenes=${min_targeted_genes},\n                            OutDir='./')\n\n    write.table(correctedCounts, file=paste0(\"${prefix}\",\"_norm_table.tsv\"),row.names=FALSE,quote=FALSE,sep=\"\\t\")\n\n    version_file_path <- \"versions.yml\"\n    version_crisprcleanr <- paste(unlist(packageVersion(\"CRISPRcleanR\")), collapse = \".\")\n    f <- file(version_file_path, \"w\")\n    writeLines('\"${task.process}\":', f)\n    writeLines(\"    crisprcleanr: \", f, sep = \"\")\n    writeLines(version_crisprcleanr, f)\n    close(f)\n\n    \"\"\"\n}\n"}
{"question": "Description: Determine Shigella serotype from assemblies or Illumina paired-end reads\nTags: fastq, fasta, shigella, serotype", "answer": "process SHIGEIFINDER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/shigeifinder:1.3.2--pyhdfd78af_0':\n        'biocontainers/shigeifinder:1.3.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(seqs)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    shigeifinder \\\\\n        $args \\\\\n        --output ${prefix}.tsv \\\\\n        -t $task.cpus \\\\\n        -i $seqs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shigeifinder: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: AMPlify is an attentive deep learning model for antimicrobial peptide prediction.\nTags: antimicrobial peptides, AMPs, prediction, model", "answer": "process AMPLIFY_PREDICT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/amplify:2.0.0--py36hdfd78af_1':\n        'biocontainers/amplify:2.0.0--py36hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(faa)\n    path(model_dir)\n\n    output:\n    tuple val(meta), path('*.tsv'), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def custom_model_dir = model_dir ? \"-md ${model_dir}\" : \"\"\n    \"\"\"\n    AMPlify \\\\\n        $args \\\\\n        ${custom_model_dir} \\\\\n        -s '${faa}'\n\n    #rename output, because tool includes date and time in name\n    mv *.tsv ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        AMPlify: \\$(AMPlify --help | grep 'AMPlify v' | sed -e \"s/^.*AMPlify v//\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        AMPlify: \\$(AMPlify --help | grep 'AMPlify v' | sed -e \"s/^.*AMPlify v//\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: inStrain is python program for analysis of co-occurring genome populations from metagenomes that allows highly accurate genome comparisons, analysis of coverage, microdiversity, and linkage, and sensitive SNP detection with gene localization and synonymous non-synonymous identification\nTags: instrain, metagenomics, population genomics, profile", "answer": "process INSTRAIN_PROFILE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/instrain:1.7.1--pyhdfd78af_0':\n        'biocontainers/instrain:1.7.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path genome_fasta\n    path genes_fasta\n    path stb_file\n\n    output:\n    tuple val(meta), path(\"*.IS\")                               , emit: profile\n    tuple val(meta), path(\"*.IS/output/*.IS_SNVs.tsv\")          , emit: snvs\n    tuple val(meta), path(\"*.IS/output/*.IS_gene_info.tsv\")     , emit: gene_info       , optional: true\n    tuple val(meta), path(\"*.IS/output/*.IS_genome_info.tsv\")   , emit: genome_info\n    tuple val(meta), path(\"*.IS/output/*.IS_linkage.tsv\")       , emit: linkage\n    tuple val(meta), path(\"*.IS/output/*.IS_mapping_info.tsv\")  , emit: mapping_info\n    tuple val(meta), path(\"*.IS/output/*.IS_scaffold_info.tsv\") , emit: scaffold_info\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def genes_args = genes_fasta ? \"-g ${genes_fasta}\": ''\n    def stb_args = stb_file ? \"-s ${stb_file}\": ''\n    \"\"\"\n    inStrain \\\\\n        profile \\\\\n        $bam \\\\\n        $genome_fasta \\\\\n        -o ${prefix}.IS \\\\\n        -p $task.cpus \\\\\n        $genes_args \\\\\n        $stb_args \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        instrain: \\$(echo \\$(inStrain profile --version 2>&1) | awk 'NF{ print \\$NF }')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def genes_args = genes_fasta ? \"-g ${genes_fasta}\": ''\n    def stb_args = stb_file ? \"-s ${stb_file}\": ''\n    \"\"\"\n    mkdir -p ${prefix}.IS/output\n    touch ${prefix}.IS/output/${prefix}.IS_SNVs.tsv\n    touch ${prefix}.IS/output/${prefix}.IS_gene_info.tsv\n    touch ${prefix}.IS/output/${prefix}.IS_genome_info.tsv\n    touch ${prefix}.IS/output/${prefix}.IS_linkage.tsv\n    touch ${prefix}.IS/output/${prefix}.IS_mapping_info.tsv\n    touch ${prefix}.IS/output/${prefix}.IS_scaffold_info.tsv\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        instrain: \\$(echo \\$(inStrain profile --version 2>&1) | awk 'NF{ print \\$NF }')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Strain-level comparisons across multiple inStrain profiles\nTags: instrain, compare, align, diversity, coverage", "answer": "process INSTRAIN_COMPARE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/instrain:1.7.1--pyhdfd78af_0':\n        'biocontainers/instrain:1.7.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bams), path(profiles)\n    path stb_file\n\n    output:\n    tuple val(meta), path(\"*.IS_compare\")                                               , emit: compare\n    tuple val(meta), path(\"*.IS_compare/output/*.IS_compare_comparisonsTable.tsv\")      , emit: comparisons_table   , optional: true\n    tuple val(meta), path(\"*.IS_compare/output/*.IS_compare_pooled_SNV_data.tsv\")       , emit: pooled_snv\n    tuple val(meta), path(\"*.IS_compare/output/*.IS_compare_pooled_SNV_data_keys.tsv\")  , emit: snv_keys\n    tuple val(meta), path(\"*.IS_compare/output/*.IS_compare_pooled_SNV_info.tsv\")       , emit: snv_info\n    path \"versions.yml\"                                                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def stb_args = stb_file ? \"-s ${stb_file}\": ''\n    \"\"\"\n    inStrain \\\\\n        compare \\\\\n        -i $profiles \\\\\n        -o ${prefix}.IS_compare \\\\\n        --processes $task.cpus \\\\\n        --bams $bams \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        instrain: \\$(echo \\$(inStrain compare --version 2>&1) | awk 'NF{ print \\$NF }')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def stb_args = stb_file ? \"-s ${stb_file}\": ''\n    \"\"\"\n    mkdir -p ${prefix}.IS_compare/output\n    touch ${prefix}.IS_compare/output/${prefix}.IS_compare_pooled_SNV_info.tsv\n    touch ${prefix}.IS_compare/output/${prefix}.IS_compare_comparisonsTable.tsv\n    touch ${prefix}.IS_compare/output/${prefix}.IS_compare_pooled_SNV_data.tsv\n    touch ${prefix}.IS_compare/output/${prefix}.IS_compare_pooled_SNV_data_keys.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        instrain: \\$(echo \\$(inStrain compare --version 2>&1) | awk 'NF{ print \\$NF }')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: In silico prediction of E. coli serotype\nTags: escherichia coli, fasta, serotype", "answer": "process ECTYPER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ectyper:1.0.0--pyhdfd78af_1' :\n        'biocontainers/ectyper:1.0.0--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.log\"), emit: log\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getName().endsWith(\".gz\") ? true : false\n    def fasta_name = fasta.getName().replace(\".gz\", \"\")\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    ectyper \\\\\n        $args \\\\\n        --cores $task.cpus \\\\\n        --output ./ \\\\\n        --input $fasta_name\n\n    mv output.tsv ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ectyper: \\$(echo \\$(ectyper --version 2>&1)  | sed 's/.*ectyper //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: estimation of the unfolded site frequency spectrum\nTags: site frequency spectrum, ancestral alleles, derived alleles", "answer": "process ESTSFS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"bioconda::est-sfs=2.04\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/est-sfs:2.04--h245ed52_0':\n        'biocontainers/est-sfs:2.04--h245ed52_0' }\"\n\n    input:\n    tuple val(meta), path(e_config), path(data), path(seed)\n\n    output:\n    tuple val(meta), path(\"${prefix}_sfs.txt\")   , emit: sfs_out\n    tuple val(meta), path(\"${prefix}_pvalues.txt\"), emit: pvalues_out\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def VERSION = '2.04' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    est-sfs ${e_config} ${data} ${seed} ${prefix}_sfs.txt ${prefix}_pvalues.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        est-sfs: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_sfs.txt\n    touch ${prefix}_pvalues.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        est-sfs: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Gubbins (Genealogies Unbiased By recomBinations In Nucleotide Sequences) is an algorithm that iteratively identifies loci containing elevated densities of base substitutions while concurrently constructing a phylogeny based on the putative point mutations outside of these regions.\nTags: recombination, alignment", "answer": "process GUBBINS {\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gubbins:3.0.0--py39h5bf99c6_0' :\n        'biocontainers/gubbins:3.0.0--py39h5bf99c6_0' }\"\n\n    input:\n    path alignment\n\n    output:\n    path \"*.fasta\"                          , emit: fasta\n    path \"*.gff\"                            , emit: gff\n    path \"*.vcf\"                            , emit: vcf\n    path \"*.csv\"                            , emit: stats\n    path \"*.phylip\"                         , emit: phylip\n    path \"*.recombination_predictions.embl\" , emit: embl_predicted\n    path \"*.branch_base_reconstruction.embl\", emit: embl_branch\n    path \"*.final_tree.tre\"                 , emit: tree\n    path \"*.node_labelled.final_tree.tre\"   , emit: tree_labelled\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    run_gubbins.py \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $alignment\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gubbins: \\$(run_gubbins.py --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Uses evigene/scripts/prot/tr2aacds.pl to filter a transcript assembly\nTags: genomics, transcript, assembly, clean, polish, filter, redundant, duplicate", "answer": "process EVIGENE_TR2AACDS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/evigene:23.7.15--hdfd78af_1':\n        'biocontainers/evigene:23.7.15--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"dropset\")    , emit: dropset\n    tuple val(meta), path(\"okayset\")    , emit: okayset\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args     ?: ''\n    def prefix      = task.ext.prefix   ?: \"${meta.id}\"\n\n    def max_memory  = 7*1024\n    if (!task.memory) {\n        log.info '[evigene] Available memory not known - defaulting to 7GB. Specify process memory requirements to change this.'\n    } else {\n        max_memory  = (task.memory.mega*0.8).intValue()\n    }\n\n    def simple_name = fasta.simpleName\n    def rename_files= ( simple_name != prefix ) ? 'yes' : 'no'\n    \"\"\"\n    # Nextflow changes the container --entrypoint to /bin/bash (container default entrypoint: /usr/local/env-execute)\n    # Check for container variable initialisation script and source it.\n    if [ -f \"/usr/local/env-activate.sh\" ]; then\n        set +u  # Otherwise, errors out because of various unbound variables\n        . \"/usr/local/env-activate.sh\"\n        set -u\n    fi\n\n    \\$EVIGENEHOME/scripts/prot/tr2aacds.pl \\\\\n        $args \\\\\n        -NCPU=$task.cpus \\\\\n        -MAXMEM=$max_memory \\\\\n        -cdnaseq $fasta\n\n    if [ \"$rename_files\" = \"yes\" ]; then\n        find \\\\\n            dropset \\\\\n            -type f \\\\\n            -exec sh -c 'mv \"\\$1\" \"\\$(echo \\$1 | sed s/$simple_name/$prefix/)\"' sh {} \\\\;\n\n        find \\\\\n            okayset \\\\\n            -type f \\\\\n            -exec sh -c 'mv \"\\$1\" \"\\$(echo \\$1 | sed s/$simple_name/$prefix/)\"' sh {} \\\\;\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tr2aacds: \\$(cat \\$EVIGENEHOME/scripts/prot/tr2aacds.pl | sed -n 's/use constant VERSION =>  \\\\([^;]*\\\\);.*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args        = task.ext.args ?: ''\n    def prefix      = task.ext.prefix ?: \"${meta.id}\"\n    def max_memory  = 7*1024\n    if (!task.memory) {\n        log.info '[evigene] Available memory not known - defaulting to 7GB. Specify process memory requirements to change this.'\n    }\n    \"\"\"\n    # Nextflow changes the container --entrypoint to /bin/bash (container default entrypoint: /usr/local/env-execute)\n    # Check for container variable initialisation script and source it.\n    if [ -f \"/usr/local/env-activate.sh\" ]; then\n        set +u  # Otherwise, errors out because of various unbound variables\n        . \"/usr/local/env-activate.sh\"\n        set -u\n    fi\n\n    mkdir dropset\n    touch dropset/${prefix}.drop.aa\n    touch dropset/${prefix}.drop.cds\n    touch dropset/${prefix}.drop.tr\n\n    mkdir okayset\n    touch okayset/${prefix}.ann.txt\n    touch okayset/${prefix}.cull.aa\n    touch okayset/${prefix}.cull.cds\n    touch okayset/${prefix}.cull.mrna\n    touch okayset/${prefix}.genesum.txt\n    touch okayset/${prefix}.mainalt.tab\n    touch okayset/${prefix}.okay.aa\n    touch okayset/${prefix}.okay.cds\n    touch okayset/${prefix}.okay.mrna\n    touch okayset/${prefix}.pubids\n    touch okayset/${prefix}.pubids.old\n    touch okayset/${prefix}.pubids.realt.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tr2aacds: \\$(cat \\$EVIGENEHOME/scripts/prot/tr2aacds.pl | sed -n 's/use constant VERSION =>  \\\\([^;]*\\\\);.*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: De novo genome assembler for long uncorrected reads.\nTags: de novo, assembly, genome, genome assembler, long uncorrected reads", "answer": "process RAVEN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/raven-assembler:1.6.1--h2e03b76_0' :\n        'biocontainers/raven-assembler:1.6.1--h2e03b76_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.fasta.gz\"), emit: fasta\n    tuple val(meta), path(\"*.gfa.gz\")  , emit: gfa\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    # run tool\n    raven \\\\\n        -t $task.cpus \\\\\n        --graphical-fragment-assembly ${prefix}.gfa \\\\\n        $args \\\\\n        $reads | \\\\\n        gzip -c > ${prefix}.fasta.gz\n\n    # compress assembly graph\n    gzip -c ${prefix}.gfa > ${prefix}.gfa.gz\n\n    # get tool version\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        raven: \\$( raven --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: HUMID is a tool to quickly and easily remove duplicate reads from FastQ files, with or without UMIs.\nTags: umi, fastq, deduplication, hamming-distance, clustering", "answer": "\nprocess HUMID {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/humid:1.0.4--hadf994f_0':\n        'biocontainers/humid:1.0.4--hadf994f_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(umi_file)\n\n    output:\n    tuple val(meta), path(\"${prefix}.log\")         , emit: log\n    tuple val(meta), path(\"*_dedup*.fastq.gz\")     , emit: dedup    , optional: true\n    tuple val(meta), path(\"*_annotated*.fastq.gz\") , emit: annotated, optional: true\n    tuple val(meta), path(\"${prefix}\")             , emit: stats    , optional: true\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def umis = umi_file ?: ''\n    def VERSION = '1.0.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    humid \\\\\n        $args \\\\\n        -d ${prefix} \\\\\n        -l ${prefix}.log \\\\\n        $reads \\\\\n        $umis \\\\\n\n    mv ${prefix}/*.fastq* .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        humid: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def umis = umi_file ?: ''\n    def VERSION = '1.0.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    mkdir -p ${prefix}\n    touch ${prefix}_1_dedup.fastq.gz\n    touch ${prefix}_2_dedup.fastq.gz\n    touch ${prefix}_1_annotated.fastq.gz\n    touch ${prefix}_2_annotated.fastq.gz\n    touch ${prefix}/stats.dat\n    touch ${prefix}/neigh.dat\n    touch ${prefix}/counts.dat\n    touch ${prefix}/clusters.dat\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        humid: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cellsnp-lite is a C/C++ tool for efficient genotyping bi-allelic SNPs on single cells. You can use the mode A of cellsnp-lite after read alignment to obtain the snp x cell pileup UMI or read count matrices for each alleles of given or detected SNPs for droplet based single cell data.\nTags: genotyping, single cell, SNP, droplet based single cells", "answer": "process CELLSNP_MODEA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cellsnp-lite:1.2.3--h6141fd1_2' :\n        'biocontainers/cellsnp-lite:1.2.3--h6141fd1_2' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(region_vcf), path(barcode)\n\n    output:\n    tuple val(meta), path('*.base.vcf.gz') , emit: base\n    tuple val(meta), path('*.cells.vcf.gz'), emit: cell          , optional: true\n    tuple val(meta), path('*.samples.tsv') , emit: sample\n    tuple val(meta), path('*.tag.AD.mtx')  , emit: allele_depth\n    tuple val(meta), path('*.tag.DP.mtx')  , emit: depth_coverage\n    tuple val(meta), path('*.tag.OTH.mtx') , emit: depth_other\n    path 'versions.yml'                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args         = task.ext.args   ?: ''\n    def prefix       = task.ext.prefix ?: \"${meta.id}\"\n    def region_file  = region_vcf      ? \"-R $region_vcf\"  : ''\n    \"\"\"\n    cellsnp-lite -s $bam \\\\\n        -b $barcode \\\\\n        $region_file \\\\\n        -O . \\\\\n        --gzip \\\\\n        --nproc $task.cpus \\\\\n        $args\n\n    mv cellSNP.base.vcf.gz ${prefix}.base.vcf.gz\n    if [[ \"$args\" == *\"--genotype\"* ]]; then\n        mv cellSNP.cells.vcf.gz ${prefix}.cells.vcf.gz\n    fi\n    mv cellSNP.tag.AD.mtx ${prefix}.tag.AD.mtx\n    mv cellSNP.tag.DP.mtx ${prefix}.tag.DP.mtx\n    mv cellSNP.tag.OTH.mtx ${prefix}.tag.OTH.mtx\n    mv cellSNP.samples.tsv ${prefix}.samples.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellsnp: \\$(cellsnp-lite --v | awk '{print \\$2}')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir $prefix\n    echo \"\" | gzip > ${prefix}.base.vcf.gz\n    touch ${prefix}.samples.tsv\n    touch ${prefix}.tag.AD.mtx\n    touch ${prefix}.tag.DP.mtx\n    touch ${prefix}.tag.OTH.mtx\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellsnp: \\$(cellsnp-lite --v | awk '{print \\$2}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to create a Gemini-compatible DB file from an annotated VCF\nTags: vcf2db, vcf, gemini", "answer": "process VCF2DB {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vcf2db:2020.02.24--pl5321hdfd78af_3':\n        'biocontainers/vcf2db:2020.02.24--pl5321hdfd78af_3' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(ped)\n\n    output:\n    tuple val(meta), path(\"*.db\") , emit: db\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"2020.02.24\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    vcf2db.py \\\\\n        $vcf \\\\\n        $ped \\\\\n        ${prefix}.db \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcf2db: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"2020.02.24\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.db\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcf2db: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Determining whether sequencing data comes from the same individual by using SNP matching. Designed for humans on vcf or bam files.\nTags: ngscheckmate, matching, snp", "answer": "process NGSCHECKMATE_NCM {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ngscheckmate:1.0.1--py27pl5321r40hdfd78af_1':\n        'biocontainers/ngscheckmate:1.0.1--py27pl5321r40hdfd78af_1' }\"\n\n    input:\n    tuple val(meta) , path(files)\n    tuple val(meta2), path(snp_bed)\n    tuple val(meta3), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*_corr_matrix.txt\"), emit: corr_matrix\n    tuple val(meta), path(\"*_matched.txt\")    , emit: matched\n    tuple val(meta), path(\"*_all.txt\")        , emit: all\n    tuple val(meta), path(\"*.pdf\")            , emit: pdf, optional: true\n    tuple val(meta), path(\"*.vcf\")            , emit: vcf, optional: true\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n    def unzip = files.any { it.toString().endsWith(\".vcf.gz\") }\n    \"\"\"\n    if $unzip\n    then\n        for VCFGZ in *.vcf.gz; do\n            gunzip -cdf \\$VCFGZ > \\$( basename \\$VCFGZ .gz );\n        done\n    fi\n\n    NCM_REF=\"./\"${fasta} ncm.py -d . -bed ${snp_bed} -O . -N ${prefix} $args\n\n    if $unzip\n    then\n        rm -f *.vcf  # clean up decompressed vcfs\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n    \"\"\"\n    touch ${prefix}_output_corr_matrix.txt\n    touch ${prefix}_matched.txt\n    touch ${prefix}_all.txt\n    touch ${prefix}.pdf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Determining whether sequencing data comes from the same individual by using SNP matching. This module generates PT files from a bed file containing individual positions.\nTags: ngscheckmate, matching, snp, qc", "answer": "process NGSCHECKMATE_VAFNCM {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ngscheckmate:1.0.1--py27pl5321r40hdfd78af_1' :\n        'biocontainers/ngscheckmate:1.0.1--py27pl5321r40hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(vafs)\n\n    output:\n    tuple val(meta), path(\"*.pdf\")             , emit: pdf, optional: true\n    tuple val(meta), path(\"*_corr_matrix.txt\") , emit: corr_matrix\n    tuple val(meta), path(\"*_all.txt\")         , emit: all\n    tuple val(meta), path(\"*_matched.txt\")     , emit: matched\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    # tool has a bug where it misses the final file, so add a dummy one.\n    cp ${vafs[0]} zzzzzz.vaf\n    vaf_ncm.py -I . -O . -N ${prefix} $args\n\n    # remove the existance of the dummy file\n    rm zzzzzz.vaf\n    sed -i.bak \"/zzzzzz/d\" ${prefix}_all.txt\n\n    # generate a file with all the samples that do match, for consistency with the bam mode (ngscheckmate/ncm)\n    sed \"/unmatched/d\" ${prefix}_all.txt > ${prefix}_matched.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}_corr_matrix.txt\n    touch ${prefix}_matched.txt\n    touch ${prefix}_all.txt\n    touch ${prefix}.pdf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Determining whether sequencing data comes from the same individual by using SNP matching. This module generates PT files from a bed file containing individual positions.\nTags: ngscheckmate, matching, snp, qc", "answer": "process NGSCHECKMATE_PATTERNGENERATOR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ngscheckmate:1.0.1--py27pl5321r40hdfd78af_1' :\n        'biocontainers/ngscheckmate:1.0.1--py27pl5321r40hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(bowtie_index)\n\n    output:\n    tuple val(meta), path(\"*.pt\"), emit: pt\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$fasta\" == \"${prefix}.fasta\") error \"makesnvpattern.pl generates a fasta file with the same name as the input fasta, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    INDEX=\\$(find -L ./ -name \"*.3.ebwt\" | sed 's/\\\\.3.ebwt\\$//')\n\n    makesnvpattern.pl ${bed} ${fasta} \\$INDEX . ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$fasta\" == \"${prefix}.fasta\") error \"makesnvpattern.pl generates a fasta file with the same name as the input fasta, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    touch ${prefix}.pt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Determining whether sequencing data comes from the same individual by using SNP matching. This module generates vaf files for individual fastq file(s), ready for the vafncm module.\nTags: ngscheckmate, matching, snp, qc", "answer": "process NGSCHECKMATE_FASTQ {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ngscheckmate:1.0.1--py27pl5321r40hdfd78af_1':\n        'biocontainers/ngscheckmate:1.0.1--py27pl5321r40hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(snp_pt)\n\n    output:\n    tuple val(meta), path(\"*.vaf\"), emit: vaf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def fastq2command  = ( reads instanceof List && reads.size() == 2 ) ? \" -2 ${reads[1]} \" : \"\"\n\n    \"\"\"\n    ngscheckmate_fastq  -1 ${reads[0]} $fastq2command ${snp_pt} -p ${task.cpus} $args > ${prefix}.vaf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vaf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngscheckmate: \\$(ncm.py --help | sed \"7!d;s/ *Ensuring Sample Identity v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: An ultra-fast metagenomic assembler for large and complex metagenomics\nTags: megahit, denovo, assembly, debruijn, metagenomics", "answer": "process MEGAHIT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/megahit_pigz:657d77006ae5f222' :\n        'community.wave.seqera.io/library/megahit_pigz:87a590163e594224' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.contigs.fa.gz\")                            , emit: contigs\n    tuple val(meta), path(\"intermediate_contigs/k*.contigs.fa.gz\")      , emit: k_contigs\n    tuple val(meta), path(\"intermediate_contigs/k*.addi.fa.gz\")         , emit: addi_contigs\n    tuple val(meta), path(\"intermediate_contigs/k*.local.fa.gz\")        , emit: local_contigs\n    tuple val(meta), path(\"intermediate_contigs/k*.final.contigs.fa.gz\"), emit: kfinal_contigs\n    path \"versions.yml\"                                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads_command = meta.single_end ? \"-r ${reads}\" : \"-1 ${reads[0]} -2 ${reads[1]}\"\n    \"\"\"\n    megahit \\\\\n        ${reads_command} \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        --out-prefix ${prefix}\n\n    pigz \\\\\n        --no-name \\\\\n        -p $task.cpus \\\\\n        $args2 \\\\\n        megahit_out/*.fa \\\\\n        megahit_out/intermediate_contigs/*.fa\n\n    mv megahit_out/* .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        megahit: \\$(echo \\$(megahit -v 2>&1) | sed 's/MEGAHIT v//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads_command = meta.single_end ? \"-r ${reads}\" : \"-1 ${reads[0]} -2 ${reads[1]}\"\n    \"\"\"\n    mkdir -p intermediate_contigs\n    echo \"\" | gzip > ${prefix}.contigs.fa.gz\n    echo \"\" | gzip > intermediate_contigs/k21.contigs.fa.gz\n    echo \"\" | gzip > intermediate_contigs/k21.addi.fa.gz\n    echo \"\" | gzip > intermediate_contigs/k21.local.fa.gz\n    echo \"\" | gzip > intermediate_contigs/k21.final.contigs.fa.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        megahit: \\$(echo \\$(megahit -v 2>&1) | sed 's/MEGAHIT v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tool for evaluation of MALT results for true positives of ancient metagenomic taxonomic screening\nTags: malt, MaltExtract, HOPS, alignment, metagenomics, ancient DNA, aDNA, palaeogenomics, archaeogenomics, microbiome, authentication, damage, edit distance", "answer": "process MALTEXTRACT {\n\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hops:0.35--hdfd78af_1' :\n        'biocontainers/hops:0.35--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(rma6)\n    path taxon_list\n    path ncbi_dir\n\n    output:\n    tuple val(meta), path(\"results\")      , emit: results\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    MaltExtract \\\\\n        -Xmx${task.memory.toGiga()}g \\\\\n        -p $task.cpus \\\\\n        -i ${rma6.join(' ')} \\\\\n        -t $taxon_list \\\\\n        -r $ncbi_dir \\\\\n        -o results/ \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        maltextract: \\$(MaltExtract --help | head -n 2 | tail -n 1 | sed 's/MaltExtract version//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Genetic variant annotation and functional effect prediction toolbox\nTags: annotation, effect prediction, snpeff, variant, vcf", "answer": "process SNPEFF_SNPEFF {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snpeff:5.1--hdfd78af_2' :\n        'biocontainers/snpeff:5.1--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    val   db\n    tuple val(meta2), path(cache)\n\n    output:\n    tuple val(meta), path(\"*.ann.vcf\"),   emit: vcf\n    tuple val(meta), path(\"*.csv\"),       emit: report\n    tuple val(meta), path(\"*.html\"),      emit: summary_html\n    tuple val(meta), path(\"*.genes.txt\"), emit: genes_txt\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def avail_mem = 6144\n    if (!task.memory) {\n        log.info '[snpEff] Available memory not known - defaulting to 6GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def cache_command = cache ? \"-dataDir \\${PWD}/${cache}\" : \"\"\n    \"\"\"\n    snpEff \\\\\n        -Xmx${avail_mem}M \\\\\n        $db \\\\\n        $args \\\\\n        -csvStats ${prefix}.csv \\\\\n        $cache_command \\\\\n        $vcf \\\\\n        > ${prefix}.ann.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpeff: \\$(echo \\$(snpEff -version 2>&1) | cut -f 2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.ann.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpeff: \\$(echo \\$(snpEff -version 2>&1) | cut -f 2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Genetic variant annotation and functional effect prediction toolbox\nTags: annotation, effect prediction, snpeff, variant, vcf", "answer": "process SNPEFF_DOWNLOAD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snpeff:5.1--hdfd78af_2' :\n        'biocontainers/snpeff:5.1--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), val(genome), val(cache_version)\n\n    output:\n    tuple val(meta), path('snpeff_cache'), emit: cache\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def avail_mem = 6144\n    if (!task.memory) {\n        log.info '[snpEff] Available memory not known - defaulting to 6GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    snpEff \\\\\n        -Xmx${avail_mem}M \\\\\n        download ${genome}.${cache_version} \\\\\n        -dataDir \\${PWD}/snpeff_cache \\\\\n        ${args}\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpeff: \\$(echo \\$(snpEff -version 2>&1) | cut -f 2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir ${genome}.${cache_version}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpeff: \\$(echo \\$(snpEff -version 2>&1) | cut -f 2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert paired-end bwa SA coordinate files to SAM format\nTags: bwa, aln, short-read, align, reference, fasta, map, sam, bam", "answer": "process BWA_SAMPE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-fe8faa35dbf6dc65a0f7f5d4ea12e31a79f73e40:9c0128851101dafef65cef649826d2dbe6bedd7e-0' :\n        'biocontainers/mulled-v2-fe8faa35dbf6dc65a0f7f5d4ea12e31a79f73e40:9c0128851101dafef65cef649826d2dbe6bedd7e-0' }\"\n\n    input:\n    tuple val(meta), path(reads), path(sai)\n    tuple val(meta2), path(index)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def read_group = meta.read_group ? \"-r ${meta.read_group}\" : \"\"\n\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n\n    bwa sampe \\\\\n        $args \\\\\n        $read_group \\\\\n        \\$INDEX \\\\\n        $sai \\\\\n        $reads | samtools sort -@ ${task.cpus} -O bam - > ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwa: \\$(echo \\$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert bwa SA coordinate file to SAM format\nTags: bwa, aln, short-read, align, reference, fasta, map, sam, bam", "answer": "process BWA_SAMSE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-fe8faa35dbf6dc65a0f7f5d4ea12e31a79f73e40:9c0128851101dafef65cef649826d2dbe6bedd7e-0' :\n        'biocontainers/mulled-v2-fe8faa35dbf6dc65a0f7f5d4ea12e31a79f73e40:9c0128851101dafef65cef649826d2dbe6bedd7e-0' }\"\n\n    input:\n    tuple val(meta), path(reads), path(sai)\n    tuple val(meta2), path(index)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def read_group = meta.read_group ? \"-r ${meta.read_group}\" : \"\"\n\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n\n    bwa samse \\\\\n        $args \\\\\n        $read_group \\\\\n        \\$INDEX \\\\\n        $sai \\\\\n        $reads | samtools sort -@ ${task.cpus - 1} -O bam - > ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwa: \\$(echo \\$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create BWA index for reference genome\nTags: index, fasta, genome, reference", "answer": "process BWA_INDEX {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bwa:0.7.18--he4a0461_0' :\n        'biocontainers/bwa:0.7.18--he4a0461_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(bwa) , emit: index\n    path \"versions.yml\"        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${fasta.baseName}\"\n    def args   = task.ext.args ?: ''\n    \"\"\"\n    mkdir bwa\n    bwa \\\\\n        index \\\\\n        $args \\\\\n        -p bwa/${prefix} \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwa: \\$(echo \\$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${fasta.baseName}\"\n    \"\"\"\n    mkdir bwa\n\n    touch bwa/${prefix}.amb\n    touch bwa/${prefix}.ann\n    touch bwa/${prefix}.bwt\n    touch bwa/${prefix}.pac\n    touch bwa/${prefix}.sa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwa: \\$(echo \\$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs fastq alignment to a fasta reference using BWA\nTags: mem, bwa, alignment, map, fastq, bam, sam", "answer": "process BWA_MEM {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-fe8faa35dbf6dc65a0f7f5d4ea12e31a79f73e40:1bd8542a8a0b42e0981337910954371d0230828e-0' :\n        'biocontainers/mulled-v2-fe8faa35dbf6dc65a0f7f5d4ea12e31a79f73e40:1bd8542a8a0b42e0981337910954371d0230828e-0' }\"\n\n    input:\n    tuple val(meta) , path(reads)\n    tuple val(meta2), path(index)\n    tuple val(meta3), path(fasta)\n    val   sort_bam\n\n    output:\n    tuple val(meta), path(\"*.bam\")  , emit: bam,    optional: true\n    tuple val(meta), path(\"*.cram\") , emit: cram,   optional: true\n    tuple val(meta), path(\"*.csi\")  , emit: csi,    optional: true\n    tuple val(meta), path(\"*.crai\") , emit: crai,   optional: true\n    path  \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    def extension = args2.contains(\"--output-fmt sam\")   ? \"sam\" :\n                    args2.contains(\"--output-fmt cram\")  ? \"cram\":\n                    sort_bam && args2.contains(\"-O cram\")? \"cram\":\n                    !sort_bam && args2.contains(\"-C\")    ? \"cram\":\n                    \"bam\"\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n    \"\"\"\n    INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n\n    bwa mem \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        \\$INDEX \\\\\n        $reads \\\\\n        | samtools $samtools_command $args2 ${reference} --threads $task.cpus -o ${prefix}.${extension} -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwa: \\$(echo \\$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    def extension = args2.contains(\"--output-fmt sam\")   ? \"sam\" :\n                    args2.contains(\"--output-fmt cram\")  ? \"cram\":\n                    sort_bam && args2.contains(\"-O cram\")? \"cram\":\n                    !sort_bam && args2.contains(\"-C\")    ? \"cram\":\n                    \"bam\"\n    \"\"\"\n    touch ${prefix}.${extension}\n    touch ${prefix}.csi\n    touch ${prefix}.crai\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bwa: \\$(echo \\$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Find SA coordinates of the input reads for bwa short-read mapping\nTags: bwa, aln, short-read, align, reference, fasta, map, fastq", "answer": "process BWA_ALN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bwa:0.7.18--he4a0461_0' :\n        'biocontainers/bwa:0.7.18--he4a0461_0' }\"\n\n    input:\n    tuple val(meta) , path(reads)\n    tuple val(meta2), path(index)\n\n    output:\n    tuple val(meta), path(\"*.sai\"), emit: sai\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (meta.single_end) {\n        \"\"\"\n        INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n\n        bwa aln \\\\\n            $args \\\\\n            -t $task.cpus \\\\\n            -f ${prefix}.sai \\\\\n            \\$INDEX \\\\\n            ${reads}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            bwa: \\$(echo \\$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n\n        bwa aln \\\\\n            $args \\\\\n            -t $task.cpus \\\\\n            -f ${prefix}.1.sai \\\\\n            \\$INDEX \\\\\n            ${reads[0]}\n\n        bwa aln \\\\\n            $args \\\\\n            -t $task.cpus \\\\\n            -f ${prefix}.2.sai \\\\\n            \\$INDEX \\\\\n            ${reads[1]}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            bwa: \\$(echo \\$(bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Determines the gender of a sample from the BAM/CRAM file.\nTags: gender, cram, bam, short reads", "answer": "process NGSBITS_SAMPLEGENDER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ngs-bits:2023_02--py311ha0b7adc_2':\n        'biocontainers/ngs-bits:2023_02--py311ha0b7adc_2' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta2), path(fai)\n    val method\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def ref = fasta ? \"-ref ${fasta}\" : \"\"\n    \"\"\"\n    SampleGender \\\\\n        -in ${bam} \\\\\n        -method ${method} \\\\\n        -out ${prefix}.tsv \\\\\n        ${ref} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngs-bits: \\$(echo \\$(SampleGender --version 2>&1) | sed 's/SampleGender //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ngs-bits: \\$(echo \\$(SampleGender --version 2>&1) | sed 's/SampleGender //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Strelka2 is a fast and accurate small variant caller optimized for analysis of germline variation\nTags: variantcalling, germline, wgs, vcf, variants", "answer": "process STRELKA_GERMLINE {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'error_retry'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/strelka:2.9.10--h9ee0642_1' :\n        'biocontainers/strelka:2.9.10--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path (target_bed), path (target_bed_index)\n    path  fasta\n    path  fai\n\n    output:\n    tuple val(meta), path(\"*variants.vcf.gz\")    , emit: vcf\n    tuple val(meta), path(\"*variants.vcf.gz.tbi\"), emit: vcf_tbi\n    tuple val(meta), path(\"*genome.vcf.gz\")      , emit: genome_vcf\n    tuple val(meta), path(\"*genome.vcf.gz.tbi\")  , emit: genome_vcf_tbi\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions  = target_bed ? \"--callRegions ${target_bed}\" : \"\"\n    \"\"\"\n    configureStrelkaGermlineWorkflow.py \\\\\n        --bam $input \\\\\n        --referenceFasta $fasta \\\\\n        $regions \\\\\n        $args \\\\\n        --runDir strelka\n\n    sed -i s/\"isEmail = isLocalSmtp()\"/\"isEmail = False\"/g strelka/runWorkflow.py\n\n    python strelka/runWorkflow.py -m local -j $task.cpus\n    mv strelka/results/variants/genome.*.vcf.gz     ${prefix}.genome.vcf.gz\n    mv strelka/results/variants/genome.*.vcf.gz.tbi ${prefix}.genome.vcf.gz.tbi\n    mv strelka/results/variants/variants.vcf.gz     ${prefix}.variants.vcf.gz\n    mv strelka/results/variants/variants.vcf.gz.tbi ${prefix}.variants.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        strelka: \\$( configureStrelkaGermlineWorkflow.py --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.genome.vcf.gz\n    touch ${prefix}.genome.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.variants.vcf.gz\n    touch ${prefix}.variants.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        strelka: \\$( configureStrelkaSomaticWorkflow.py --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Strelka2 is a fast and accurate small variant caller optimized for analysis of germline variation in small cohorts and somatic variation in tumor/normal sample pairs\nTags: variant calling, germline, wgs, vcf, variants", "answer": "process STRELKA_SOMATIC {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'error_retry'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/strelka:2.9.10--h9ee0642_1' :\n        'biocontainers/strelka:2.9.10--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(input_normal), path(input_index_normal), path(input_tumor), path(input_index_tumor),  path(manta_candidate_small_indels), path(manta_candidate_small_indels_tbi), path(target_bed), path(target_bed_index)\n    path  fasta\n    path  fai\n\n    output:\n    tuple val(meta), path(\"*.somatic_indels.vcf.gz\")    , emit: vcf_indels\n    tuple val(meta), path(\"*.somatic_indels.vcf.gz.tbi\"), emit: vcf_indels_tbi\n    tuple val(meta), path(\"*.somatic_snvs.vcf.gz\")      , emit: vcf_snvs\n    tuple val(meta), path(\"*.somatic_snvs.vcf.gz.tbi\")  , emit: vcf_snvs_tbi\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def options_target_bed = target_bed ? \"--callRegions ${target_bed}\" : \"\"\n    def options_manta = manta_candidate_small_indels ? \"--indelCandidates ${manta_candidate_small_indels}\" : \"\"\n    \"\"\"\n\n    configureStrelkaSomaticWorkflow.py \\\\\n        --tumor $input_tumor \\\\\n        --normal $input_normal \\\\\n        --referenceFasta $fasta \\\\\n        ${options_target_bed} \\\\\n        ${options_manta} \\\\\n        $args \\\\\n        --runDir strelka\n\n    sed -i s/\"isEmail = isLocalSmtp()\"/\"isEmail = False\"/g strelka/runWorkflow.py\n\n    python strelka/runWorkflow.py -m local -j $task.cpus\n    mv strelka/results/variants/somatic.indels.vcf.gz     ${prefix}.somatic_indels.vcf.gz\n    mv strelka/results/variants/somatic.indels.vcf.gz.tbi ${prefix}.somatic_indels.vcf.gz.tbi\n    mv strelka/results/variants/somatic.snvs.vcf.gz       ${prefix}.somatic_snvs.vcf.gz\n    mv strelka/results/variants/somatic.snvs.vcf.gz.tbi   ${prefix}.somatic_snvs.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        strelka: \\$( configureStrelkaSomaticWorkflow.py --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.somatic_indels.vcf.gz\n    touch ${prefix}.somatic_indels.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.somatic_snvs.vcf.gz\n    touch ${prefix}.somatic_snvs.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        strelka: \\$( configureStrelkaSomaticWorkflow.py --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assessment of duplication rates in RNA-Seq datasets\nTags: rnaseq, duplication, genomics", "answer": "process DUPRADAR {\n    tag \"$meta.id\"\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-dupradar:1.32.0--r43hdfd78af_0' :\n        'biocontainers/bioconductor-dupradar:1.32.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(gtf)\n\n    output:\n    tuple val(meta), path(\"*_duprateExpDens.pdf\")   , emit: scatter2d\n    tuple val(meta), path(\"*_duprateExpBoxplot.pdf\"), emit: boxplot\n    tuple val(meta), path(\"*_expressionHist.pdf\")   , emit: hist\n    tuple val(meta), path(\"*_dupMatrix.txt\")        , emit: dupmatrix\n    tuple val(meta), path(\"*_intercept_slope.txt\")  , emit: intercept_slope\n    tuple val(meta), path(\"*_mqc.txt\")              , emit: multiqc\n    tuple val(meta), path(\"*.R_sessionInfo.log\")    , emit: session_info\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'dupradar.r'\n\n    stub:\n    \"\"\"\n    touch ${meta.id}_duprateExpDens.pdf\n    touch ${meta.id}_duprateExpBoxplot.pdf\n    touch ${meta.id}_expressionHist.pdf\n    touch ${meta.id}_dupMatrix.txt\n    touch ${meta.id}_intercept_slope.txt\n    touch ${meta.id}_dup_intercept_mqc.txt\n    touch ${meta.id}_duprateExpDensCurve_mqc.txt\n    touch ${meta.id}.R_sessionInfo.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bioconductor-dupradar: \\$(Rscript -e \"library(dupRadar); cat(as.character(packageVersion('dupRadar')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Align reads to a reference genome using bowtie\nTags: align, map, fastq, fasta, genome, reference", "answer": "process BOWTIE_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-ffbf83a6b0ab6ec567a336cf349b80637135bca3:c84c7c55c45af231883d9ff4fe706ac44c479c36-0' :\n        'biocontainers/mulled-v2-ffbf83a6b0ab6ec567a336cf349b80637135bca3:c84c7c55c45af231883d9ff4fe706ac44c479c36-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(index)\n    val (save_unaligned)\n\n    output:\n    tuple val(meta), path('*.bam')     , emit: bam\n    tuple val(meta), path('*.out')     , emit: log\n    tuple val(meta), path('*fastq.gz') , emit: fastq, optional : true\n    path  \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def unaligned = save_unaligned ? \"--un ${prefix}.unmapped.fastq\" : ''\n    def endedness = meta.single_end ? \"$reads\" : \"-1 ${reads[0]} -2 ${reads[1]}\"\n    \"\"\"\n    INDEX=\\$(find -L ./ -name \"*.3.ebwt\" | sed 's/\\\\.3.ebwt\\$//')\n    bowtie \\\\\n        --threads $task.cpus \\\\\n        --sam \\\\\n        -x \\$INDEX \\\\\n        -q \\\\\n        $unaligned \\\\\n        $args \\\\\n        $endedness \\\\\n        2> >(tee ${prefix}.out >&2) \\\\\n        | samtools view $args2 -@ $task.cpus -bS -o ${prefix}.bam -\n\n    if [ -f ${prefix}.unmapped.fastq ]; then\n        gzip ${prefix}.unmapped.fastq\n    fi\n    if [ -f ${prefix}.unmapped_1.fastq ]; then\n        gzip ${prefix}.unmapped_1.fastq\n        gzip ${prefix}.unmapped_2.fastq\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bowtie: \\$(echo \\$(bowtie --version 2>&1) | sed 's/^.*bowtie-align-s version //; s/ .*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def unaligned = save_unaligned ?\n                    meta.single_end ? \"echo '' | gzip > ${prefix}.unmapped.fastq.gz\" :\n                        \"echo '' | gzip > ${prefix}.unmapped_1.fastq.gz; echo '' | gzip > ${prefix}.unmapped_2.fastq.gz\"\n                    : ''\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix}.out\n    $unaligned\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bowtie: \\$(echo \\$(bowtie --version 2>&1) | sed 's/^.*bowtie-align-s version //; s/ .*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n\n}\n"}
{"question": "Description: Create bowtie index for reference genome\nTags: index, fasta, genome, reference", "answer": "process BOWTIE_BUILD {\n    tag \"${meta.id}\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bowtie:1.3.0--py38hed8969a_1' :\n        'biocontainers/bowtie:1.3.0--py38hed8969a_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path('bowtie') , emit: index\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p bowtie\n    bowtie-build --threads $task.cpus $fasta bowtie/${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bowtie: \\$(echo \\$(bowtie --version 2>&1) | sed 's/^.*bowtie-align-s version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p bowtie\n    touch bowtie/${prefix}.1.ebwt\n    touch bowtie/${prefix}.2.ebwt\n    touch bowtie/${prefix}.3.ebwt\n    touch bowtie/${prefix}.4.ebwt\n    touch bowtie/${prefix}.rev.1.ebwt\n    touch bowtie/${prefix}.rev.2.ebwt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bowtie: \\$(echo \\$(bowtie --version 2>&1) | sed 's/^.*bowtie-align-s version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Pacbio ccs - Generate Higly Accurate Single-Molecule Consensus Reads\nTags: ccs, pacbio, isoseq, subreads", "answer": "process PBCCS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pbccs:6.4.0--h9ee0642_0' :\n        'biocontainers/pbccs:6.4.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(pbi)\n    val chunk_num\n    val chunk_on\n\n    output:\n    tuple val(meta), path(\"*.chunk*.bam\")     , emit: bam\n    tuple val(meta), path(\"*.chunk*.bam.pbi\") , emit: pbi\n    tuple val(meta), path(\"*.report.txt\" )    , emit: report_txt\n    tuple val(meta), path(\"*.report.json\" )   , emit: report_json\n    tuple val(meta), path(\"*.metrics.json.gz\"), emit: metrics\n    path  \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ccs \\\\\n        $bam \\\\\n        ${prefix}.chunk${chunk_num}.bam \\\\\n        --report-file ${prefix}.chunk${chunk_num}.report.txt \\\\\n        --report-json ${prefix}.chunk${chunk_num}.report.json \\\\\n        --metrics-json ${prefix}.chunk${chunk_num}.metrics.json.gz \\\\\n        --chunk $chunk_num/$chunk_on \\\\\n        -j $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pbccs: \\$(echo \\$(ccs --version 2>&1) | grep 'ccs' | sed 's/^.*ccs //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch dummy.chunk1.bam\n    touch dummy.chunk1.bam.pbi\n    touch dummy.report.txt\n    touch dummy.report.json\n    echo \"test\" > dummy.metrics.json\n    gzip dummy.metrics.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pbccs: \\$(echo \\$(ccs --version 2>&1) | grep 'ccs' | sed 's/^.*ccs //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates a histogram of the number of distinct k-mers having a given frequency.\nTags: k-mer, histogram, count", "answer": "process KAT_HIST {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kat:2.4.2--py38hfc5f9d8_2':\n        'biocontainers/kat:2.4.2--py38hfc5f9d8_2' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.hist\")                   , emit: hist\n    tuple val(meta), path(\"*.hist.dist_analysis.json\"), emit: json\n    tuple val(meta), path(\"*.png\")                    , emit: png           , optional: true\n    tuple val(meta), path(\"*.ps\")                     , emit: ps            , optional: true\n    tuple val(meta), path(\"*.pdf\")                    , emit: pdf           , optional: true\n    tuple val(meta), path(\"*-hash.jf*\")               , emit: jellyfish_hash, optional: true\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    kat hist \\\\\n        --threads $task.cpus \\\\\n        --output_prefix ${prefix}.hist \\\\\n        $args \\\\\n        $reads\n\n    ls -l\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kat: \\$( kat hist --version | sed 's/kat //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: gget is a free, open-source command-line tool and Python package that enables efficient querying of genomic databases. gget consists of a collection of separate but interoperable modules, each designed to facilitate one type of database querying in a single line of code.\nTags: gget, reference, database, databases, download", "answer": "process GGET_GGET {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gget:0.27.2--pyh4a94de4_2':\n        'biocontainers/gget:0.27.2--pyh4a94de4_2' }\"\n\n    input:\n    tuple val(meta), path(files)\n\n    output:\n    tuple val(meta), path(\"*[!versions.yml][!${prefix}.${extension}]*\"), emit: files, optional: true\n    tuple val(meta), path(\"${prefix}.${extension}\")                   , emit: output, optional: true\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def inputs = files ?: \"\"\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    extension = args.startsWith(\"pdb\")  ? \"pdb\" :\n                args.contains(\"-csv\")   ? \"csv\" :\n                \"json\"\n    \"\"\"\n    gget \\\\\n        $args \\\\\n        -o ${prefix}.${extension} \\\\\n        $inputs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gget: \\$(echo \\$(gget --version 2>&1 | sed 's/gget version: //g'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs quality and adapter trimming on paired end and single end reads\nTags: trimming, adapter trimming, quality trimming", "answer": "process TRIMMOMATIC {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/trimmomatic:0.39--hdfd78af_2':\n        'biocontainers/trimmomatic:0.39--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.paired.trim*.fastq.gz\")   , emit: trimmed_reads\n    tuple val(meta), path(\"*.unpaired.trim_*.fastq.gz\"), emit: unpaired_reads, optional:true\n    tuple val(meta), path(\"*_trim.log\")                , emit: trim_log\n    tuple val(meta), path(\"*_out.log\")                 , emit: out_log\n    tuple val(meta), path(\"*.summary\")                 , emit: summary\n    path \"versions.yml\"                                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def trimmed = meta.single_end ? \"SE\" : \"PE\"\n    def output = meta.single_end ?\n        \"${prefix}.SE.paired.trim.fastq.gz\" // HACK to avoid unpaired and paired in the trimmed_reads output\n        : \"${prefix}.paired.trim_1.fastq.gz ${prefix}.unpaired.trim_1.fastq.gz ${prefix}.paired.trim_2.fastq.gz ${prefix}.unpaired.trim_2.fastq.gz\"\n    def qual_trim = task.ext.args2 ?: ''\n    \"\"\"\n    trimmomatic \\\\\n        $trimmed \\\\\n        -threads $task.cpus \\\\\n        -trimlog ${prefix}_trim.log \\\\\n        -summary ${prefix}.summary \\\\\n        $reads \\\\\n        $output \\\\\n        $qual_trim \\\\\n        $args 2> >(tee ${prefix}_out.log >&2)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trimmomatic: \\$(trimmomatic -version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (meta.single_end) {\n        output_command = \"echo '' | gzip > ${prefix}.SE.paired.trim.fastq.gz\"\n    } else {\n        output_command  = \"echo '' | gzip > ${prefix}.paired.trim_1.fastq.gz\"\n        output_command  = \"echo '' | gzip > ${prefix}.paired.trim_2.fastq.gz\"\n        output_command += \"echo '' | gzip > ${prefix}.unpaired.trim_1.fastq.gz\"\n        output_command += \"echo '' | gzip > ${prefix}.unpaired.trim_2.fastq.gz\"\n    }\n\n    \"\"\"\n    $output_command\n    touch ${prefix}.summary\n    touch ${prefix}_trim.log\n    touch ${prefix}_out.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trimmomatic: \\$(trimmomatic -version)\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Computes PCA eigenvectors for a Hi-C matrix.\nTags: eigenvectors, PCA, hicPCA", "answer": "process HICEXPLORER_HICPCA {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hicexplorer:3.7.2--pyhdfd78af_1':\n        'biocontainers/hicexplorer:3.7.2--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(matrix)\n\n    output:\n    tuple val(meta), path(\"${prefix}_*\")           , emit:results\n    tuple val(meta), path(\"${prefix}_pca1.$format\"), emit:pca1\n    tuple val(meta), path(\"${prefix}_pca2.$format\"), emit:pca2\n    path(\"versions.yml\")                           , emit:versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    args     = args.tokenize()\n    def idx  = args.findIndexOf{ it == '--format' | it == '-f' }\n    format   = 'bigwig'\n    if (idx>=0) {\n        format = args[idx+1]\n        args.remove(idx+1)\n        args.remove(idx)\n    }\n    idx = args.indexOf('--whichEigenvectors')\n    eigenvectors = '1 2'\n    if(idx>=0) {\n        eigenvectors = args[idx + 1]\n        args.remove(idx+1)\n        args.remove(idx)\n    }\n    outfilenames = eigenvectors.tokenize()\n        .collect{\"${prefix}_pca${it}.${format}\"}.join(' ')\n    args = args.join(' ')\n    \"\"\"\n    hicPCA \\\\\n        -m $matrix \\\\\n        $args \\\\\n        --format $format \\\\\n        --whichEigenvectors $eigenvectors \\\\\n        --outputFileName $outfilenames\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hicexplorer: \\$(hicPCA --version 2>&1 | sed 's/hicPCA //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs fastq alignment to a reference using DRAGMAP\nTags: alignment, map, fastq, bam, sam", "answer": "process DRAGMAP_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-580d344d9d4a496cd403932da8765f9e0187774d:7eed251370ac7f3537c3d9472cdb2f9f5d8da1c5-0':\n        'biocontainers/mulled-v2-580d344d9d4a496cd403932da8765f9e0187774d:7eed251370ac7f3537c3d9472cdb2f9f5d8da1c5-0' }\"\n\n    input:\n    tuple val(meta) , path(reads)\n    tuple val(meta2), path(hashmap)\n    tuple val(meta3), path(fasta)\n    val   sort_bam\n\n    output:\n    tuple val(meta), path(\"*.sam\")  , emit: sam   , optional: true\n    tuple val(meta), path(\"*.bam\")  , emit: bam   , optional: true\n    tuple val(meta), path(\"*.cram\") , emit: cram  , optional: true\n    tuple val(meta), path(\"*.crai\") , emit: crai  , optional: true\n    tuple val(meta), path(\"*.csi\")  , emit: csi   , optional: true\n    tuple val(meta), path('*.log')  , emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads_command       = meta.single_end ? \"-1 $reads\" : \"-1 ${reads[0]} -2 ${reads[1]}\"\n    def samtools_command    = sort_bam ? 'sort' : 'view'\n    def extension_pattern   = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher   =  (args2 =~ extension_pattern)\n    def extension           = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference           = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    \"\"\"\n    dragen-os \\\\\n        -r $hashmap \\\\\n        $args \\\\\n        --num-threads $task.cpus \\\\\n        $reads_command \\\\\n        2> >(tee ${prefix}.dragmap.log >&2) \\\\\n        | samtools $samtools_command $args2 --threads $task.cpus ${reference} -o ${prefix}.${extension} -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dragmap: \\$(echo \\$(dragen-os --version 2>&1))\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads_command = meta.single_end ? \"-1 $reads\" : \"-1 ${reads[0]} -2 ${reads[1]}\"\n    def samtools_command = sort_bam ? 'sort' : 'view'\n    def extension_pattern = /(--output-fmt|-O)+\\s+(\\S+)/\n    def extension_matcher =  (args2 =~ extension_pattern)\n    def extension = extension_matcher.getCount() > 0 ? extension_matcher[0][2].toLowerCase() : \"bam\"\n    def reference = fasta && extension==\"cram\"  ? \"--reference ${fasta}\" : \"\"\n    if (!fasta && extension==\"cram\") error \"Fasta reference is required for CRAM output\"\n\n    def create_index = \"\"\n    if (extension == \"cram\") {\n        create_index = \"touch ${prefix}.crai\"\n    } else if (extension == \"bam\") {\n        create_index = \"touch ${prefix}.csi\"\n    }\n\n    \"\"\"\n    touch ${prefix}.${extension}\n    ${create_index}\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dragmap: \\$(echo \\$(dragen-os --version 2>&1))\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create DRAGEN hashtable for reference genome\nTags: index, fasta, genome, reference", "answer": "process DRAGMAP_HASHTABLE {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/dragmap:1.3.0--h91baf5a_3':\n        'biocontainers/dragmap:1.3.0--h91baf5a_3' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"dragmap\")    , emit: hashmap\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir dragmap\n    dragen-os \\\\\n        --build-hash-table true \\\\\n        --ht-reference $fasta \\\\\n        --output-directory dragmap \\\\\n        $args \\\\\n        --ht-num-threads $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dragmap: \\$(echo \\$(dragen-os --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir dragmap\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dragmap: \\$(echo \\$(dragen-os --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Checks if the input file is bgzip compressed or not\nTags: compression, bgzip, grabix", "answer": "process GRABIX_CHECK {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/grabix:0.1.8--hdcf5f25_9':\n        'biocontainers/grabix:0.1.8--hdcf5f25_9' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), stdout, emit: compress_bgzip\n    path \"versions.yml\"    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    grabix check ${input} | tr -d '\\\\n'\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        grabix: \\$(grabix | sed -n -E 's/version: (.*)/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    \\$(echo yes)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        grabix: \\$(grabix | sed -n -E 's/version: (.*)/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compress file lists to produce ZIP archive files\nTags: unzip, decompression, zip, archiving", "answer": "process ZIP {\n    tag \"$prefix\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/p7zip:16.02' :\n        'biocontainers/p7zip:16.02' }\"\n\n    input:\n    tuple val(meta), path(files, stageAs: \"inputs/*\")\n\n    output:\n    tuple val(meta), path(\"${prefix}.zip\"), emit: zipped_archive\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    prefix = task.ext.prefix ?: ( meta.id ? \"${meta.id}\" : 'zipped_files')\n    \"\"\"\n    7z \\\\\n        a \\\\\n        -l \\\\\n        $args \\\\\n        \"${prefix}.zip\" ./inputs/*\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        7za: \\$(echo \\$(7za --help) | sed 's/.*p7zip Version //; s/(.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Simple software to call UPD regions from germline exome/wgs trios.\nTags: upd, uniparental, disomy", "answer": "\nprocess UPD {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/upd:0.1.1--pyhdfd78af_0':\n        'biocontainers/upd:0.1.1--pyhdfd78af_0' }\"\n\n    input:\n        tuple val(meta), path(vcf)\n\n    output:\n        tuple val(meta), path(\"*.bed\"), emit: bed\n        path \"versions.yml\"           , emit: versions\n\n    when:\n        task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    upd \\\\\n        --vcf $vcf \\\\\n        $args \\\\\n        | sort -k 1,1 -k 2,2n >${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        upd: \\$( upd --version 2>&1 | sed 's/upd, version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        upd: \\$( upd --version 2>&1 | sed 's/upd, version //' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Run NanoPlot on nanopore-sequenced reads\nTags: quality control, qc, fastq, sequencing summary, nanopore", "answer": "process NANOPLOT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nanoplot:1.41.6--pyhdfd78af_0' :\n        'biocontainers/nanoplot:1.41.6--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(ontfile)\n\n    output:\n    tuple val(meta), path(\"*.html\")                , emit: html\n    tuple val(meta), path(\"*.png\") , optional: true, emit: png\n    tuple val(meta), path(\"*.txt\")                 , emit: txt\n    tuple val(meta), path(\"*.log\")                 , emit: log\n    path  \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def input_file = (\"$ontfile\".endsWith(\".fastq.gz\") || \"$ontfile\".endsWith(\".fq.gz\")) ? \"--fastq ${ontfile}\" :\n        (\"$ontfile\".endsWith(\".txt\")) ? \"--summary ${ontfile}\" : ''\n    \"\"\"\n    NanoPlot \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        $input_file\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanoplot: \\$(echo \\$(NanoPlot --version 2>&1) | sed 's/^.*NanoPlot //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch LengthvsQualityScatterPlot_dot.html\n    touch LengthvsQualityScatterPlot_kde.html\n    touch NanoPlot-report.html\n    touch NanoPlot_20240301_1130.log\n    touch NanoStats.txt\n    touch Non_weightedHistogramReadlength.html\n    touch Non_weightedLogTransformed_HistogramReadlength.html\n    touch WeightedHistogramReadlength.html\n    touch WeightedLogTransformed_HistogramReadlength.html\n    touch Yield_By_Length.html\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanoplot: \\$(echo \\$(NanoPlot --version 2>&1) | sed 's/^.*NanoPlot //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SummarizedExperiment container\n\nTags: gene, transcript, sample, matrix, assay", "answer": "process SUMMARIZEDEXPERIMENT_SUMMARIZEDEXPERIMENT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-summarizedexperiment:1.32.0--r43hdfd78af_0' :\n        'biocontainers/bioconductor-summarizedexperiment:1.32.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(matrix_files)\n    tuple val(meta2), path(rowdata)\n    tuple val(meta3), path(coldata)\n\n    output:\n    tuple val(meta), path(\"*.rds\")              , emit: rds\n    tuple val(meta), path(\"*.R_sessionInfo.log\"), emit: log\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'summarizedexperiment.r'\n\n    stub:\n    \"\"\"\n    touch ${meta.id}.SummarizedExperiment.rds\n    touch ${meta.id}.R_sessionInfo.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bioconductor-summarizedexperiment: \\$(Rscript -e \"library(SummarizedExperiment); cat(as.character(packageVersion('SummarizedExperiment')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a counts matrix for single-cell data using STARSolo, handling cell barcodes and UMI information.\nTags: align, count, genome, reference", "answer": "process STARSOLO {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/star:2.7.10b--h9ee0642_0':\n        'biocontainers/star:2.7.10b--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), val(solotype), path(reads)\n    path(opt_whitelist)\n    tuple val(meta2), path(index)\n\n    output:\n    tuple val(meta),  path('*.Solo.out')         , emit: counts\n    tuple val(meta),  path('*Log.final.out')     , emit: log_final\n    tuple val(meta),  path('*Log.out')           , emit: log_out\n    tuple val(meta),  path('*Log.progress.out')  , emit: log_progress\n    tuple val(meta),  path('*/Gene/Summary.csv') , emit: summary\n    path \"versions.yml\"                          , emit: versions\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def (forward, reverse) = reads.collate(2).transpose()\n    def zcat = reads[0].getExtension() == \"gz\" ? \"--readFilesCommand zcat\": \"\"\n\n    // Handle solotype argument logic\n    switch(solotype) {\n        case \"CB_UMI_Simple\":\n            solotype_args = meta.umi_len ? \"--soloUMIlen ${meta.umi_len} \" : \"\";\n            solotype_args = solotype_args + (opt_whitelist.name != 'NO_FILE' ? \"--soloCBwhitelist ${opt_whitelist} \" : \"--soloCBwhitelist None \");\n            solotype_args = solotype_args + (meta.umi_start ? \"--soloUMIstart ${meta.umi_start} \" : \"\");\n            solotype_args = solotype_args + (meta.cb_len ? \"--soloCBlen ${meta.cb_len} \" : \"\");\n            solotype_args = solotype_args + (meta.cb_start ? \"--soloCBstart ${meta.cb_start} \" : \"\");\n            solotype_args = solotype_args + (meta.barcode_len ? \"--soloBarcodeReadLength ${meta.barcode_len} \" : \"\");\n            solotype_args = solotype_args + (meta.barcode_mate ? \"--soloBarcodeMate ${meta.barcode_mate} \" : \"\");\n            break\n        case \"CB_UMI_Complex\":\n            solotype_args = meta.cb_position ? \"--soloCBposition ${meta.cb_position}\" : \"\";\n            solotype_args = solotype_args + (opt_whitelist.name != 'NO_FILE' ? \"--soloCBwhitelist ${opt_whitelist} \" : \"--soloCBwhitelist None \");\n            solotype_args = solotype_args + (meta.umi_position ? \"--soloUMIposition ${meta.umi_position} \" : \"\");\n            solotype_args = solotype_args + (meta.adapter_seq ? \"--soloAdapterSequence ${meta.adapter_seq} \" : \"\");\n            solotype_args = solotype_args + (meta.max_mismatch_adapter ? \"--soloAdapterMismatchesNmax ${meta.max_mismatch_adapter} \" : \"\");\n            break\n        case \"SmartSeq\":\n            solotype_args = \"--soloUMIdedup Exact \";\n            solotype_args = solotype_args + (meta.strandedness ? \"--soloStrand ${meta.strandedness} \" : \"\");\n            solotype_args = solotype_args + \"--outSAMattrRGline ID:${prefix} \";\n            break\n        default:\n            log.warn(\"Unknown output solotype (${solotype})\");\n            break\n    }\n\n    \"\"\"\n    STAR \\\\\n        --genomeDir $index \\\\\n        --readFilesIn ${reverse.join( \",\" )} ${forward.join( \",\" )} \\\\\n        --runThreadN $task.cpus \\\\\n        --outFileNamePrefix $prefix. \\\\\n        --soloType $solotype \\\\\n        $zcat \\\\\n        $solotype_args \\\\\n        $args\n\n    if [ -d ${prefix}.Solo.out ]; then\n        find ${prefix}.Solo.out \\\\( -name \"*.tsv\" -o -name \"*.mtx\" \\\\) -exec gzip {} \\\\;\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}.Solo.out/Gene\n    touch ${prefix}.Log.final.out\n    touch ${prefix}.Log.out\n    touch ${prefix}.Log.progress.out\n    touch ${prefix}.Solo.out/Gene/Summary.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create index for STAR\nTags: index, fasta, genome, reference", "answer": "process STAR_GENOMEGENERATE {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-1fa26d1ce03c295fe2fdcf85831a92fbcbd7e8c2:ded3841da0194af2701c780e9b3d653a85d27489-0' :\n        'biocontainers/mulled-v2-1fa26d1ce03c295fe2fdcf85831a92fbcbd7e8c2:ded3841da0194af2701c780e9b3d653a85d27489-0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(gtf)\n\n    output:\n    tuple val(meta), path(\"star\")  , emit: index\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def args_list   = args.tokenize()\n    def memory      = task.memory ? \"--limitGenomeGenerateRAM ${task.memory.toBytes() - 100000000}\" : ''\n    def include_gtf = gtf ? \"--sjdbGTFfile $gtf\" : ''\n    if (args_list.contains('--genomeSAindexNbases')) {\n        \"\"\"\n        mkdir star\n        STAR \\\\\n            --runMode genomeGenerate \\\\\n            --genomeDir star/ \\\\\n            --genomeFastaFiles $fasta \\\\\n            $include_gtf \\\\\n            --runThreadN $task.cpus \\\\\n            $memory \\\\\n            $args\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n            gawk: \\$(echo \\$(gawk --version 2>&1) | sed 's/^.*GNU Awk //; s/, .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        samtools faidx $fasta\n        NUM_BASES=`gawk '{sum = sum + \\$2}END{if ((log(sum)/log(2))/2 - 1 > 14) {printf \"%.0f\", 14} else {printf \"%.0f\", (log(sum)/log(2))/2 - 1}}' ${fasta}.fai`\n\n        mkdir star\n        STAR \\\\\n            --runMode genomeGenerate \\\\\n            --genomeDir star/ \\\\\n            --genomeFastaFiles $fasta \\\\\n            $include_gtf \\\\\n            --runThreadN $task.cpus \\\\\n            --genomeSAindexNbases \\$NUM_BASES \\\\\n            $memory \\\\\n            $args\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n            gawk: \\$(echo \\$(gawk --version 2>&1) | sed 's/^.*GNU Awk //; s/, .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    if (gtf) {\n        \"\"\"\n        mkdir star\n        touch star/Genome\n        touch star/Log.out\n        touch star/SA\n        touch star/SAindex\n        touch star/chrLength.txt\n        touch star/chrName.txt\n        touch star/chrNameLength.txt\n        touch star/chrStart.txt\n        touch star/exonGeTrInfo.tab\n        touch star/exonInfo.tab\n        touch star/geneInfo.tab\n        touch star/genomeParameters.txt\n        touch star/sjdbInfo.txt\n        touch star/sjdbList.fromGTF.out.tab\n        touch star/sjdbList.out.tab\n        touch star/transcriptInfo.tab\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n            gawk: \\$(echo \\$(gawk --version 2>&1) | sed 's/^.*GNU Awk //; s/, .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        mkdir star\n        touch star/Genome\n        touch star/Log.out\n        touch star/SA\n        touch star/SAindex\n        touch star/chrLength.txt\n        touch star/chrName.txt\n        touch star/chrNameLength.txt\n        touch star/chrStart.txt\n        touch star/genomeParameters.txt\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n            gawk: \\$(echo \\$(gawk --version 2>&1) | sed 's/^.*GNU Awk //; s/, .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Align reads to a reference genome using STAR\nTags: align, fasta, genome, reference", "answer": "process STAR_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-1fa26d1ce03c295fe2fdcf85831a92fbcbd7e8c2:ded3841da0194af2701c780e9b3d653a85d27489-0' :\n        'biocontainers/mulled-v2-1fa26d1ce03c295fe2fdcf85831a92fbcbd7e8c2:ded3841da0194af2701c780e9b3d653a85d27489-0' }\"\n\n    input:\n    tuple val(meta), path(reads, stageAs: \"input*/*\")\n    tuple val(meta2), path(index)\n    tuple val(meta3), path(gtf)\n    val star_ignore_sjdbgtf\n    val seq_platform\n    val seq_center\n\n    output:\n    tuple val(meta), path('*Log.final.out')   , emit: log_final\n    tuple val(meta), path('*Log.out')         , emit: log_out\n    tuple val(meta), path('*Log.progress.out'), emit: log_progress\n    path  \"versions.yml\"                      , emit: versions\n\n    tuple val(meta), path('*d.out.bam')              , optional:true, emit: bam\n    tuple val(meta), path('*sortedByCoord.out.bam')  , optional:true, emit: bam_sorted\n    tuple val(meta), path('*toTranscriptome.out.bam'), optional:true, emit: bam_transcript\n    tuple val(meta), path('*Aligned.unsort.out.bam') , optional:true, emit: bam_unsorted\n    tuple val(meta), path('*fastq.gz')               , optional:true, emit: fastq\n    tuple val(meta), path('*.tab')                   , optional:true, emit: tab\n    tuple val(meta), path('*.SJ.out.tab')            , optional:true, emit: spl_junc_tab\n    tuple val(meta), path('*.ReadsPerGene.out.tab')  , optional:true, emit: read_per_gene_tab\n    tuple val(meta), path('*.out.junction')          , optional:true, emit: junction\n    tuple val(meta), path('*.out.sam')               , optional:true, emit: sam\n    tuple val(meta), path('*.wig')                   , optional:true, emit: wig\n    tuple val(meta), path('*.bg')                    , optional:true, emit: bedgraph\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads1 = [], reads2 = []\n    meta.single_end ? [reads].flatten().each{reads1 << it} : reads.eachWithIndex{ v, ix -> ( ix & 1 ? reads2 : reads1) << v }\n    def ignore_gtf      = star_ignore_sjdbgtf ? '' : \"--sjdbGTFfile $gtf\"\n    def seq_platform    = seq_platform ? \"'PL:$seq_platform'\" : \"\"\n    def seq_center      = seq_center ? \"'CN:$seq_center'\" : \"\"\n    def attrRG          = args.contains(\"--outSAMattrRGline\") ? \"\" : \"--outSAMattrRGline 'ID:$prefix' $seq_center 'SM:$prefix' $seq_platform\"\n    def out_sam_type    = (args.contains('--outSAMtype')) ? '' : '--outSAMtype BAM Unsorted'\n    def mv_unsorted_bam = (args.contains('--outSAMtype BAM Unsorted SortedByCoordinate')) ? \"mv ${prefix}.Aligned.out.bam ${prefix}.Aligned.unsort.out.bam\" : ''\n    \"\"\"\n    STAR \\\\\n        --genomeDir $index \\\\\n        --readFilesIn ${reads1.join(\",\")} ${reads2.join(\",\")} \\\\\n        --runThreadN $task.cpus \\\\\n        --outFileNamePrefix $prefix. \\\\\n        $out_sam_type \\\\\n        $ignore_gtf \\\\\n        $attrRG \\\\\n        $args\n\n    $mv_unsorted_bam\n\n    if [ -f ${prefix}.Unmapped.out.mate1 ]; then\n        mv ${prefix}.Unmapped.out.mate1 ${prefix}.unmapped_1.fastq\n        gzip ${prefix}.unmapped_1.fastq\n    fi\n    if [ -f ${prefix}.Unmapped.out.mate2 ]; then\n        mv ${prefix}.Unmapped.out.mate2 ${prefix}.unmapped_2.fastq\n        gzip ${prefix}.unmapped_2.fastq\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        gawk: \\$(echo \\$(gawk --version 2>&1) | sed 's/^.*GNU Awk //; s/, .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.unmapped_1.fastq.gz\n    echo \"\" | gzip > ${prefix}.unmapped_2.fastq.gz\n    touch ${prefix}Xd.out.bam\n    touch ${prefix}.Log.final.out\n    touch ${prefix}.Log.out\n    touch ${prefix}.Log.progress.out\n    touch ${prefix}.sortedByCoord.out.bam\n    touch ${prefix}.toTranscriptome.out.bam\n    touch ${prefix}.Aligned.unsort.out.bam\n    touch ${prefix}.Aligned.sortedByCoord.out.bam\n    touch ${prefix}.tab\n    touch ${prefix}.SJ.out.tab\n    touch ${prefix}.ReadsPerGene.out.tab\n    touch ${prefix}.Chimeric.out.junction\n    touch ${prefix}.out.sam\n    touch ${prefix}.Signal.UniqueMultiple.str1.out.wig\n    touch ${prefix}.Signal.UniqueMultiple.str1.out.bg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        star: \\$(STAR --version | sed -e \"s/STAR_//g\")\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        gawk: \\$(echo \\$(gawk --version 2>&1) | sed 's/^.*GNU Awk //; s/, .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Perform merging of mate paired-end sequencing reads\nTags: sort, reads merging, merge mate pairs", "answer": "process FLASH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/flash:1.2.11--h5bf99c6_6' :\n        'biocontainers/flash:1.2.11--h5bf99c6_6' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"${prefix}.extendedFrags.fastq.gz\"), emit: merged\n    tuple val(meta), path(\"${prefix}.notCombined_*.fastq.gz\"), emit: notcombined\n    tuple val(meta), path(\"${prefix}.hist\")                  , emit: histogram\n    path \"versions.yml\"                                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$reads\" == \"${prefix}.extendedFrags.fastq.gz\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    if (\"$reads\" == \"${prefix}.notCombined_1.fastq.gz\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    if (\"$reads\" == \"${prefix}.notCombined_2.fastq.gz\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    flash \\\\\n        $args \\\\\n        -o ${prefix} \\\\\n        -z \\\\\n        ${reads[0]} \\\\\n        ${reads[1]}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        flash: \\$(echo \\$(flash --version 2>&1) | sed 's/^.*FLASH v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n\n    touch ${prefix}.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        flash: \\$(echo \\$(flash --version 2>&1) | sed 's/^.*FLASH v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run TRUST4 on RNA-seq data\nTags: sort, example, genomics", "answer": "process TRUST4 {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"bioconda::trust4=1.0.13\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/trust4:1.0.13--h43eeafb_0':\n        'biocontainers/trust4:1.0.13--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(reads)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(vdj_reference)\n    tuple val(meta4), val(barcode_read)\n    tuple val(meta5), val(umi_read)\n\n    output:\n    tuple val(meta), path(\"*.tsv\")                  , emit: tsv\n    tuple val(meta), path(\"*_airr.tsv\")             , emit: airr_files\n    tuple val(meta), path(\"${meta.id}_airr.tsv\")    , emit: airr_tsv\n    tuple val(meta), path(\"*_report.tsv\")           , emit: report_tsv\n    tuple val(meta), path(\"*.fa\")                   , emit: fasta\n    tuple val(meta), path(\"*.out\")                  , emit: out\n    tuple val(meta), path(\"*.fq\")                   , emit: fq\n    tuple val(meta), path(\"**\")                     , emit: outs\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bam_mode = bam ? \"-b ${bam}\" : ''\n    def single_end_mode = reads && meta.single_end ? \"-u ${reads}\" : ''\n    // reference is optional for fastq input\n    def reference = vdj_reference ? \"--ref ${vdj_reference}\" : \"\"\n    // separate forward from reverse pairs\n    def (forward, reverse) = reads.collate(2).transpose()\n    def paired_end_mode = reads && (meta.single_end == false) ? \"-1 ${forward[0]} -2 ${reverse[0]}\" : ''\n    // read format is optional\n    def readFormat = params.read_format ? \"--readFormat ${params.read_format}\" : ''\n    // add barcode information if present\n    if (barcode_read) {\n        if (barcode_read == \"R1\") {\n            barcode = \"--barcode ${forward[0]}\"\n        } else if (barcode_read == \"R2\") {\n            barcode = \"--barcode ${reverse[0]}\"\n        }\n    }\n    else {\n        barcode = ''\n    }\n    // add umi information if present\n    if (umi_read) {\n        if (umi_read == \"R1\") {\n            umi = \"--UMI ${forward[0]}\"\n        } else if (umi_read == \"R2\") {\n            umi = \"--UMI ${reverse[0]}\"\n        }\n    }\n    else {\n        umi = ''\n    }\n\n    \"\"\"\n    run-trust4 \\\\\n        ${bam_mode} \\\\\n        ${single_end_mode} \\\\\n        ${paired_end_mode} \\\\\n        ${barcode} \\\\\n        ${readFormat} \\\\\n        ${umi} \\\\\n        -t $task.cpus \\\\\n        -f ${fasta} \\\\\n        -o ${prefix} \\\\\n        ${reference} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trust4: \\$(run-trust4 2>&1 | grep -o 'v[0-9.]*-r[0-9]*' | sed 's/^/TRUST4 using /' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_airr.tsv\n    touch ${prefix}_airr_align.tsv\n    touch ${prefix}_report.tsv\n    touch ${prefix}_assembled_reads.fa\n    touch ${prefix}_annot.fa\n    touch ${prefix}_cdr3.out\n    touch ${prefix}_raw.out\n    touch ${prefix}_final.out\n    touch ${prefix}_toassemble.fq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        trust4: \\$(run-trust4 2>&1 | grep -o 'v[0-9.]*-r[0-9]*' | sed 's/^/TRUST4 using /' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filter and trim long read data.\nTags: filter, trimming, fastq, nanopore, qc", "answer": "process CHOPPER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/chopper:0.3.0--hd03093a_0':\n        'biocontainers/chopper:0.3.0--hd03093a_0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\") , emit: fastq\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def args2  = task.ext.args2  ?: ''\n    def args3  = task.ext.args3  ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$fastq\" == \"${prefix}.fastq.gz\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    zcat \\\\\n        $args \\\\\n        $fastq | \\\\\n    chopper \\\\\n        --threads $task.cpus \\\\\n        $args2 | \\\\\n    gzip \\\\\n        $args3 > ${prefix}.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        chopper: \\$(chopper --version 2>&1 | cut -d ' ' -f 2)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split fasta file by 'N's to aid in self alignment for duplicate purging\nTags: split assembly, duplicate purging", "answer": "process PURGEDUPS_SPLITFA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/purge_dups:1.2.6--h7132678_0':\n        'biocontainers/purge_dups:1.2.6--h7132678_0' }\"\n\n    input:\n    tuple val(meta), path(assembly)\n\n    output:\n    tuple val(meta), path(\"*.split.fasta.gz\"), emit: split_fasta\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    split_fa $args $assembly | gzip -c > ${prefix}.split.fasta.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purgedups: \\$( purge_dups -h |& sed '3!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Separates out sequences purged of falsely duplicated sequences.\nTags: haplotype purging, duplicate purging, false duplications, assembly curation", "answer": "process PURGEDUPS_GETSEQS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/purge_dups:1.2.6--h7132678_0':\n        'biocontainers/purge_dups:1.2.6--h7132678_0' }\"\n\n    input:\n    tuple val(meta), path(assembly), path(bed)\n\n    output:\n    tuple val(meta), path(\"*.hap.fa\")   , emit: haplotigs\n    tuple val(meta), path(\"*.purged.fa\"), emit: purged\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    get_seqs \\\\\n        $args \\\\\n        -e $bed \\\\\n        -p $prefix \\\\\n        $assembly\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purgedups: \\$( purge_dups -h |& sed '3!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Plots the read coverage from a purge dups statistics file and cutoffs.\nTags: Read coverage histogram, Duplication purging, Read depth", "answer": "process PURGEDUPS_HISTPLOT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/purge_dups:1.2.6--py39h7132678_1':\n        'biocontainers/purge_dups:1.2.6--py39h7132678_1' }\"\n\n    input:\n    tuple val(meta), path(statfile), path(cutoff)\n\n    output:\n    tuple val(meta), path(\"*.png\"), emit: png\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    hist_plot.py \\\\\n        -c $cutoff \\\\\n        $args \\\\\n        $statfile \\\\\n        ${prefix}.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hist_plot : \\$( hist_plot.py -v | sed 's/hist_plot //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hist_plot : \\$( hist_plot.py -v | sed 's/hist_plot //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create read depth histogram and base-level read depth for an assembly based on pacbio data\nTags: sort, genome assembly, purge duplications, read depth", "answer": "process PURGEDUPS_PBCSTAT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/purge_dups:1.2.6--h7132678_0':\n        'biocontainers/purge_dups:1.2.6--h7132678_0' }\"\n\n    input:\n    tuple val(meta), path(paf_alignment)\n\n    output:\n    tuple val(meta), path(\"*.PB.stat\")    , emit: stat\n    tuple val(meta), path(\"*.PB.base.cov\"), emit: basecov\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pbcstat \\\\\n        $args \\\\\n        $paf_alignment\n\n    for PBFILE in PB.*; do mv \\$PBFILE ${prefix}.\\$PBFILE; done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purgedups: \\$( purge_dups -h |& sed '3!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Purge haplotigs and overlaps for an assembly\nTags: Haplotype purging, Duplication purging, False duplications, Assembly curation, Read depth", "answer": "process PURGEDUPS_PURGEDUPS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/purge_dups:1.2.6--h7132678_0':\n        'biocontainers/purge_dups:1.2.6--h7132678_0' }\"\n\n    input:\n    tuple val(meta), path(basecov), path(cutoff), path(paf)\n\n    output:\n    tuple val(meta), path(\"*.dups.bed\")      , emit: bed\n    tuple val(meta), path(\"*.purge_dups.log\"), emit: log\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    purge_dups \\\\\n        $args \\\\\n        -T $cutoff \\\\\n        -c $basecov \\\\\n        $paf > ${prefix}.dups.bed 2> >(tee ${prefix}.purge_dups.log >&2)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purgedups: \\$( purge_dups -h |& sed '3!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate coverage cutoffs to determine when to purge duplicated sequence.\nTags: coverage, cutoff, purge duplications", "answer": "process PURGEDUPS_CALCUTS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/purge_dups:1.2.6--h7132678_0':\n        'biocontainers/purge_dups:1.2.6--h7132678_0' }\"\n\n    input:\n    tuple val(meta), path(stat)\n\n    output:\n    tuple val(meta), path(\"*.cutoffs\")    , emit: cutoff\n    tuple val(meta), path(\"*.calcuts.log\"), emit: log\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    calcuts $args $stat > ${prefix}.cutoffs 2> >(tee ${prefix}.calcuts.log >&2)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purgedups: \\$( purge_dups -h |& sed '3!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: converts pacbio bam files to fastq.gz using PacBioToolKit (pbtk) bam2fastq\nTags: convert, bam, genomics, pacbio", "answer": "process PBTK_BAM2FASTQ {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pbtk:3.1.1--h9ee0642_0':\n        'biocontainers/pbtk:3.1.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(pbi)\n\n    output:\n    tuple val(meta), path(\"*.$extension\")   , emit: fastq\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args         ?: ''\n    def prefix  = task.ext.prefix       ?: \"${meta.id}\"\n    extension   = args.contains('-u')   ? 'fastq'       : 'fastq.gz'\n    \"\"\"\n    bam2fastq \\\\\n        $args \\\\\n        -j $task.cpus \\\\\n        -o ${prefix} \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bam2fastq: \\$(bam2fastq --version 2>&1 | sed -n 's/.*bam2fastq \\\\([0-9]\\\\+\\\\.[0-9]\\\\+\\\\.[0-9]\\\\+\\\\).*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args    = task.ext.args         ?: ''\n    def prefix  = task.ext.prefix       ?: \"${meta.id}\"\n    def gzip    = args.contains('-u')   ? ''            : \"gzip *.fastq\"\n    extension   = args.contains('-u')   ? 'fastq'       : 'fastq.gz'\n    \"\"\"\n    touch ${prefix}.fastq\n    $gzip\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bam2fastq: \\$(bam2fastq --version 2>&1 | sed -n 's/.*bam2fastq \\\\([0-9]\\\\+\\\\.[0-9]\\\\+\\\\.[0-9]\\\\+\\\\).*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Minimalistic tool which creates an index file that enables random access into PacBio BAM files\nTags: genomics, bam, index, pacbio", "answer": "process PBTK_PBINDEX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pbtk:3.1.1--h9ee0642_0':\n        'biocontainers/pbtk:3.1.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.pbi\"), emit: pbi\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    \"\"\"\n    pbindex \\\\\n        -j $task.cpus \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pbindex: \\$(pbindex --version | sed -n 's/pbindex \\\\(.*\\\\)/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${bam}.pbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pbindex: \\$(pbindex --version | sed -n 's/pbindex \\\\(.*\\\\)/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Predict prophages in bacterial genomes\nTags: genomics, virus, phage, prophage, annotation, identification", "answer": "process PHISPY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/phispy:4.2.21--py310h30d9df9_1':\n        'biocontainers/phispy:4.2.21--py310h30d9df9_1' }\"\n\n    input:\n    tuple val(meta), path(gbk)\n\n    output:\n    tuple val(meta), path(\"${prefix}.tsv\")                     , emit: coordinates\n    tuple val(meta), path(\"${prefix}.gb*\")                     , emit: gbk\n    tuple val(meta), path(\"${prefix}.log\")                     , emit: log\n    tuple val(meta), path(\"${prefix}_prophage_information.tsv\"), optional:true, emit: information\n    tuple val(meta), path(\"${prefix}_bacteria.fasta\")          , optional:true, emit: bacteria_fasta\n    tuple val(meta), path(\"${prefix}_bacteria.gbk\")            , optional:true, emit: bacteria_gbk\n    tuple val(meta), path(\"${prefix}_phage.fasta\")             , optional:true, emit: phage_fasta\n    tuple val(meta), path(\"${prefix}_phage.gbk\")               , optional:true, emit: phage_gbk\n    tuple val(meta), path(\"${prefix}_prophage.gff3\")           , optional:true, emit: prophage_gff\n    tuple val(meta), path(\"${prefix}_prophage.tbl\")            , optional:true, emit: prophage_tbl\n    tuple val(meta), path(\"${prefix}_prophage.tsv\")            , optional:true, emit: prophage_tsv\n    path \"versions.yml\"                                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    // Extract GBK file extension, i.e. .gbff, .gbk.gz\n    gbk_extension = gbk.getName() - gbk.getSimpleName()\n\n    if (\"$gbk\" == \"${prefix}${gbk_extension}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    PhiSpy.py \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        -p $prefix \\\\\n        -o . \\\\\n        $gbk\n\n    mv ${prefix}_prophage_coordinates.tsv ${prefix}.tsv\n    mv ${prefix}_${gbk} ${prefix}${gbk_extension}\n    mv ${prefix}_phispy.log ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        PhiSpy: \\$(echo \\$(PhiSpy.py --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    gbk_extension = gbk.getName() - gbk.getSimpleName()\n\n    if (\"$gbk\" == \"${prefix}${gbk_extension}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    touch ${prefix}.tsv\n    touch ${prefix}${gbk_extension}\n    touch ${prefix}.log\n    touch ${prefix}_prophage_information.tsv\n    touch ${prefix}_bacteria.fasta\n    touch ${prefix}_bacteria.gbk\n    touch ${prefix}_phage.fasta\n    touch ${prefix}_phage.gbk\n    touch ${prefix}_prophage.gff3\n    touch ${prefix}_prophage.tbl\n    touch ${prefix}_prophage.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        PhiSpy: \\$(echo \\$(PhiSpy.py --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: decoupler is a package containing different statistical methods\nto extract biological activities from omics data within a unified framework.\nIt allows to flexibly test any enrichment method with any prior knowledge\nresource and incorporates methods that take into account the sign and weight.\nIt can be used with any omic, as long as its features can be linked to a\nbiological process based on prior knowledge. For example, in transcriptomics\ngene sets regulated by a transcription factor, or in phospho-proteomics\nphosphosites that are targeted by a kinase.\n\nTags: enrichment, omics, biological activity, functional analysis, prior knowledge", "answer": "process DECOUPLER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"conda-forge::decoupler-py=1.6.0\"\n    container = \"ghcr.io/saezlab/publish-packages/decoupler:sha-5838309\"\n\n    input:\n    tuple val(meta), path(mat)\n    path(net)\n\n    output:\n    tuple val(meta), path(\"*estimate__decoupler.tsv\"), emit: dc_estimate\n    tuple val(meta), path(\"*pvals__decoupler.tsv\"), emit: dc_pvals\n    path(\"versions.yml\"), emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"{}\"\n    \"\"\"\n    #!/usr/bin/env python3\n    import os\n    import pandas as pd\n\n    os.environ[\"NUMBA_CACHE_DIR\"] = \"./tmp\"\n\n    import decoupler as dc\n\n    methods = ['aucell', 'gsea', 'gsva', 'mdt', 'mlm', 'ora', 'udt',\n        'ulm', 'viper', 'wmean', 'wsum']\n\n    mat = pd.read_csv(\"${mat}\", sep=\"\\t\", index_col=0)\n    net = pd.read_csv(\"${net}\", sep=\"\\t\", index_col=0)\n\n    # Parsing arguments\n    args = ${args}\n    parsedargs = {'args': {}}\n\n    for k, v in args.items():\n        # Specific method argument\n        if k.split('_')[0] in methods:\n            meth = k.split('_')[0]\n            arg = '_'.join(k.split('_')[1:])\n\n            if meth not in args['args'].keys():\n                parsedargs['args'][meth] = {arg: v}\n            else:\n                parsedargs['args'][meth].update({arg: v})\n\n        # Generic argument\n        else:\n            parsedargs[k] = v\n\n\n    results = dc.decouple(\n        mat=mat,\n        net=net,\n        **parsedargs\n    )\n\n    for result in results:\n        results[result].to_csv(result + \"__decoupler.tsv\", sep=\"\\t\")\n\n    ## VERSIONS FILE\n    with open('versions.yml', 'a') as version_file:\n        version_file.write('\"${task.process}\":' + \"\\\\n\")\n        version_file.write(\"\\tdecoupler-py: \" + dc.__version__ + \"\\\\n\")\n    \"\"\"\n}\n"}
{"question": "Description: binning of metagenomic sequences\nTags: sort, example, genomics", "answer": "process CLAME {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/clame:1.0--he1b5a44_1':\n        'biocontainers/clame:1.0--he1b5a44_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.fasta\")  , emit: fasta, optional: true\n    tuple val(meta), path(\"*.binning\"), emit: bins\n    tuple val(meta), path(\"*.fm9\")    , emit: fm\n    tuple val(meta), path(\"*.index\")  , emit: index\n    tuple val(meta), path(\"*.links\")  , emit: links\n    tuple val(meta), path(\"*.result\") , emit: result\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    clame \\\\\n        $args \\\\\n        -nt $task.cpus \\\\\n        -multiFasta ${fasta} \\\\\n        -output ${prefix} || test -f ${prefix}.binning\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        clame: \\$(echo \\$(clame -h | sed -n '2p' | cut -d ' ' -f 2 ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.binning\n    touch ${prefix}.fm9\n    touch ${prefix}.index\n    touch ${prefix}.links\n    touch ${prefix}.result\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        clame: \\$(echo \\$(clame -h | sed -n '2p' | cut -d ' ' -f 2 ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Splits/Joins VCF(s) file into chromosomes\nTags: split, join, vcf", "answer": "process SNPSIFT_SPLIT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snpsift:4.3.1t--hdfd78af_3' :\n        'biocontainers/snpsift:4.3.1t--hdfd78af_3' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: out_vcfs\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.split) {\n        \"\"\"\n        SnpSift \\\\\n            split \\\\\n            $args \\\\\n            $vcf\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            snpsift: \\$( echo \\$(SnpSift split -h 2>&1) | sed 's/^.*version //' | sed 's/(.*//' | sed 's/t//g' )\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        SnpSift \\\\\n            split \\\\\n            -j \\\\\n            $args \\\\\n            $vcf \\\\\n            > ${prefix}.joined.vcf\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            snpsift: \\$( echo \\$(SnpSift split -h 2>&1) | sed 's/^.*version //' | sed 's/(.*//' | sed 's/t//g' )\n        END_VERSIONS\n        \"\"\"\n    }\n\n}\n"}
{"question": "Description: Annotate a VCF file with another VCF file\nTags: variant calling, annotate, snpsift, cancer genomics", "answer": "process SNPSIFT_ANNOTATE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snpsift:5.1d--hdfd78af_0' :\n        'biocontainers/snpsift:5.1d--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_tbi)\n    tuple val(meta2), path(database), path(dbs_tbi)// TBI files are optional (use when compressed VCF file)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    SnpSift \\\\\n        annotate \\\\\n        $args \\\\\n        $database \\\\\n        $vcf > ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpsift: \\$( echo \\$(SnpSift split -h 2>&1) | sed 's/^.*version //' | sed 's/(.*//' | sed 's/t//g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${prefix}.vcf\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpsift: \\$( echo \\$(SnpSift split -h 2>&1) | sed 's/^.*version //' | sed 's/(.*//' | sed 's/t//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The dbNSFP is an integrated database of functional predictions from multiple algorithms\nTags: variant calling, dbnsfp, snpsift, cancer genomics, predictions", "answer": "process SNPSIFT_DBNSFP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snpsift:5.1d--hdfd78af_0' :\n        'biocontainers/snpsift:5.1d--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_tbi)\n    tuple val(meta2), path(database), path(dbs_tbi)// TBI files are optional (use when compressed VCF file)\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    SnpSift \\\\\n        dbnsfp \\\\\n        $args \\\\\n        -db $database \\\\\n        $vcf > ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpsift: \\$( echo \\$(SnpSift split -h 2>&1) | sed 's/^.*version //' | sed 's/(.*//' | sed 's/t//g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${prefix}.vcf\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snpsift: \\$( echo \\$(SnpSift split -h 2>&1) | sed 's/^.*version //' | sed 's/(.*//' | sed 's/t//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Short Read Sequence Typing for Bacterial Pathogens is a program designed to take Illumina sequence data,\na MLST database and/or a database of gene sequences (e.g. resistance genes, virulence genes, etc)\nand report the presence of STs and/or reference genes.\n\nTags: mlst, typing, illumina", "answer": "process SRST2_SRST2 {\n    tag \"${meta.id}\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/srst2%3A0.2.0--py27_2':\n        'biocontainers/srst2:0.2.0--py27_2'}\"\n\n    input:\n    tuple val(meta), path(fastq_s), path(db)\n\n    output:\n    tuple val(meta), path(\"*_genes_*_results.txt\")               , optional:true, emit: gene_results\n    tuple val(meta), path(\"*_fullgenes_*_results.txt\")           , optional:true, emit: fullgene_results\n    tuple val(meta), path(\"*_mlst_*_results.txt\")                , optional:true, emit: mlst_results\n    tuple val(meta), path(\"*.pileup\")                            ,                emit: pileup\n    tuple val(meta), path(\"*.sorted.bam\")                        ,                emit: sorted_bam\n    path \"versions.yml\"                                          ,                emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def read_s = meta.single_end ? \"--input_se ${fastq_s}\" : \"--input_pe ${fastq_s[0]} ${fastq_s[1]}\"\n    if (meta.db==\"gene\") {\n        database = \"--gene_db ${db}\"\n    } else if (meta.db==\"mlst\") {\n        database = \"--mlst_db ${db}\"\n    } else {\n        error \"Please set meta.db to either \\\"gene\\\" or \\\"mlst\\\"\"\n    }\n    \"\"\"\n    srst2 \\\\\n        ${read_s} \\\\\n        --threads $task.cpus \\\\\n        --output ${prefix} \\\\\n        ${database} \\\\\n        $args\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        srst2: \\$(echo \\$(srst2 --version 2>&1) | sed 's/srst2 //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: hmmalign from the HMMER suite aligns a number of sequences to an HMM profile\nTags: alignment", "answer": "process HMMER_HMMALIGN {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmer:3.3.2--h1b792b2_1' :\n        'biocontainers/hmmer:3.3.2--h1b792b2_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path hmm\n\n    output:\n    tuple val(meta), path(\"*.sthlm.gz\"), emit: sthlm\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    hmmalign \\\\\n        $args \\\\\n        $hmm \\\\\n        $fasta | gzip -c > ${prefix}.sthlm.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmer: \\$(hmmalign -h | grep -o '^# HMMER [0-9.]*' | sed 's/^# HMMER *//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: extract hmm from hmm database file or create index for hmm database\nTags: hidden Markov model, HMM, hmmer, hmmfetch", "answer": "process HMMER_HMMFETCH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmer:3.3.2--h87f3376_2':\n        'biocontainers/hmmer:3.3.2--h87f3376_2' }\"\n\n    // The module can be called with either a key, a file containing keys or neither.\n    // In the latter case, the hmm database will be indexed and an index but no output\n    // hmm will be produced.\n    input:\n    tuple val(meta), path(hmm)\n    val   key\n    path  keyfile\n    path  index         // Only used to stage the index from a previous run\n\n    output:\n    tuple val(meta), path(\"*.hmm\"), emit: hmm,   optional: true\n    tuple val(meta), path(\"*.ssi\"), emit: index, optional: true\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def keyarg  = key ?: ''\n    def kfopt   = keyfile ? '-f' : ''\n    def index   = ! key && ! keyfile ? '--index' : ''\n    def outfile = ! key && ! keyfile ? '' : \"> ${prefix}.hmm\"\n\n    \"\"\"\n    hmmfetch \\\\\n        $kfopt \\\\\n        $index \\\\\n        $args \\\\\n        $hmm \\\\\n        $keyarg \\\\\n        $keyfile \\\\\n        $outfile\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmer: \\$(hmmsearch -h | grep -o '^# HMMER [0-9.]*' | sed 's/^# HMMER *//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.hmm\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmer: \\$(hmmsearch -h | grep -o '^# HMMER [0-9.]*' | sed 's/^# HMMER *//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: create an hmm profile from a multiple sequence alignment\nTags: search, hidden Markov model, HMM, hmmer, hmmsearch", "answer": "process HMMER_HMMBUILD {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmer:3.3.2--h87f3376_2':\n        'biocontainers/hmmer:3.3.2--h1b792b2_1' }\"\n\n    input:\n    tuple val(meta), path(alignment)\n    path mxfile\n\n    output:\n    tuple val(meta), path(\"*.hmm.gz\"), emit: hmm\n    path \"*.hmmbuild.txt\",             emit: hmmbuildout\n    path \"versions.yml\",               emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args ?: ''\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def mxfileopt = mxfile ? \"--mxfile ${mxfile}\" : \"\"\n\n    \"\"\"\n    hmmbuild \\\\\n        $args \\\\\n        --cpu $task.cpus \\\\\n        -n ${prefix}  \\\\\n        -o ${prefix}.hmmbuild.txt \\\\\n        ${mxfileopt} \\\\\n        ${prefix}.hmm \\\\\n        $alignment\n\n    gzip ${prefix}.hmm\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmer: \\$(echo \\$(hmmbuild -h | grep HMMER | sed 's/# HMMER //' | sed 's/ .*//' 2>&1))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: R script that scores output from multiple runs of hmmer/hmmsearch\nTags: hmmer, hmmsearch, rank", "answer": "process HMMER_HMMRANK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-b2ec1fea5791d428eebb8c8ea7409c350d31dada:a447f6b7a6afde38352b24c30ae9cd6e39df95c4-1' :\n        'biocontainers/mulled-v2-b2ec1fea5791d428eebb8c8ea7409c350d31dada:a447f6b7a6afde38352b24c30ae9cd6e39df95c4-1' }\"\n\n    input:\n    tuple val(meta), path(tblouts)      // HMMER_HMMSEARCH.out.target_summary\n\n    output:\n    tuple val(meta), path(\"*.hmmrank.tsv.gz\"), emit: hmmrank\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    #!/usr/bin/env Rscript\n    library(readr)\n    library(dplyr)\n    library(tidyr)\n    library(stringr)\n\n    # Read all the tblout files\n\n    read_fwf(c('${tblouts.join(\"','\")}'), fwf_cols(content = c(1, NA)), col_types = cols(content = col_character()), comment='#', id = 'fname') %>%\n        filter(! str_detect(content, '^ *#')) %>%\n        separate(\n            content,\n            c('accno', 't0', 'profile_desc', 't1', 'evalue', 'score', 'bias', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'rest'),\n            '\\\\\\\\s+',  extra='merge', convert = FALSE\n        ) %>%\n        transmute(profile = basename(fname) %>% str_remove('${prefix}\\\\\\\\.') %>% str_remove('.tbl.gz'), accno, profile_desc, evalue = as.double(evalue), score = as.double(score)) %>%\n        # Group and calculate a rank based on score and evalue; let ties be resolved by profile in alphabetical order\n        group_by(accno) %>%\n        arrange(desc(score), evalue, profile) %>%\n        mutate(rank = row_number()) %>%\n        ungroup() %>%\n        write_tsv('${prefix}.hmmrank.tsv.gz')\n\n    writeLines(\n        c(\n            \"\\\\\"${task.process}\\\\\":\",\n            paste0(\"    R: \", paste0(R.Version()[c(\"major\",\"minor\")], collapse = \".\")),\n            paste0(\"    tidyverse: \", packageVersion('tidyverse'))\n        ),\n        \"versions.yml\"\n    )\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \\\"profile\\taccno\\tprofile_desc\\tevalue\\tscore\\trank\\\" | gzip -c > ${prefix}.hmmrank.tsv.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        R: 4.0\n        tidyverse: 2.0\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: reformats sequence files, see HMMER documentation for details. The module requires that the format is specified in ext.args in a config file, and that this comes last. See the tools help for possible values.\nTags: sort", "answer": "process HMMER_ESLREFORMAT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmer:3.3.2--h1b792b2_1':\n        'biocontainers/hmmer:3.3.2--h1b792b2_1' }\"\n\n    input:\n    tuple val(meta), path(seqfile)\n\n    output:\n    tuple val(meta), path(\"*.*.gz\"), emit: seqreformated\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args     = task.ext.args ?: ''\n    def prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def suffix   = args ? args.trim().tokenize(\" \")[-1] : \"sequences\"\n    // Use for any postprocessing of the sequence file, e.g. removal of gap characters\n    def postproc = task.ext.postprocessing ?: \"\"\n    \"\"\"\n    esl-reformat \\\\\n        $args \\\\\n        $seqfile \\\\\n        $postproc \\\\\n        | gzip -c > ${prefix}.${suffix}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmer/easel: \\$(esl-reformat -h | grep -o '^# Easel [0-9.]*' | sed 's/^# Easel *//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Mask multiple sequence alignments\nTags: hmmer, alignment, mask", "answer": "process HMMER_ESLALIMASK {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmer:3.3.2--h1b792b2_1':\n        'biocontainers/hmmer:3.3.2--h1b792b2_1' }\"\n\n    input:\n    tuple val(meta), path(unmaskedaln), val(fmask_rf), val(fmask_all), val(gmask_rf), val(gmask_all), val(pmask_rf), val(pmask_all)\n    path  maskfile\n\n    output:\n    tuple val(meta), path(\"*.masked.sthlm.gz\"), emit: maskedaln\n    path  \"*.fmask-rf.gz\"                     , emit: fmask_rf , optional: true\n    path  \"*.fmask-all.gz\"                    , emit: fmask_all, optional: true\n    path  \"*.gmask-rf.gz\"                     , emit: gmask_rf , optional: true\n    path  \"*.gmask-all.gz\"                    , emit: gmask_all, optional: true\n    path  \"*.pmask-rf.gz\"                     , emit: pmask_rf , optional: true\n    path  \"*.pmask-all.gz\"                    , emit: pmask_all, optional: true\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def fmask_rfarg  = fmask_rf  ? \"--fmask-rf ${prefix}.fmask-rf\"   : \"\"\n    def fmask_allarg = fmask_all ? \"--fmask-all ${prefix}.fmask-all\" : \"\"\n    def gmask_rfarg  = gmask_rf  ? \"--gmask-rf ${prefix}.gmask-rf\"   : \"\"\n    def gmask_allarg = gmask_all ? \"--gmask-all ${prefix}.gmask-all\" : \"\"\n    def pmask_rfarg  = pmask_rf  ? \"--pmask-rf ${prefix}.pmask-rf\"   : \"\"\n    def pmask_allarg = pmask_all ? \"--pmask-all ${prefix}.pmask-all\" : \"\"\n    \"\"\"\n    esl-alimask \\\\\n        $args \\\\\n        $fmask_rfarg \\\\\n        $fmask_allarg \\\\\n        $gmask_rfarg \\\\\n        $gmask_allarg \\\\\n        $pmask_rfarg \\\\\n        $pmask_allarg \\\\\n        -o ${prefix}.masked.sthlm \\\\\n        $unmaskedaln \\\\\n        $maskfile\n\n    gzip ${prefix}.*mask*\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmer/easel: \\$(esl-reformat -h | grep -o '^# Easel [0-9.]*' | sed 's/^# Easel *//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: search profile(s) against a sequence database\nTags: Hidden Markov Model, HMM, hmmer, hmmsearch", "answer": "process HMMER_HMMSEARCH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hmmer:3.4--hdbdd923_1' :\n        'biocontainers/hmmer:3.4--hdbdd923_1' }\"\n\n    input:\n    tuple val(meta), path(hmmfile), path(seqdb), val(write_align), val(write_target), val(write_domain)\n\n    output:\n    tuple val(meta), path('*.txt.gz')   , emit: output\n    tuple val(meta), path('*.sto.gz')   , emit: alignments    , optional: true\n    tuple val(meta), path('*.tbl.gz')   , emit: target_summary, optional: true\n    tuple val(meta), path('*.domtbl.gz'), emit: domain_summary, optional: true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args   ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    output         = \"${prefix}.txt\"\n    alignment      = write_align     ? \"-A ${prefix}.sto\" : ''\n    target_summary = write_target    ? \"--tblout ${prefix}.tbl\" : ''\n    domain_summary = write_domain    ? \"--domtblout ${prefix}.domtbl\" : ''\n    \"\"\"\n    hmmsearch \\\\\n        $args \\\\\n        --cpu $task.cpus \\\\\n        -o $output \\\\\n        $alignment \\\\\n        $target_summary \\\\\n        $domain_summary \\\\\n        $hmmfile \\\\\n        $seqdb\n\n    gzip --no-name *.txt \\\\\n        ${write_align ? '*.sto' : ''} \\\\\n        ${write_target ? '*.tbl' : ''} \\\\\n        ${write_domain ? '*.domtbl' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmer: \\$(hmmsearch -h | grep -o '^# HMMER [0-9.]*' | sed 's/^# HMMER *//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.txt\"\n    ${write_align ? \"touch ${prefix}.sto\" : ''} \\\\\n    ${write_target ? \"touch ${prefix}.tbl\" : ''} \\\\\n    ${write_domain ? \"touch ${prefix}.domtbl\" : ''}\n\n    gzip --no-name *.txt \\\\\n        ${write_align ? '*.sto' : ''} \\\\\n        ${write_target ? '*.tbl' : ''} \\\\\n        ${write_domain ? '*.domtbl' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hmmer: \\$(hmmsearch -h | grep -o '^# HMMER [0-9.]*' | sed 's/^# HMMER *//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Genotype Salmonella Typhi from Mykrobe results\nTags: genotype, Salmonella Typhi", "answer": "process GENOTYPHI_PARSE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genotyphi:1.9.1--hdfd78af_1':\n        'biocontainers/genotyphi:1.9.1--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(json)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    parse_typhi_mykrobe.py \\\\\n        --jsons $json \\\\\n        --prefix ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genotyphi: \\$(echo \\$(genotyphi --version 2>&1) | sed 's/^.*GenoTyphi v//;' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge multiple transcriptomes while maintaining source information.\nTags: gstama, gstama/merge, long-read, isoseq, nanopore, tama, trancriptome, annotation", "answer": "process GSTAMA_MERGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gs-tama:1.0.3--hdfd78af_0' :\n        'biocontainers/gs-tama:1.0.3--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path filelist\n\n    output:\n    tuple val(meta), path(\"*.bed\")             , emit: bed\n    tuple val(meta), path(\"*_gene_report.txt\") , emit: gene_report\n    tuple val(meta), path(\"*_merge.txt\")       , emit: merge\n    tuple val(meta), path(\"*_trans_report.txt\"), emit: trans_report\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    tama_merge.py \\\\\n        -f $filelist \\\\\n        -d merge_dup \\\\\n        -p ${prefix} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gstama: \\$( tama_merge.py -version | head -n1 )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collapse redundant transcript models in Iso-Seq data.\nTags: tama_collapse.py, isoseq, nanopore, long-read, transcriptome, gene model, TAMA", "answer": "process GSTAMA_COLLAPSE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gs-tama:1.0.3--hdfd78af_0' :\n        'biocontainers/gs-tama:1.0.3--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*_collapsed.bed\")          , emit: bed\n    tuple val(meta), path(\"*_trans_read.bed\")         , emit: bed_trans_reads\n    tuple val(meta), path(\"*_local_density_error.txt\"), emit: local_density_error\n    tuple val(meta), path(\"*_polya.txt\")              , emit: polya\n    tuple val(meta), path(\"*_read.txt\")               , emit: read\n    tuple val(meta), path(\"*_strand_check.txt\")       , emit: strand_check\n    tuple val(meta), path(\"*_trans_report.txt\")       , emit: trans_report\n    path \"versions.yml\"                               , emit: versions\n\n    tuple val(meta), path(\"*_varcov.txt\")             , emit: varcov  , optional: true\n    tuple val(meta), path(\"*_variants.txt\")           , emit: variants, optional: true\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    tama_collapse.py \\\\\n        -s $bam \\\\\n        -f $fasta \\\\\n        -p ${prefix} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gstama: \\$( tama_collapse.py -version | grep 'tc_version_date_'|sed 's/tc_version_date_//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Helper script, remove remaining polyA sequences from Full Length Non Chimeric reads (Pacbio isoseq3)\nTags: gstama, gstama/polyacleanup, long-read, isoseq, tama, trancriptome, annotation", "answer": "process GSTAMA_POLYACLEANUP {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gs-tama:1.0.3--hdfd78af_0':\n        'biocontainers/gs-tama:1.0.3--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*_tama.fa.gz\")                   , emit: fasta\n    tuple val(meta), path(\"*_tama_polya_flnc_report.txt.gz\"), emit: report\n    tuple val(meta), path(\"*_tama_tails.fa.gz\")             , emit: tails\n    path \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$fasta\" == \"${prefix}.fasta\" | \"$fasta\" == \"${prefix}.fa\" ) error \"Input and output names are the same, set prefix in module configuration\"\n    \"\"\"\n    tama_flnc_polya_cleanup.py \\\\\n        -f $fasta \\\\\n        -p ${prefix} \\\\\n        $args\n    gzip ${prefix}.fa\n    gzip ${prefix}_polya_flnc_report.txt\n    gzip ${prefix}_tails.fa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gstama: \\$( tama_collapse.py -version | grep 'tc_version_date_'|sed 's/tc_version_date_//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: write your description here\nTags: classify, metagenomics, taxonomic profiling", "answer": "process KAIJU_KAIJU2TABLE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kaiju:1.10.0--h43eeafb_0':\n        'biocontainers/kaiju:1.10.0--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path db\n    val taxon_rank\n\n    output:\n    tuple val(meta), path('*.txt'), emit: summary\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    dbnodes=`find -L ${db} -name \"*nodes.dmp\"`\n    dbnames=`find -L ${db} -name \"*names.dmp\"`\n    kaiju2table   $args \\\\\n        -t \\$dbnodes \\\\\n        -n \\$dbnames \\\\\n        -r ${taxon_rank} \\\\\n        -o ${prefix}.txt \\\\\n        ${input}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Make Kaiju FMI-index file from a protein FASTA file\nTags: classify, metagenomics, fastq, taxonomic profiling, database, index", "answer": "process KAIJU_MKFMI {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"bioconda::kaiju=1.10.0\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kaiju:1.10.0--h43eeafb_0':\n        'biocontainers/kaiju:1.10.0--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.fmi\"), emit: fmi\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    kaiju-mkbwt \\\\\n        $args \\\\\n        -n $task.cpus \\\\\n        -o ${prefix} \\\\\n        ${fasta}\n    kaiju-mkfmi ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fmi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge two tab-separated output files of Kaiju and Kraken in the column format\nTags: classify, metagenomics, fastq, taxonomic profiling", "answer": "process KAIJU_MERGEOUTPUTS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kaiju:1.10.0--h43eeafb_0':\n        'biocontainers/kaiju:1.10.0--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(kaiju), path(kraken)\n    path (db)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: merged\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def dbnodes = db ? '-t <(find -L ${db} -name \"*nodes.dmp\")' : ''\n    script:\n    if (\"$kaiju\" == \"${prefix}.tsv\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    if (\"$kraken\" == \"${prefix}.tsv\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    kaiju-mergeOutputs \\\\\n        -i <(sort -k2,2 ${kaiju}) \\\\\n        -j <(sort -k2,2 ${kraken}) \\\\\n        -o ${prefix}.tsv \\\\\n        $dbnodes \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Taxonomic classification of metagenomic sequence data using a protein reference database\nTags: classify, metagenomics, fastq, taxonomic profiling", "answer": "process KAIJU_KAIJU {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kaiju:1.10.0--h43eeafb_0':\n        'biocontainers/kaiju:1.10.0--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path(db)\n\n    output:\n    tuple val(meta), path('*.tsv'), emit: results\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input = meta.single_end ? \"-i ${reads}\" : \"-i ${reads[0]} -j ${reads[1]}\"\n    \"\"\"\n    dbnodes=`find -L ${db} -name \"*nodes.dmp\"`\n    dbname=`find -L ${db} -name \"*.fmi\" -not -name \"._*\"`\n    kaiju \\\\\n        $args \\\\\n        -z $task.cpus \\\\\n        -t \\$dbnodes \\\\\n        -f \\$dbname \\\\\n        -o ${prefix}.tsv \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input = meta.single_end ? \"-i ${reads}\" : \"-i ${reads[0]} -j ${reads[1]}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Convert Kaiju's tab-separated output file into a tab-separated text file which can be imported into Krona.\nTags: taxonomy, visualisation, krona chart, metagenomics", "answer": "process KAIJU_KAIJU2KRONA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kaiju:1.10.0--h43eeafb_0':\n        'biocontainers/kaiju:1.10.0--h43eeafb_0' }\"\n\n    input:\n    tuple val(meta), path(tsv)\n    path(db)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    dbnodes=`find -L ${db} -name \"*nodes.dmp\"`\n    dbnames=`find -L ${db} -name \"*names.dmp\"`\n    kaiju2krona \\\\\n        $args \\\\\n        -t \\$dbnodes \\\\\n        -n \\$dbnames \\\\\n        -i ${tsv} \\\\\n        -o ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kaiju: \\$(echo \\$( kaiju -h 2>&1 | sed -n 1p | sed 's/^.*Kaiju //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Measures reproducibility of ChIP-seq, ATAC-seq peaks using IDR (Irreproducible\nDiscovery Rate)\n\nTags: IDR, peaks, ChIP-seq, ATAC-seq", "answer": "process IDR {\n    tag \"$prefix\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/idr:2.0.4.2--py39hcbe4a3b_5' :\n        'biocontainers/idr:2.0.4.2--py39hcbe4a3b_5' }\"\n\n    input:\n    path peaks\n    val peak_type\n    val prefix\n\n    output:\n    path \"*idrValues.txt\", emit: idr\n    path \"*log.txt\"      , emit: log\n    path \"*.png\"         , emit: png\n    path \"versions.yml\"  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    if (peaks.toList().size < 2) {\n        log.error \"[ERROR] idr needs at least two replicates only one provided.\"\n    }\n    def peak_types = ['narrowPeak', 'broadPeak', 'bed']\n    if (!peak_types.contains(peak_type)) {\n        log.error \"[ERROR] Invalid option: '${peak_type}'. Valid options for 'peak_type': ${peak_types.join(', ')}.\"\n    }\n    def idr_vals = prefix ? \"${prefix}.idrValues.txt\" : \"idrValues.txt\"\n    def log_file = prefix ? \"${prefix}.log.txt\" : \"log.txt\"\n    \"\"\"\n    idr \\\\\n        --samples $peaks \\\\\n        --input-file-type $peak_type \\\\\n        --output-file $idr_vals \\\\\n        --log-output-file $log_file \\\\\n        --plot \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        idr: \\$(echo \\$(idr --version 2>&1) | sed 's/^.*IDR //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate the relative coverage on the Gonosomes vs Autosomes from the output of samtools depth, with error bars.\nTags: sex determination, genetic sex, relative coverage, ancient dna", "answer": "process SEXDETERRMINE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sexdeterrmine:1.1.2--hdfd78af_1':\n        'biocontainers/sexdeterrmine:1.1.2--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(depth)\n    path sample_list_file\n\n    output:\n    tuple val(meta), path(\"*.json\"), emit: json\n    tuple val(meta), path(\"*.tsv\") , emit: tsv\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def sample_list = sample_list_file ? '-f ${sample_list_file}' : ''\n    if (\"$depth\" == \"${prefix}.tsv\") error \"Input depth and output TSV names are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    sexdeterrmine \\\\\n        -I $depth \\\\\n        $sample_list \\\\\n        $args \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sexdeterrmine: \\$(echo \\$(sexdeterrmine --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Plots telomeric repeat frequency against sliding window location\nusing data produced by `tidk/search`\n\nTags: genomics, telomere, search, plot", "answer": "process TIDK_PLOT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/tidk:0.2.41--hdbdd923_0':\n        'biocontainers/tidk:0.2.41--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(tsv)\n\n    output:\n    tuple val(meta), path(\"*.svg\"), emit: svg\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    tidk \\\\\n        plot \\\\\n        --output $prefix \\\\\n        $args \\\\\n        --tsv \"$tsv\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tidk: \\$(tidk --version | sed 's/tidk //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.svg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tidk: \\$(tidk --version | sed 's/tidk //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: `tidk explore` attempts to find the simple telomeric repeat unit in the genome provided.\nIt will report this repeat in its canonical form (e.g. TTAGG -> AACCT).\n\nTags: genomics, telomere, search", "answer": "process TIDK_EXPLORE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/tidk:0.2.41--hdbdd923_0':\n        'biocontainers/tidk:0.2.41--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tidk.explore.tsv\") , emit: explore_tsv\n    tuple val(meta), path(\"*.top.sequence.txt\") , emit: top_sequence, optional: true\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    tidk \\\\\n        explore \\\\\n        $args \\\\\n        $fasta \\\\\n        > ${prefix}.tidk.explore.tsv\n\n    [[ \\$(cat ${prefix}.tidk.explore.tsv | wc -l) -gt 1 ]] \\\\\n        && cat \\\\\n        ${prefix}.tidk.explore.tsv \\\\\n        | sed -n 2p \\\\\n        | awk '{print \\$1;}' \\\\\n        > ${prefix}.top.sequence.txt \\\\\n        || echo \"No sequence identified\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tidk: \\$(tidk --version | sed 's/tidk //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tidk.explore.tsv\n    touch ${prefix}.top.sequence.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tidk: \\$(tidk --version | sed 's/tidk //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Searches a genome for a telomere string such as TTAGGG\nTags: genomics, telomere, search", "answer": "process TIDK_SEARCH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/tidk:0.2.41--hdbdd923_0':\n        'biocontainers/tidk:0.2.41--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val string\n\n    output:\n    tuple val(meta), path(\"*.tsv\")          , emit: tsv         , optional: true\n    tuple val(meta), path(\"*.bedgraph\")     , emit: bedgraph    , optional: true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    tidk \\\\\n        search \\\\\n        --string $string \\\\\n        --output $prefix \\\\\n        --dir tidk \\\\\n        $args \\\\\n        $fasta\n\n    mv \\\\\n        tidk/${prefix}_telomeric_repeat_windows.tsv \\\\\n        ${prefix}.tsv \\\\\n        || echo \"TSV file was not produced\"\n\n    mv \\\\\n        tidk/${prefix}_telomeric_repeat_windows.bedgraph \\\\\n        ${prefix}.bedgraph \\\\\n        || echo \"BEDGRAPH file was not produced\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tidk: \\$(tidk --version | sed 's/tidk //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--extension bedgraph\") ? 'bedgraph' : 'tsv'\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tidk: \\$(tidk --version | sed 's/tidk //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Predicts Staphylococcus aureus SCCmec type based on primers.\nTags: amr, fasta, sccmec", "answer": "process STAPHOPIASCCMEC {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/staphopia-sccmec:1.0.0--hdfd78af_0' :\n        'biocontainers/staphopia-sccmec:1.0.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    staphopia-sccmec --assembly $fasta $args > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        staphopiasccmec: \\$(staphopia-sccmec --version 2>&1 | sed 's/^.*staphopia-sccmec //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The cluster_identifier tool of Scramble identifies soft clipped clusters\nTags: bam, cram, soft-clipped clusters", "answer": "process SCRAMBLE_CLUSTERIDENTIFIER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/scramble:1.0.1--h779adbc_1':\n        'biocontainers/scramble:1.0.1--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*.clusters.txt\") , emit: clusters\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    // The tool does not contain a way to specify the reference file when using CRAM files.\n    // It just looks in the header of the CRAM file where the reference file is located,\n    // but that reference can't always be fetched since most test data is created on\n    // another machine. I had to find another way to specify the reference and I\n    // found that I could create an md5 cache of a specified fasta and supply it to\n    // the REF_PATH environment variable. This way the tool uses the correct reference.\n    // An issue has been made about this: https://github.com/GeneDx/scramble/issues/27\n    // The reference code is a placeholder until this issue has been fixed.\n    def reference = fasta ? \"wget https://raw.githubusercontent.com/samtools/samtools/master/misc/seq_cache_populate.pl && perl seq_cache_populate.pl -root ./md5_ref ${fasta} && export REF_PATH=`pwd`/md5_ref/%2s/%2s/%s\" : \"\"\n    \"\"\"\n    ${reference}\n\n    cluster_identifier \\\\\n        ${args} \\\\\n        ${input} \\\\\n        > ${prefix}.clusters.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        scramble: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The Cluster Analysis tool of Scramble analyses and interprets the soft-clipped clusters found by `cluster_identifier`\nTags: soft-clipped clusters, scramble", "answer": "process SCRAMBLE_CLUSTERANALYSIS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/scramble:1.0.1--h779adbc_1':\n        'biocontainers/scramble:1.0.1--h779adbc_1' }\"\n\n    input:\n    tuple val(meta), path(clusters)\n    path fasta\n    path mei_ref\n\n    output:\n    tuple val(meta), path(\"*_MEIs.txt\")                 , optional:true, emit: meis_tab\n    tuple val(meta), path(\"*_PredictedDeletions.txt\")   , optional:true, emit: dels_tab\n    tuple val(meta), path(\"*.vcf\")                      , optional:true, emit: vcf\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def blastdb = args.contains(\"--eval-dels\") ? \"makeblastdb -in ${fasta} -parse_seqids -title ${fasta} -dbtype nucl -out ${fasta}\" : \"\"\n    def reference = fasta ? \"--ref `pwd`/${fasta}\" : \"\"\n\n    // The default file for the MEI reference is a file that's inside the container\n    def mei_reference = mei_ref ? \"`pwd`/${mei_ref}\" : \"/usr/local/share/scramble/resources/MEI_consensus_seqs.fa\"\n\n    def blastdb_version = args.contains(\"--eval-dels\") ? \"makeblastdb: \\$(echo \\$(makeblastdb -version 2>&1) | head -n 1 | sed 's/^makeblastdb: //; s/+ Package.*\\$//')\" : \"\"\n    \"\"\"\n    ${blastdb}\n\n    Rscript --vanilla /usr/local/share/scramble/bin/SCRAMble.R \\\\\n        --install-dir /usr/local/share/scramble/bin \\\\\n        ${args} \\\\\n        --cluster-file `pwd`/${clusters} \\\\\n        ${reference} \\\\\n        --mei-refs ${mei_reference} \\\\\n        --out-name `pwd`/${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        scramble: ${VERSION}\n        ${blastdb_version}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to estimate bacterial species abundance\nTags: bacteria, metagenomic, abundance", "answer": "VERSION = '1.3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\nprocess MIDAS_RUN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/midas:1.3.2--pyh5e36f6f_6':\n        'biocontainers/midas:1.3.2--pyh5e36f6f_6' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path db, stageAs: 'db/*'\n    val(mode)\n\n    output:\n    tuple val(meta), path(\"results/*\"), emit: results\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.single_end) {\n        \"\"\"\n        run_midas.py \\\\\n            $mode \\\\\n            results \\\\\n            -1 ${reads[0]} \\\\\n            -d $db \\\\\n            $args \\\\\n            -t $task.cpus\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            midas: $VERSION\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        run_midas.py \\\\\n            $mode \\\\\n            $prefix \\\\\n            -1 ${reads[0]} \\\\\n            -2 ${reads[1]} \\\\\n            -d $db \\\\\n            $args \\\\\n            -t $task.cpus\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            midas: $VERSION\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p results/species\n    touch \"results/species/species_profile.tsv\"\n    touch \"results/species/log.txt\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sra-human-scrubber: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Use k-mers to rapidly subtype S. enterica genomes\nTags: Salmonella enterica, subtyping, prokaryote", "answer": "process BIOHANSEL {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bio_hansel:2.6.1--py_0':\n        'biocontainers/bio_hansel:2.6.1--py_0' }\"\n\n    input:\n    tuple val(meta), path(seqs)\n    path scheme_metadata\n\n    output:\n    tuple val(meta), path(\"${prefix}-summary.txt\")       , emit: summary\n    tuple val(meta), path(\"${prefix}-kmer-results.txt\")  , emit: kmer_results\n    tuple val(meta), path(\"${prefix}-simple-summary.txt\"), emit: simple_summary\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def scheme_metadata_opt = scheme_metadata ? \"--scheme-metadata ${scheme_metadata}\" : \"\"\n    def input_type = seqs[1] == null ? \"\" : \"--paired-reads\"\n    \"\"\"\n    hansel \\\\\n        $args \\\\\n        $scheme_metadata_opt \\\\\n        --threads $task.cpus \\\\\n        --output-summary ${prefix}-summary.txt \\\\\n        --output-kmer-results ${prefix}-kmer-results.txt \\\\\n        --output-simple-summary ${prefix}-simple-summary.txt \\\\\n        $input_type \\\\\n        $seqs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biohansel: \\$(echo \\$(hansel --version 2>&1) | sed 's/^.*hansel //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to use CellBender to remove ambient RNA from single-cell RNA-seq data\nTags: single-cell, scRNA-seq, ambient RNA removal", "answer": "process CELLBENDER_MERGE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/cellbender:0.3.0--c4addb97ab2d83fe':\n        'community.wave.seqera.io/library/cellbender:0.3.0--41318a055fc3aacb' }\"\n\n    input:\n    tuple val(meta), path(filtered), path(unfiltered), path(cellbender_h5)\n\n    output:\n    tuple val(meta), path(\"${prefix}.h5ad\"), emit: h5ad\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    output_layer = task.ext.output_layer ?: \"cellbender\"\n    template 'merge.py'\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.h5ad\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellbender: \\$(cellbender --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to use CellBender to estimate ambient RNA from single-cell RNA-seq data\nTags: single-cell, scRNA-seq, ambient RNA removal", "answer": "process CELLBENDER_REMOVEBACKGROUND {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'process_gpu'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/cellbender:0.3.0--c4addb97ab2d83fe':\n        'community.wave.seqera.io/library/cellbender:0.3.0--41318a055fc3aacb' }\"\n\n    input:\n    tuple val(meta), path(h5ad)\n\n    output:\n    tuple val(meta), path(\"${prefix}.h5\")               , emit: h5\n    tuple val(meta), path(\"${prefix}_filtered.h5\")      , emit: filtered_h5\n    tuple val(meta), path(\"${prefix}_posterior.h5\")     , emit: posterior_h5\n    tuple val(meta), path(\"${prefix}_cell_barcodes.csv\"), emit: barcodes\n    tuple val(meta), path(\"${prefix}_metrics.csv\")      , emit: metrics\n    tuple val(meta), path(\"${prefix}_report.html\")      , emit: report\n    tuple val(meta), path(\"${prefix}.pdf\")              , emit: pdf\n    tuple val(meta), path(\"${prefix}.log\")              , emit: log\n    tuple val(meta), path(\"ckpt.tar.gz\")                , emit: checkpoint\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    args = task.ext.args ?: \"\"\n    use_gpu = task.ext.use_gpu ? \"--cuda\" : \"\"\n    \"\"\"\n    TMPDIR=. cellbender remove-background \\\n        ${args} \\\n        --cpu-threads ${task.cpus} \\\n        ${use_gpu} \\\n        --input ${h5ad} \\\n        --output ${prefix}.h5\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellbender: \\$(cellbender --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.h5\"\n    touch \"${prefix}_filtered.h5\"\n    touch \"${prefix}_posterior.h5\"\n    touch \"${prefix}_cell_barcodes.csv\"\n    touch \"${prefix}_metrics.csv\"\n    touch \"${prefix}_report.html\"\n    touch \"${prefix}.pdf\"\n    touch \"${prefix}.log\"\n    touch \"ckpt.tar.gz\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellbender: \\$(cellbender --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merging paired-end reads and removing sequencing adapters.\nTags: sort, reads merging, merge mate pairs", "answer": "process NGMERGE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ngmerge:0.3--ha92aebf_1':\n        'biocontainers/ngmerge:0.3--ha92aebf_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.merged.fq.gz\"), emit: merged_reads\n    tuple val(meta), path(\"*_1.fastq.gz\")  , emit: unstitched_read1\n    tuple val(meta), path(\"*_2.fastq.gz\")  , emit: unstitched_read2\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    NGmerge \\\\\n        -1 ${reads[0]} \\\\\n        -2 ${reads[1]} \\\\\n        -o ${prefix}.merged.fq.gz \\\\\n        -f ${prefix}_unstitched \\\\\n        -z \\\\\n        -n $task.cpus \\\\\n        $args\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        NGmerge: \\$(echo \\$(NGmerge --version 2>&1) | sed 's/^.*NGmerge, version //; s/ Copyright.*// ; s/: //g' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.merged.fq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        NGmerge: \\$(echo \\$(NGmerge --version 2>&1) | sed 's/^.*NGmerge, version //; s/ Copyright.*// ; s/: //g' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Distance-based phylogeny with FastME\nTags: phylogenetics, newick, minimum_evolution, distance-based", "answer": "process FASTME {\n    tag \"$infile\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fastme:2.1.6.1--hec16e2b_1':\n        'biocontainers/fastme:2.1.6.1--hec16e2b_1' }\"\n\n    input:\n    tuple val(meta), path(infile), path(initial_tree)\n\n    output:\n    tuple val(meta), path(\"*.nwk\")       , emit: nwk\n    tuple val(meta), path(\"*_stat.txt\")  , emit: stats\n    tuple val(meta), path(\"*.matrix.phy\"), emit: matrix    , optional: true\n    tuple val(meta), path(\"*.bootstrap\") , emit: bootstrap , optional: true\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: infile\n    def initarg = initial_tree ? \"-u $initial_tree\" : ''\n    def matarg  = task.ext.args =~ \"-O\" ? \"-O ${prefix}.matrix.phy\" : ''\n    def bootarg = task.ext.args =~ \"-B\" ? \"-B ${prefix}.bootstrap\" : ''\n    \"\"\"\n    fastme \\\\\n        $args \\\\\n        -i $infile \\\\\n        $initarg \\\\\n        -o ${prefix}.nwk \\\\\n        $matarg \\\\\n        $bootarg \\\\\n        -T $task.cpus\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastme: \\$(fastme --version |& sed '1!d ; s/FastME //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: infile\n    def mat    = task.ext.args =~ \"-O\" ? \"touch ${prefix}.matrix.phy\" : ''\n    def boot   = task.ext.args =~ \"-B\" ? \"touch ${prefix}.bootstrap\" : ''\n    \"\"\"\n    touch ${prefix}.nwk\n    touch ${prefix}_stat.txt\n    $mat\n    $boot\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastme: \\$(fastme --version |& sed '1!d ; s/FastME //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assign PBP type of Streptococcus pneumoniae assemblies\nTags: bacteria, pbp, fasta, assembly", "answer": "process PBPTYPER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pbptyper:1.0.2--hdfd78af_0':\n        'biocontainers/pbptyper:1.0.2--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path(db)\n\n    output:\n    tuple val(meta), path(\"${prefix}.tsv\"), emit: tsv\n    tuple val(meta), path(\"*.tblastn.tsv\"), emit: blast\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def db_args = db ? '--db ${db}' : ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pbptyper \\\\\n        $db_args \\\\\n        $args \\\\\n        --prefix $prefix \\\\\n        --assembly $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pbptyper: \\$(echo \\$(pbptyper --version 2>&1) | sed 's/^.*pbptyper, version //;' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A genomic k-mer counter (and sequence utility) with nice features.\nTags: k-mer, unionsum, reference-free", "answer": "process MERYL_UNIONSUM {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/meryl:1.4.1--h4ac6f70_0':\n        'biocontainers/meryl:1.4.1--h4ac6f70_0' }\"\n\n    input:\n    tuple val(meta), path(meryl_dbs)\n    val kvalue\n\n    output:\n    tuple val(meta), path(\"*.unionsum.meryl\"), emit: meryl_db\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    meryl union-sum \\\\\n        k=$kvalue \\\\\n        threads=$task.cpus \\\\\n        memory=${task.memory.toGiga()} \\\\\n        $args \\\\\n        output ${prefix}.unionsum.meryl \\\\\n        $meryl_dbs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        meryl: \\$( meryl --version |& sed 's/meryl //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.unionsum.meryl\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        meryl: \\$( meryl --version |& sed 's/meryl //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A genomic k-mer counter (and sequence utility) with nice features.\nTags: k-mer, count, reference-free", "answer": "process MERYL_COUNT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/meryl:1.4.1--h4ac6f70_0':\n        'biocontainers/meryl:1.4.1--h4ac6f70_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    val kvalue\n\n    output:\n    tuple val(meta), path(\"*.meryl\")    , emit: meryl_db\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    for READ in $reads; do\n        meryl count \\\\\n            k=$kvalue \\\\\n            threads=$task.cpus \\\\\n            memory=${task.memory.toGiga()} \\\\\n            $args \\\\\n            $reads \\\\\n            output read.\\${READ%.f*}.meryl\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        meryl: \\$( meryl --version |& sed 's/meryl //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    for READ in $reads; do\n        touch read.\\${READ%.f*}.meryl\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        meryl: \\$( meryl --version |& sed 's/meryl //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A genomic k-mer counter (and sequence utility) with nice features.\nTags: k-mer, histogram, reference-free", "answer": "process MERYL_HISTOGRAM {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/meryl:1.4.1--h4ac6f70_0':\n        'biocontainers/meryl:1.4.1--h4ac6f70_0' }\"\n\n    input:\n    tuple val(meta), path(meryl_db)\n    val kvalue\n\n    output:\n    tuple val(meta), path(\"*.hist\"), emit: hist\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    meryl histogram \\\\\n        k=$kvalue \\\\\n        threads=$task.cpus \\\\\n        memory=${task.memory.toGiga()} \\\\\n        $args \\\\\n        $meryl_db > ${prefix}.hist\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        meryl: \\$( meryl --version |& sed 's/meryl //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.hist\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        meryl: \\$( meryl --version |& sed 's/meryl //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GMM-Demux is a Gaussian-Mixture-Model-based software for processing sample barcoding data (cell hashing and MULTI-seq).\nTags: demultiplexing, hashing-based deconvolution, single-cell", "answer": "\nprocess GMMDEMUX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gmm-demux:0.2.2.3--pyh7cba7a3_0':\n        'biocontainers/gmm-demux:0.2.2.3--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(hto_matrix), val(hto_names)\n    val type_report\n    val summary_report\n    path skip\n    path examine\n\n    output:\n    tuple val(meta), path(\"barcodes.tsv.gz\"     ), emit: barcodes\n    tuple val(meta), path(\"matrix.mtx.gz\"       ), emit: matrix\n    tuple val(meta), path(\"features.tsv.gz\"     ), emit: features\n    tuple val(meta), path(\"GMM_*.csv\"           ), emit: classification_report\n    tuple val(meta), path(\"GMM_*.config\"        ), emit: config_report\n    tuple val(meta), path(\"summary_report_*.txt\"), emit: summary_report, optional: true\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args           = task.ext.args ?: ''\n    def prefix         = task.ext.prefix ?: \"${meta.id}\"\n    def skip           = skip ? \"--skip $skip\" : \"\"\n    def examine_cells  = examine ? \"--examine $examine\" : \"\"\n    def VERSION        = '0.2.2.3' // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    def type_report    = type_report ? \"-f .\" : \"-s .\"\n    def summary_rep    = summary_report ? \"-r ${prefix}_summary_report.txt\" : \"\"\n    \"\"\"\n    if [[ ${summary_report} == true ]]; then\n        cat /dev/null > ${prefix}_summary_report.txt\n    fi\n\n    GMM-demux $args \\\\\n        $type_report \\\\\n        $summary_rep \\\\\n        $skip \\\\\n        $examine_cells \\\\\n        $hto_matrix \\\\\n        $hto_names \\\\\n        -o .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        GMM-Demux: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def VERSION = '0.2.2.3'\n    def prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > barcodes.tsv.gz\n    echo \"\" | gzip > features.tsv.gz\n    echo \"\" | gzip > matrix.mtx.gz\n    touch GMM_full.config\n    touch GMM_full.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        GMM-Demux: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: removes unused references from header of sorted BAM/CRAM files.\nTags: bam, clean, align", "answer": "process BAMALIGNCLEANER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bamaligncleaner:0.2.2--pyhdfd78af_0' :\n        'biocontainers/bamaligncleaner:0.2.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    bamAlignCleaner \\\\\n        $args \\\\\n        -o ${prefix}.bam \\\\\n        ${bam}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamaligncleaner: \\$(bamAlignCleaner --version | sed 's/.*version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamaligncleaner: \\$(bamAlignCleaner --version | sed 's/.*version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: count how many reads map to each feature\nTags: htseq, count, gtf, annotation", "answer": "process HTSEQ_COUNT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/htseq:2.0.3--py310ha14a713_0':\n        'biocontainers/htseq:2.0.3--py310ha14a713_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(index)\n    tuple val(meta2), path(gtf)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    htseq-count \\\\\n        ${input} \\\\\n        ${gtf} \\\\\n        ${args} \\\\\n        > ${prefix}.txt\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        htseq: \\$(echo \\$(htseq-count --version ) | sed 's/^.*htseq-count //; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        : \\$(echo \\$(htseq-count --version ) | sed 's/^.*htseq-count //; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a cooler from genomic pairs and bins\nTags: cool, cooler, cload, hic", "answer": "process COOLER_CLOAD {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cooler:0.9.2--pyh7cba7a3_0' :\n        'biocontainers/cooler:0.9.2--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(pairs), path(index), val(cool_bin)\n    path chromsizes\n\n    output:\n    tuple val(meta), path(\"*.cool\"), val(cool_bin), emit: cool\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def nproc  = args.contains('pairix') || args.contains('tabix')? \"--nproc $task.cpus\" : ''\n\n    \"\"\"\n    cooler cload \\\\\n        $args \\\\\n        $nproc \\\\\n        ${chromsizes}:${cool_bin} \\\\\n        $pairs \\\\\n        ${prefix}.cool\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.cool\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Dump a cooler\u2019s data to a text stream.\nTags: dump, text, cooler", "answer": "process COOLER_DUMP {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cooler:0.9.2--pyh7cba7a3_0' :\n        'biocontainers/cooler:0.9.2--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(cool), val(resolution)\n\n    output:\n    tuple val(meta), path(\"*.bedpe\"), emit: bedpe\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = resolution ? \"::/resolutions/$resolution\" : \"\"\n    \"\"\"\n    cooler dump \\\\\n        $args \\\\\n        -o ${prefix}.bedpe \\\\\n        $cool$suffix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate fixed-width genomic bins\nTags: makebins, cooler, genomic bins", "answer": "process COOLER_MAKEBINS {\n    tag \"${meta.id}}\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cooler:0.9.2--pyh7cba7a3_0' :\n        'biocontainers/cooler:0.9.2--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(chromsizes), val(cool_bin)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cooler makebins \\\\\n        $args \\\\\n        ${chromsizes} \\\\\n        ${cool_bin} > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge multiple coolers with identical axes\nTags: merge, cooler, hic", "answer": "process COOLER_MERGE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cooler:0.9.2--pyh7cba7a3_0' :\n        'biocontainers/cooler:0.9.2--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(cool)\n\n    output:\n    tuple val(meta), path(\"*.cool\"), emit: cool\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cooler merge \\\\\n        $args \\\\\n        ${prefix}.cool \\\\\n        ${cool}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.cool\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate fragment-delimited genomic bins\nTags: digest, enzyme, cooler", "answer": "process COOLER_DIGEST {\n    tag \"$fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cooler:0.9.2--pyh7cba7a3_0' :\n        'biocontainers/cooler:0.9.2--pyh7cba7a3_0' }\"\n\n    input:\n    path fasta\n    path chromsizes\n    val  enzyme\n\n    output:\n    path \"*.bed\"                  , emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    cooler digest \\\\\n        $args \\\\\n        -o \"${fasta.baseName}_${enzyme.replaceAll(/[^0-9a-zA-Z]+/, '_')}.bed\" \\\\\n        $chromsizes \\\\\n        $fasta \\\\\n        $enzyme\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run matrix balancing on a cool file\nTags: cooler/balance, cooler, cool, cooler", "answer": "process COOLER_BALANCE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cooler:0.9.2--pyh7cba7a3_0' :\n        'biocontainers/cooler:0.9.2--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(cool), val(resolution)\n\n    output:\n    tuple val(meta), path(\"${prefix}.${extension}\"), emit: cool\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = resolution ? \"::/resolutions/$resolution\" : \"\"\n    extension = cool.getExtension()\n    if (\"$cool\" == \"${prefix}.${extension}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    cp ${cool} ${prefix}.${extension}\n\n    cooler balance \\\\\n        $args \\\\\n        -p ${task.cpus} \\\\\n        ${prefix}.${extension}${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate a multi-resolution cooler file by coarsening\nTags: mcool, cool, cooler", "answer": "process COOLER_ZOOMIFY {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cooler:0.9.2--pyh7cba7a3_0' :\n        'biocontainers/cooler:0.9.2--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(cool)\n\n    output:\n    tuple val(meta), path(\"*.mcool\"), emit: mcool\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cooler zoomify \\\\\n        $args \\\\\n        -n $task.cpus \\\\\n        -o ${prefix}.mcool \\\\\n        $cool\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.mcool\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cooler: \\$(cooler --version 2>&1 | sed 's/cooler, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SNP table generator from GATK UnifiedGenotyper with functionality geared for aDNA\nTags: vcf, ancient DNA, aDNA, SNP, GATK UnifiedGenotyper, SNP table", "answer": "process MULTIVCFANALYZER {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/multivcfanalyzer:0.85.2--hdfd78af_1':\n        'biocontainers/multivcfanalyzer:0.85.2--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(vcfs)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(snpeff_results)\n    tuple val(meta4), path(gff)\n    val allele_freqs\n    val genotype_quality\n    val coverage\n    val homozygous_freq\n    val heterozygous_freq\n    tuple val(meta5), path(gff_exclude)\n\n\n    output:\n    tuple val(meta), path('fullAlignment.fasta.gz')                       , emit: full_alignment\n    tuple val(meta), path('info.txt')                                     , emit: info_txt\n    tuple val(meta), path('snpAlignment.fasta.gz')                        , emit: snp_alignment\n    tuple val(meta), path('snpAlignmentIncludingRefGenome.fasta.gz')      , emit: snp_genome_alignment\n    tuple val(meta), path('snpStatistics.tsv')                            , emit: snpstatistics\n    tuple val(meta), path('snpTable.tsv')                                 , emit: snptable\n    tuple val(meta), path('snpTableForSnpEff.tsv')                        , emit: snptable_snpeff\n    tuple val(meta), path('snpTableWithUncertaintyCalls.tsv')             , emit: snptable_uncertainty\n    tuple val(meta), path('structureGenotypes.tsv')                       , emit: structure_genotypes\n    tuple val(meta), path('structureGenotypes_noMissingData-Columns.tsv') , emit: structure_genotypes_nomissing\n    tuple val(meta), path('MultiVCFAnalyzer.json')                        , emit: json\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // def args = task.ext.args ?: '' // MultiVCFAnalyzer has strict and input ordering and all are mandatory. Deactivating $args to prevent breakage of input\n    def args2 = task.ext.args2 ?: ''\n\n    def cmd_snpeff_results = snpeff_results ? \"${snpeff_results}\" : \"NA\"\n    def cmd_gff            = gff ? \"${gff}\" : \"NA\"\n    def cmd_allele_freqs   = allele_freqs ? \"T\" : \"F\"\n    def cmd_gff_exclude    = gff_exclude ? \"${gff}\" : \"NA\"\n\n    \"\"\"\n    multivcfanalyzer \\\\\n        ${cmd_snpeff_results} \\\\\n        ${fasta} \\\\\n        ${cmd_gff} \\\\\n        . \\\n        ${cmd_allele_freqs}  \\\\\n        ${genotype_quality}  \\\\\n        ${coverage}  \\\\\n        ${homozygous_freq}  \\\\\n        ${heterozygous_freq}  \\\\\n        ${cmd_gff_exclude}  \\\\\n        ${vcfs.sort().join(\" \")}\n\n    gzip \\\\\n        $args2 \\\\\n        fullAlignment.fasta snpAlignment.fasta snpAlignmentIncludingRefGenome.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        multivcfanalyzer: \\$(echo \\$(multivcfanalyzer --help | head -n 1) | cut -f 3 -d ' ' )\n    END_VERSIONS\n    \"\"\"\n    stub:\n\n    def args2 = task.ext.args2 ?: ''\n\n    def cmd_snpeff_results = snpeff_results ? \"${snpeff_results}\" : \"NA\"\n    def cmd_gff            = gff ? \"${gff}\" : \"NA\"\n    def cmd_allele_freqs   = allele_freqs ? \"T\" : \"F\"\n    def cmd_gff_exclude    = gff_exclude ? \"${gff}\" : \"NA\"\n\n    \"\"\"\n    echo \"\" | gzip > fullAlignment.fasta.gz\n    touch info.txt\n    echo \"\" | gzip > snpAlignment.fasta.gz\n    echo \"\" | gzip > snpAlignmentIncludingRefGenome.fasta.gz\n    touch snpStatistics.tsv\n    touch snpTable.tsv\n    touch snpTableForSnpEff.tsv\n    touch snpTableWithUncertaintyCalls.tsv\n    touch structureGenotypes.tsv\n    touch structureGenotypes_noMissingData-Columns.tsv\n    touch MultiVCFAnalyzer.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        multivcfanalyzer: \\$(echo \\$(multivcfanalyzer --help | head -n 1) | cut -f 3 -d ' ' )\n    END_VERSIONS\n\n    \"\"\"\n}\n"}
{"question": "Description: Fast genome-wide functional annotation through orthology assignment.\nTags: annotation, orthology, genomics", "answer": "process EGGNOGMAPPER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/eggnog-mapper:2.1.12--pyhdfd78af_0':\n        'biocontainers/eggnog-mapper:2.1.12--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path(eggnog_db)\n    path(eggnog_data_dir)\n    tuple val(meta2), path(eggnog_diamond_db)\n\n    output:\n    tuple val(meta), path(\"*.emapper.annotations\")   , emit: annotations\n    tuple val(meta), path(\"*.emapper.seed_orthologs\"), emit: orthologs\n    tuple val(meta), path(\"*.emapper.hits\")          , emit: hits\n    path \"versions.yml\"                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args            = task.ext.args                 ?: ''\n    def prefix          = task.ext.prefix               ?: \"${meta.id}\"\n    def is_compressed   = fasta.extension == '.gz'      ? true                              : false\n    def fasta_name      = is_compressed                 ? fasta.baseName                    : \"$fasta\"\n    def dbmem           = task.memory.toMega() > 40000  ? '--dbmem'                         : ''\n    def database_arg    = eggnog_db                     ? \"--database $eggnog_db\"           : ''\n    def dmnd_db_arg     = eggnog_diamond_db             ? \"--dmnd_db $eggnog_diamond_db\"    : ''\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    emapper.py \\\\\n        --cpu ${task.cpus} \\\\\n        -i ${fasta_name} \\\\\n        --data_dir ${eggnog_data_dir} \\\\\n        -m diamond \\\\\n        $dmnd_db_arg \\\\\n        $database_arg \\\\\n        --output ${prefix} \\\\\n        ${dbmem} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        eggnog-mapper: \\$(echo \\$(emapper.py --version) | grep -o \"emapper-[0-9]\\\\+\\\\.[0-9]\\\\+\\\\.[0-9]\\\\+\" | sed \"s/emapper-//\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.emapper.annotations\n    touch ${prefix}.emapper.seed_orthologs\n    touch ${prefix}.emapper.hits\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        eggnog-mapper: \\$(echo \\$(emapper.py --version) | grep -o \"emapper-[0-9]\\\\+\\\\.[0-9]\\\\+\\\\.[0-9]\\\\+\" | sed \"s/emapper-//\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run standard proteomics data analysis with MaxQuant, mostly dedicated to label-free. Paths to fasta and raw files needs to be marked by \"PLACEHOLDER\"\nTags: sort", "answer": "process MAXQUANT_LFQ {\n    tag \"$meta.id\"\n    label 'process_long'\n    conda \"${moduleDir}/environment.yml\"\n    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {\n        container \"https://depot.galaxyproject.org/singularity/maxquant:2.0.3.0--py310hdfd78af_1\"\n    } else {\n        container \"biocontainers/maxquant:2.0.3.0--py310hdfd78af_1\"\n    }\n\n    input:\n    tuple val(meta), path(fasta), path(paramfile)\n    path raw\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: maxquant_txt\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            maxquant: \\$(maxquant --version 2>&1 > /dev/null | cut -f2 -d\\\" \\\")\n    END_VERSIONS\n    sed \\\"s_<numThreads>.*_<numThreads>$task.cpus</numThreads>_\\\" ${paramfile} > mqpar_changed.xml\n    sed -i \\\"s|PLACEHOLDER|\\$PWD/|g\\\" mqpar_changed.xml\n    mkdir temp\n    maxquant mqpar_changed.xml\n    mv combined/txt/*.txt .\n    \"\"\"\n}\n"}
{"question": "Description: Import transcript-level abundances and estimated counts for gene-level\nanalysis packages\n\nTags: gene, kallisto, pseudoalignment, salmon, transcript", "answer": "process TXIMETA_TXIMPORT {\n    label \"process_medium\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-tximeta%3A1.20.1--r43hdfd78af_0' :\n        'biocontainers/bioconductor-tximeta:1.20.1--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(\"quants/*\")\n    tuple val(meta2), path(tx2gene)\n    val quant_type\n\n    output:\n    tuple val(meta), path(\"*gene_tpm.tsv\")                 , emit: tpm_gene\n    tuple val(meta), path(\"*gene_counts.tsv\")              , emit: counts_gene\n    tuple val(meta), path(\"*gene_counts_length_scaled.tsv\"), emit: counts_gene_length_scaled\n    tuple val(meta), path(\"*gene_counts_scaled.tsv\")       , emit: counts_gene_scaled\n    tuple val(meta), path(\"*gene_lengths.tsv\")             , emit: lengths_gene\n    tuple val(meta), path(\"*transcript_tpm.tsv\")           , emit: tpm_transcript\n    tuple val(meta), path(\"*transcript_counts.tsv\")        , emit: counts_transcript\n    tuple val(meta), path(\"*transcript_lengths.tsv\")       , emit: lengths_transcript\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'tximport.r'\n\n    stub:\n    \"\"\"\n    touch ${meta.id}.gene_tpm.tsv\n    touch ${meta.id}.gene_counts.tsv\n    touch ${meta.id}.gene_counts_length_scaled.tsv\n    touch ${meta.id}.gene_counts_scaled.tsv\n    touch ${meta.id}.gene_lengths.tsv\n    touch ${meta.id}.transcript_tpm.tsv\n    touch ${meta.id}.transcript_counts.tsv\n    touch ${meta.id}.transcript_lengths.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bioconductor-tximeta: \\$(Rscript -e \"library(tximeta); cat(as.character(packageVersion('tximeta')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Predicts LTR retrotransposons using the parallel version of GenomeTools gt-ltrharvest\nutility included in the EDTA toolchain\n\nTags: genomics, genome, annotation, repeat, transposons, retrotransposons", "answer": "process LTRHARVEST {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ltr_harvest_parallel:1.1--hdfd78af_0':\n        'biocontainers/ltr_harvest_parallel:1.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.gff3\") , emit: gff3\n    tuple val(meta), path(\"*.scn\")  , emit: scn\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    LTR_HARVEST_parallel \\\\\n        -seq $fasta \\\\\n        $args \\\\\n        -threads $task.cpus\n\n    mv \"${fasta}.harvest.combine.gff3\" \\\\\n        \"${prefix}.gff3\"\n\n    mv \"${fasta}.harvest.combine.scn\" \\\\\n        \"${prefix}.scn\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        LTR_HARVEST_parallel: \\$(LTR_HARVEST_parallel -h | sed -n '/Version/s/Version: //p')\n        genometools: \\$(gt --version | sed '1!d ; s/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.gff3\"\n    touch \"${prefix}.scn\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        LTR_HARVEST_parallel: \\$(LTR_HARVEST_parallel -h | sed -n '/Version/s/Version: //p')\n        genometools: \\$(gt --version | sed '1!d ; s/gt (GenomeTools) //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: AMR predictions for supported species\nTags: fastq, bam, antimicrobial resistance", "answer": "process MYKROBE_PREDICT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mykrobe:0.11.0--py39h2add14b_1':\n        'biocontainers/mykrobe:0.11.0--py39h2add14b_1' }\"\n\n    input:\n    tuple val(meta), path(seqs)\n    val species\n\n    output:\n    tuple val(meta), path(\"${prefix}.csv\") , emit: csv\n    tuple val(meta), path(\"${prefix}.json\"), emit: json\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mykrobe \\\\\n        predict \\\\\n        $args \\\\\n        --species $species \\\\\n        --threads $task.cpus \\\\\n        --sample $prefix \\\\\n        --format json_and_csv \\\\\n        --output ${prefix} \\\\\n        --seq $seqs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mykrobe: \\$(echo \\$(mykrobe --version 2>&1) | sed 's/^.*mykrobe v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filtlong filters long reads based on quality measures or short read data.\nTags: nanopore, quality control, QC, filtering, long reads, short reads", "answer": "process FILTLONG {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/filtlong:0.2.1--h9a82719_0' :\n        'biocontainers/filtlong:0.2.1--h9a82719_0' }\"\n\n    input:\n    tuple val(meta), path(shortreads), path(longreads)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: reads\n    tuple val(meta), path(\"*.log\")     , emit: log\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def short_reads = !shortreads ? \"\" : meta.single_end ? \"-1 $shortreads\" : \"-1 ${shortreads[0]} -2 ${shortreads[1]}\"\n    if (\"$longreads\" == \"${prefix}.fastq.gz\") error \"Longread FASTQ input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    filtlong \\\\\n        $short_reads \\\\\n        $args \\\\\n        $longreads \\\\\n        2> >(tee ${prefix}.log >&2) \\\\\n        | gzip -n > ${prefix}.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        filtlong: \\$( filtlong --version | sed -e \"s/Filtlong v//g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: BaSiCPy is a python package for background and shading correction of optical microscopy images. It is developed based on the Matlab version of BaSiC tool with major improvements in the algorithm.\nTags: illumiation_correction, background_correction, microscopy, imaging", "answer": "process BASICPY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"docker.io/labsyspharm/basicpy-docker-mcmicro:1.2.0-patch1\"\n\n    input:\n    tuple val(meta), path(image)\n\n    output:\n    tuple val(meta), path(\"*.tiff\"), emit: fields\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Basicpy module does not support Conda. Please use Docker / Singularity instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"1.2.0-patch1\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping\n    \"\"\"\n    /opt/main.py -i $image -o . $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        basicpy:: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Basicpy module does not support Conda. Please use Docker / Singularity instead.\"\n    }\n    \"\"\"\n    touch ${prefix}.-dfp.tiff\n    touch ${prefix}.-dfp.tiff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        basicpy:: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calling lowest common ancestors from multi-mapped reads in SAM/BAM/CRAM files\nTags: LCA, alignment, bam, metagenomics, Ancestor, multimapper", "answer": "\nprocess SAM2LCA_ANALYZE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sam2lca:1.1.2--pyhdfd78af_1':\n        'biocontainers/sam2lca:1.1.2--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path(database)\n\n    output:\n    tuple val(meta), path(\"*.csv\") ,                 emit: csv\n    tuple val(meta), path(\"*.json\"),                 emit: json\n    tuple val(meta), path(\"*.bam\") , optional: true, emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def make_db = database ? \"\" : \"mkdir sam2lca_db\"\n    def database = database ? \"${database}\" : \"sam2lca_db\"\n    \"\"\"\n    $make_db\n    sam2lca \\\\\n        -d $database \\\\\n        analyze \\\\\n        $args \\\\\n        -o ${prefix} \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sam2lca: \\$(echo \\$(sam2lca --version 2>&1) | sed 's/^sam2lca, version //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: If you are like many computer users, you would frequently like to make changes in various text files\nwherever certain patterns appear, or extract data from parts of certain lines while discarding the rest.\nThe job is easy with awk, especially the GNU implementation gawk.\n\nTags: gawk, awk, txt, text, file parsing", "answer": "process GAWK {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gawk:5.3.0' :\n        'biocontainers/gawk:5.3.0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path(program_file)\n\n    output:\n    tuple val(meta), path(\"${prefix}.${suffix}\"), emit: output\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args  ?: '' // args is used for the main arguments of the tool\n    def args2 = task.ext.args2 ?: '' // args2 is used to specify a program when no program file has been given\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.suffix ?: \"${input.getExtension()}\"\n\n    program = program_file ? \"-f ${program_file}\" : \"${args2}\"\n\n    \"\"\"\n    awk \\\\\n        ${args} \\\\\n        ${program} \\\\\n        ${input} \\\\\n        > ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gawk: \\$(awk -Wversion | sed '1!d; s/.*Awk //; s/,.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.suffix ?: \"${input.getExtension()}\"\n    def create_cmd = suffix.endsWith(\"gz\") ? \"echo '' | gzip >\" : \"touch\"\n\n    \"\"\"\n    ${create_cmd} ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gawk: \\$(awk -Wversion | sed '1!d; s/.*Awk //; s/,.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assemble bacterial isolate genomes from Illumina paired-end reads\nTags: bacterial, assembly, illumina", "answer": "process SHOVILL {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/shovill:1.1.0--0' :\n        'biocontainers/shovill:1.1.0--0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"contigs.fa\")                         , emit: contigs\n    tuple val(meta), path(\"shovill.corrections\")                , emit: corrections\n    tuple val(meta), path(\"shovill.log\")                        , emit: log\n    tuple val(meta), path(\"{skesa,spades,megahit,velvet}.fasta\"), emit: raw_contigs\n    tuple val(meta), path(\"contigs.{fastg,gfa,LastGraph}\")      , optional:true, emit: gfa\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def memory = task.memory.toGiga()\n    \"\"\"\n    shovill \\\\\n        --R1 ${reads[0]} \\\\\n        --R2 ${reads[1]} \\\\\n        $args \\\\\n        --cpus $task.cpus \\\\\n        --ram $memory \\\\\n        --outdir ./ \\\\\n        --force\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        shovill: \\$(echo \\$(shovill --version 2>&1) | sed 's/^.*shovill //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: marks duplicate spots along gridline edges.\nTags: imaging, resolve_bioscience, spatial_transcriptomics", "answer": "process MINDAGAP_DUPLICATEFINDER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"bioconda::mindagap=0.0.2\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mindagap:0.0.2--pyhdfd78af_1':\n        'biocontainers/mindagap:0.0.2--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(spot_table)\n\n    output:\n    tuple val(meta), path(\"*markedDups.txt\"), emit: marked_dups_spots\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    duplicate_finder.py \\\\\n        $spot_table \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mindagap: \\$(mindagap.py test -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Takes a single panorama image and fills the empty grid lines with neighbour-weighted values.\nTags: imaging, resolve_bioscience, spatial_transcriptomics", "answer": "process MINDAGAP_MINDAGAP {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n    'https://depot.galaxyproject.org/singularity/mindagap:0.0.2--pyhdfd78af_1' :\n    'biocontainers/mindagap:0.0.2--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(panorama)\n\n    output:\n    tuple val(meta), path(\"*.{tif,tiff}\"), emit: tiff\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mindagap.py \\\\\n        $panorama \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mindagap: \\$(mindagap.py test -v)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${panorama.baseName}_gridfilled.tiff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mindagap: \\$(mindagap.py test -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Annotate list of metagenome members (based on sourmash signature matches) with taxonomic information.\nTags: fracminhash sketch, signature, kmer, containment, sourmash, genomics, metagenomics, taxonomic classification, taxonomic profiling", "answer": "process SOURMASH_TAXANNOTATE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sourmash:4.8.4--hdfd78af_0':\n        'biocontainers/sourmash:4.8.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gather_results)\n    path(taxonomy)\n\n    output:\n    tuple val(meta), path(\"*.with-lineages.csv.gz\"), emit: result\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    sourmash \\\\\n        tax annotate \\\n        $args \\\\\n        --gather-csv ${gather_results} \\\\\n        --taxonomy ${taxonomy} \\\\\n        --output-dir \".\"\n\n    ## Compress output\n    gzip --no-name *.with-lineages.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sourmash: \\$(echo \\$(sourmash --version 2>&1) | sed 's/^sourmash //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Search a metagenome sourmash signature against one or many reference databases and return the minimum set of genomes that contain the k-mers in the metagenome.\nTags: FracMinHash sketch, signature, kmer, containment, sourmash, genomics, metagenomics, taxonomic classification, taxonomic profiling", "answer": "process SOURMASH_GATHER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sourmash:4.8.4--hdfd78af_0':\n        'biocontainers/sourmash:4.8.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(signature)\n    path(database)\n    val save_unassigned\n    val save_matches_sig\n    val save_prefetch\n    val save_prefetch_csv\n\n    output:\n    tuple val(meta), path('*.csv.gz')             , optional:true, emit: result\n    tuple val(meta), path('*_unassigned.sig.zip') , optional:true, emit: unassigned\n    tuple val(meta), path('*_matches.sig.zip')    , optional:true, emit: matches\n    tuple val(meta), path('*_prefetch.sig.zip')   , optional:true, emit: prefetch\n    tuple val(meta), path('*_prefetch.csv.gz')    , optional:true, emit: prefetchcsv\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def unassigned  = save_unassigned   ? \"--output-unassigned ${prefix}_unassigned.sig.zip\" : ''\n    def matches     = save_matches_sig  ? \"--save-matches ${prefix}_matches.sig.zip\"         : ''\n    def prefetch    = save_prefetch     ? \"--save-prefetch ${prefix}_prefetch.sig.zip\"       : ''\n    def prefetchcsv = save_prefetch_csv ? \"--save-prefetch-csv ${prefix}_prefetch.csv.gz\"    : ''\n\n    \"\"\"\n    sourmash gather \\\\\n        $args \\\\\n        --output ${prefix}.csv.gz \\\\\n        ${unassigned} \\\\\n        ${matches} \\\\\n        ${prefetch} \\\\\n        ${prefetchcsv} \\\\\n        ${signature} \\\\\n        ${database}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sourmash: \\$(echo \\$(sourmash --version 2>&1) | sed 's/^sourmash //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compare many FracMinHash signatures generated by sourmash sketch.\nTags: compare, FracMinHash sketch, containment, sourmash, metagenomics, genomics, kmer", "answer": "process SOURMASH_COMPARE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sourmash:4.8.4--hdfd78af_0':\n        'biocontainers/sourmash:4.8.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(signatures)\n    path file_list // optional file\n    val save_numpy_matrix\n    val save_csv\n\n    output:\n    tuple val(meta), path(\"*comp.npy\")            , emit: matrix, optional:true\n    tuple val(meta), path(\"*comp.npy.labels.txt\") , emit: labels, optional:true\n    tuple val(meta), path(\"*comp.csv\")            , emit: csv   , optional:true\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args     ?: ''\n    def prefix = task.ext.prefix   ?: \"${meta.id}\"\n    def comp   = save_numpy_matrix ? \"--output comp.npy\"  : ''\n    def csv    = save_csv          ? \"--csv comp.csv\" : ''\n    if ( !save_numpy_matrix && !save_csv ) error \"Supply either save_numpy_matrix, save_csv, or both or no output will be created\"\n    def ffile = file_list ? \"--from-file ${file_list}\" : ''\n    def sigs = signatures ? \"${signatures.sort{it.toString()}.join(' ')}\" : ''\n    if ( !file_list && !signatures ) error \"Supply either signatures, file_list, or both\"\n    \"\"\"\n    sourmash compare \\\\\n        $args \\\\\n        --processes ${task.cpus} \\\\\n        ${comp} \\\\\n        ${csv} \\\\\n        ${ffile} \\\\\n        ${sigs}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sourmash: \\$(echo \\$(sourmash --version 2>&1) | sed 's/^sourmash //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch comp.npy.labels.txt\n    touch comp.npy\n    touch comp.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sourmash: \\$(echo \\$(sourmash --version 2>&1) | sed 's/^sourmash //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a database of sourmash signatures (a group of FracMinHash sketches) to be used as references.\nTags: signatures, sourmash, genomics, metagenomics, mapping, kmer", "answer": "process SOURMASH_INDEX {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sourmash:4.8.4--hdfd78af_0':\n        'biocontainers/sourmash:4.8.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(signatures)\n    val(ksize)\n\n    output:\n    tuple val(meta), path(\"*.sbt.zip\"), emit: signature_index\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    sourmash index \\\\\n        --ksize ${ksize} \\\\\n        $args \\\\\n        '${prefix}.sbt.zip' \\\\\n        $signatures\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sourmash: \\$(echo \\$(sourmash --version 2>&1) | sed 's/^sourmash //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.sbt.zip\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sourmash: \\$(echo \\$(sourmash --version 2>&1) | sed 's/^sourmash //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a signature (a group of FracMinHash sketches) of a sequence using sourmash\nTags: hash sketch, sourmash, genomics, metagenomics, taxonomic classification, taxonomic profiling, kmer", "answer": "process SOURMASH_SKETCH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sourmash:4.8.4--hdfd78af_0':\n        'biocontainers/sourmash:4.8.4--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(sequence)\n\n    output:\n    tuple val(meta), path(\"*.sig\"), emit: signatures\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // required defaults for the tool to run, but can be overridden\n    def args = task.ext.args ?: \"dna --param-string 'scaled=1000,k=21,k=31,k=51,abund'\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    sourmash sketch \\\\\n        $args \\\\\n        --merge '${prefix}' \\\\\n        --output '${prefix}.sig' \\\\\n        $sequence\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sourmash: \\$(echo \\$(sourmash --version 2>&1) | sed 's/^sourmash //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Induce a variation graph in GFA format from alignments in PAF format\nTags: induce, paf, gfa, graph, variation graph", "answer": "process SEQWISH_INDUCE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqwish:0.7.9--h5b5514e_0' :\n        'biocontainers/seqwish:0.7.9--h5b5514e_0' }\"\n\n    input:\n    tuple val(meta), path(paf), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.gfa\"), emit: gfa\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input = paf.join(',') // this ensures that we can actually input a\n        // comma-separated list of PAF files as required by\n        // https://github.com/nf-core/pangenome. If one wants to use this,\n        // ensure that you put a \".collect()\" behind your channel.\n        // See https://github.com/nf-core/pangenome/blob/34149c6cdc19bce3a7b99f97c769d8986a8d429b/main.nf#L543\n        // for an example.\n    \"\"\"\n    seqwish \\\\\n        --threads $task.cpus \\\\\n        --paf-alns=$input \\\\\n        --seqs=$fasta \\\\\n        --gfa=${prefix}.gfa \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqwish: \\$(echo \\$(seqwish --version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Local sequence alignment tool for filtering, mapping and clustering.\nTags: filtering, mapping, clustering, rRNA, ribosomal RNA", "answer": "process SORTMERNA {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sortmerna:4.3.6--h9ee0642_0' :\n        'biocontainers/sortmerna:4.3.6--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(fastas)\n    tuple val(meta3), path(index)\n\n    output:\n    tuple val(meta), path(\"*non_rRNA.fastq.gz\"), emit: reads, optional: true\n    tuple val(meta), path(\"*.log\")             , emit: log, optional: true\n    tuple val(meta2), path(\"idx\")              , emit: index, optional: true\n    path  \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args          = task.ext.args  ?: ''\n    def prefix        = task.ext.prefix ?: \"${meta.id}\"\n\n    def index_only    = args.contains('--index 1')? true : false\n    def skip_index    = args.contains('--index 0')? true : false\n    def paired_end    = reads instanceof List\n    def paired_cmd    = ''\n    def reads_args    = ''\n    def out2_cmd      = ''\n    def mv_cmd        = ''\n    def reads_input   = ''\n    def refs_input    = ''\n\n    if (! index_only){\n        reads_args = '--aligned rRNA_reads --fastx --other non_rRNA_reads'\n        reads_input = paired_end ? reads.collect{\"--reads $it\"}.join(' ') : \"--reads $reads\"\n        def n_fastq = paired_end ? reads.size() : 1\n        if ( n_fastq == 1 ) {\n            mv_cmd = \"\"\"\n            mv non_rRNA_reads.f*q.gz ${prefix}.non_rRNA.fastq.gz\n            mv rRNA_reads.log ${prefix}.sortmerna.log\n            \"\"\"\n        } else {\n            mv_cmd = \"\"\"\n            mv non_rRNA_reads_fwd.f*q.gz ${prefix}_1.non_rRNA.fastq.gz\n            mv non_rRNA_reads_rev.f*q.gz ${prefix}_2.non_rRNA.fastq.gz\n            mv rRNA_reads.log ${prefix}.sortmerna.log\n            \"\"\"\n            paired_cmd = \"--paired_in\"\n            out2_cmd   = \"--out2\"\n        }\n    }\n    \"\"\"\n    sortmerna \\\\\n        ${'--ref '+fastas.join(' --ref ')} \\\\\n        $refs_input \\\\\n        $reads_input \\\\\n        --threads $task.cpus \\\\\n        --workdir . \\\\\n        $reads_args \\\\\n        $paired_cmd \\\\\n        $out2_cmd \\\\\n        $args\n\n    $mv_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sortmerna: \\$(echo \\$(sortmerna --version 2>&1) | sed 's/^.*SortMeRNA version //; s/ Build Date.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args          = task.ext.args  ?: ''\n    def prefix        = task.ext.prefix ?: \"${meta.id}\"\n\n    def index_only    = args.contains('--index 1')? true : false\n    def paired_end    = reads instanceof List\n    def paired_cmd    = ''\n    def out2_cmd      = ''\n    def mv_cmd        = ''\n    def reads_input   = ''\n\n    if (! index_only){\n        reads_input = paired_end ? reads.collect{\"--reads $it\"}.join(' ') : \"--reads $reads\"\n        def n_fastq = paired_end ? reads.size() : 1\n        if ( n_fastq == 1 ) {\n            mv_cmd = \"touch ${prefix}.non_rRNA.fastq.gz\"\n        } else {\n            mv_cmd = \"\"\"\n            touch ${prefix}_1.non_rRNA.fastq.gz\n            touch ${prefix}_2.non_rRNA.fastq.gz\n            \"\"\"\n        }\n    }\n    \"\"\"\n    $mv_cmd\n    mkdir -p idx\n    touch ${prefix}.sortmerna.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sortmerna: \\$(echo \\$(sortmerna --version 2>&1) | sed 's/^.*SortMeRNA version //; s/ Build Date.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: STITCH is an R program for reference panel free, read aware, low coverage sequencing genotype imputation. STITCH runs on a set of samples with sequencing reads in BAM format, as well as a list of positions to genotype, and outputs imputed genotypes in VCF format.\nTags: imputation, genomics, vcf, bgen, cram, bam, sam", "answer": "process STITCH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-stitch:1.6.10--r43h06b5641_0':\n        'biocontainers/r-stitch:1.6.10--r43h06b5641_0' }\"\n\n    input:\n    tuple val(meta) , path(posfile), path(input, stageAs: \"input\"), path(rdata, stageAs: \"RData_in\"), val(chromosome_name), val(K), val(nGen)\n    tuple val(meta2), path(collected_crams), path(collected_crais), path(cramlist)\n    tuple val(meta3), path(fasta), path(fasta_fai)\n    val seed\n\n    output:\n    tuple val(meta), path(\"input\", type: \"dir\") , emit: input\n    tuple val(meta), path(\"RData\", type: \"dir\") , emit: rdata\n    tuple val(meta), path(\"plots\", type: \"dir\") , emit: plots , optional: { generate_input_only }\n    tuple val(meta), path(\"*.vcf.gz\")           , emit: vcf   , optional: { generate_input_only || bgen_output }\n    tuple val(meta), path(\"*.bgen\")             , emit: bgen  , optional: { generate_input_only || !bgen_output }\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix               = task.ext.prefix ?: \"${meta.id}\"\n    def args                 = task.ext.args   ?: \"\"\n    def args2                = task.ext.args2  ?: \"\"\n    def generate_input_only  = args2.contains( \"--generateInputOnly TRUE\" )\n    def bgen_output          = args2.contains( \"--output_format bgen\" )\n    def reads_ext            = collected_crams             ? collected_crams.extension.unique()                                : []\n    def rsync_cmd            = rdata                       ? \"rsync -rL ${rdata}/ RData\"                                       : \"\"\n    def stitch_cmd           = seed                        ? \"Rscript <(cat \\$(which STITCH.R) | tail -n +2 | cat <(echo 'set.seed(${seed})') -)\" : \"STITCH.R\"\n    def cramlist_cmd         = cramlist && reads_ext == [\"cram\"] ? \"--cramlist ${cramlist}\"                                    : \"\"\n    def bamlist_cmd          = cramlist && reads_ext == [\"bam\" ] ? \"--bamlist ${cramlist}\"                                     : \"\"\n    def reference_cmd        = fasta                       ? \"--reference ${fasta}\"                                            : \"\"\n    def regenerate_input_cmd = input && rdata && !cramlist ? \"--regenerateInput FALSE --originalRegionName ${chromosome_name}\" : \"\"\n    def rsync_version_cmd    = rdata                       ? \"rsync: \\$(rsync --version | head -n1 | sed 's/^rsync  version //; s/ .*\\$//')\" : \"\"\n    \"\"\"\n    ${rsync_cmd} ${args}\n\n    ${stitch_cmd} \\\\\n        --chr ${chromosome_name} \\\\\n        --posfile ${posfile} \\\\\n        --outputdir . \\\\\n        --nCores ${task.cpus} \\\\\n        --K ${K} \\\\\n        --nGen ${nGen} \\\\\n        ${cramlist_cmd} \\\\\n        ${bamlist_cmd} \\\\\n        ${reference_cmd} \\\\\n        ${regenerate_input_cmd} \\\\\n        ${args2}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ${rsync_version_cmd}\n        r-base: \\$(Rscript -e \"cat(strsplit(R.version[['version.string']], ' ')[[1]][3])\")\n        r-stitch: \\$(Rscript -e \"cat(as.character(utils::packageVersion('STITCH')))\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix               = task.ext.prefix      ?: \"${meta.id}\"\n    def args                 = task.ext.args        ?: \"\"\n    def args2                = task.ext.args2       ?: \"\"\n    def generate_input_only  = args2.contains( \"--generateInputOnly TRUE\" )\n    def generate_plots_cmd   = !generate_input_only ? \"mkdir plots\"                                                                   : \"\"\n    def generate_vcf_cmd     = !generate_input_only ? \"touch ${prefix}.vcf.gz\"                                                        : \"\"\n    def rsync_version_cmd    = rdata                ? \"rsync: \\$(rsync --version | head -n1 | sed 's/^rsync  version //; s/ .*\\$//')\" : \"\"\n    \"\"\"\n    touch input\n    touch RData\n    ${generate_plots_cmd}\n    ${generate_vcf_cmd}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ${rsync_version_cmd}\n        r-base: \\$(Rscript -e \"cat(strsplit(R.version[['version.string']], ' ')[[1]][3])\")\n        r-stitch: \\$(Rscript -e \"cat(as.character(utils::packageVersion('STITCH')))\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Uses Liftoff to accurately map annotations in GFF or GTF between assemblies of the same,\nor closely-related species\n\nTags: genome, annotation, gff3, gtf, liftover", "answer": "process LIFTOFF {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/liftoff:1.6.3--pyhdfd78af_0':\n        'biocontainers/liftoff:1.6.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(target_fa)\n    path ref_fa, name: 'ref_assembly.fa'\n    path ref_annotation\n    path ref_db\n\n    output:\n    tuple val(meta), path(\"${prefix}.gff3\")     , emit: gff3\n    tuple val(meta), path(\"*.polished.gff3\")    , emit: polished_gff3, optional: true\n    tuple val(meta), path(\"*.unmapped.txt\")     , emit: unmapped_txt\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args     ?:  ''\n    def arg_g   = ref_annotation    ?   \"-g $ref_annotation\"    : ''\n    def arg_db  = ref_db            ?   \"-db $ref_db\"           : ''\n    prefix      = task.ext.prefix   ?:  \"${meta.id}\"\n    \"\"\"\n    liftoff \\\\\n        $arg_g \\\\\n        $arg_db \\\\\n        -p $task.cpus \\\\\n        -o \"${prefix}.gff3\" \\\\\n        -u \"${prefix}.unmapped.txt\" \\\\\n        $args \\\\\n        $target_fa \\\\\n        ref_assembly.fa\n\n    mv \\\\\n        \"${prefix}.gff3_polished\" \\\\\n        \"${prefix}.polished.gff3\" \\\\\n        || echo \"-polish is absent\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        liftoff: \\$(liftoff --version 2> /dev/null)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args            = task.ext.args     ?: ''\n    prefix              = task.ext.prefix   ?: \"${meta.id}\"\n    def touch_polished  = args.contains('-polish') ? \"touch ${prefix}.polished.gff3\" : ''\n    \"\"\"\n    touch \"${prefix}.gff3\"\n    touch \"${prefix}.unmapped.txt\"\n    $touch_polished\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        liftoff: \\$(liftoff --version 2> /dev/null)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Automatically improve draft assemblies and find variation among strains, including large event detection\nTags: polishing, assembly, variant calling", "answer": "process PILON {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pilon:1.24--hdfd78af_0':\n        'biocontainers/pilon:1.24--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(bam), path(bai)\n    val pilon_mode\n\n    output:\n    tuple val(meta), path(\"*.fasta\") , emit: improved_assembly\n    tuple val(meta), path(\"*.vcf\")   , emit: vcf               , optional : true\n    tuple val(meta), path(\"*.change\"), emit: change_record     , optional : true\n    tuple val(meta), path(\"*.bed\")   , emit: tracks_bed        , optional : true\n    tuple val(meta), path(\"*.wig\")   , emit: tracks_wig        , optional : true\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def valid_mode = [\"frags\", \"jumps\", \"unpaired\", \"bam\"]\n    if ( !valid_mode.contains(pilon_mode) )  { error \"Unrecognised mode to run Pilon. Options: ${valid_mode.join(', ')}\" }\n    \"\"\"\n    pilon \\\\\n        --genome $fasta \\\\\n        --output ${meta.id} \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        --$pilon_mode $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pilon: \\$(echo \\$(pilon --version) | sed 's/^.*version //; s/ .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def valid_mode = [\"frags\", \"jumps\", \"unpaired\", \"bam\"]\n    if ( !valid_mode.contains(pilon_mode) )  { error \"Unrecognised mode to run Pilon. Options: ${valid_mode.join(', ')}\" }\n    \"\"\"\n    touch ${prefix}.fasta\n    touch ${prefix}.vcf\n    touch ${prefix}.change\n    touch ${prefix}.bed\n    touch ${prefix}.wig\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pilon: \\$(echo \\$(pilon --version) | sed 's/^.*version //; s/ .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Build fastq screen config file from bowtie index files\nTags: build, index, genome, reference", "answer": "process FASTQSCREEN_BUILDFROMINDEX {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fastq-screen:0.15.3--pl5321hdfd78af_0':\n        'biocontainers/fastq-screen:0.15.3--pl5321hdfd78af_0'}\"\n\n    input:\n    val(genome_names)\n    path(indexes), stageAs: \"dir*\"\n\n    output:\n    path(\"FastQ_Screen_Genomes\"), emit: database\n    path \"versions.yml\"         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    dir = \"FastQ_Screen_Genomes\"\n    folder = indexes.collect { it.toString() }\n    database = [genome_names, folder].transpose()\n    copy_indexes = folder.collect { \"cp -r ${it} $dir/${it}\"}.join(\" && \")\n\n    // Folder name and index (within folder) name could be different - use bash to look for index name\n    config = database\n        .collect { \"########## ${it[0]} \\nDATABASE ${it[0]} $dir/${it[1]}/${it[1] + '_to_be_replaced'}\" }\n        .join(\"\\n\\n\")\n        .replace(\"\\n\", \"\\\\n\")\n\n    \"\"\"\n    mkdir $dir\n    $copy_indexes\n\n    echo \"$config\" > fastq_screen.conf\n    sed 's/\\\\\\\\n/\\\\n/g' fastq_screen.conf > $dir/fastq_screen.conf\n    echo \"Replace folder name real index name\"\n\n    for f in ${folder.join(' ')}\n    do\n        TO_REPLACE=\\${f}_to_be_replaced\n\n        REPLACE_WITH=(\\$f\"/*.rev.1.bt2\")\n        REPLACE_WITH=\\$(basename \\$REPLACE_WITH)\n        REPLACE_WITH=\\${REPLACE_WITH%%.rev.1.bt2}\n\n        sed \"s/\\$TO_REPLACE/\\$REPLACE_WITH/g\" $dir/fastq_screen.conf > new_conf.conf\n        mv new_conf.conf $dir/fastq_screen.conf\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastqscreen: \\$(echo \\$(fastq_screen --version 2>&1) | sed 's/^.*FastQ Screen v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    dir = \"FastQ_Screen_Genomes\"\n    \"\"\"\n    mkdir $dir\n    touch $dir/fastq_screen.conf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastqscreen: \\$(echo \\$(fastq_screen --version 2>&1) | sed 's/^.*FastQ Screen v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Align reads to multiple reference genomes using fastq-screen\nTags: align, map, fasta, fastq, genome, reference", "answer": "process FASTQSCREEN_FASTQSCREEN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fastq-screen:0.15.3--pl5321hdfd78af_0':\n        'biocontainers/fastq-screen:0.15.3--pl5321hdfd78af_0'}\"\n\n    input:\n    tuple val(meta), path(reads)  // .fastq files\n    path database\n\n    output:\n    tuple val(meta), path(\"*.txt\") , emit: txt\n    tuple val(meta), path(\"*.png\") , emit: png\n    tuple val(meta), path(\"*.html\"), emit: html\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args = task.ext.args ?: \"\"\n\n    \"\"\"\n    fastq_screen --threads ${task.cpus} \\\\\n        --aligner bowtie2 \\\\\n        --conf ${database}/fastq_screen.conf \\\\\n        $reads \\\\\n        $args \\\\\n        --outdir .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastqscreen: \\$(echo \\$(fastq_screen --version 2>&1) | sed 's/^.*FastQ Screen v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch test_1_screen.html\n    touch test_1_screen.png\n    touch test_1_screen.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastqscreen: \\$(echo \\$(fastq_screen --version 2>&1) | sed 's/^.*FastQ Screen v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Software for predicting library complexity and genome coverage in high-throughput sequencing\nTags: preseq, library, complexity", "answer": "process PRESEQ_CCURVE {\n    tag \"$meta.id\"\n    label 'process_single'\n    label 'error_ignore'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/preseq:3.1.2--h445547b_2':\n        'biocontainers/preseq:3.1.2--h445547b_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.c_curve.txt\"), emit: c_curve\n    tuple val(meta), path(\"*.log\")        , emit: log\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def paired_end = meta.single_end ? '' : '-pe'\n    \"\"\"\n    preseq \\\\\n        c_curve \\\\\n        $args \\\\\n        $paired_end \\\\\n        -output ${prefix}.c_curve.txt \\\\\n        $bam\n    cp .command.err ${prefix}.command.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        preseq: \\$(echo \\$(preseq 2>&1) | sed 's/^.*Version: //; s/Usage:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Software for predicting library complexity and genome coverage in high-throughput sequencing\nTags: preseq, library, complexity", "answer": "process PRESEQ_LCEXTRAP {\n    tag \"$meta.id\"\n    label 'process_single'\n    label 'error_retry'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/preseq:3.1.2--h445547b_2':\n        'biocontainers/preseq:3.1.2--h445547b_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.lc_extrap.txt\"), emit: lc_extrap\n    tuple val(meta), path(\"*.log\")          , emit: log\n    path  \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    args = task.attempt > 1 ? args.join(' -defects') : args  // Disable testing for defects\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def paired_end = meta.single_end ? '' : '-pe'\n    \"\"\"\n    preseq \\\\\n        lc_extrap \\\\\n        $args \\\\\n        $paired_end \\\\\n        -output ${prefix}.lc_extrap.txt \\\\\n        $bam\n    cp .command.err ${prefix}.command.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        preseq: \\$(echo \\$(preseq 2>&1) | sed 's/^.*Version: //; s/Usage:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.lc_extrap.txt\n    touch ${prefix}.command.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        preseq: \\$(echo \\$(preseq 2>&1) | sed 's/^.*Version: //; s/Usage:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: In-memory nucleotide sequence k-mer counting, filtering, graph traversal and more\nTags: khmer, k-mer, effective genome size", "answer": "process KHMER_UNIQUEKMERS {\n    tag \"$fasta\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/khmer:3.0.0a3--py37haa7609a_2' :\n        'biocontainers/khmer:3.0.0a3--py37haa7609a_2' }\"\n\n    input:\n    path fasta\n    val  kmer_size\n\n    output:\n    path \"report.txt\"  , emit: report\n    path \"kmers.txt\"   , emit: kmers\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    unique-kmers.py \\\\\n        -k $kmer_size \\\\\n        -R report.txt \\\\\n        $args \\\\\n        $fasta\n\n    grep ^number report.txt | sed 's/^.*:.[[:blank:]]//g' > kmers.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        khmer: \\$( unique-kmers.py --version 2>&1 | grep ^khmer | sed 's/^khmer //;s/ .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module that calls normalize-by-median.py from khmer. The module can take a mix of paired end (interleaved) and single end reads. If both types are provided, only a single file with single ends is possible.\nTags: digital normalization, khmer", "answer": "process KHMER_NORMALIZEBYMEDIAN {\n    tag \"${name}\"\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/khmer:3.0.0a3--py37haa7609a_2' :\n        'biocontainers/khmer:3.0.0a3--py37haa7609a_2' }\"\n\n    input:\n    path pe_reads\n    path se_reads\n    val  name\n\n    output:\n    path \"${name}.fastq.gz\", emit: reads\n    path \"versions.yml\"    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    pe_args = pe_reads ? \"--paired\" : \"\"\n    se_args = se_reads ? \"--unpaired-reads ${se_reads}\" : \"\"\n    files   = pe_reads ? pe_reads : se_reads\n    \"\"\"\n    normalize-by-median.py \\\\\n        -M ${task.memory.toGiga()}e9 \\\\\n        --gzip $args \\\\\n        -o ${name}.fastq.gz \\\\\n        $pe_args \\\\\n        $se_args \\\\\n        $files\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        khmer: \\$( normalize-by-median.py --version 2>&1 | grep ^khmer | sed 's/^khmer //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split BED files into several smaller BED files\nTags: bedtools, split, bed", "answer": "process BEDTOOLS_SPLIT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bed), val(count)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: beds\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    bedtools \\\\\n        split \\\\\n        $args \\\\\n        -n ${count} \\\\\n        -i ${bed} \\\\\n        -p ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    create_beds = (1..count).collect {\n        number = \"0\".multiply(4 - it.toString().size()) + \"${it}\"\n        \"    touch ${prefix}.${number}.bed\"\n    }.join(\"\\n\")\n\n    \"\"\"\n    ${create_beds}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Returns all intervals in a genome that are not covered by at least one interval in the input BED/GFF/VCF file.\nTags: bed, gff, vcf, complement, bedtools, intervals", "answer": "process BEDTOOLS_COMPLEMENT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path  sizes\n\n    output:\n    tuple val(meta), path('*.bed'), emit: bed\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bed\" == \"${prefix}.bed\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        complement \\\\\n        -i $bed \\\\\n        -g $sizes \\\\\n        $args \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: masks sequences in a FASTA file based on intervals defined in a feature file.\nTags: bed, fasta, maskfasta", "answer": "process BEDTOOLS_MASKFASTA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path  fasta\n\n    output:\n    tuple val(meta), path(\"*.fa\"), emit: fasta\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bedtools \\\\\n        maskfasta \\\\\n        $args \\\\\n        -fi $fasta \\\\\n        -bed $bed \\\\\n        -fo ${prefix}.fa\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Allows one to screen for overlaps between two sets of genomic features.\nTags: bed, intersect, overlap", "answer": "process BEDTOOLS_INTERSECT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(intervals1), path(intervals2)\n    tuple val(meta2), path(chrom_sizes)\n\n    output:\n    tuple val(meta), path(\"*.${extension}\"), emit: intersect\n    path  \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    //Extension of the output file. It is set by the user via \"ext.suffix\" in the config. Corresponds to the file format which depends on arguments (e. g., \".bed\", \".bam\", \".txt\", etc.).\n    extension = task.ext.suffix ?: \"${intervals1.extension}\"\n    def sizes = chrom_sizes ? \"-g ${chrom_sizes}\" : ''\n    if (\"$intervals1\" == \"${prefix}.${extension}\" ||\n        \"$intervals2\" == \"${prefix}.${extension}\")\n        error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        intersect \\\\\n        -a $intervals1 \\\\\n        -b $intervals2 \\\\\n        $args \\\\\n        $sizes \\\\\n        > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    extension = task.ext.suffix ?: \"bed\"\n    if (\"$intervals1\" == \"${prefix}.${extension}\" ||\n        \"$intervals2\" == \"${prefix}.${extension}\")\n        error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sorts a feature file by chromosome and other criteria.\nTags: bed, sort, bedtools, chromosome", "answer": "process BEDTOOLS_SORT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(intervals)\n    path genome_file\n\n    output:\n    tuple val(meta), path(\"*.${extension}\"), emit: sorted\n    path  \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args   ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def genome_cmd = genome_file     ?  \"-g $genome_file\" : \"\"\n    extension      = task.ext.suffix ?: intervals.extension\n    if (\"$intervals\" == \"${prefix}.${extension}\") {\n        error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    }\n    \"\"\"\n    bedtools \\\\\n        sort \\\\\n        -i $intervals \\\\\n        $genome_cmd \\\\\n        $args \\\\\n        > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    extension      = task.ext.suffix ?: intervals.extension\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Finds overlaps between two sets of regions (A and B), removes the overlaps from A and reports the remaining portion of A.\nTags: bed, gff, vcf, subtract", "answer": "process BEDTOOLS_SUBTRACT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(intervals1), path(intervals2)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$intervals1\" == \"${prefix}.bed\" ||\n        \"$intervals2\" == \"${prefix}.bed\")\n        error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        subtract \\\\\n        -a $intervals1 \\\\\n        -b $intervals2 \\\\\n        $args \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: combines overlapping or \u201cbook-ended\u201d features in an interval file into a single feature which spans all of the combined features.\nTags: bed, merge, bedtools, overlapped bed", "answer": "process BEDTOOLS_MERGE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n\n    output:\n    tuple val(meta), path('*.bed'), emit: bed\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bed\" == \"${prefix}.bed\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        merge \\\\\n        -i $bed \\\\\n        $args \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Adds a specified number of bases in each direction (unique values may be specified for either -l or -r)\nTags: bed, slopBed, bedtools", "answer": "process BEDTOOLS_SLOP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path  sizes\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bed\" == \"${prefix}.bed\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        slop \\\\\n        -i $bed \\\\\n        -g $sizes \\\\\n        $args \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Combines multiple BedGraph files into a single file\nTags: bed, unionBedGraphs, bedGraph, comparisons, combine", "answer": "process BEDTOOLS_UNIONBEDG {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bedgraph)\n    tuple val(meta2), path(chrom_sizes)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def sizes = chrom_sizes ? \"-g ${chrom_sizes}\" : ''\n    bedgraph.collect { if (\"$it\" == \"${prefix}.bed\") error \"$it has the same name as the output, use \\\"task.ext.prefix\\\" to disambiguate!\" }\n    \"\"\"\n    bedtools \\\\\n        unionbedg \\\\\n        -i $bedgraph \\\\\n        $sizes \\\\\n        $args \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Shifts each feature by specific number of bases\nTags: bed, shiftBed, region, fai, sizes, genome, bases", "answer": "process BEDTOOLS_SHIFT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    tuple val(meta2), path(chrom_sizes)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bed\" == \"${prefix}.bed\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        shift \\\\\n        -i $bed \\\\\n        -g $chrom_sizes \\\\\n        $args \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes histograms (default), per-base reports (-d) and BEDGRAPH (-bg) summaries of feature coverage (e.g., aligned sequences) for a given genome.\nTags: bed, bam, genomecov, bedtools, histogram", "answer": "process BEDTOOLS_GENOMECOV {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/bedtools_coreutils:ba273c06a3909a15':\n        'community.wave.seqera.io/library/bedtools_coreutils:a623c13f66d5262b' }\"\n\n    input:\n    tuple val(meta), path(intervals), val(scale)\n    path  sizes\n    val   extension\n    val   sort\n\n    output:\n    tuple val(meta), path(\"*.${extension}\"), emit: genomecov\n    path  \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args  ?: ''\n    def args_list = args.tokenize()\n    args += (scale > 0 && scale != 1) ? \" -scale $scale\" : \"\"\n    if (!args_list.contains('-bg') && (scale > 0 && scale != 1)) {\n        args += \" -bg\"\n    }\n    // Sorts output file by chromosome and position using additional options for performance and consistency\n    // See https://www.biostars.org/p/66927/ for further details\n    def buffer   = task.memory ? \"--buffer-size=${task.memory.toGiga().intdiv(2)}G\" : ''\n    def sort_cmd = sort ? \"| LC_ALL=C sort --parallel=$task.cpus $buffer -k1,1 -k2,2n\" : ''\n\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (intervals.name =~ /\\.bam/) {\n        \"\"\"\n        bedtools \\\\\n            genomecov \\\\\n            -ibam $intervals \\\\\n            $args \\\\\n            $sort_cmd \\\\\n            > ${prefix}.${extension}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        bedtools \\\\\n            genomecov \\\\\n            -i $intervals \\\\\n            -g $sizes \\\\\n            $args \\\\\n            $sort_cmd \\\\\n            > ${prefix}.${extension}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch  ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate Jaccard statistic b/w two feature files.\nTags: vcf, gff, bed, jaccard, intersection, union, statistics", "answer": "process BEDTOOLS_JACCARD {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(input_a), path(input_b)\n    tuple val(meta2), path(genome_file)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def genome = genome_file ? \"-g ${genome_file}\" : \"\"\n    \"\"\"\n    bedtools jaccard \\\\\n        -a ${input_a} \\\\\n        -b ${input_b} \\\\\n        ${genome} \\\\\n        ${args} \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Groups features in a BED file by given column(s) and computes summary statistics for each group to another column.\nTags: bed, groupby, bedtools", "answer": "process BEDTOOLS_GROUPBY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    val(summary_col)\n\n    output:\n    tuple val(meta), path('*.bed'), emit: bed\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}.grouped\"\n    def summary_col = task.ext.summary_col ? \"-c ${task.ext.summary_col}\" : \"-c 5\"\n    if (\"$bed\" == \"${prefix}.bed\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        groupby \\\\\n        -i $bed \\\\\n        ${summary_col} \\\\\n        $args \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: extract sequences in a FASTA file based on intervals defined in a feature file.\nTags: bed, fasta, getfasta", "answer": "process BEDTOOLS_GETFASTA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*.fa\"), emit: fasta\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$fasta\" == \"${prefix}.fa\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        getfasta \\\\\n        $args \\\\\n        -fi $fasta \\\\\n        -bed $bed \\\\\n        -fo ${prefix}.fa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$fasta\" == \"${prefix}.fa\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.fa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Allows one to screen for overlaps between two sets of genomic features.\nTags: bed, vcf, gff, map, bedtools", "answer": "process BEDTOOLS_MAP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(intervals1), path(intervals2)\n    tuple val(meta2), path(chrom_sizes)\n\n    output:\n    tuple val(meta), path(\"*.${extension}\"), emit: mapped\n    path  \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    extension = intervals1.getExtension()\n    def sizes = chrom_sizes ? \"-g ${chrom_sizes}\" : ''\n    if (\"$intervals1\" == \"${prefix}.${extension}\" ||\n        \"$intervals2\" == \"${prefix}.${extension}\")\n        error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        map \\\\\n        -a $intervals1 \\\\\n        -b $intervals2 \\\\\n        $args \\\\\n        $sizes \\\\\n        > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    extension = intervals1.getExtension()\n    if (\"$intervals1\" == \"${prefix}.${extension}\" ||\n        \"$intervals2\" == \"${prefix}.${extension}\")\n        error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Identifies common intervals among multiple (and subsets thereof) sorted BED/GFF/VCF files.\nTags: bedtools, multinterval, bed, vcf, gff", "answer": "process BEDTOOLS_MULTIINTER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(beds, stageAs: \"inputs/*\")\n    path chrom_sizes\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def sizes_cmd = chrom_sizes ? \"-g $chrom_sizes\" : ''\n\n    \"\"\"\n    bedtools \\\\\n        multiinter \\\\\n        $args \\\\\n        $sizes_cmd \\\\\n        -i $beds \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: For each feature in A, finds the closest feature (upstream or downstream) in B.\nTags: bedtools, closest, bed, vcf, gff", "answer": "process BEDTOOLS_CLOSEST {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(input_1), path(input_2)\n    path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.${extension}\") , emit: output\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    extension = input_1.extension == \"gz\" ?\n                        (input_1 =~ /^.*\\.(.*)\\.gz$/)[0][1] :\n                        input_1.extension\n\n    def reference = fasta_fai ? \"-g ${fasta_fai}\" : \"\"\n\n    if (input_1 == \"${prefix}.${extension}\" || input_2 == \"${prefix}.${extension}\") {\n        error(\"One of the input files is called the same as the output file. Please specify another prefix.\")\n    }\n\n    \"\"\"\n    bedtools closest \\\\\n        ${args} \\\\\n        -a ${input_1} \\\\\n        -b ${input_2} \\\\\n        ${reference} \\\\\n        > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: computes both the depth and breadth of coverage of features in file B on the features in file A\nTags: bedtools, coverage, bam, bed, gff, vcf, histogram", "answer": "process BEDTOOLS_COVERAGE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(input_A), path(input_B)\n    path genome_file\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = genome_file ? \"-g ${genome_file} -sorted\" : \"\"\n    \"\"\"\n    bedtools \\\\\n        coverage \\\\\n        $args \\\\\n        $reference \\\\\n        -a $input_A \\\\\n        -b $input_B \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(echo \\$(bedtools --version 2>&1) | sed 's/^.*bedtools v//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a bam file to a bed12 file.\nTags: bam, bed, bedtools, bamtobed, converter", "answer": "process BEDTOOLS_BAMTOBED {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bedtools \\\\\n        bamtobed \\\\\n        $args \\\\\n        -i $bam \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Makes adjacent or sliding windows across a genome or BED file.\nTags: bed, windows, fai, chunking", "answer": "process BEDTOOLS_MAKEWINDOWS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedtools:2.31.1--hf5e1c6e_0' :\n        'biocontainers/bedtools:2.31.1--hf5e1c6e_0' }\"\n\n    input:\n    tuple val(meta), path(regions)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def arg_input = regions.extension in [\"bed\", \"tab\"] ? \"-b ${regions}\" : \"-g ${regions}\"\n    if (\"${regions}\" == \"${prefix}.bed\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    bedtools \\\\\n        makewindows \\\\\n        ${arg_input} \\\\\n        ${args} \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"${regions}\" == \"${prefix}.bed\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: tool for detection and quantification of large mtDNA rearrangements.\nTags: eklipse, mitochondria, mtDNA, circos, deletion, SV", "answer": "\nprocess EKLIPSE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/eklipse:1.8--hdfd78af_1':\n        'biocontainers/eklipse:1.8--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path ref_gb\n\n    output:\n    tuple val(meta), path(\"*deletions.csv\") , emit: deletions\n    tuple val(meta), path(\"*genes.csv\")     , emit: genes\n    tuple val(meta), path(\"*.png\")          , emit: circos\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def ref_gb = ref_gb ? \"$ref_gb\" : \"/usr/local/bin/data/NC_012920.1.gb\"\n    def VERSION = \"1.8\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    echo \"$bam\\t${prefix}\" > infile.txt\n    eKLIPse.py \\\\\n        -in infile.txt \\\\\n        $args \\\\\n        -ref $ref_gb\n    mv eKLIPse_*/eKLIPse_deletions.csv eKLIPse_${prefix}_deletions.csv\n    mv eKLIPse_*/eKLIPse_genes.csv eKLIPse_${prefix}_genes.csv\n    mv eKLIPse_*/eKLIPse_${prefix}.png eKLIPse_${prefix}.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        eklipse: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"1.8\"\n    \"\"\"\n    touch eKLIPse_${prefix}_deletions.csv\n    touch eKLIPse_${prefix}_genes.csv\n    touch eKLIPse_${prefix}.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        eklipse: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Renders a guidetree in famsa\nTags: guide tree, msa, newick", "answer": "\nprocess FAMSA_GUIDETREE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/famsa:2.2.2--h9f5acd7_0':\n        'biocontainers/famsa:2.2.2--h9f5acd7_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.dnd\"), emit: tree\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    famsa -gt_export \\\\\n        $args \\\\\n        -t ${task.cpus} \\\\\n        ${fasta} \\\\\n        ${prefix}.dnd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        famsa: \\$( famsa -help 2>&1 | head -n 2 | tail -n 1 | sed 's/ version //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.dnd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        famsa: \\$( famsa -help 2>&1 | head -n 2 | tail -n 1 | sed 's/ version //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Aligns sequences using FAMSA\nTags: alignment, MSA, genomics", "answer": "\n\nprocess FAMSA_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/famsa:2.2.2--h9f5acd7_0':\n        'biocontainers/famsa:2.2.2--h9f5acd7_0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(tree)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"*.aln{.gz,}\"), emit: alignment\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def compress_args = compress ? '-gz' : ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def options_tree = tree ? \"-gt import $tree\" : \"\"\n    \"\"\"\n    famsa $options_tree \\\\\n        $compress_args \\\\\n        $args \\\\\n        -t ${task.cpus} \\\\\n        ${fasta} \\\\\n        ${prefix}.aln${compress ? '.gz':''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        famsa: \\$( famsa -help 2>&1 | head -n 2 | tail -n 1 | sed 's/ version //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.aln${compress ? '.gz' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        famsa: \\$( famsa -help 2>&1 | head -n 2 | tail -n 1 | sed 's/ version //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SALSA, A tool to scaffold long read assemblies with HiC\nTags: assembly, hi-c, scaffolding, long reads, salsa, salsa2", "answer": "process SALSA2 {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/salsa2:2.3--py27hee3b9ab_0':\n        'biocontainers/salsa2:2.3--py27hee3b9ab_0' }\"\n\n    input:\n    tuple val(meta), path(fasta), path(index)\n    path(bed)\n    path(gfa)\n    path(dup)\n    path(filter_bed)\n\n    output:\n    tuple val(meta), path(\"*_scaffolds_FINAL.fasta\")\t                , emit: fasta\n    tuple val(meta), path(\"*_scaffolds_FINAL.agp\")\t                    , emit: agp\n    tuple val(meta), path(\"*/*scaffolds_FINAL.original-coordinates.agp\"), emit: agp_original_coordinates, optional: true\n    path \"versions.yml\"                                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def gfa = gfa ? \"--gfa $gfa\" : \"\"\n    def dup = dup ? \"--dup $dup\" : \"\"\n    def filter = filter_bed ? \"--filter $filter_bed\" : \"\"\n    def VERSION = '2.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    run_pipeline.py \\\\\n        $args \\\\\n        --assembly $fasta \\\\\n        --bed $bed \\\\\n        --length $index \\\\\n        $gfa \\\\\n        $dup \\\\\n        $filter\n\n    mv */scaffolds_FINAL.fasta ${prefix}_scaffolds_FINAL.fasta\n    mv */scaffolds_FINAL.agp ${prefix}_scaffolds_FINAL.agp\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        SALSA2: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Quickly generate evenly sized (by amount of data) regions across a number of bam/cram files\nTags: bam, bed, cram, index, split", "answer": "process GOLEFT_INDEXSPLIT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/goleft:0.2.4--h9ee0642_1':\n        'biocontainers/goleft:0.2.4--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta) , path(bai)\n    tuple val(meta2), path(fai)\n    val split\n\n    output:\n    tuple val(meta), path(\"*.bed\") , emit: bed\n    path  \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    goleft \\\\\n        indexsplit \\\\\n        $args \\\\\n        -n ${split} \\\\\n        --fai ${fai} \\\\\n        ${bai} \\\\\n        > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        goleft: \\$(goleft --version 2>&1 | head -n 1 | sed 's/^.*goleft Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        goleft: \\$(goleft --version 2>&1 | head -n 1 | sed 's/^.*goleft Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Quickly estimate coverage from a whole-genome bam or cram index. A bam index has 16KB resolution so that's what this gives, but it provides what appears to be a high-quality coverage estimate in seconds per genome.\nTags: coverage, cnv, genomics, depth", "answer": "process GOLEFT_INDEXCOV {\n    tag \"${meta.id}\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/goleft:0.2.4--h9ee0642_1':\n        'biocontainers/goleft:0.2.4--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(bams), path(indexes)\n    tuple val(meta2), path(fai)\n\n    output:\n    tuple val(meta), path(\"${prefix}/*\")      , emit: output\n    tuple val(meta), path(\"${prefix}/*ped\")   , emit: ped , optional: true\n    tuple val(meta), path(\"${prefix}/*bed.gz\"), emit: bed , optional: true\n    tuple val(meta), path(\"${prefix}/*roc\")   , emit: roc , optional: true\n    tuple val(meta), path(\"${prefix}/*html\")  , emit: html, optional: true\n    tuple val(meta), path(\"${prefix}/*png\")   , emit: png , optional: true\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    // indexcov uses BAM files or CRAI\n    def input_files = bams.findAll{it.name.endsWith(\".bam\")} + indexes.findAll{it.name.endsWith(\".crai\")}\n    def extranormalize = input_files.any{it.name.endsWith(\".crai\")} ? \" --extranormalize \" : \"\"\n    \"\"\"\n    goleft indexcov \\\\\n        --fai ${fai}  \\\\\n        --directory ${prefix} \\\\\n        ${extranormalize} \\\\\n        $args \\\\\n        ${input_files.join(\" \")}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        goleft: \\$(goleft --version 2>&1 | head -n 1 | sed 's/^.*goleft Version: //')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir \"${prefix}\"\n    touch \"${prefix}/${prefix}-indexcov.bed.gz\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        goleft: \\$(goleft --version 2>&1 | head -n 1 | sed 's/^.*goleft Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Conversion of PacBio BAM files into gzipped fastq files, including splitting of barcoded data\nTags: bam2fastx, bam2fastq, pacbio", "answer": "def deprecation_message = \"\"\"\nWARNING: This module has been deprecated. Please use nf-core/pbtk/bam2fastq\n\nReason:\nThis module is no longer fit for purpose because bam2fastx has been deprecated by PacificBiosciences\n\n\"\"\"\nprocess BAM2FASTX_BAM2FASTQ {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bam2fastx:1.3.1--hf05d43a_1':\n        'biocontainers/bam2fastx:1.3.1--hf05d43a_1' }\"\n\n    input:\n    tuple val(meta), path(bam), path(index)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: fastq\n    path \"versions.yml\",                 emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    assert true: deprecation_message\n    \"\"\"\n    bam2fastq \\\\\n        $args \\\\\n        -o ${prefix} \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bam2fastx: \\$(echo \\$(bam2fastq --version 2>&1) | sed 's/^.*bam2fastq //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A multi-split mapping algorithm for circular RNA, splicing, trans-splicing and fusion detection\nTags: alignment, circrna, splicing, fusions", "answer": "process SEGEMEHL_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/segemehl:0.3.4--hc2ea5fd_5':\n        'biocontainers/segemehl:0.3.4--hc2ea5fd_5' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path(fasta)\n    path(index)\n\n    output:\n    tuple val(meta), path(\"${prefix}/${prefix}.${suffix}\"), emit: alignment\n    tuple val(meta), path(\"${prefix}/${prefix}.trns.txt\") , emit: trans_alignments, optional: true\n    tuple val(meta), path(\"${prefix}/${prefix}.mult.bed\") , emit: multi_bed, optional: true\n    tuple val(meta), path(\"${prefix}/${prefix}.sngl.bed\") , emit: single_bed, optional: true\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads = meta.single_end ? \"-q ${reads}\" : \"-q ${reads[0]} -p ${reads[1]}\"\n    suffix = ( args.contains(\"-b\") || args.contains(\"--bamabafixoida\") ) ? \"bam\" : \"sam\"\n    \"\"\"\n    mkdir -p $prefix\n\n    segemehl.x \\\\\n        -t $task.cpus \\\\\n        -d $fasta \\\\\n        -i $index \\\\\n        $reads \\\\\n        $args \\\\\n        -o ${prefix}/${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        segemehl: \\$(echo \\$(segemehl.x 2>&1 | grep \"ge5dee\" | awk -F Z '{print substr(\\$1, 2, 6)}' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = ( args.contains(\"-b\") || args.contains(\"--bamabafixoida\") ) ? \"bam\" : \"sam\"\n    \"\"\"\n    mkdir -p $prefix\n    touch ${prefix}/${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        segemehl: \\$(echo \\$(segemehl.x 2>&1 | grep \"ge5dee\" | awk -F Z '{print substr(\\$1, 2, 6)}' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate genome indices for segemehl align\nTags: index, circrna, splicing, fusions", "answer": "process SEGEMEHL_INDEX {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/segemehl:0.3.4--hc2ea5fd_5':\n        'biocontainers/segemehl:0.3.4--hc2ea5fd_5' }\"\n\n    input:\n    path fasta\n\n    output:\n    path \"*.idx\",        emit: index\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = \"${fasta.baseName}\"\n    \"\"\"\n    segemehl.x \\\\\n        -t $task.cpus \\\\\n        -d $fasta \\\\\n        -x ${prefix}.idx \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        segemehl: \\$(echo \\$(segemehl.x 2>&1 | grep \"ge5dee\" | awk -F Z '{print substr(\\$1, 2, 6)}' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = \"${fasta.baseName}\"\n    \"\"\"\n    touch ${prefix}.idx\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        segemehl: \\$(echo \\$(segemehl.x 2>&1 | grep \"ge5dee\" | awk -F Z '{print substr(\\$1, 2, 6)}' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SVbenchmark compares a set of \u201ctest\u201d structural variants in VCF format to a known truth set (also in VCF format) and outputs estimates of sensitivity and specificity.\nTags: structural variant, sv, benchmarking", "answer": "\nprocess SVANALYZER_SVBENCHMARK {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    //Conda is not supported at the moment: https://github.com/bioconda/bioconda-recipes/issues/37646\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svanalyzer:0.36--pl526_0':\n        'biocontainers/svanalyzer:0.36--pl526_0' }\"\n\n    input:\n    tuple val(meta), path(test), path(test_tbi), path(truth), path(truth_tbi), path(bed)\n    tuple val(meta2),path(fasta)\n    tuple val(meta3),path(fai)\n\n    output:\n    tuple val(meta), path(\"*.falsenegatives.vcf.gz\"), emit: fns\n    tuple val(meta), path(\"*.falsepositives.vcf.gz\"), emit: fps\n    tuple val(meta), path(\"*.distances\")            , emit: distances\n    tuple val(meta), path(\"*.log\")                  , emit: log\n    tuple val(meta), path(\"*.report\")               , emit: report\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"SVANALYZER_SVBENCHMARK module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args   = task.ext.args ?: ''\n    def args2  = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bed = bed ? \"-includebed $bed\" : \"\"\n    def VERSION = '0.36' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    svanalyzer \\\\\n        benchmark \\\\\n        $args \\\\\n        --ref $fasta \\\\\n        --test $test \\\\\n        --truth $truth \\\\\n        --prefix $prefix \\\\\n        $bed\n\n    bgzip ${args2} --threads ${task.cpus} -c ${prefix}.falsenegatives.vcf > ${prefix}.falsenegatives.vcf.gz\n    bgzip ${args2} --threads ${task.cpus} -c ${prefix}.falsepositives.vcf > ${prefix}.falsepositives.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svanalyzer: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"SVANALYZER_SVBENCHMARK module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.36' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.falsenegatives.vcf.gz\n    touch ${prefix}.falsepositives.vcf.gz\n    touch ${prefix}.distances\n    touch ${prefix}.log\n    touch ${prefix}.report\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svanalyzer: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MUMmer is a system for rapidly aligning entire genomes\nTags: align, genome, fasta", "answer": "process MUMMER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mummer:3.23--pl5262h1b792b2_12' :\n        'biocontainers/mummer:3.23--pl5262h1b792b2_12' }\"\n\n    input:\n    tuple val(meta), path(ref), path(query)\n\n    output:\n    tuple val(meta), path(\"*.coords\"), emit: coords\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed_ref = ref.getName().endsWith(\".gz\") ? true : false\n    def fasta_name_ref = ref.getName().replace(\".gz\", \"\")\n\n    def is_compressed_query = query.getName().endsWith(\".gz\") ? true : false\n    def fasta_name_query = query.getName().replace(\".gz\", \"\")\n    def VERSION = '3.23' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    if [ \"$is_compressed_ref\" == \"true\" ]; then\n        gzip -c -d $ref > $fasta_name_ref\n    fi\n    if [ \"$is_compressed_query\" == \"true\" ]; then\n        gzip -c -d $query > $fasta_name_query\n    fi\n    mummer \\\\\n        $args \\\\\n        $fasta_name_ref \\\\\n        $fasta_name_query \\\\\n        > ${prefix}.coords\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mummer: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '3.23' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefx}.coords\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mummer: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A large variant benchmarking tool analogous to hap.py for small variants.\nTags: structural-variants, benchmarking, vcf", "answer": "process WITTYER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"nf-core/wittyer:0.5.2.0\"\n\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"WITTYER module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    input:\n    tuple val(meta), path(query_vcf), path(truth_vcf), path(bed), path(wittyer_config)\n\n    output:\n    tuple val(meta),    path(\"*.json\")         , emit: report\n    tuple val(meta),    path(\"*.vcf.gz\")       , emit: bench_vcf\n    tuple val(meta),    path(\"*.vcf.gz.tbi\")   , emit: bench_vcf_tbi\n    path  \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // you can not define both bed and wittyer_config\n    def regions = bed ? \"-b $bed\" : \"\"\n    def config_file = wittyer_config ? \"-c $wittyer_config\" : \"\"\n    if (\"$truth_vcf\" == \"${prefix}.vcf\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n    if (\"$query_vcf\" == \"${prefix}.vcf\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n\n    // dotnet /opt/Wittyer/Wittyer.dll might need to be replaced with new docker image\n    \"\"\"\n    mkdir bench\n\n    dotnet /opt/Wittyer/Wittyer.dll \\\\\n        -t ${truth_vcf} \\\\\n        -i ${query_vcf} \\\\\n        -o bench \\\\\n        ${regions} \\\\\n        ${config_file} \\\\\n        ${args}\n\n    mv bench/Wittyer.Stats.json ${prefix}.json\n    mv bench/*.vcf.gz ${prefix}.vcf.gz\n    mv bench/*.vcf.gz.tbi ${prefix}.vcf.gz.tbi\n\n    rm -rf bench\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wittyer: \\$(dotnet /opt/Wittyer/Wittyer.dll --version  |& sed '1!d ; s/witty.er //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$truth_vcf\" == \"${prefix}.vcf\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n    if (\"$query_vcf\" == \"${prefix}.vcf\") {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n    \"\"\"\n    touch ${prefix}.json\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wittyer: \\$(dotnet /opt/Wittyer/Wittyer.dll --version  |& sed '1!d ; s/witty.er //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Depth computation per contig step of metabat2\nTags: sort, binning, depth, bam, coverage, de novo assembly", "answer": "process METABAT2_JGISUMMARIZEBAMCONTIGDEPTHS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metabat2:2.15--h986a166_1' :\n        'biocontainers/metabat2:2.15--h986a166_1' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path(\"*.txt.gz\"), emit: depth\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    export OMP_NUM_THREADS=$task.cpus\n\n    jgi_summarize_bam_contig_depths \\\\\n        --outputDepth ${prefix}.txt \\\\\n        $args \\\\\n        $bam\n\n    bgzip --threads $task.cpus ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metabat2: \\$( metabat2 --help 2>&1 | head -n 2 | tail -n 1| sed 's/.*\\\\:\\\\([0-9]*\\\\.[0-9]*\\\\).*/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Metagenome binning of contigs\nTags: sort, binning, depth, bam, coverage, de novo assembly", "answer": "process METABAT2_METABAT2 {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metabat2:2.15--h986a166_1' :\n        'biocontainers/metabat2:2.15--h986a166_1' }\"\n\n    input:\n    tuple val(meta), path(fasta), path(depth)\n\n    output:\n    tuple val(meta), path(\"*.tooShort.fa.gz\")                    , optional:true, emit: tooshort\n    tuple val(meta), path(\"*.lowDepth.fa.gz\")                    , optional:true, emit: lowdepth\n    tuple val(meta), path(\"*.unbinned.fa.gz\")                    , optional:true, emit: unbinned\n    tuple val(meta), path(\"*.tsv.gz\")                            , optional:true, emit: membership\n    tuple val(meta), path(\"*[!lowDepth|tooShort|unbinned].fa.gz\"), optional:true, emit: fasta\n    path \"versions.yml\"                                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args             = task.ext.args   ?: ''\n    def prefix           = task.ext.prefix ?: \"${meta.id}\"\n    def decompress_depth = depth           ? \"gzip -d -f $depth\"    : \"\"\n    def depth_file       = depth           ? \"-a ${depth.baseName}\" : \"\"\n    \"\"\"\n    $decompress_depth\n\n    metabat2 \\\\\n        $args \\\\\n        -i $fasta \\\\\n        $depth_file \\\\\n        -t $task.cpus \\\\\n        --saveCls \\\\\n        -o ${prefix}\n\n    gzip -cn ${prefix} > ${prefix}.tsv.gz\n    find . -name \"*.fa\" -type f | xargs -t -n 1 bgzip -@ ${task.cpus}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metabat2: \\$( metabat2 --help 2>&1 | head -n 2 | tail -n 1| sed 's/.*\\\\:\\\\([0-9]*\\\\.[0-9]*\\\\).*/\\\\1/' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Install databases necessary for Pharokka's functional analysis\nTags: pharokka, prokka, bakta, phage, function, install, database", "answer": "process PHAROKKA_INSTALLDATABASES {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pharokka:1.7.3--pyhdfd78af_0':\n        'biocontainers/pharokka:1.7.3--pyhdfd78af_0' }\"\n\n    input:\n\n    output:\n    path(\"${prefix}/\")      , emit: pharokka_db\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: 'pharokka_db'\n    \"\"\"\n    install_databases.py \\\\\n        --outdir $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pharokka: \\$(pharokka.py --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: 'pharokka_db'\n    \"\"\"\n    mkdir -p $prefix\n    touch $prefix/1Aug2023_data.tsv\n    touch $prefix/1Aug2023_genomes.fa.msh\n    touch $prefix/CARD\n    touch $prefix/CARD.dbtype\n    touch $prefix/CARD.index\n    touch $prefix/CARD.lookup\n    touch $prefix/CARD.source\n    touch $prefix/CARD_h\n    touch $prefix/CARD_h.dbtype\n    touch $prefix/CARD_h.index\n    touch $prefix/VFDB_setB_pro.fas.gz\n    touch $prefix/VFDBclusterRes_cluster.tsv\n    touch $prefix/VFDBclusterRes_rep_seq.fasta\n    touch $prefix/all_phrogs.h3m\n    touch $prefix/aro_index.tsv\n    touch $prefix/phrog_annot_v4.tsv\n    touch $prefix/phrogs_db\n    touch $prefix/phrogs_db.dbtype\n    touch $prefix/phrogs_db.index\n    touch $prefix/phrogs_profile_db\n    touch $prefix/phrogs_profile_db.dbtype\n    touch $prefix/phrogs_profile_db.index\n    touch $prefix/phrogs_profile_db_consensus\n    touch $prefix/phrogs_profile_db_consensus.dbtype\n    touch $prefix/phrogs_profile_db_consensus.index:\n    touch $prefix/phrogs_profile_db_h\n    touch $prefix/phrogs_profile_db_h.index\n    touch $prefix/phrogs_profile_db_seq\n    touch $prefix/phrogs_profile_db_seq.dbtype\n    touch $prefix/phrogs_profile_db_seq.index\n    touch $prefix/phrogs_profile_db_seq_h\n    touch $prefix/phrogs_profile_db_seq_h.index\n    touch $prefix/vfdb\n    touch $prefix/vfdb.dbtype\n    touch $prefix/vfdb.index\n    touch $prefix/vfdb.lookup\n    touch $prefix/vfdb.source\n    touch $prefix/vfdb_h\n    touch $prefix/vfdb_h.dbtype\n    touch $prefix/vfdb_h.index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pharokka: \\$(pharokka.py --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Functional annotation of phages\nTags: pharokka, phage, function, prokka, bakta", "answer": "process PHAROKKA_PHAROKKA {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pharokka:1.7.3--pyhdfd78af_0':\n        'biocontainers/pharokka:1.7.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(phage_fasta)\n    path pharokka_db\n\n    output:\n    tuple val(meta), path(\"${prefix}_pharokka/${prefix}_cds_final_merged_output.tsv\")       , emit: cds_final_merged_output\n    tuple val(meta), path(\"${prefix}_pharokka/${prefix}_cds_functions.tsv\")                 , emit: cds_functions\n    tuple val(meta), path(\"${prefix}_pharokka/${prefix}_length_gc_cds_density.tsv\")         , emit: length_gc_cds_density\n    tuple val(meta), path(\"${prefix}_pharokka/${prefix}_top_hits_card.tsv\")                 , emit: card                    , optional: true\n    tuple val(meta), path(\"${prefix}_pharokka/${prefix}_top_hits_vfdb.tsv\")                 , emit: vfdb                    , optional: true\n    tuple val(meta), path(\"${prefix}_pharokka/${prefix}_top_hits_mash_inphared.tsv\")        , emit: mash                    , optional: true\n    tuple val(meta), path(\"${prefix}_pharokka/${prefix}_genome_terminase_reoriented.fasta\") , emit: reoriented              , optional: true\n    path \"versions.yml\"                                                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    pharokka.py \\\\\n        --infile ${phage_fasta} \\\\\n        --outdir ${prefix}_pharokka \\\\\n        --database ${pharokka_db} \\\\\n        --threads ${task.cpus} \\\\\n        --prefix ${prefix} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pharokka: \\$(pharokka.py --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mkdir -p ${prefix}_pharokka\n    touch ${prefix}_pharokka/${prefix}.gbk\n    touch ${prefix}_pharokka/${prefix}.log\n    touch ${prefix}_pharokka/${prefix}_cds_functions.tsv\n    touch ${prefix}_pharokka/${prefix}_top_hits_card.tsv\n    touch ${prefix}_pharokka/top_hits_vfdb.tsv\n    touch ${prefix}_pharokka/${prefix}_top_hits_inphared\n    touch ${prefix}_pharokka/${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pharokka: \\$(pharokka.py --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Great....yet another TMA dearray program. What does this one do? Coreograph uses UNet, a deep learning model, to identify complete/incomplete tissue cores on a tissue microarray. It has been trained on 9 TMA slides of different sizes and tissue types.\nTags: UNet, TMA dearray, Segmentation, Cores", "answer": "process COREOGRAPH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"docker.io/labsyspharm/unetcoreograph:2.2.9\"\n\n    input:\n    tuple val(meta), path(image)\n\n    output:\n    tuple val(meta), path(\"*[0-9]*.tif\"), emit: cores\n    tuple val(meta), path(\"./masks/\"), emit: masks\n    tuple val(meta), path(\"TMA_MAP.tif\"), emit: tma_map\n    tuple val(meta), path(\"centroidsY-X.txt\"), emit: centroids\n\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.2.9'\n\n    \"\"\"\n    python /app/UNetCoreograph.py \\\\\n        --imagePath ${image}\\\\\n        --outputPath .\\\\\n        $args\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        coreograph: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch TMA_MAP.tif\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        coreograph: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs fastq alignment to a fasta reference using NextGenMap\nTags: NextGenMap, ngm, alignment, map, fastq, bam, sam", "answer": "process NEXTGENMAP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nextgenmap%3A0.5.5--hc9558a2_4' :\n        'biocontainers/nextgenmap:0.5.5--hc9558a2_4' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def threads = task.cpus\n\n    if(meta.single_end){\n        \"\"\"\n        ngm \\\\\n            -r $fasta \\\\\n            -q $reads \\\\\n            -t $threads \\\\\n            --bam \\\\\n            -o ${prefix}.bam \\\\\n            $args\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            NextGenMap: \\$(ngm 2>&1 | head -1 | grep -o -E '[[:digit:]]+.[[:digit:]]+.[[:digit:]]+')\n        END_VERSIONS\n        \"\"\"\n    } else{\n        \"\"\"\n        ngm \\\\\n            -r $fasta \\\\\n            -1 ${reads[0]} \\\\\n            -2 ${reads[1]} \\\\\n            -t $threads \\\\\n            --bam \\\\\n            -o ${prefix}.bam \\\\\n            $args\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            NextGenMap: \\$(ngm 2>&1 | head -1 | grep -o -E '[[:digit:]]+.[[:digit:]]+.[[:digit:]]+')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Quickly create a tree using Mash distances\nTags: tree, mash, fasta, fastq", "answer": "process MASHTREE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mashtree:1.2.0--pl526h516909a_0' :\n        'biocontainers/mashtree:1.2.0--pl526h516909a_0' }\"\n\n    input:\n    tuple val(meta), path(seqs)\n\n    output:\n    tuple val(meta), path(\"*.dnd\"), emit: tree\n    tuple val(meta), path(\"*.tsv\"), emit: matrix\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mashtree \\\\\n        $args \\\\\n        --numcpus $task.cpus \\\\\n        --outmatrix ${prefix}.tsv \\\\\n        --outtree ${prefix}.dnd \\\\\n        $seqs\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mashtree: \\$( echo \\$( mashtree --version 2>&1 ) | sed 's/^.*Mashtree //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A Deep Learning Model for Transmembrane Topology Prediction and Classification\nTags: transmembrane, protein, classification", "answer": "process DEEPTMHMM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pybiolib:1.1.1393--pyhdfd78af_0':\n        'biocontainers/pybiolib:1.1.1393--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"biolib_results/TMRs.gff3\")                 , emit: gff3\n    tuple val(meta), path(\"biolib_results/predicted_topologies.3line\"), emit: line3\n    tuple val(meta), path(\"biolib_results/deeptmhmm_results.md\")      , emit: md\n    tuple val(meta), path(\"biolib_results/*_probs.csv\")               , optional: true, emit: csv\n    tuple val(meta), path(\"biolib_results/plot.png\")                  , optional: true, emit: png\n    path \"versions.yml\"                                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def is_compressed = fasta.name.endsWith(\".gz\")\n    def fasta_name = fasta.name.replace(\".gz\", \"\")\n\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    biolib \\\\\n        run \\\\\n        DTU/DeepTMHMM \\\\\n        --fasta ${fasta_name} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biolib: \\$(echo \\$(biolib --version) | sed -n 's/.*version \\\\([0-9.]*\\\\).*/\\\\1/p' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    mkdir biolib_results\n    touch biolib_results/TMRs.gff3\n    touch biolib_results/predicted_topologies.3line\n    touch biolib_results/deeptmhmm_results.md\n    touch biolib_results/MX_probs.csv\n    touch biolib_results/plot.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        biolib: \\$(echo \\$(biolib --version) | sed -n 's/.*version \\\\([0-9.]*\\\\).*/\\\\1/p' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply different kind of sorting algorithms to a graph. The most prominent one is the PG-SGD sorting algorithm.\nTags: variation graph, pangenome graph, gfa, graph layout", "answer": "process ODGI_SORT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graph)\n\n    output:\n    tuple val(meta), path(\"*.og\"), emit: sorted_graph\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    odgi \\\\\n        sort \\\\\n        --threads $task.cpus \\\\\n        --idx ${graph} \\\\\n        --out ${prefix}.og \\\\\n        $args\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Establish 2D layouts of the graph using path-guided stochastic gradient descent. The graph must be sorted and id-compacted.\nTags: variation graph, pangenome graph, gfa, graph layout", "answer": "process ODGI_LAYOUT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graph)\n\n    output:\n    tuple val(meta), path(\"*.lay\"), optional: true, emit: lay\n    tuple val(meta), path(\"*.tsv\"), optional: true, emit: tsv\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"--out ${meta.id}.lay\"\n    \"\"\"\n    odgi \\\\\n        layout \\\\\n        --threads $task.cpus \\\\\n        --idx ${graph} \\\\\n        $args\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge unitigs into a single node preserving the node order.\nTags: variation graph, pangenome graph, gfa, graph unchopping", "answer": "process ODGI_UNCHOP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graph)\n\n    output:\n    tuple val(meta), path(\"*.og\"), emit: unchopped_graph\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    odgi \\\\\n        unchop \\\\\n        --threads $task.cpus \\\\\n        --idx ${graph} \\\\\n        --out ${prefix}.og \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Visualize a variation graph in 1D.\nTags: variation graph, pangenome graph, gfa, graph viz", "answer": "process ODGI_VIZ {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graph)\n\n    output:\n    tuple val(meta), path(\"*.png\"), emit: png\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    odgi \\\\\n        viz \\\\\n        --threads $task.cpus \\\\\n        --idx ${graph} \\\\\n        --out ${prefix}.png \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Project a graph into other formats.\nTags: variation graph, pangenome graph, gfa, graph formats", "answer": "process ODGI_VIEW {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graph)\n\n    output:\n    tuple val(meta), path(\"*.gfa\"), emit: gfa\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    odgi \\\\\n        view \\\\\n        --threads $task.cpus \\\\\n        --idx ${graph} \\\\\n        --to-gfa \\\\\n        $args > ${prefix}.gfa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Construct a dynamic succinct variation graph in ODGI format from a GFAv1.\nTags: variation graph, pangenome graph, gfa, graph construction", "answer": "process ODGI_BUILD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graph)\n\n    output:\n    tuple val(meta), path(\"*.og\"), emit: og\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    odgi \\\\\n        build \\\\\n        --threads $task.cpus \\\\\n        --gfa ${graph} \\\\\n        --out ${prefix}.og \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Squeezes multiple graphs in ODGI format into the same file in ODGI format.\nTags: squeeze, odgi, gfa, combine graphs", "answer": "process ODGI_SQUEEZE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graphs)\n\n    output:\n    tuple val(meta), path(\"*.og\"), emit: graph\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ls *.og > files\n    odgi \\\\\n        squeeze \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --input-graphs files \\\\\n        -o ${prefix}.og\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Draw previously-determined 2D layouts of the graph with diverse annotations.\nTags: variation graph, pangenome graph, gfa, graph drawing", "answer": "process ODGI_DRAW {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graph), path(lay)\n\n    output:\n    tuple val(meta), path(\"*.png\"), emit: png\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    odgi \\\\\n        draw \\\\\n        --threads $task.cpus \\\\\n        --idx ${graph} \\\\\n        --coords-in ${lay} \\\\\n        --png ${prefix}.png \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Metrics describing a variation graph and its path relationship.\nTags: variation graph, pangenome graph, gfa, graph stats", "answer": "process ODGI_STATS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/odgi:0.8.4--py310h6cc9453_0':\n        'biocontainers/odgi:0.8.4--py310h6cc9453_0' }\"\n\n    input:\n    tuple val(meta), path(graph)\n\n    output:\n    tuple val(meta), path(\"*.og.stats.tsv\") , optional: true, emit: tsv\n    tuple val(meta), path(\"*.og.stats.yaml\"), optional: true, emit: yaml\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = \"og.stats.tsv\"\n    if (args.contains(\"--yaml\") || args.contains(\"--multiqc\")) {\n        suffix = \"og.stats.yaml\"\n    }\n    \"\"\"\n    odgi \\\\\n        stats \\\\\n        --threads $task.cpus \\\\\n        --idx ${graph} \\\\\n        $args > ${prefix}.$suffix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        odgi: \\$(echo \\$(odgi version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: simpleaf is a program to simplify and customize the running and configuration of single-cell processing with alevin-fry.\nTags: quantification, gene expression, SimpleAF", "answer": "process SIMPLEAF_QUANT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/simpleaf:0.15.1--h4ac6f70_0':\n        'biocontainers/simpleaf:0.15.1--h4ac6f70_0' }\"\n\n    input:\n    //\n    // Input reads are expected to come as: [ meta, [ pair1_read1, pair1_read2, pair2_read1, pair2_read2 ] ]\n    // Input array for a sample is created in the same order reads appear in samplesheet as pairs from replicates are appended to array.\n    //\n    tuple val(meta), val(chemistry), path(reads)\n    tuple val(meta2), path(index)\n    tuple val(meta3), path(txp2gene)\n    val resolution\n    tuple val(meta4), path(whitelist)\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: results\n    path  \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args ?: ''\n    def args_list = args.tokenize()\n    prefix    = task.ext.prefix ?: \"${meta.id}\"\n\n    unfiltered_command = \"\"\n    if (whitelist) {\n        unfiltered_command = \"-u <(gzip -dcf ${whitelist})\"\n    }\n\n    // separate forward from reverse pairs\n    def (forward, reverse) = reads.collate(2).transpose()\n    \"\"\"\n    # export required var\n    export ALEVIN_FRY_HOME=.\n\n    # prep simpleaf\n    simpleaf set-paths\n\n    # run simpleaf quant\n    simpleaf quant \\\\\n        -i ${index} \\\\\n        -1 ${forward.join( \",\" )} \\\\\n        -2 ${reverse.join( \",\" )} \\\\\n        -c $chemistry \\\\\n        -r $resolution \\\\\n        -o ${prefix} \\\\\n        -t $task.cpus \\\\\n        -m $txp2gene \\\\\n        $unfiltered_command \\\\\n        $args\n\n    [[ ! -f ${prefix}/af_quant/all_freq.bin ]] && cp ${prefix}/af_quant/permit_freq.bin ${prefix}/af_quant/all_freq.bin\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        simpleaf: \\$(simpleaf -V | tr -d '\\\\n' | cut -d ' ' -f 2)\n        salmon: \\$(salmon --version | sed -e \"s/salmon //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix    = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}/af_map\n    mkdir -p ${prefix}/af_quant/alevin\n\n    touch ${prefix}/af_map/map.rad\n    touch ${prefix}/af_map/unmapped_bc_count.bin\n    touch ${prefix}/af_quant/alevin/quants_mat_rows.txt\n    touch ${prefix}/af_quant/all_freq.bin\n    touch ${prefix}/af_quant/map.collated.rad\n    touch ${prefix}/af_quant/permit_freq.bin\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        simpleaf: \\$(simpleaf -V | tr -d '\\\\n' | cut -d ' ' -f 2)\n        salmon: \\$(salmon --version | sed -e \"s/salmon //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Indexing of transcriptome for gene expression quantification using SimpleAF\nTags: indexing, transcriptome, gene expression, SimpleAF", "answer": "process SIMPLEAF_INDEX {\n    tag \"$genome_fasta $transcript_fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/simpleaf:0.15.1--h4ac6f70_0':\n        'biocontainers/simpleaf:0.15.1--h4ac6f70_0' }\"\n\n    input:\n    tuple val(meta), path(genome_fasta)\n    tuple val(meta2), path(genome_gtf)\n    tuple val(meta3), path(transcript_fasta)\n\n    output:\n    tuple val(meta), path(\"${prefix}/index\")              , emit: index\n    tuple val(meta), path(\"${prefix}/ref/t2g_3col.tsv\")   , emit: transcript_tsv, optional: true\n    tuple val(meta), path(\"${prefix}\")                    , emit: salmon\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def seq_inputs = (transcript_fasta) ? \"--refseq $transcript_fasta\" : \"--gtf $genome_gtf --fasta $genome_fasta\"\n\n    // Output meta needs to correspond to the input used\n    meta = (transcript_fasta) ? meta3 : meta\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    # export required var\n    export ALEVIN_FRY_HOME=.\n\n    # prep simpleaf\n    simpleaf set-paths\n\n    # run simpleaf index\n    simpleaf \\\\\n        index \\\\\n        --threads $task.cpus \\\\\n        $seq_inputs \\\\\n        $args \\\\\n        -o ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        simpleaf: \\$(simpleaf -V | tr -d '\\\\n' | cut -d ' ' -f 2)\n        salmon: \\$(salmon --version | sed -e \"s/salmon //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: (meta.id ? \"${meta.id}\" : \"${meta3.id}\")\n    \"\"\"\n    mkdir -p ${prefix}/index\n    mkdir -p ${prefix}/ref\n    touch ${prefix}/index/ctg_offsets.bin\n    touch ${prefix}/index/duplicate_clusters.tsv\n    touch ${prefix}/index/mphf.bin\n    touch ${prefix}/ref/t2g_3col.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        simpleaf: \\$(simpleaf -V | tr -d '\\\\n' | cut -d ' ' -f 2)\n        salmon: \\$(salmon --version | sed -e \"s/salmon //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Accurate detection of short and long active ORFs using Ribo-seq data\nTags: riboseq, orf, genomics", "answer": "process RIBOTRICER_PREPAREORFS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ribotricer:1.3.3--pyhdfd78af_0':\n        'biocontainers/ribotricer:1.3.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta), path(gtf)\n\n    output:\n    tuple val(meta), path(\"*_candidate_orfs.tsv\"), emit: candidate_orfs\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    ribotricer prepare-orfs \\\\\n        --gtf $gtf \\\\\n        --fasta $fasta \\\\\n        --prefix $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ribotricer: \\$(ribotricer --version | grep ribotricer |& sed '1!d ; s/ribotricer, version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_candidate_orfs.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ribotricer: \\$(ribotricer --version | grep ribotricer |& sed '1!d ; s/ribotricer, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Accurate detection of short and long active ORFs using Ribo-seq data\nTags: riboseq, orf, genomics", "answer": "process RIBOTRICER_DETECTORFS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ribotricer:1.3.3--pyhdfd78af_0':\n        'biocontainers/ribotricer:1.3.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(candidate_orfs)\n\n    output:\n    tuple val(meta), path('*_protocol.txt')             , emit: protocol, optional: true\n    tuple val(meta), path('*_bam_summary.txt')          , emit: bam_summary\n    tuple val(meta), path('*_read_length_dist.pdf')     , emit: read_length_dist\n    tuple val(meta), path('*_metagene_profiles_5p.tsv') , emit: metagene_profile_5p\n    tuple val(meta), path('*_metagene_profiles_3p.tsv') , emit: metagene_profile_3p\n    tuple val(meta), path('*_metagene_plots.pdf')       , emit: metagene_plots\n    tuple val(meta), path('*_psite_offsets.txt')        , emit: psite_offsets, optional: true\n    tuple val(meta), path('*_pos.wig')                  , emit: pos_wig\n    tuple val(meta), path('*_neg.wig')                  , emit: neg_wig\n    tuple val(meta), path('*_translating_ORFs.tsv')     , emit: orfs\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def strandedness_cmd = ''\n\n    switch(meta.strandedness) {\n        case \"forward\":\n            strandedness_cmd = \"--stranded yes\"\n            break\n        case \"reverse\":\n            strandedness_cmd = \"--stranded reverse\"\n            break\n        //\n        // Specifying unstranded seems broken - see\n        // https://github.com/smithlabcode/ribotricer/issues/153. Leaving it\n        // undefined works, though ribotricer may incorrectly infer\n        // strandednesss?\n        //\n        //case \"unstranded\":\n        //    strandedness_cmd = \"--stranded no\"\n        //    break\n    }\n    \"\"\"\n    ribotricer detect-orfs \\\\\n        --bam $bam \\\\\n        --ribotricer_index $candidate_orfs \\\\\n        --prefix $prefix \\\\\n        $strandedness_cmd \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ribotricer: \\$(ribotricer --version 2>&1 | grep ribotricer | sed '1!d ; s/ribotricer, version //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_protocol.txt\n    touch ${prefix}_bam_summary.txt\n    touch ${prefix}_read_length_dist.pdf\n    touch ${prefix}_metagene_profiles_5p.tsv\n    touch ${prefix}_metagene_profiles_3p.tsv\n    touch ${prefix}_metagene_plots.pdf\n    touch ${prefix}_psite_offsets.txt\n    touch ${prefix}_pos.wig\n    touch ${prefix}_neg.wig\n    touch ${prefix}_translating_ORFs.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ribotricer: \\$(ribotricer --version 2>&1 | grep ribotricer | sed '1!d ; s/ribotricer, version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: for annotating regions, frequencies, cadd scores\nTags: annotate, genmod, ranking", "answer": "process GENMOD_ANNOTATE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genmod:3.8.2--pyhdfd78af_0':\n        'biocontainers/genmod:3.8.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input_vcf)\n\n    output:\n    tuple val(meta), path(\"*_annotate.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    genmod \\\\\n        annotate \\\\\n        $args \\\\\n        --outfile ${prefix}_annotate.vcf \\\\\n        $input_vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmod: \\$(echo \\$(genmod --version 2>&1) | sed 's/^.*genmod version: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_annotate.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmod: \\$(echo \\$(genmod --version 2>&1) | sed 's/^.*genmod version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: annotate models of inheritance\nTags: models, genmod, ranking", "answer": "process GENMOD_MODELS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genmod:3.8.2--pyhdfd78af_0':\n        'biocontainers/genmod:3.8.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input_vcf)\n    path (fam)\n    path (reduced_penetrance)\n\n    output:\n    tuple val(meta), path(\"*_models.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def prefix      = task.ext.prefix ?: \"${meta.id}\"\n    def family_file =  fam ? \"--family_file ${fam}\" : \"\"\n    def pen_file    = reduced_penetrance ? \"--reduced_penetrance ${reduced_penetrance}\" : \"\"\n    \"\"\"\n    genmod \\\\\n        models \\\\\n        $args \\\\\n        $pen_file \\\\\n        $family_file \\\\\n        --processes ${task.cpus} \\\\\n        --outfile ${prefix}_models.vcf \\\\\n        $input_vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmod: \\$(echo \\$(genmod --version 2>&1) | sed 's/^.*genmod version: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_models.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmod: \\$(echo \\$(genmod --version 2>&1) | sed 's/^.*genmod version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Score the variants of a vcf based on their annotation\nTags: score, ranking, genmod", "answer": "process GENMOD_SCORE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genmod:3.8.2--pyhdfd78af_0':\n        'biocontainers/genmod:3.8.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input_vcf)\n    path (fam)\n    path (score_config)\n\n    output:\n    tuple val(meta), path(\"*_score.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def prefix      = task.ext.prefix ?: \"${meta.id}\"\n    def family_file = fam ? \"--family_file ${fam}\" : \"\"\n    def config_file = score_config ? \"--score_config ${score_config}\" : \"\"\n    \"\"\"\n    genmod \\\\\n        score \\\\\n        $args \\\\\n        $family_file \\\\\n        $config_file \\\\\n        --outfile ${prefix}_score.vcf \\\\\n        $input_vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmod: \\$(echo \\$(genmod --version 2>&1) | sed 's/^.*genmod version: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_score.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmod: \\$(echo \\$(genmod --version 2>&1) | sed 's/^.*genmod version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Score compounds\nTags: compound, genmod, ranking", "answer": "process GENMOD_COMPOUND {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genmod:3.8.2--pyhdfd78af_0':\n        'biocontainers/genmod:3.8.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input_vcf)\n\n    output:\n    tuple val(meta), path(\"*_compound.vcf\"), emit: vcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    genmod \\\\\n        compound \\\\\n        $args \\\\\n        --processes ${task.cpus} \\\\\n        --outfile ${prefix}_compound.vcf \\\\\n        $input_vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmod: \\$(echo \\$(genmod --version 2>&1) | sed 's/^.*genmod version: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_compound.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmod: \\$(echo \\$(genmod --version 2>&1) | sed 's/^.*genmod version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Plot Freec output\nTags: cna, cnv, somatic, single, tumor-only", "answer": "process CONTROLFREEC_FREEC2BED {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/control-freec:11.6b--hdbdd923_0' :\n        'biocontainers/control-freec:11.6b--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(ratio)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    freec2bed.pl -f ${ratio} ${args} > ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Plot Freec output\nTags: cna, cnv, somatic, single, tumor-only", "answer": "process CONTROLFREEC_MAKEGRAPH2 {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/control-freec:11.6b--hdbdd923_0':\n        'biocontainers/control-freec:11.6b--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(ratio), path(baf)\n\n    output:\n    tuple val(meta), path(\"*_BAF.png\")       , emit: png_baf\n    tuple val(meta), path(\"*_ratio.log2.png\"), emit: png_ratio_log2\n    tuple val(meta), path(\"*_ratio.png\")     , emit: png_ratio\n\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def baf = baf ?: \"\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    cat \\$(which makeGraph2.0.R) | R --slave --args ${args} ${ratio} ${baf}\n\n    mv *_BAF.txt.png ${prefix}_BAF.png\n    mv *_ratio.txt.log2.png ${prefix}_ratio.log2.png\n    mv *_ratio.txt.png ${prefix}_ratio.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}_BAF.png\n    touch ${prefix}_ratio.log2.png\n    touch ${prefix}_ratio.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Format Freec output to circos input format\nTags: cna, cnv, somatic, single, tumor-only", "answer": "process CONTROLFREEC_FREEC2CIRCOS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/control-freec:11.6b--hdbdd923_0' :\n        'biocontainers/control-freec:11.6b--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(ratio)\n\n    output:\n    tuple val(meta), path(\"*.circos.txt\"), emit: circos\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    freec2circos.pl -f ${ratio} ${args} > ${prefix}.circos.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.circos.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Copy number and genotype annotation from whole genome and whole exome sequencing data\nTags: cna, cnv, somatic, single, tumor-only", "answer": "process CONTROLFREEC_FREEC {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/control-freec:11.6b--hdbdd923_0' :\n        'biocontainers/control-freec:11.6b--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(mpileup_normal), path(mpileup_tumor), path(cpn_normal), path(cpn_tumor), path(minipileup_normal), path(minipileup_tumor)\n    path fasta\n    path fai\n    path snp_position\n    path known_snps\n    path known_snps_tbi\n    path chr_directory\n    path mappability\n    path target_bed\n    path gccontent_profile\n\n    output:\n    tuple val(meta), path(\"*_ratio.BedGraph\")   , emit: bedgraph, optional: true\n    tuple val(meta), path(\"*_control.cpn\")      , emit: control_cpn, optional: true\n    tuple val(meta), path(\"*_sample.cpn\")       , emit: sample_cpn\n    tuple val(meta), path(\"GC_profile.*.cpn\")   , emit: gcprofile_cpn, optional:true\n    tuple val(meta), path(\"*_BAF.txt\")          , emit: BAF\n    tuple val(meta), path(\"*_CNVs\")             , emit: CNV\n    tuple val(meta), path(\"*_info.txt\")         , emit: info\n    tuple val(meta), path(\"*_ratio.txt\")        , emit: ratio\n    tuple val(meta), path(\"config.txt\")         , emit: config\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    //\"General\" configurations\n    def bedgraphoutput              = task.ext.args?[\"general\"]?[\"bedgraphoutput\"]              ? \"BedGraphOutput = ${task.ext.args[\"general\"][\"bedgraphoutput\"]}\"                              : \"\"\n    def chr_files                   = chr_directory                                             ? \"chrFiles =\\${PWD}/${chr_directory}\"                                                          : \"\"\n    def chr_length                  = fai                                                       ? \"chrLenFile = \\${PWD}/${fai}\"                                                                 : \"\"\n    def breakpointthreshold         = task.ext.args?[\"general\"]?[\"breakpointthreshold\"]         ? \"breakPointThreshold = ${task.ext.args[\"general\"][\"breakpointthreshold\"]}\"                    : \"\"\n    def breakpointtype              = task.ext.args?[\"general\"]?[\"breakpointtype\"]              ? \"breakPointType = ${task.ext.args[\"general\"][\"breakpointtype\"]}\"                              : \"\"\n    def coefficientofvariation      = task.ext.args?[\"general\"]?[\"coefficientofvariation\"]      ? \"coefficientOfVariation = ${task.ext.args[\"general\"][\"coefficientofvariation\"]}\"              : \"\"\n    def contamination               = task.ext.args?[\"general\"]?[\"contamination\"]               ? \"contamination = ${task.ext.args[\"general\"][\"contamination\"]}\"                                : \"\"\n    def contaminationadjustment     = task.ext.args?[\"general\"]?[\"contaminationadjustment\"]     ? \"contaminationAdjustment = ${task.ext.args[\"general\"][\"contaminationadjustment\"]}\"            : \"\"\n    def degree                      = task.ext.args?[\"general\"]?[\"degree\"]                      ? \"degree = ${task.ext.args[\"general\"][\"degree\"]}\"                                              : \"\"\n    def forcegccontentnormalization = task.ext.args?[\"general\"]?[\"forcegccontentnormalization\"] ? \"forceGCcontentNormalization = ${task.ext.args[\"general\"][\"forcegccontentnormalization\"]}\"    : \"\"\n    def gccontentprofile            = gccontent_profile                                         ? \"GCcontentProfile = ${gccontent_profile}\"                                                     : \"\"\n    def mappability                 = mappability                                               ? \"gemMappabilityFile = \\${PWD}/${mappability}\"                                                 : \"\"\n    def intercept                   = task.ext.args?[\"general\"]?[\"intercept\"]                   ? \"intercept = ${task.ext.args[\"general\"][\"intercept\"]}\"                                         : \"\"\n    def mincnalength                = task.ext.args?[\"general\"]?[\"mincnalength\"]                ? \"minCNAlength = ${task.ext.args[\"general\"][\"mincnalength\"]}\"                                  : \"\"\n    def minmappabilityperwindow     = task.ext.args?[\"general\"]?[\"minmappabilityperwindow\"]     ? \"minMappabilityPerWindow = ${task.ext.args[\"general\"][\"minmappabilityperwindow\"]}\"            : \"\"\n    def minexpectedgc               = task.ext.args?[\"general\"]?[\"minexpectedgc\"]               ? \"minExpectedGC = ${task.ext.args[\"general\"][\"minexpectedgc\"]}\"                                : \"\"\n    def maxexpectedgc               = task.ext.args?[\"general\"]?[\"maxexpectedgc\"]               ? \"maxExpectedGC = ${task.ext.args[\"general\"][\"maxexpectedgc\"]}\"                                : \"\"\n    def minimalsubclonepresence     = task.ext.args?[\"general\"]?[\"minimalsubclonepresence\"]     ? \"minimalSubclonePresence = ${task.ext.args[\"general\"][\"minimalsubclonepresence\"]}\"            : \"\"\n    def noisydata                   = task.ext.args?[\"general\"]?[\"noisydata\"]                   ? \"noisyData = ${task.ext.args[\"general\"][\"noisydata\"]}\"                                        : \"\"\n    def output                      = task.ext.prefix                                           ? \"outputDir = \\${PWD}/${task.ext.prefix}\"  : \"\"\n    def ploidy                      = task.ext.args?[\"general\"]?[\"ploidy\"]                      ? \"ploidy = ${task.ext.args[\"general\"][\"ploidy\"]}\"                                              : \"\"\n    def printNA                     = task.ext.args?[\"general\"]?[\"printNA\"]                     ? \"printNA = ${task.ext.args[\"general\"][\"printNA\"]}\"                                            : \"\"\n    def readcountthreshold          = task.ext.args?[\"general\"]?[\"readcountthreshold\"]          ? \"readCountThreshold = ${task.ext.args[\"general\"][\"readcountthreshold\"]}\"                      : \"\"\n    def sex                         = task.ext.args?[\"general\"]?[\"sex\"]                         ? \"sex = ${task.ext.args[\"general\"][\"sex\"]}\"                                                    : \"\"\n    def step                        = task.ext.args?[\"general\"]?[\"step\"]                        ? \"step = ${task.ext.args[\"general\"][\"step\"]}\"                                                  : \"\"\n    def telocentromeric             = task.ext.args?[\"general\"]?[\"telocentromeric\"]             ? \"telocentromeric = ${task.ext.args[\"general\"][\"telocentromeric\"]} \"                           : \"\"\n    def uniquematch                 = task.ext.args?[\"general\"]?[\"uniquematch\"]                 ? \"uniqueMatch = ${task.ext.args[\"general\"][\"uniquematch\"]}\"                                    : \"\"\n    def window                      = task.ext.args?[\"general\"]?[\"window\"]                      ? \"window = ${task.ext.args[\"general\"][\"window\"]}\"                                              : \"\"\n\n    //\"Control\" configurations\n    def matefile_normal             = mpileup_normal                                            ? \"mateFile = \\${PWD}/${mpileup_normal}\"                                                        : \"\"\n    def matecopynumberfile_normal   = cpn_normal                                                ? \"mateCopyNumberFile = \\${PWD}/${cpn_normal}\"                                                  : \"\"\n    def minipileup_normal           = minipileup_normal                                         ? \"miniPileup = \\${PWD}/${minipileup_normal}\"                                                   : \"\"\n    def inputformat_normal          = task.ext.args?[\"control\"]?[\"inputformat\"]                 ? \"inputFormat = ${task.ext.args[\"control\"][\"inputformat\"]}\"                                    : \"\"\n    def mateorientation_normal      = task.ext.args?[\"control\"]?[\"mateorientation\"]             ? \"mateOrientation = ${task.ext.args[\"control\"][\"mateorientation\"]}\"                            : \"\"\n\n    //\"Sample\" configuration\n    def matefile_tumor             = mpileup_tumor                                              ? \"mateFile = \\${PWD}/${mpileup_tumor}\"                                                         : \"\"\n    def matecopynumberfile_tumor   = cpn_tumor                                                  ? \"mateCopyNumberFile = \\${PWD}/${cpn_tumor}\"                                                   : \"\"\n    def minipileup_tumor           = minipileup_tumor                                           ? \"miniPileup = \\${PWD}/${minipileup_tumor}\"                                                    : \"\"\n    def inputformat_tumor          = task.ext.args?[\"sample\"]?[\"inputformat\"]                   ? \"inputFormat = ${task.ext.args[\"sample\"][\"inputformat\"]}\"                                     : \"\"\n    def mateorientation_tumor      = task.ext.args?[\"sample\"]?[\"mateorientation\"]               ? \"mateOrientation = ${task.ext.args[\"sample\"][\"mateorientation\"]}\"                             : \"\"\n\n    //\"BAF\" configuration\n    def makepileup                 = snp_position                                               ? \"makePileup = \\${PWD}/${snp_position}\"                                                        : \"\"\n    def fastafile                  = fasta                                                      ? \"fastaFile = \\${PWD}/${fasta}\"                                                                : \"\"\n    def minimalcoverageperposition = task.ext.args?[\"BAF\"]?[\"minimalcoverageperposition\"]       ? \"minimalCoveragePerPosition = ${task.ext.args[\"BAF\"][\"minimalcoverageperposition\"]}\"          : \"\"\n    def minimalqualityperposition  = task.ext.args?[\"BAF\"]?[\"minimalqualityperposition\"]        ? \"minimalQualityPerPosition = ${task.ext.args[\"BAF\"][\"minimalqualityperposition\"]}\"            : \"\"\n    def shiftinquality             = task.ext.args?[\"BAF\"]?[\"shiftinquality\"]                   ? \"shiftInQuality = ${task.ext.args[\"BAF\"][\"shiftinquality\"]}\"                                  : \"\"\n    def snpfile                    = known_snps                                                 ? \"SNPfile = \\$PWD/${known_snps}\"                                                               : \"\"\n\n    //\"Target\" configuration\n    def target_bed                 = target_bed                                                 ? \"captureRegions = ${target_bed}\"                                                              : \"\"\n\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch config.txt\n\n    echo \"[general]\" >> config.txt\n    echo ${bedgraphoutput} >> config.txt\n    echo ${breakpointthreshold} >> config.txt\n    echo ${breakpointtype} >> config.txt\n    echo ${chr_files} >> config.txt\n    echo ${chr_length} >> config.txt\n    echo ${coefficientofvariation} >> config.txt\n    echo ${contamination} >> config.txt\n    echo ${contaminationadjustment} >> config.txt\n    echo ${degree} >> config.txt\n    echo ${forcegccontentnormalization} >> config.txt\n    echo ${gccontentprofile} >> config.txt\n    echo ${mappability} >> config.txt\n    echo ${intercept} >> config.txt\n    echo ${mincnalength} >> config.txt\n    echo ${minmappabilityperwindow} >> config.txt\n    echo ${minexpectedgc} >> config.txt\n    echo ${maxexpectedgc} >> config.txt\n    echo ${minimalsubclonepresence} >> config.txt\n    echo \"maxThreads = ${task.cpus}\" >> config.txt\n    echo ${noisydata} >> config.txt\n    echo ${output} >> config.txt\n    echo ${ploidy} >> config.txt\n    echo ${printNA} >> config.txt\n    echo ${readcountthreshold} >> config.txt\n    echo ${sex} >> config.txt\n    echo ${step} >> config.txt\n    echo ${telocentromeric} >> config.txt\n    echo ${uniquematch} >> config.txt\n    echo ${window} >> config.txt\n\n    echo \"[control]\" >> config.txt\n    echo ${matefile_normal} >> config.txt\n    echo ${matecopynumberfile_normal} >> config.txt\n    echo ${minipileup_normal} >> config.txt\n    echo ${inputformat_normal} >> config.txt\n    echo ${mateorientation_normal} >> config.txt\n\n    echo \"[sample]\" >> config.txt\n    echo ${matefile_tumor} >> config.txt\n    echo ${matecopynumberfile_tumor} >> config.txt\n    echo ${minipileup_tumor} >> config.txt\n    echo ${inputformat_tumor} >> config.txt\n    echo ${mateorientation_tumor} >> config.txt\n\n    echo \"[BAF]\" >> config.txt\n    echo ${makepileup} >> config.txt\n    echo ${fastafile} >> config.txt\n    echo ${minimalcoverageperposition} >> config.txt\n    echo ${minimalqualityperposition} >> config.txt\n    echo ${shiftinquality} >> config.txt\n    echo ${snpfile} >> config.txt\n\n    echo \"[target]\" >> config.txt\n    echo ${target_bed} >> config.txt\n\n    freec -conf config.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}_ratio.BedGraph\n    touch ${prefix}_sample.cpn\n    touch GC_profile.${prefix}.cpn\n    touch ${prefix}_BAF.txt\n    touch ${prefix}_CNVs\n    touch ${prefix}_info.txt\n    touch ${prefix}_ratio.txt\n    touch config.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Plot Freec output\nTags: cna, cnv, somatic, single, tumor-only", "answer": "process CONTROLFREEC_MAKEGRAPH {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/control-freec:11.6b--hdbdd923_0' :\n        'biocontainers/control-freec:11.6b--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(ratio), path(baf), val(ploidy)\n\n    output:\n    tuple val(meta), path(\"*_BAF.png\")       , emit: png_baf\n    tuple val(meta), path(\"*_ratio.log2.png\"), emit: png_ratio_log2\n    tuple val(meta), path(\"*_ratio.png\")     , emit: png_ratio\n\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def baf = baf ?: \"\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    cat \\$(which makeGraph.R) | R --slave --args ${ploidy} ${args} ${ratio} ${baf}\n\n    mv *_BAF.txt.png ${prefix}_BAF.png\n    mv *_ratio.txt.log2.png ${prefix}_ratio.log2.png\n    mv *_ratio.txt.png ${prefix}_ratio.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}_BAF.png\n    touch ${prefix}_ratio.log2.png\n    touch ${prefix}_ratio.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Add both Wilcoxon test and Kolmogorov-Smirnov test p-values to each CNV output of FREEC\nTags: cna, cnv, somatic, single, tumor-only", "answer": "process CONTROLFREEC_ASSESSSIGNIFICANCE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/control-freec:11.6b--hdbdd923_0' :\n        'biocontainers/control-freec:11.6b--hdbdd923_0' }\"\n\n    input:\n    tuple val(meta), path(cnvs), path(ratio)\n\n    output:\n    tuple val(meta), path(\"*.p.value.txt\"), emit: p_value_txt\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    cat \\$(which assess_significance.R) | R --slave --args ${cnvs} ${ratio}\n\n    mv *.p.value.txt ${prefix}.p.value.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '11.6b' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.p.value.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        controlfreec: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Jointly Accurate Sv Merging with Intersample Network Edges\nTags: jasminesv, jasmine, structural variants, vcf, bam", "answer": "process JASMINESV {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/jasminesv:1.1.5--hdfd78af_0':\n        'biocontainers/jasminesv:1.1.5--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcfs), path(bams), path(sample_dists)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n    path(chr_norm)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")   , emit: vcf\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def args2   = task.ext.args2 ?: ''\n    def args3   = task.ext.args3 ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n\n    make_bam = bams ? \"ls *.bam > bams.txt\" : \"\"\n    bam_argument = bams ? \"bam_list=bams.txt\" : \"\"\n    iris_argument = args2 != '' ? \"iris_args=${args2}\" : \"\"\n    sample_dists_argument = sample_dists ? \"sample_dists=${sample_dists}\" : \"\"\n    chr_norm_argument = chr_norm ? \"chr_norm_file=${chr_norm}\" : \"\"\n\n    unzip_inputs = vcfs.collect { it.extension == \"gz\" ? \"    bgzip -d --threads ${task.cpus} ${args2} ${it}\" : \"\" }.join(\"\\n\")\n    \"\"\"\n    ${unzip_inputs}\n\n    ls *.vcf > vcfs.txt\n    ${make_bam}\n\n    jasmine \\\\\n        file_list=vcfs.txt \\\\\n        out_file=${prefix}.vcf \\\\\n        threads=${task.cpus} \\\\\n        genome_file=${fasta} \\\\\n        ${bam_argument} \\\\\n        ${iris_argument} \\\\\n        ${sample_dists_argument} \\\\\n        ${chr_norm_argument} \\\\\n        ${args}\n\n    bgzip --threads ${task.cpus} ${args3} ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        jasminesv: \\$(echo \\$(jasmine 2>&1 | grep \"version\" | sed 's/Jasmine version //'))\n        tabix: \\$(echo \\$(tabix -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        jasminesv: \\$(echo \\$(jasmine 2>&1 | grep \"version\" | sed 's/Jasmine version //'))\n        tabix: \\$(echo \\$(tabix -h 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Dysgu calls structural variants (SVs) from mapped sequencing reads. It is designed for accurate and efficient detection of structural variations.\nTags: structural variants, sv, vcf", "answer": "process DYSGU {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/dysgu:48830f55112c399e':\n        'community.wave.seqera.io/library/dysgu:faf71ac972284412' }\"\n\n    input:\n    tuple val(meta), path(input), path(index)\n    tuple val(meta2), path(fasta), path(fai)\n\n    output:\n    tuple val(meta), path('*.vcf.gz')       , emit: vcf\n    tuple val(meta), path('*.vcf.gz.tbi')   , emit: tbi\n    path 'versions.yml'                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    dysgu run \\\\\n        -p ${task.cpus} \\\\\n        -x \\\\\n        $fasta \\\\\n        . \\\\\n        $input \\\\\n        | bgzip ${args2} --threads ${task.cpus} --stdout > ${prefix}.vcf.gz\n    tabix ${args3} ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dysgu: \\$(dysgu --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dysgu: \\$(dysgu --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Call structural variants\nTags: genome, structural, variants, bcf", "answer": "process DELLY_CALL {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/delly:1.2.6--hb7e2ac5_1' :\n        'biocontainers/delly:1.2.6--hb7e2ac5_1' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(vcf), path(vcf_index), path(exclude_bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.{bcf,vcf.gz}\")  , emit: bcf\n    tuple val(meta), path(\"*.{csi,tbi}\")     , emit: csi\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"bcf\"\n\n    def exclude = exclude_bed ? \"--exclude ${exclude_bed}\" : \"\"\n\n    def bcf_output = suffix == \"bcf\" ? \"--outfile ${prefix}.bcf\" : \"\"\n    def vcf_output = suffix == \"vcf\" ? \"| bgzip ${args2} --threads ${task.cpus} --stdout > ${prefix}.vcf.gz && tabix ${prefix}.vcf.gz\" : \"\"\n\n    def genotype = vcf ? \"--vcffile ${vcf}\" : \"\"\n\n    \"\"\"\n    delly \\\\\n        call \\\\\n        ${args} \\\\\n        ${bcf_output} \\\\\n        --genome ${fasta} \\\\\n        ${genotype} \\\\\n        ${exclude} \\\\\n        ${input} \\\\\n        ${vcf_output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        delly: \\$( echo \\$(delly --version 2>&1) | sed 's/^.*Delly version: v//; s/ using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"bcf\"\n\n    def bcf_output = suffix == \"bcf\" ? \"touch ${prefix}.bcf && touch ${prefix}.bcf.csi\" : \"\"\n    def vcf_output = suffix == \"vcf\" ? \"echo '' | gzip > ${prefix}.vcf.gz && touch ${prefix}.vcf.gz.tbi\" : \"\"\n\n    \"\"\"\n    ${bcf_output}\n    ${vcf_output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        delly: \\$( echo \\$(delly --version 2>&1) | sed 's/^.*Delly version: v//; s/ using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Takes multiple kraken-style reports and combines them into a single report file\nTags: kraken, krakentools, metagenomics, table, combining, merging", "answer": "process KRAKENTOOLS_COMBINEKREPORTS {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krakentools:1.2--pyh5e36f6f_0':\n        'biocontainers/krakentools:1.2--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(kreports)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    combine_kreports.py \\\\\n        -r ${kreports} \\\\\n        -o ${prefix}.txt \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        combine_kreports.py: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        combine_kreports.py: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Takes a Kraken report file and prints out a krona-compatible TEXT file\nTags: kraken, krona, metagenomics, visualization", "answer": "process KRAKENTOOLS_KREPORT2KRONA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krakentools:1.2--pyh5e36f6f_0':\n        'biocontainers/krakentools:1.2--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(kreport)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    kreport2krona.py \\\\\n        -r ${kreport} \\\\\n        -o ${prefix}.txt \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kreport2krona.py: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kreport2krona.py: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extract reads classified at any user-specified taxonomy IDs.\nTags: kraken2, krakentools, metagenomics", "answer": "process KRAKENTOOLS_EXTRACTKRAKENREADS {\n\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krakentools:1.2--pyh5e36f6f_0':\n        'biocontainers/krakentools:1.2--pyh5e36f6f_0'}\"\n\n    input:\n    val taxid // Separated by spaces\n    tuple val(meta), path(classified_reads_assignment)\n    tuple val(meta), path(classified_reads_fastq)\n    tuple val(meta), path(report)\n\n    output:\n    tuple val(meta), path(\"*.{fastq,fasta}\"), emit: extracted_kraken2_reads\n\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--fastq-output\") ? \"fastq\" : \"fasta\"\n    def input_reads_command = meta.single_end ? \"-s $classified_reads_fastq\" : \"-s1 ${classified_reads_fastq[0]} -s2 ${classified_reads_fastq[1]}\"\n    def output_reads_command = meta.single_end ? \"-o ${prefix}.extracted_kraken2_read.${extension}\" : \"-o ${prefix}.extracted_kraken2_read_1.${extension} -o2 ${prefix}.extracted_kraken2_read_2.${extension}\"\n    def report_option = report ? \"-r ${report}\" : \"\"\n    def VERSION = '1.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    extract_kraken_reads.py \\\\\n        ${args} \\\\\n        -t $taxid \\\\\n        -k $classified_reads_assignment \\\\\n        $report_option \\\\\n        $input_reads_command \\\\\n        $output_reads_command\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        extract_kraken_reads.py: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--fastq-output\") ? \"fastq\" : \"fasta\"\n    def input_reads_command = meta.single_end ? \"-s $classified_reads_fastq\" : \"-s1 ${classified_reads_fastq[0]} -s2 ${classified_reads_fastq[1]}\"\n    def output_reads_command = meta.single_end ? \"-o ${prefix}.extracted_kraken2_read.${extension}\" : \"-o ${prefix}.extracted_kraken2_read_1.${extension} -o2 ${prefix}.extracted_kraken2_read_2.${extension}\"\n    def report_option = report ? \"-r ${report}\" : \"\"\n    def VERSION = '1.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    if [ \"$meta.single_end\" == \"true\" ];\n    then\n        touch ${prefix}.extracted_kraken2_read.${extension}\n    else\n        touch ${prefix}.extracted_kraken2_read_1.${extension}\n        touch ${prefix}.extracted_kraken2_read_2.${extension}\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        extract_kraken_reads.py: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produces a Newick format phylogeny from a multiple sequence alignment. Capable of bacterial genome size alignments.\nTags: phylogeny, newick", "answer": "process FASTTREE {\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fasttree:2.1.10--h516909a_4' :\n        'biocontainers/fasttree:2.1.10--h516909a_4' }\"\n\n    input:\n    path alignment\n\n    output:\n    path \"*.tre\",         emit: phylogeny\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    fasttree \\\\\n        $args \\\\\n        -log fasttree_phylogeny.tre.log \\\\\n        -nt $alignment \\\\\n        > fasttree_phylogeny.tre\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fasttree: \\$(fasttree -help 2>&1 | head -1  | sed 's/^FastTree \\\\([0-9\\\\.]*\\\\) .*\\$/\\\\1/')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run falco on sequenced reads\nTags: quality control, qc, adapters, fastq", "answer": "process FALCO {\n    tag \"$meta.id\"\n    label 'process_single'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/falco:1.2.1--h867801b_3':\n        'biocontainers/falco:1.2.1--h867801b_3' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.html\"), emit: html\n    tuple val(meta), path(\"*.txt\") , emit: txt\n    path  \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if ( reads.toList().size() == 1 ) {\n        \"\"\"\n        falco $args --threads $task.cpus ${reads} -D ${prefix}_fastqc_data.txt -S ${prefix}_summary.txt -R ${prefix}_report.html\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            falco:\\$( falco --version | sed -e \"s/falco//g\" )\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        falco $args --threads $task.cpus ${reads}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            falco:\\$( falco --version | sed -e \"s/falco//g\" )\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_data.txt\n    touch ${prefix}_fastqc_data.html\n    touch ${prefix}_summary.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        falco: \\$( falco --version | sed -e \"s/falco v//g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: SNP and Indel variant caller on a per-locus basis\nTags: bam, vcf, variant calling", "answer": "process GATK_UNIFIEDGENOTYPER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-5e3fd88c6b8af48bb5982d5721ca5e36da94029b:c496eeb8cc9067e0720d35121dbff7732a7ebdb0-0':\n        'biocontainers/mulled-v2-5e3fd88c6b8af48bb5982d5721ca5e36da94029b:c496eeb8cc9067e0720d35121dbff7732a7ebdb0-0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n    tuple val(meta5), path(intervals)\n    tuple val(meta6), path(contamination)\n    tuple val(meta7), path(dbsnp)\n    tuple val(meta8), path(comp)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def contamination_file = contamination ? \"-contaminationFile ${contamination}\" : \"\"\n    def dbsnp_file = dbsnp ? \"--dbsnp ${dbsnp}\" : \"\"\n    def comp_file = comp ? \"--comp ${comp}\" : \"\"\n    def intervals_file = intervals ? \"--intervals ${intervals}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK RealignerTargetCreator] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    gatk3 \\\\\n        -Xmx${avail_mem}M \\\\\n        -nt ${task.cpus} \\\\\n        -T UnifiedGenotyper \\\\\n        -I ${bam} \\\\\n        -R ${fasta} \\\\\n        ${contamination_file} \\\\\n        ${dbsnp_file} \\\\\n        ${comp_file} \\\\\n        ${intervals_file} \\\\\n        -o ${prefix}.vcf \\\\\n        $args\n\n    bgzip ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk: \\$(echo \\$(gatk3 --version))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs local realignment around indels to correct for mapping errors\nTags: bam, vcf, variant calling, indel, realignment", "answer": "process GATK_INDELREALIGNER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk:3.5--hdfd78af_11':\n        'biocontainers/gatk:3.5--hdfd78af_11' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n    tuple val(meta5), path(known_vcf)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), path(\"*.bai\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def known = known_vcf ? \"-known ${known_vcf}\" : \"\"\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK IndelRealigner] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    gatk3 \\\\\n        -Xmx${avail_mem}M \\\\\n        -T IndelRealigner \\\\\n        -R ${fasta} \\\\\n        -I ${bam} \\\\\n        --targetIntervals ${intervals} \\\\\n        ${known} \\\\\n        -o ${prefix}.bam \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk: \\$(echo \\$(gatk3 --version))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generates a list of locations that should be considered for local realignment prior genotyping.\nTags: bam, vcf, variant calling, indel, realignment, targets", "answer": "process GATK_REALIGNERTARGETCREATOR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk:3.5--hdfd78af_11':\n        'biocontainers/gatk:3.5--hdfd78af_11' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n    tuple val(meta5), path(known_vcf)\n\n    output:\n    tuple val(meta), path(\"*.intervals\"), emit: intervals\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def known = known_vcf ? \"-known ${known_vcf}\" : \"\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK RealignerTargetCreator] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    gatk3 \\\\\n        -Xmx${avail_mem}M \\\\\n        -T RealignerTargetCreator \\\\\n        -nt ${task.cpus} \\\\\n        -I ${bam} \\\\\n        -R ${fasta} \\\\\n        -o ${prefix}.intervals \\\\\n        ${known} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk: \\$(echo \\$(gatk3 --version))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Linking bins output by vRhyme to create one sequences per bin\nTags: bin, binning, link, vrhyme, linkbins", "answer": "process VRHYME_LINKBINS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vrhyme:1.1.0--pyhdfd78af_1':\n        'biocontainers/vrhyme:1.1.0--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(bins)\n\n    output:\n    tuple val(meta), path(\"*_linked_bins.fasta\")        , emit: linked_bins\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    link_bin_sequences.py \\\\\n        -i $bins \\\\\n        -o vRhyme_linked_bins \\\\\n        -e fasta \\\\\n        $args\n\n    cat vRhyme_linked_bins/*.fasta > ${prefix}_linked_bins.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vrhyme: \\$(echo \\$(vRhyme --version 2>&1) | sed 's/^.*vRhyme v//; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_linked_bins.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vrhyme: \\$(echo \\$(vRhyme --version 2>&1) | sed 's/^.*vRhyme v//; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extracting sequences that were unbinnned by vRhyme into a FASTA file\nTags: bin, binning, link, vrhyme, extractunbinned", "answer": "process VRHYME_EXTRACTUNBINNED {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vrhyme:1.1.0--pyhdfd78af_1':\n        'biocontainers/vrhyme:1.1.0--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(membership)\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*_unbinned_sequences.fasta\") , emit: unbinned_sequences\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    extract_unbinned_sequences.py \\\\\n        -i $membership \\\\\n        -f $fasta \\\\\n        -o ${prefix}_unbinned_sequences.fasta \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vrhyme: \\$(echo \\$(vRhyme --version 2>&1) | sed 's/^.*vRhyme v//; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_unbinned_sequences.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vrhyme: \\$(echo \\$(vRhyme --version 2>&1) | sed 's/^.*vRhyme v//; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Binning virus genomes from metagenomes\nTags: binning, bin, phage, virus, vrhyme", "answer": "process VRHYME_VRHYME {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vrhyme:1.1.0--pyhdfd78af_1':\n        'biocontainers/vrhyme:1.1.0--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"vRhyme_best_bins_fasta/\")                , emit: bins\n    tuple val(meta), path(\"**/vRhyme_best_bins.*.membership.tsv\")   , emit: membership\n    tuple val(meta), path(\"**/vRhyme_best_bins.*.summary.tsv\")      , emit: summary\n    path \"versions.yml\"                                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    vRhyme \\\\\n        -i $fasta \\\\\n        -r $reads \\\\\n        -o $prefix \\\\\n        -t $task.cpus \\\\\n        $args\n\n    mv $prefix/vRhyme_best_bins_fasta/ vRhyme_best_bins_fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vrhyme: \\$(echo \\$(vRhyme --version 2>&1) | sed 's/^.*vRhyme v//; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p $prefix\n    touch $prefix/vRhyme_best_bins.19.membership.tsv\n    touch $prefix/vRhyme_best_bins.19.summary.tsv\n    mkdir -p vRhyme_best_bins_fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_1.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_10.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_11.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_12.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_13.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_14.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_2.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_3.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_4.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_5.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_6.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_7.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_8.fasta\n    touch vRhyme_best_bins_fasta/vRhyme_bin_9.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vrhyme: \\$(echo \\$(vRhyme --version 2>&1) | sed 's/^.*vRhyme v//; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calls CNVs in bam files from tumor patients\nTags: cnv, bam, tumor/normal", "answer": "process ONCOCNV {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://containers.biocontainers.pro/s3/SingImgsRepo/oncocnv/v7.0_cv2/oncocnv_v7.0_cv2.sif':\n        'registry.hub.docker.com/biocontainers/oncocnv:v7.0_cv2' }\"\n\n    input:\n    tuple val(meta), path(normal), path(normal_index), path(tumor), path(tumor_index)\n    path bed\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*.profile.png\")  ,emit: png\n    tuple val(meta), path(\"*.profile.txt\")  ,emit: profile\n    tuple val(meta), path(\"*.summary.txt\")  ,emit: summary\n    path \"versions.yml\"                     ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def cghseg = task.ext.args2 ?: 'cghseg'\n    def mode = task.ext.args ?: '-m Ampli'\n    def normal = normal.join(',')\n    def tumor = tumor.join(',')\n    def VERSION = '7.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    perl \\$(which ONCOCNV_getCounts.pl) \\\\\n        getControlStats \\\\\n        $mode \\\\\n        -b ${bed} \\\\\n        -c $normal \\\\\n        -o ControlStats.txt\n\n    perl \\$(which ONCOCNV_getCounts.pl) \\\\\n        getSampleStats \\\\\n        $mode \\\\\n        -c ControlStats.txt \\\\\n        -s $tumor \\\\\n        -o SampleStats.txt\n\n    cat ControlStats.txt \\\\\n        | grep -v start \\\\\n        | awk '{print \\$1,\\$2,\\$3}' \\\\\n        | sed \"s/ /\\t/g\" > target.bed\n\n    perl \\$(which createTargetGC.pl) \\\\\n        -bed target.bed \\\\\n        -fi ${fasta} \\\\\n        -od . \\\\\n        -of TargetGC.txt\n\n    cat \\$(which processControl.R) \\\\\n        | R \\\\\n        --slave \\\\\n        --args ControlStats.txt ControlStatsProcessed.txt TargetGC.txt\n\n    cat \\$(which processSamples.R) \\\\\n        | R \\\\\n        --slave \\\\\n        --args SampleStats.txt ControlStatsProcessed.txt Output.log $cghseg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        oncocnv: $VERSION\n        perl: \\$(perl --version | grep 'This is perl' | sed 's/.*(v//g' | sed 's/)//g')\n        r: \\$(R --version | grep \"R version\" | sed 's/R version //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assemble bacterial isolate genomes from Nanopore reads\nTags: bacterial, assembly, nanopore", "answer": "process DRAGONFLYE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/dragonflye:1.1.2--hdfd78af_0' :\n        'biocontainers/dragonflye:1.1.2--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(shortreads), path(longreads)\n\n    output:\n    tuple val(meta), path(\"*.fa\")                                               , emit: contigs\n    tuple val(meta), path(\"dragonflye.log\")                                     , emit: log\n    tuple val(meta), path(\"{flye,miniasm,raven}.fasta\")                         , emit: raw_contigs\n    tuple val(meta), path(\"{flye,miniasm,raven}-unpolished.gfa\"), optional:true , emit: gfa\n    tuple val(meta), path(\"flye-info.txt\")                      , optional:true , emit: txt\n    path \"versions.yml\"                                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def memory  = task.memory.toGiga()\n    def shortreads_polishing = shortreads ? \"--R1 ${shortreads[0]} --R2 ${shortreads[1]}\" : ''\n    \"\"\"\n    dragonflye \\\\\n        --reads ${longreads} \\\\\n        $shortreads_polishing \\\\\n        $args \\\\\n        --prefix ${prefix} \\\\\n        --cpus $task.cpus \\\\\n        --ram $memory \\\\\n        --outdir ./ \\\\\n        --force\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dragonflye: \\$(dragonflye --version 2>&1 | sed 's/^.*dragonflye //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: metagenomic binning with self-supervised learning\nTags: binning, assembly-binning, metagenomics", "answer": "process SEMIBIN_SINGLEEASYBIN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/semibin:1.4.0--pyh7cba7a3_0':\n        'biocontainers/semibin:1.4.0--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(fasta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.csv\")                        , emit: csv\n    tuple val(meta), path(\"*.h5\")                         , emit: model\n    tuple val(meta), path(\"output_prerecluster_bins/*.fa\"), emit: output_fasta\n    tuple val(meta), path(\"output_recluster_bins/*.fa\")   , emit: recluster_fasta\n    tuple val(meta), path(\"*.tsv\")                        , emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args3 = task.ext.args3 ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n\n    SemiBin \\\\\n        $args \\\\\n        single_easy_bin \\\\\n        -i $fasta \\\\\n        -b $bam \\\\\n        -o $prefix \\\\\n        -t $task.cpus \\\\\n        $args3\n\n    mv $prefix/* .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        SemiBin: \\$( SemiBin --version )\n    END_VERSIONS\n\"\"\"\n}\n"}
{"question": "Description: Create a tsv file from a query and a target database as well as the result database\nTags: protein sequence, databases, clustering, searching, indexing, mmseqs2, tsv", "answer": "\nprocess MMSEQS_CREATETSV {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:15.6f452--pl5321h6a68c12_0':\n        'biocontainers/mmseqs2:15.6f452--pl5321h6a68c12_0' }\"\n\n    input:\n    tuple val(meta), path(db_result)\n    tuple val(meta2), path(db_query)\n    tuple val(meta3), path(db_target)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args ?: \"*.dbtype\" // database generated by mmyseqs cluster | search | taxonomy | ...\n    def args3 = task.ext.args ?: \"*.dbtype\" // database generated by mmyseqs/createdb\n    def args4 = task.ext.args ?: \"*.dbtype\" // database generated by mmyseqs/createdb\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    # Extract files with specified args based suffix | remove suffix | isolate longest common substring of files\n    DB_RESULT_PATH_NAME=\\$(find -L \"$db_result/\" -maxdepth 1 -name \"$args2\" | sed 's/\\\\.[^.]*\\$//' | sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n    DB_QUERY_PATH_NAME=\\$(find -L \"$db_query/\" -maxdepth 1 -name \"$args3\" | sed 's/\\\\.[^.]*\\$//' | sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n    DB_TARGET_PATH_NAME=\\$(find -L \"$db_target/\" -maxdepth 1 -name \"$args4\" | sed 's/\\\\.[^.]*\\$//' | sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n\n    mmseqs \\\\\n        createtsv \\\\\n        \\$DB_QUERY_PATH_NAME \\\\\n        \\$DB_TARGET_PATH_NAME \\\\\n        \\$DB_RESULT_PATH_NAME \\\\\n        ${prefix}.tsv \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --compressed 1\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cluster sequences using MMSeqs2 cluster.\nTags: protein sequence, databases, clustering, searching, indexing, mmseqs2", "answer": "process MMSEQS_CLUSTER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:15.6f452--pl5321h6a68c12_0':\n        'biocontainers/mmseqs2:15.6f452--pl5321h6a68c12_0' }\"\n\n    input:\n    tuple val(meta), path(db_input)\n\n    output:\n    tuple val(meta), path(\"${prefix}/\"), emit: db_cluster\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: \"*.dbtype\"\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$db_input\" == \"${prefix}\") error \"Input and output names of databases are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    mkdir -p ${prefix}\n    # Extract files with specified args based suffix | remove suffix | isolate longest common substring of files\n    DB_INPUT_PATH_NAME=\\$(find -L \"$db_input/\" -maxdepth 1 -name \"$args2\" | sed 's/\\\\.[^.]*\\$//' |  sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n\n    mmseqs \\\\\n        cluster \\\\\n        \\$DB_INPUT_PATH_NAME \\\\\n        ${prefix}/${prefix} \\\\\n        tmp1 \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --compressed 1\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}\n\n    touch ${prefix}/${prefix}.{0..9}\n    touch ${prefix}/${prefix}.dbtype\n    touch ${prefix}/${prefix}.index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download an mmseqs-formatted database\nTags: database, indexing, clustering, searching", "answer": "process MMSEQS_DATABASES {\n    tag \"${database}\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:15.6f452--pl5321h6a68c12_0':\n        'biocontainers/mmseqs2:15.6f452--pl5321h6a68c12_0' }\"\n\n    input:\n    val database\n\n    output:\n    path \"${prefix}/\" , emit: database\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: 'mmseqs_database'\n    \"\"\"\n    mkdir ${prefix}/\n\n    mmseqs databases \\\\\n        ${database} \\\\\n        ${prefix}/database \\\\\n        tmp/ \\\\\n        --threads ${task.cpus} \\\\\n        --compressed 1 \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: 'mmseqs_database'\n    \"\"\"\n    mkdir ${prefix}/\n\n    touch ${prefix}/database\n    touch ${prefix}/database.dbtype\n    touch ${prefix}/database_h\n    touch ${prefix}/database_h.dbtype\n    touch ${prefix}/database_h.index\n    touch ${prefix}/database.index\n    touch ${prefix}/database.lookup\n    touch ${prefix}/database_mapping\n    touch ${prefix}/database.source\n    touch ${prefix}/database_taxonomy\n    touch ${prefix}/database.version\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: /')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cluster sequences in linear time using MMSeqs2 linclust.\nTags: protein sequence, databases, clustering, searching, indexing, mmseqs2", "answer": "process MMSEQS_LINCLUST {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:15.6f452--pl5321h6a68c12_0':\n        'biocontainers/mmseqs2:15.6f452--pl5321h6a68c12_0' }\"\n\n    input:\n    tuple val(meta), path(db_input)\n\n    output:\n    tuple val(meta), path(\"${prefix}/\"), emit: db_cluster\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: \"*.dbtype\"\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$db_input\" == \"${prefix}\") error \"Input and output names of databases are the same, set prefix in module configuration to disambiguate!\"\n\n    \"\"\"\n    mkdir -p ${prefix}\n    # Extract files with specified args based suffix | remove suffix | isolate longest common substring of files\n    DB_INPUT_PATH_NAME=\\$(find -L \"$db_input/\" -maxdepth 1 -name \"$args2\" | sed 's/\\\\.[^.]*\\$//' |  sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n\n    mmseqs \\\\\n        linclust \\\\\n        \\$DB_INPUT_PATH_NAME \\\\\n        ${prefix}/${prefix} \\\\\n        tmp1 \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --compressed 1\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}\n\n    touch ${prefix}/${prefix}.{0..9}\n    touch ${prefix}/${prefix}.dbtype\n    touch ${prefix}/${prefix}.index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Searches for the sequences of a fasta file in a databse using MMseqs2\nTags: protein sequence, databases, searching, mmseqs2", "answer": "\nprocess MMSEQS_EASYSEARCH {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:15.6f452--pl5321h6a68c12_0':\n        'biocontainers/mmseqs2:15.6f452--pl5321h6a68c12_0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(db_target)\n\n    output:\n    tuple val(meta), path(\"${prefix}.tsv\"), emit: tsv\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: \"*.dbtype\"\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}\n\n    # Extract files with specified args based suffix | remove suffix | isolate longest common substring of files\n    DB_TARGET_PATH_NAME=\\$(find -L \"$db_target/\" -maxdepth 1 -name \"$args2\" | sed 's/\\\\.[^.]*\\$//' | sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n\n    mmseqs \\\\\n        easy-search \\\\\n        $fasta \\\\\n        \\$DB_TARGET_PATH_NAME \\\\\n        ${prefix}.tsv \\\\\n        tmp1 \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --compressed 1\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: \"*.dbtype\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: /')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Conversion of expandable profile to databases to the MMseqs2 databases format\nTags: protein sequence, databases, clustering, searching, indexing", "answer": "process MMSEQS_TSV2EXPROFILEDB {\n    tag \"$db\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:14.7e284--pl5321hf1761c0_0':\n        'biocontainers/mmseqs2:14.7e284--pl5321hf1761c0_0' }\"\n\n    input:\n    path db\n\n    output:\n    path (db)          , emit: db_exprofile\n    path \"versions.yml\", emit: versions\n    // INDEX=`find -L ./ -name \"*.amb\" | sed 's/\\\\.amb\\$//'`\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    DB_PATH_NAME=\\$(find -L \"$db/\" -name \"*_seq.tsv\" | sed 's/_seq\\\\.tsv\\$//')\n\n    mmseqs tsv2exprofiledb \\\\\n        \\${DB_PATH_NAME} \\\\\n        \"\\${DB_PATH_NAME}_db\" \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    DB_PATH_NAME=\\$(find -L \"$db/\" -name \"*_seq.tsv\" | sed 's/_seq\\\\.tsv\\$//')\n\n    touch \"\\${DB_PATH_NAME}_db\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create an MMseqs database from an existing FASTA/Q file\nTags: protein sequence, databases, clustering, searching, indexing, mmseqs2", "answer": "process MMSEQS_CREATEDB {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:15.6f452--pl5321h6a68c12_0':\n        'biocontainers/mmseqs2:15.6f452--pl5321h6a68c12_0' }\"\n\n    input:\n    tuple val(meta), path(sequence)\n\n    output:\n    tuple val(meta), path(\"${prefix}/\"), emit: db\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = sequence.getExtension() == \"gz\" ? true : false\n    def sequence_name = is_compressed ? sequence.getBaseName() : sequence\n    \"\"\"\n    if [ \"${is_compressed}\" == \"true\" ]; then\n        gzip -c -d ${sequence} > ${sequence_name}\n    fi\n\n    mkdir -p ${prefix}\n\n    mmseqs \\\\\n        createdb \\\\\n        ${sequence_name} \\\\\n        ${prefix}/${prefix} \\\\\n        $args \\\\\n        --compressed 1\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}\n\n    touch ${prefix}/${prefix}\n    touch ${prefix}/${prefix}.dbtype\n    touch ${prefix}/${prefix}.index\n    touch ${prefix}/${prefix}.lookup\n    touch ${prefix}/${prefix}.source\n    touch ${prefix}/${prefix}_h\n    touch ${prefix}/${prefix}_h.dbtype\n    touch ${prefix}/${prefix}_h.index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Search and calculate a score for similar sequences in a query and a target database.\nTags: protein sequence, databases, clustering, searching, indexing, mmseqs2", "answer": "\nprocess MMSEQS_SEARCH {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:14.7e284--pl5321h6a68c12_2':\n        'biocontainers/mmseqs2:14.7e284--pl5321h6a68c12_2' }\"\n\n    input:\n    tuple val(meta), path(db_query)\n    tuple val(meta2), path(db_target)\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: db_search\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: \"*.dbtype\"\n    def args3 = task.ext.args3 ?: \"*.dbtype\"\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$db_query\" == \"${prefix}\" || \"$db_target\" == \"${prefix}\"  ) error \"Input and output names of databases are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    mkdir -p ${prefix}\n\n    # Extract files with specified args based suffix | remove suffix | isolate longest common substring of files\n    DB_QUERY_PATH_NAME=\\$(find -L \"$db_query/\" -maxdepth 1 -name \"$args2\" | sed 's/\\\\.[^.]*\\$//' | sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n    DB_TARGET_PATH_NAME=\\$(find -L \"$db_target/\" -maxdepth 1 -name \"$args3\" | sed 's/\\\\.[^.]*\\$//' | sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n\n    mmseqs \\\\\n        search \\\\\n        \\$DB_QUERY_PATH_NAME \\\\\n        \\$DB_TARGET_PATH_NAME \\\\\n        ${prefix}/${prefix} \\\\\n        tmp1 \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --compressed 1\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$db_query\" == \"${prefix}\" || \"$db_target\" == \"${prefix}\"  ) error \"Input and output names of databases are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    mkdir -p $prefix\n    touch ${prefix}/${prefix}.{0..9}\n    touch ${prefix}/${prefix}.dbtype\n    touch ${prefix}/${prefix}.index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: /')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes the lowest common ancestor by identifying the query sequence homologs against the target database.\nTags: protein sequence, nucleotide sequence, databases, taxonomy, homologs, mmseqs2", "answer": "process MMSEQS_TAXONOMY {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:15.6f452--pl5321h6a68c12_0':\n        'biocontainers/mmseqs2:15.6f452--pl5321h6a68c12_0' }\"\n\n    input:\n    tuple val(meta), path(db_query)\n    path(db_target)\n\n    output:\n    tuple val(meta), path(\"${prefix}_taxonomy\"), emit: db_taxonomy\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: \"*.dbtype\" //represents the db_query\n    def args3 = task.ext.args3 ?: \"*.dbtype\" //represents the db_target\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mkdir -p ${prefix}_taxonomy\n\n    # Extract files with specified args based suffix | remove suffix | isolate longest common substring of files\n    DB_QUERY_PATH_NAME=\\$(find -L \"${db_query}/\" -maxdepth 1 -name \"${args2}\" | sed 's/\\\\.[^.]*\\$//' | sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n    DB_TARGET_PATH_NAME=\\$(find -L \"${db_target}/\" -maxdepth 1 -name \"${args3}\" | sed 's/\\\\.[^.]*\\$//' | sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n\n    mmseqs \\\\\n        taxonomy \\\\\n        \\$DB_QUERY_PATH_NAME \\\\\n        \\$DB_TARGET_PATH_NAME \\\\\n        ${prefix}_taxonomy/${prefix} \\\\\n        tmp1 \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --compressed 1\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mkdir -p ${prefix}_taxonomy\n    touch ${prefix}_taxonomy/${prefix}.{0..25}\n    touch ${prefix}_taxonomy/${prefix}.dbtype\n    touch ${prefix}_taxonomy/${prefix}.index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates sequence index for mmseqs database\nTags: protein sequence, databases, clustering, searching, indexing", "answer": "process MMSEQS_CREATEINDEX {\n    tag \"${meta.id}\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mmseqs2:15.6f452--pl5321h6a68c12_0':\n        'biocontainers/mmseqs2:15.6f452--pl5321h6a68c12_0' }\"\n\n    input:\n    tuple val(meta), path(db)\n\n    output:\n    tuple val(meta), path(db) , emit: db_indexed\n    path \"versions.yml\"       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: \"*.dbtype\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    DB_INPUT_PATH_NAME=\\$(find -L \"$db/\" -maxdepth 1 -name \"$args2\" | sed 's/\\\\.[^.]*\\$//' |  sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n\n    mmseqs \\\\\n        createindex \\\\\n        \\${DB_INPUT_PATH_NAME} \\\\\n        tmp1 \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --compressed 1\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    DB_INPUT_PATH_NAME=\\$(find -L \"$db/\" -maxdepth 1 -name \"$args2\" | sed 's/\\\\.[^.]*\\$//' |  sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' )\n\n    touch \"\\${DB_PATH_NAME}.idx\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mmseqs: \\$(mmseqs | grep 'Version' | sed 's/MMseqs2 Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cell and nuclear segmentation with star-convex shapes\nTags: stardist, segmentation, image", "answer": "process STARDIST {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"ghcr.io/schapirolabor/stardist:0.9.1\"\n\n    input:\n    tuple val(meta), path(image)\n\n    output:\n    tuple val(meta), path(\"*.stardist.tif\"), emit: mask\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args               = task.ext.args   ?: ''\n    def prefix             = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    stardist-predict2d \\\\\n        -i $image \\\\\n        -o . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stardist: \\$( python -m pip show --version stardist | grep \"Version\" | sed -e \"s/Version: //g\" )\n        python: \\$( python --version | sed -e \"s/Python //g\" )\n        tensorflow: \\$( python -m pip show --version tensorflow | grep \"Version\" | sed -e \"s/Version: //g\" )\n        tifffile: \\$( python -m pip show --version tifffile | grep \"Version\" | sed -e \"s/Version: //g\" )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args               = task.ext.args   ?: ''\n    def prefix             = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.stardist.tif\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stardist: \\$( python -m pip show --version stardist | grep \"Version\" | sed -e \"s/Version: //g\" )\n        python: \\$( python --version | sed -e \"s/Python //g\" )\n        tensorflow: \\$( python -m pip show --version tensorflow | grep \"Version\" | sed -e \"s/Version: //g\" )\n        tifffile: \\$( python -m pip show --version tifffile | grep \"Version\" | sed -e \"s/Version: //g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Use pangenome outputs for GWAS\nTags: gwas, pangenome, prokaryote", "answer": "process SCOARY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/scoary:1.6.16--py_2' :\n        'biocontainers/scoary:1.6.16--py_2' }\"\n\n    input:\n    tuple val(meta), path(genes), path(traits)\n    path(tree)\n\n    output:\n    tuple val(meta), path(\"*.csv\"), emit: csv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def newick_tree = tree ? \"-n ${tree}\" : \"\"\n    \"\"\"\n    scoary \\\\\n        $args \\\\\n        --no-time \\\\\n        --threads $task.cpus \\\\\n        --traits $traits \\\\\n        --genes $genes\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        scoary: \\$( scoary --version 2>&1 )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: FASTQ summary statistics in JSON format\nTags: fastq, summary, statistics", "answer": "process FASTQSCAN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fastq-scan:0.4.4--h7d875b9_0' :\n        'biocontainers/fastq-scan:0.4.4--h7d875b9_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.json\"), emit: json\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    zcat $reads | \\\\\n        fastq-scan \\\\\n        $args > ${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastqscan: \\$( echo \\$(fastq-scan -v 2>&1) | sed 's/^.*fastq-scan //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Demultiplexer for Nanopore samples\nTags: demultiplex", "answer": "process QCAT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/qcat:1.1.0--py_0' :\n        'biocontainers/qcat:1.1.0--py_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    val   barcode_kit\n\n    output:\n    tuple val(meta), path(\"fastq/*.fastq.gz\"), emit: reads\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ## Unzip fastq file\n    ## qcat doesn't support zipped files yet\n    FILE=$reads\n    if [[ \\$FILE == *.gz ]]\n    then\n        zcat $reads > unzipped.fastq\n        FILE=unzipped.fastq\n    fi\n\n    qcat \\\\\n        -f \\$FILE \\\\\n        -b ./fastq \\\\\n        --kit $barcode_kit\n\n    ## Zip fastq files\n    gzip fastq/*\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        qcat: \\$(qcat --version 2>&1 | sed 's/^.*qcat //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Quality Assessment Tool for Genome Assemblies\nTags: quast, assembly, quality, contig, scaffold", "answer": "process QUAST {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/quast:5.2.0--py39pl5321h2add14b_1' :\n        'biocontainers/quast:5.2.0--py39pl5321h2add14b_1' }\"\n\n    input:\n    tuple val(meta) , path(consensus)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(gff)\n\n    output:\n    tuple val(meta), path(\"${prefix}\")                   , emit: results\n    tuple val(meta), path(\"${prefix}.tsv\")               , emit: tsv\n    tuple val(meta), path(\"${prefix}_transcriptome.tsv\") , optional: true , emit: transcriptome\n    tuple val(meta), path(\"${prefix}_misassemblies.tsv\") , optional: true , emit: misassemblies\n    tuple val(meta), path(\"${prefix}_unaligned.tsv\")     , optional: true , emit: unaligned\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args   ?: ''\n    prefix        = task.ext.prefix ?: \"${meta.id}\"\n    def features  = gff             ?  \"--features $gff\" : ''\n    def reference = fasta           ?  \"-r $fasta\"       : ''\n    \"\"\"\n    quast.py \\\\\n        --output-dir $prefix \\\\\n        $reference \\\\\n        $features \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        ${consensus.join(' ')}\n\n    ln -s ${prefix}/report.tsv ${prefix}.tsv\n    [ -f  ${prefix}/contigs_reports/all_alignments_transcriptome.tsv ] && ln -s ${prefix}/contigs_reports/all_alignments_transcriptome.tsv ${prefix}_transcriptome.tsv\n    [ -f  ${prefix}/contigs_reports/misassemblies_report.tsv         ] && ln -s ${prefix}/contigs_reports/misassemblies_report.tsv ${prefix}_misassemblies.tsv\n    [ -f  ${prefix}/contigs_reports/unaligned_report.tsv             ] && ln -s ${prefix}/contigs_reports/unaligned_report.tsv ${prefix}_unaligned.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        quast: \\$(quast.py --version 2>&1 | sed 's/^.*QUAST v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args      = task.ext.args   ?: ''\n    prefix        = task.ext.prefix ?: \"${meta.id}\"\n    def features  = gff             ? \"--features $gff\" : ''\n    def reference = fasta           ? \"-r $fasta\" : ''\n\n    \"\"\"\n    mkdir -p $prefix\n    touch $prefix/report.tsv\n    touch $prefix/report.html\n    touch $prefix/report.pdf\n    touch $prefix/quast.log\n    touch $prefix/transposed_report.txt\n    touch $prefix/transposed_report.tex\n    touch $prefix/icarus.html\n    touch $prefix/report.tex\n    touch $prefix/report.txt\n\n    mkdir -p $prefix/basic_stats\n    touch $prefix/basic_stats/cumulative_plot.pdf\n    touch $prefix/basic_stats/Nx_plot.pdf\n    touch $prefix/basic_stats/genome_GC_content_plot.pdf\n    touch $prefix/basic_stats/GC_content_plot.pdf\n\n    mkdir -p $prefix/icarus_viewers\n    touch $prefix/icarus_viewers/contig_size_viewer.html\n\n    ln -s $prefix/report.tsv ${prefix}.tsv\n\n    if [ $fasta ]; then\n        touch $prefix/basic_stats/NGx_plot.pdf\n        touch $prefix/basic_stats/gc.icarus.txt\n\n        mkdir -p $prefix/aligned_stats\n        touch $prefix/aligned_stats/NAx_plot.pdf\n        touch $prefix/aligned_stats/NGAx_plot.pdf\n        touch $prefix/aligned_stats/cumulative_plot.pdf\n\n        mkdir -p $prefix/contigs_reports\n        touch $prefix/contigs_reports/all_alignments_transcriptome.tsv\n        touch $prefix/contigs_reports/contigs_report_transcriptome.mis_contigs.info\n        touch $prefix/contigs_reports/contigs_report_transcriptome.stderr\n        touch $prefix/contigs_reports/contigs_report_transcriptome.stdout\n        touch $prefix/contigs_reports/contigs_report_transcriptome.unaligned.info\n        mkdir -p $prefix/contigs_reports/minimap_output\n        touch $prefix/contigs_reports/minimap_output/transcriptome.coords\n        touch $prefix/contigs_reports/minimap_output/transcriptome.coords.filtered\n        touch $prefix/contigs_reports/minimap_output/transcriptome.coords_tmp\n        touch $prefix/contigs_reports/minimap_output/transcriptome.sf\n        touch $prefix/contigs_reports/minimap_output/transcriptome.unaligned\n        touch $prefix/contigs_reports/minimap_output/transcriptome.used_snps\n        touch $prefix/contigs_reports/misassemblies_frcurve_plot.pdf\n        touch $prefix/contigs_reports/misassemblies_plot.pdf\n        touch $prefix/contigs_reports/misassemblies_report.tex\n        touch $prefix/contigs_reports/misassemblies_report.tsv\n        touch $prefix/contigs_reports/misassemblies_report.txt\n        touch $prefix/contigs_reports/transcriptome.mis_contigs.fa\n        touch $prefix/contigs_reports/transposed_report_misassemblies.tex\n        touch $prefix/contigs_reports/transposed_report_misassemblies.tsv\n        touch $prefix/contigs_reports/transposed_report_misassemblies.txt\n        touch $prefix/contigs_reports/unaligned_report.tex\n        touch $prefix/contigs_reports/unaligned_report.tsv\n        touch $prefix/contigs_reports/unaligned_report.txt\n\n        mkdir -p $prefix/genome_stats\n        touch $prefix/genome_stats/genome_info.txt\n        touch $prefix/genome_stats/transcriptome_gaps.txt\n        touch $prefix/icarus_viewers/alignment_viewer.html\n\n        ln -sf ${prefix}/contigs_reports/misassemblies_report.tsv ${prefix}_misassemblies.tsv\n        ln -sf ${prefix}/contigs_reports/unaligned_report.tsv ${prefix}_unaligned.tsv\n        ln -sf ${prefix}/contigs_reports/all_alignments_transcriptome.tsv ${prefix}_transcriptome.tsv\n\n    fi\n\n    if ([ $fasta ] && [ $gff ]); then\n        touch $prefix/genome_stats/features_cumulative_plot.pdf\n        touch $prefix/genome_stats/features_frcurve_plot.pdf\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        quast: \\$(quast.py --version 2>&1 | sed 's/^.*QUAST v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Rapid identification of Staphylococcus aureus agr locus type and agr operon variants\nTags: fasta, virulence, Staphylococcus aureus", "answer": "process AGRVATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/agrvate:1.0.2--hdfd78af_0' :\n        'biocontainers/agrvate:1.0.2--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${fasta.baseName}-results/${fasta.baseName}-summary.tab\"), emit: summary\n    path \"${fasta.baseName}-results\"                                                , emit: results_dir\n    path \"versions.yml\"                                                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    agrvate \\\\\n        $args \\\\\n        -i $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agrvate: \\$(echo \\$(agrvate -v 2>&1) | sed 's/agrvate v//;')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${fasta.baseName}-results\n    touch ${fasta.baseName}-results/${fasta.baseName}-summary.tab\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        agrvate: \\$(echo \\$(agrvate -v 2>&1) | sed 's/agrvate v//;')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Validate samplesheet or PEP config against a schema\nTags: eido, validate, schema, format, pep", "answer": "process EIDO_VALIDATE {\n    tag \"$samplesheet\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://containers.biocontainers.pro/s3/SingImgsRepo/eido/0.1.9_cv2/eido_0.1.9_cv2.sif' :\n        'docker.io/biocontainers/eido:0.1.9_cv2' }\"\n\n    input:\n    path samplesheet\n    path schema\n    path pep_input_base_dir\n\n    output:\n    path \"versions.yml\"  , emit: versions\n    path \"*.log\"         , emit: log\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"validation\"\n    \"\"\"\n    eido validate $args $samplesheet -s $schema -e > ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        eido: \\$(echo \\$(eido --version 2>&1) | sed 's/^.*eido //;s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert any PEP project or Nextflow samplesheet to any format\nTags: eido, convert, PEP, format, samplesheet", "answer": "process EIDO_CONVERT {\n    tag \"$samplesheet\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://containers.biocontainers.pro/s3/SingImgsRepo/eido/0.1.9_cv1/eido_0.1.9_cv1.sif' :\n        'docker.io/biocontainers/eido:0.1.9_cv1' }\"\n\n    input:\n    path samplesheet\n    val format\n    path pep_input_base_dir\n\n    output:\n    path \"versions.yml\"           , emit: versions\n    path \"${prefix}.${format}\"    , emit: samplesheet_converted\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"samplesheet_converted\"\n    \"\"\"\n    eido \\\\\n        convert \\\\\n        -f $format \\\\\n        $samplesheet \\\\\n        $args \\\\\n        -p samples=${prefix}.${format}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        eido: \\$(echo \\$(eido --version 2>&1) | sed 's/^.*eido //;s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Finds full-length LTR retrotranspsons in genome sequences using the\nparallel version of LTR_Finder\n\nTags: genomics, annotation, parallel, repeat, long terminal retrotransposon, retrotransposon", "answer": "process LTRFINDER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ltr_finder_parallel:1.1--hdfd78af_0':\n        'biocontainers/ltr_finder_parallel:1.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.scn\")      , emit: scn\n    tuple val(meta), path(\"*.gff3\")     , emit: gff\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args            = task.ext.args ?: ''\n    def prefix          = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    LTR_FINDER_parallel \\\\\n        -seq $fasta \\\\\n        -threads $task.cpus \\\\\n        $args\n\n    mv \"${fasta}.finder.combine.scn\"    \"${prefix}.scn\"\n    mv \"${fasta}.finder.combine.gff3\"   \"${prefix}.gff3\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        LTR_FINDER_parallel: \\$(LTR_FINDER_parallel -h | grep 'Version:' | sed 's/Version: //')\n        ltr_finder: \\$(ltr_finder -h 2>&1 | grep 'ltr_finder' | sed 's/ltr_finder //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args            = task.ext.args ?: ''\n    def prefix          = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.scn\"\n    touch \"${prefix}.gff3\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        LTR_FINDER_parallel: \\$(LTR_FINDER_parallel -h | grep 'Version:' | sed 's/Version: //')\n        ltr_finder: \\$(ltr_finder -h 2>&1 | grep 'ltr_finder' | sed 's/ltr_finder //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Perform HLA-I typing of sequencing data\nTags: hla-typing, ILP, HLA-I", "answer": "process OPTITYPE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-f3579993d544920cc7c09e8ddf77569e95ea8950:d3ee2331cb4615915b1eda5d23f231da6b0741d7-0' :\n        'biocontainers/mulled-v2-f3579993d544920cc7c09e8ddf77569e95ea8950:d3ee2331cb4615915b1eda5d23f231da6b0741d7-0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path(\"${prefix}/*.tsv\"), emit: hla_type\n    tuple val(meta), path(\"${prefix}/*.pdf\"), emit: coverage_plot\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args   ?: ''\n    def args2 = task.ext.args2  ?: ''\n    prefix    = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    # Create a config for OptiType on a per sample basis with task.ext.args2\n\n    #Doing it old school now\n    echo \"[mapping]\" > config.ini\n    echo \"razers3=razers3\" >> config.ini\n    echo \"threads=$task.cpus\" >> config.ini\n    echo \"[ilp]\" >> config.ini\n    echo \"$args2\" >> config.ini\n    echo \"threads=1\" >> config.ini\n    echo \"[behavior]\" >> config.ini\n    echo \"deletebam=true\" >> config.ini\n    echo \"unpaired_weight=0\" >> config.ini\n    echo \"use_discordant=false\" >> config.ini\n\n    # Run the actual OptiType typing with args\n    OptiTypePipeline.py -i ${bam} -c config.ini --${meta.seq_type} $args --prefix $prefix --outdir $prefix\n\n    #Couldn't find a nicer way of doing this\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        optitype: \\$(cat \\$(which OptiTypePipeline.py) | grep -e \"Version:\" | sed -e \"s/Version: //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Quality control of riboseq bam data\nTags: riboseq, quality, bam", "answer": "process RIBOTISH_QUALITY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ribotish:0.2.7--pyhdfd78af_0':\n        'biocontainers/ribotish:0.2.7--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(gtf)\n\n    output:\n    tuple val(meta), path(\"*.txt\")    , emit: distribution\n    tuple val(meta), path(\"*.pdf\")    , emit: pdf\n    tuple val(meta), path(\"*.para.py\"), emit: offset\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ribotish quality \\\\\n        -b $bam \\\\\n        -g $gtf \\\\\n        -o ${prefix}_qual.txt \\\\\n        -f ${prefix}_qual.pdf \\\\\n        -r ${prefix}.para.py \\\\\n        -p $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ribotish: \\$(ribotish --version | sed 's/ribotish //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_qual.txt ${prefix}_qual.pdf ${prefix}.para.py\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ribotish: \\$(ribotish --version | sed 's/ribotish //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Quality control of riboseq bam data\nTags: riboseq, predict, bam", "answer": "process RIBOTISH_PREDICT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ribotish:0.2.7--pyhdfd78af_0':\n        'biocontainers/ribotish:0.2.7--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam_ribo), path(bai_ribo)\n    tuple val(meta2), path(bam_ti), path(bai_ti)\n    tuple val(meta3), path(fasta), path(gtf)\n    tuple val(meta4), path(candidate_orfs)\n    tuple val(meta5), path(para_ribo)\n    tuple val(meta6), path(para_ti)\n\n    output:\n    tuple val(meta), path(\"*_pred.txt\")        , emit: predictions\n    tuple val(meta), path(\"*_all.txt\")         , emit: all\n    tuple val(meta), path(\"*_transprofile.py\") , emit: transprofile\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    ribo_bam_cmd = ''\n    ti_bam_cmd = ''\n    if (bam_ribo){\n        ribo_bam_cmd = \"-b ${bam_ribo.join(',')}\"\n        if (para_ribo){\n            ribo_bam_cmd += \" --ribopara ${para_ribo.join(',')}\"\n        }\n    }\n    if (bam_ti){\n        ti_bam_cmd = \"-t ${bam_ti.join(',')}\"\n        if (para_tis){\n            ti_bam_cmd += \" --tisparapara  ${para_ti.join(',')}\"\n        }\n    }\n    \"\"\"\n    ribotish predict \\\\\n        $ribo_bam_cmd \\\\\n        $ti_bam_cmd \\\\\n        -f $fasta \\\\\n        -g $gtf \\\\\n        -o ${prefix}_pred.txt \\\\\n        --allresult ${prefix}_all.txt \\\\\n        --transprofile ${prefix}_transprofile.py \\\\\n        -p $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ribotish: \\$(ribotish --version | sed 's/ribotish //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_pred.txt\n    touch ${prefix}_all.txt\n    touch ${prefix}_transprofile.py\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ribotish: \\$(ribotish --version | sed 's/ribotish //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: msisensor2 detection of MSI regions.\nTags: msi", "answer": "process MSISENSOR2_MSI {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/msisensor2:0.1--hd03093a_0':\n        'biocontainers/msisensor2:0.1--hd03093a_0' }\"\n\n    input:\n    tuple val(meta), path(tumor_bam), path(tumor_bam_index), path(normal_bam), path(normal_bam_index), path(intervals)\n    path scan\n    path(models, stageAs: \"models/*\")\n\n    output:\n    tuple val(meta), path(\"${prefix}\")        , emit: msi\n    tuple val(meta), path(\"${prefix}_dis\")    , emit: distribution\n    tuple val(meta), path(\"${prefix}_somatic\"), emit: somatic\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def scan_cmd          = scan       ? \"-d $scan\"       : \"\"\n    def model_cmd         = models     ? \"-M models/\"     : \"\"\n    def tumor_bam_cmd     = tumor_bam  ? \"-t $tumor_bam\"  : \"\"\n    def normal_bam_cmd    = normal_bam ? \"-n $normal_bam\" : \"\"\n    def interval_command  = intervals  ? \"-e $intervals\"  : \"\"\n    \"\"\"\n    msisensor2 msi \\\\\n        -b ${task.cpus} \\\\\n        $args \\\\\n        $model_cmd \\\\\n        $scan_cmd \\\\\n        $interval_command \\\\\n        $tumor_bam_cmd \\\\\n        $normal_bam_cmd \\\\\n        -o $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        msisensor2: \\$(echo \\$(msisensor2 2> >(grep Version) | sed 's/Version: v//g'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: msisensor2 detection of MSI regions.\nTags: msi", "answer": "process MSISENSOR2_SCAN {\n    tag \"$fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/msisensor2:0.1--hd03093a_0':\n        'biocontainers/msisensor2:0.1--hd03093a_0' }\"\n\n    input:\n    path fasta\n    val output\n\n    output:\n    path output_path   , emit: scan\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def inputs      = fasta.collect{ \"-d $it\"}.join(\" \")\n    output_path = output ?: \"output.scan\"\n    \"\"\"\n    msisensor2 scan \\\\\n        $args \\\\\n        $inputs \\\\\n        -o $output_path\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        msisensor2: \\$(echo \\$(msisensor2 2> >(grep Version) | sed 's/Version: v//g'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: simulating sequence reads from a reference genome\nTags: simulate, fasta, reads", "answer": "process WGSIM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/wgsim:1.0--h5bf99c6_4':\n        'biocontainers/wgsim:1.0--h5bf99c6_4' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.fastq\"), emit: fastq\n    path \"versions.yml\",              emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def WGSIM_VERSION = \"0.3.1-r13\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    wgsim \\\\\n        $args \\\\\n        $fasta \\\\\n        ${prefix}_1.fastq ${prefix}_2.fastq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wgsim: $WGSIM_VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Summary statistics for GFA files\nTags: summary, statistics, gfa, rgfa, graph, genomics", "answer": "process GFATOOLS_STAT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gfatools:0.5--he4a0461_4':\n        'biocontainers/gfatools:0.5--he4a0461_4' }\"\n\n    input:\n    tuple val(meta), path(gfa)\n\n    output:\n    tuple val(meta), path(\"*.stats\"), emit: stats\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gfatools \\\\\n        stat \\\\\n        $args \\\\\n        $gfa \\\\\n        > ${prefix}.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gfatools: \\$( gfatools version | sed '1!d; s/.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gfatools: \\$( gfatools version | sed '1!d; s/.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts GFA or rGFA files to FASTA\nTags: gfa, rgfa, fasta, assembly, genome graph, genomics", "answer": "process GFATOOLS_GFA2FA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gfatools:0.5--he4a0461_4':\n        'biocontainers/gfatools:0.5--he4a0461_4' }\"\n\n    input:\n    tuple val(meta), path(gfa)\n\n    output:\n    tuple val(meta), path(\"*.fasta.gz\"), emit: fasta\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gfatools \\\\\n        gfa2fa \\\\\n        $args \\\\\n        $gfa \\\\\n        | gzip -c > ${prefix}.fasta.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gfatools: \\$( gfatools version | sed '1!d; s/.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fasta.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gfatools: \\$( gfatools version | sed '1!d; s/.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cluster nucleotide sequences using sequence similarity\nTags: cluster, nucleotide, alignment, fasta", "answer": "process CDHIT_CDHITEST {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cd-hit%3A4.8.1--h5b5514e_7':\n        'biocontainers/cd-hit:4.8.1--h5b5514e_7' }\"\n\n    input:\n    tuple val(meta), path(sequences)\n\n    output:\n    tuple val(meta), path(\"*.{fa,fq}\")    ,emit: fasta\n    tuple val(meta), path(\"*.clstr\")      ,emit: clusters\n    path \"versions.yml\"                   ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"${sequences}\" ==~ /(.*f[astn]*a(.gz)?$)/ ? \"fa\" : \"fq\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[cd-hit-est] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    cd-hit-est \\\\\n        $args \\\\\n        -i ${sequences} \\\\\n        -o ${meta.id}.${suffix} \\\\\n        -M $avail_mem \\\\\n        -T $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cdhit: \\$(cd-hit-est -h | head -n 1 | sed 's/^.*====== CD-HIT version //;s/ (built on .*) ======//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def suffix  = task.ext.suffix ?: \"${sequences}\" ==~ /(.*f[astn]*a(.gz)?$)/ ? \"fa\" : \"fq\"\n\n    \"\"\"\n    touch ${meta.id}.${suffix}\n    touch ${meta.id}.${suffix}.clstr\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cdhit: \\$(cd-hit-est -h | head -n 1 | sed 's/^.*====== CD-HIT version //;s/ (built on .*) ======//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Cluster protein sequences using sequence similarity\nTags: cluster, protein, alignment, fasta", "answer": "process CDHIT_CDHIT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cd-hit%3A4.8.1--h5b5514e_7':\n        'biocontainers/cd-hit:4.8.1--h5b5514e_7' }\"\n\n    input:\n    tuple val(meta), path(sequences)\n\n    output:\n    tuple val(meta), path(\"*.fasta\")    ,emit: fasta\n    tuple val(meta), path(\"*.clstr\")    ,emit: clusters\n    path \"versions.yml\"                 ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[cd-hit] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    cd-hit \\\\\n        $args \\\\\n        -i $sequences \\\\\n        -o ${prefix}.fasta \\\\\n        -M $avail_mem \\\\\n        -T $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cdhit: \\$(cd-hit -h | head -n 1 | sed 's/^.*====== CD-HIT version //;s/ (built on .*) ======//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extension of Porechop whose purpose is to process adapter sequences in ONT reads.\nTags: porechop_abi, adapter, nanopore", "answer": "process PORECHOP_ABI {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/porechop_abi:0.5.0--py310h590eda1_0':\n        'biocontainers/porechop_abi:0.5.0--py310h590eda1_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\") , emit: reads\n    tuple val(meta), path(\"*.log\")      , emit: log\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}.porechop_abi\"\n    if (\"$reads\" == \"${prefix}.fastq.gz\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    porechop_abi \\\\\n        --input $reads \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        --output ${prefix}.fastq.gz \\\\\n        | tee ${prefix}.log\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        porechop_abi: \\$( porechop_abi --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}.porechop_abi\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.fastq.gz\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        porechop_abi: \\$( porechop_abi --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Adapter removal and demultiplexing of Oxford Nanopore reads\nTags: adapter, nanopore, demultiplexing", "answer": "process PORECHOP_PORECHOP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/porechop:0.2.4--py39h7cff6ad_2' :\n        'biocontainers/porechop:0.2.4--py39h7cff6ad_2' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: reads\n    tuple val(meta), path(\"*.log\")     , emit: log\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    porechop \\\\\n        -i $reads \\\\\n        -t $task.cpus \\\\\n        $args \\\\\n        -o ${prefix}.fastq.gz \\\\\n        > ${prefix}.log\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        porechop: \\$( porechop --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fastq\n    gzip ${prefix}.fastq\n    touch ${prefix}.log\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        porechop: \\$( porechop --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Runs the Clippy CLIP peak caller\nTags: iCLIP, eCLIP, CLIP", "answer": "process CLIPPY {\n    tag \"$meta.id\"\n    label \"process_high\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/clippy:1.5.0--pyhdfd78af_0' :\n        'biocontainers/clippy:1.5.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path gtf\n    path fai\n\n    output:\n    tuple val(meta), path(\"*_Peaks.bed\")             ,emit: peaks\n    tuple val(meta), path(\"*_Summits.bed\")           ,emit: summits\n    tuple val(meta), path(\"*_intergenic_regions.gtf\"),emit: intergenic_gtf, optional: true\n    path \"versions.yml\"                              ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    clippy -i $bed \\\n        -o $prefix \\\n        -a $gtf \\\n        -g $fai \\\n        -t ${task.cpus} \\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        clippy: \\$(clippy -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computational framework for tracking and quantifying DNA damage patterns among ancient DNA sequencing reads generated by Next-Generation Sequencing platforms.\nTags: ancient DNA, DNA damage, NGS, damage patterns, bam", "answer": "process MAPDAMAGE2 {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mapdamage2:2.2.1--pyr40_0' :\n        'biocontainers/mapdamage2:2.2.1--pyr40_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path(fasta)\n\n    output:\n    tuple val(meta), path(\"results_*/Runtime_log.txt\")                                    ,emit: runtime_log\n    tuple val(meta), path(\"results_*/Fragmisincorporation_plot.pdf\"), optional: true      ,emit: fragmisincorporation_plot\n    tuple val(meta), path(\"results_*/Length_plot.pdf\"), optional: true                    ,emit: length_plot\n    tuple val(meta), path(\"results_*/misincorporation.txt\"), optional: true               ,emit: misincorporation\n    tuple val(meta), path(\"results_*/lgdistribution.txt\"), optional: true                 ,emit: lgdistribution\n    tuple val(meta), path(\"results_*/dnacomp.txt\"), optional: true                        ,emit: dnacomp\n    tuple val(meta), path(\"results_*/Stats_out_MCMC_hist.pdf\"), optional: true            ,emit: stats_out_mcmc_hist\n    tuple val(meta), path(\"results_*/Stats_out_MCMC_iter.csv\"), optional: true            ,emit: stats_out_mcmc_iter\n    tuple val(meta), path(\"results_*/Stats_out_MCMC_trace.pdf\"), optional: true           ,emit: stats_out_mcmc_trace\n    tuple val(meta), path(\"results_*/Stats_out_MCMC_iter_summ_stat.csv\"), optional: true  ,emit: stats_out_mcmc_iter_summ_stat\n    tuple val(meta), path(\"results_*/Stats_out_MCMC_post_pred.pdf\"), optional: true       ,emit: stats_out_mcmc_post_pred\n    tuple val(meta), path(\"results_*/Stats_out_MCMC_correct_prob.csv\"), optional: true    ,emit: stats_out_mcmc_correct_prob\n    tuple val(meta), path(\"results_*/dnacomp_genome.csv\"), optional: true                 ,emit: dnacomp_genome\n    tuple val(meta), path(\"results_*/*rescaled.bam\"), optional: true                      ,emit: rescaled\n    tuple val(meta), path(\"results_*/5pCtoT_freq.txt\"), optional: true                    ,emit: pctot_freq\n    tuple val(meta), path(\"results_*/3pGtoA_freq.txt\"), optional: true                    ,emit: pgtoa_freq\n    tuple val(meta), path(\"results_*/*.fasta\"), optional: true                            ,emit: fasta\n    tuple val(meta), path(\"*/\"), optional: true                                           ,emit: folder\n    path \"versions.yml\",emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mapDamage \\\\\n            $args \\\\\n            -i $bam \\\\\n            -r $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mapdamage2: \\$(echo \\$(mapDamage --version))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Builds a BLAST database\nTags: fasta, blast, database", "answer": "process BLAST_MAKEBLASTDB {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${meta.id}\"), emit: db\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getExtension() == \"gz\" ? true : false\n    def fasta_name = is_compressed ? fasta.getBaseName() : fasta\n    \"\"\"\n    if [ \"${is_compressed}\" == \"true\" ]; then\n        gzip -c -d ${fasta} > ${fasta_name}\n    fi\n\n    makeblastdb \\\\\n        -in ${fasta_name} \\\\\n        ${args}\n    mkdir ${prefix}\n    mv ${fasta_name}* ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(blastn -version 2>&1 | sed 's/^.*blastn: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getExtension() == \"gz\" ? true : false\n    def fasta_name = is_compressed ? fasta.getBaseName() : fasta\n    \"\"\"\n    touch ${fasta_name}.fasta\n    touch ${fasta_name}.fasta.ndb\n    touch ${fasta_name}.fasta.nhr\n    touch ${fasta_name}.fasta.nin\n    touch ${fasta_name}.fasta.njs\n    touch ${fasta_name}.fasta.not\n    touch ${fasta_name}.fasta.nsq\n    touch ${fasta_name}.fasta.ntf\n    touch ${fasta_name}.fasta.nto\n    mkdir ${prefix}\n    mv ${fasta_name}* ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(blastn -version 2>&1 | sed 's/^.*blastn: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: BLASTP (Basic Local Alignment Search Tool- Protein) compares an amino acid (protein) query sequence against a protein database\nTags: fasta, blast, blastp, protein", "answer": "process BLAST_BLASTP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(db)\n    val out_ext\n\n    output:\n    tuple val(meta), path(\"*.xml\"), optional: true, emit: xml\n    tuple val(meta), path(\"*.tsv\"), optional: true, emit: tsv\n    tuple val(meta), path(\"*.csv\"), optional: true, emit: csv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getExtension() == \"gz\" ? true : false\n    def fasta_name = is_compressed ? fasta.getBaseName() : fasta\n    switch ( out_ext ) {\n        case \"xml\": outfmt = 5; break\n        case \"tsv\": outfmt = 6; break\n        case \"csv\": outfmt = 10; break\n        default:\n            outfmt = '6';\n            out_ext = 'tsv';\n            log.warn(\"Unknown output file format provided (${out_ext}): selecting BLAST default of tabular BLAST output (tsv)\");\n            break\n    }\n\n    \"\"\"\n    if [ \"${is_compressed}\" == \"true\" ]; then\n        gzip -c -d ${fasta} > ${fasta_name}\n    fi\n\n    DB=`find -L ./ -name \"*.phr\" | sed 's/\\\\.phr\\$//'`\n    blastp \\\\\n        -query ${fasta_name} \\\\\n        -out ${prefix}.${out_ext} \\\\\n        -db \\$DB \\\\\n        -num_threads ${task.cpus} \\\\\n        -outfmt ${outfmt} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(blastp -version 2>&1 | sed 's/^.*blastp: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    switch ( out_ext ) {\n        case \"xml\": outfmt = 5; break\n        case \"tsv\": outfmt = 6; break\n        case \"csv\": outfmt = 10; break\n        default:\n            outfmt = '6';\n            out_ext = 'tsv';\n            log.warn(\"Unknown output file format provided (${out_ext}): selecting BLAST default of tabular BLAST output (tsv)\");\n            break\n    }\n\n    \"\"\"\n    touch ${prefix}.${out_ext}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(blastp -version 2>&1 | sed 's/^.*blastp: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Downloads a BLAST database from NCBI\nTags: fasta, blast, download, database", "answer": "process BLAST_UPDATEBLASTDB {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta), val(name)\n\n    output:\n    tuple val(meta), path(prefix), emit: db\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}; cd ${prefix}\n\n    update_blastdb.pl \\\\\n        ${name} \\\\\n        ${args}\n\n    cd ..\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        updateblastdb: \\$(update_blastdb.pl -version 2>&1 | tail -n1 | rev | cut -f1 -d ' ' | rev )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    touch ${prefix}/${name}.ndb\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        updateblastdb: \\$(update_blastdb.pl -version 2>&1 | tail -n1 | rev | cut -f1 -d ' ' | rev )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Retrieve entries from a BLAST database\nTags: fasta, blast, database, retrieval, identifier", "answer": "process BLAST_BLASTDBCMD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta) , val(entry), path(entry_batch)\n    tuple val(meta2), path(db)\n\n    output:\n    tuple val(meta), path(\"*.fasta\"), optional: true, emit: fasta\n    tuple val(meta), path(\"*.txt\")  , optional: true, emit: text\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    assert (!entry && entry_batch) || (entry && !entry_batch) : \"ERROR: You must use either entry or entry_batch, not both at the same time\"\n    def input = ''\n    if (entry) {\n        input = \"-entry ${entry}\"\n    } else {\n        input = \"-entry_batch ${entry_batch}\"\n    }\n    def extension  = args.contains(\"-outfmt\") && !args.contains(\"-outfmt %f\") ? \"txt\" : \"fasta\"\n    \"\"\"\n    DB=`find -L ./ -name \"*.nhr\" | sed 's/\\\\.nhr\\$//'`\n    if test -z \"\\$DB\"\n    then\n        DB=`find -L ./ -name \"*.phr\" | sed 's/\\\\.phr\\$//'`\n    fi\n\n    blastdbcmd \\\\\n        -db \\$DB \\\\\n        ${args} \\\\\n        -out ${prefix}.${extension} \\\\\n        ${input}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(blastdbcmd -version 2>&1 | head -n1 | sed 's/^.*blastdbcmd: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension  = args.contains(\"-outfmt\") && !args.contains(\"-outfmt %f\") ? \"txt\" : \"fasta\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(blastdbcmd -version 2>&1 | head -n1 | sed 's/^.*blastdbcmd: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Queries a BLAST DNA database\nTags: fasta, blast, blastn, DNA sequence", "answer": "process BLAST_BLASTN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(db)\n\n    output:\n    tuple val(meta), path('*.txt'), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getExtension() == \"gz\" ? true : false\n    def fasta_name = is_compressed ? fasta.getBaseName() : fasta\n\n    \"\"\"\n    if [ \"${is_compressed}\" == \"true\" ]; then\n        gzip -c -d ${fasta} > ${fasta_name}\n    fi\n\n    DB=`find -L ./ -name \"*.nal\" | sed 's/\\\\.nal\\$//'`\n    if [ -z \"\\$DB\" ]; then\n        DB=`find -L ./ -name \"*.nin\" | sed 's/\\\\.nin\\$//'`\n    fi\n    echo Using \\$DB\n\n    blastn \\\\\n        -num_threads ${task.cpus} \\\\\n        -db \\$DB \\\\\n        -query ${fasta_name} \\\\\n        ${args} \\\\\n        -out ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(blastn -version 2>&1 | sed 's/^.*blastn: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(blastn -version 2>&1 | sed 's/^.*blastn: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Queries a BLAST DNA database\nTags: fasta, blast, tblastn, DNA sequence", "answer": "process BLAST_TBLASTN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/blast:2.15.0--pl5321h6f7f691_1':\n        'biocontainers/blast:2.15.0--pl5321h6f7f691_1' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(db)\n\n    output:\n    tuple val(meta), path('*.txt'), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getExtension() == \"gz\" ? true : false\n    def fasta_name = is_compressed ? fasta.getBaseName() : fasta\n    \"\"\"\n    if [ \"${is_compressed}\" == \"true\" ]; then\n        gzip -c -d ${fasta} > ${fasta_name}\n    fi\n\n    DB=`find -L ./ -name \"*.nal\" | sed 's/\\\\.nal\\$//'`\n    if [ -z \"\\$DB\" ]; then\n        DB=`find -L ./ -name \"*.nin\" | sed 's/\\\\.nin\\$//'`\n    fi\n    echo Using \\$DB\n\n    tblastn \\\\\n        -num_threads ${task.cpus} \\\\\n        -db \\$DB \\\\\n        -query ${fasta_name} \\\\\n        ${args} \\\\\n        -out ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(tblastn -version 2>&1 | sed 's/^.*tblastn: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        blast: \\$(tblastn -version 2>&1 | sed 's/^.*tblastn: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: De novo assembler for single molecule sequencing reads\nTags: assembly, genome, de novo, genome assembler, single molecule", "answer": "process FLYE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/flye:2.9--py39h6935b12_1' :\n        'biocontainers/flye:2.9--py39h6935b12_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    val mode\n\n    output:\n    tuple val(meta), path(\"*.fasta.gz\"), emit: fasta\n    tuple val(meta), path(\"*.gfa.gz\")  , emit: gfa\n    tuple val(meta), path(\"*.gv.gz\")   , emit: gv\n    tuple val(meta), path(\"*.txt\")     , emit: txt\n    tuple val(meta), path(\"*.log\")     , emit: log\n    tuple val(meta), path(\"*.json\")    , emit: json\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def valid_mode = [\"--pacbio-raw\", \"--pacbio-corr\", \"--pacbio-hifi\", \"--nano-raw\", \"--nano-corr\", \"--nano-hq\"]\n    if ( !valid_mode.contains(mode) )  { error \"Unrecognised mode to run Flye. Options: ${valid_mode.join(', ')}\" }\n    \"\"\"\n    flye \\\\\n        $mode \\\\\n        $reads \\\\\n        --out-dir . \\\\\n        --threads \\\\\n        $task.cpus \\\\\n        $args\n\n    gzip -c assembly.fasta > ${prefix}.assembly.fasta.gz\n    gzip -c assembly_graph.gfa > ${prefix}.assembly_graph.gfa.gz\n    gzip -c assembly_graph.gv > ${prefix}.assembly_graph.gv.gz\n    mv assembly_info.txt ${prefix}.assembly_info.txt\n    mv flye.log ${prefix}.flye.log\n    mv params.json ${prefix}.params.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        flye: \\$( flye --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo stub | gzip -c > ${prefix}.assembly.fasta.gz\n    echo stub | gzip -c > ${prefix}.assembly_graph.gfa.gz\n    echo stub | gzip -c > ${prefix}.assembly_graph.gv.gz\n    echo contig_1 > ${prefix}.assembly_info.txt\n    echo stub > ${prefix}.flye.log\n    echo stub > ${prefix}.params.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        flye: \\$( flye --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Indexes a fasta reference genome ready for chromatin profiling.\nTags: index, fasta, genome, reference", "answer": "process CHROMAP_INDEX {\n    tag \"$fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/chromap:0.2.6--hdcf5f25_0' :\n        'biocontainers/chromap:0.2.6--hdcf5f25_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path (\"*.index\"), emit: index\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${fasta.baseName}\"\n    \"\"\"\n    chromap \\\\\n        -i \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        -o ${prefix}.index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        chromap: \\$(echo \\$(chromap --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${fasta.baseName}\"\n    \"\"\"\n    touch ${prefix}.index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        chromap: \\$(echo \\$(chromap --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs preprocessing and alignment of chromatin fastq files to\nfasta reference files using chromap.\n\nTags: chromap, alignment, map, fastq, bam, sam, hi-c, atac-seq, chip-seq, trimming, duplicate removal", "answer": "process CHROMAP_CHROMAP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-1f09f39f20b1c4ee36581dc81cc323c70e661633:6500f0fa0c9536821177168555632d9811670937-0' :\n        'biocontainers/mulled-v2-1f09f39f20b1c4ee36581dc81cc323c70e661633:6500f0fa0c9536821177168555632d9811670937-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(index)\n    path barcodes\n    path whitelist\n    path chr_order\n    path pairs_chr_order\n\n    output:\n    tuple val(meta), path(\"*.bed.gz\")     , optional:true, emit: bed\n    tuple val(meta), path(\"*.bam\")        , optional:true, emit: bam\n    tuple val(meta), path(\"*.tagAlign.gz\"), optional:true, emit: tagAlign\n    tuple val(meta), path(\"*.pairs.gz\")   , optional:true, emit: pairs\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args_list = args.tokenize()\n\n    def file_extension = args.contains(\"--SAM\") ? 'sam' : args.contains(\"--TagAlign\")? 'tagAlign' : args.contains(\"--pairs\")? 'pairs' : 'bed'\n    if (barcodes) {\n        args_list << \"-b ${barcodes.join(',')}\"\n        if (whitelist) {\n            args_list << \"--barcode-whitelist $whitelist\"\n        }\n    }\n    if (chr_order) {\n        args_list << \"--chr-order $chr_order\"\n    }\n    if (pairs_chr_order){\n        args_list << \"--pairs-natural-chr-order $pairs_chr_order\"\n    }\n    def final_args = args_list.join(' ')\n    def compression_cmds = \"gzip -n ${prefix}.${file_extension}\"\n    if (args.contains(\"--SAM\")) {\n        compression_cmds = \"\"\"\n        samtools view $args2 -@ $task.cpus -bh \\\\\n            -o ${prefix}.bam ${prefix}.${file_extension}\n        rm ${prefix}.${file_extension}\n        \"\"\"\n    }\n    if (meta.single_end) {\n        \"\"\"\n        chromap \\\\\n            $final_args \\\\\n            -t $task.cpus \\\\\n            -x $index \\\\\n            -r $fasta \\\\\n            -1 ${reads.join(',')} \\\\\n            -o ${prefix}.${file_extension}\n\n        $compression_cmds\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            chromap: \\$(echo \\$(chromap --version 2>&1))\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        chromap \\\\\n            $final_args \\\\\n            -t $task.cpus \\\\\n            -x $index \\\\\n            -r $fasta \\\\\n            -1 ${reads[0]} \\\\\n            -2 ${reads[1]} \\\\\n            -o ${prefix}.${file_extension}\n\n        $compression_cmds\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            chromap: \\$(echo \\$(chromap --version 2>&1))\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.bed.gz\n    touch ${prefix}.bam\n    echo \"\" | gzip > ${prefix}.tagAlign.gz\n    echo \"\" | gzip > ${prefix}.pairs.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        chromap: \\$(echo \\$(chromap --version 2>&1))\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: a pangenome-scale aligner\nTags: long read alignment, pangenome-scale, all versus all, mashmap, wavefront", "answer": "process WFMASH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/wfmash:0.13.0--h11f254b_0':\n        'biocontainers/wfmash:0.13.0--h11f254b_0' }\"\n\n    input:\n    tuple val(meta), path(fasta_gz), path(paf), path(gzi), path(fai)\n    val(query_self)\n    path(fasta_query_list)\n\n    output:\n    tuple val(meta), path(\"*.paf\"), emit: paf\n    path \"versions.yml\"           , emit: versions\n\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ? task.ext.prefix : paf ? \"${meta.id}\" + \".\" + paf.baseName.split(\"\\\\.\")[-1] : \"${meta.id}\"\n    def query_list = fasta_query_list ? \"--query-file-list ${fasta_query_list}\" : \"\"\n    def query = query_self ? \"${fasta_gz}\" : \"\"\n    def paf_mappings = paf ? \"--input-paf ${paf}\" : \"\"\n    \"\"\"\n    wfmash \\\\\n        ${fasta_gz} \\\\\n        $query \\\\\n        $query_list \\\\\n        --threads $task.cpus \\\\\n        $paf_mappings \\\\\n        $args > ${prefix}.paf\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wfmash: \\$(echo \\$(wfmash --version 2>&1) | cut -f 1 -d '-' | cut -f 2 -d 'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs assembly scaffolding using YaHS\nTags: scaffolding, assembly, yahs, hic", "answer": "process YAHS {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/yahs:1.2a.2--h7132678_0':\n        'biocontainers/yahs:1.2a.2--h7132678_0' }\"\n\n    input:\n    tuple val(meta), path(hic_map)\n    path fasta\n    path fai\n\n    output:\n    tuple val(meta), path(\"*scaffolds_final.fa\") , emit: scaffolds_fasta\n    tuple val(meta), path(\"*scaffolds_final.agp\"), emit: scaffolds_agp\n    tuple val(meta), path(\"*bin\")                , emit: binary\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    yahs $args \\\\\n        -o $prefix \\\\\n        $fasta \\\\\n        $hic_map\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        yahs: \\$(yahs --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${prefix}_scaffold_final.fa\n    touch ${prefix}_scaffolds_final.agp\n    touch ${prefix}.bin\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        yahs: \\$(yahs --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Downloads and builds Kraken2 standard database\nTags: metagenomics, db, classification, build, kraken2, standard, download", "answer": "process KRAKEN2_BUILDSTANDARD {\n    label 'process_high'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-8706a1dd73c6cc426e12dd4dd33a5e917b3989ae:c8cbdc8ff4101e6745f8ede6eb5261ef98bdaff4-0':\n        'biocontainers/mulled-v2-8706a1dd73c6cc426e12dd4dd33a5e917b3989ae:c8cbdc8ff4101e6745f8ede6eb5261ef98bdaff4-0' }\"\n\n    input:\n    val cleaning\n\n    output:\n    path(\"$prefix\"),     emit: db\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"kraken2_standard_db\"\n    runclean = cleaning ? \"kraken2-build --clean --db ${db}\" : \"\"\n    \"\"\"\n    kraken2-build \\\\\n        --standard \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --db ${prefix}\n    $runclean\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kraken2: \\$(echo \\$(kraken2 --version 2>&1) | sed 's/^.*Kraken version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"kraken2_standard_db\"\n    \"\"\"\n    mkdir -p \"$prefix\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kraken2: \\$(echo \\$(kraken2 --version 2>&1) | sed 's/^.*Kraken version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Adds fasta files to a Kraken2 taxonomic database\nTags: metagenomics, db, classification, build, kraken2, add", "answer": "process KRAKEN2_ADD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-8706a1dd73c6cc426e12dd4dd33a5e917b3989ae:c8cbdc8ff4101e6745f8ede6eb5261ef98bdaff4-0' :\n        'biocontainers/mulled-v2-8706a1dd73c6cc426e12dd4dd33a5e917b3989ae:c8cbdc8ff4101e6745f8ede6eb5261ef98bdaff4-0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path taxonomy_names, stageAs: 'taxonomy/names.dmp'\n    path taxonomy_nodes, stageAs: 'taxonomy/nodes.dmp'\n    path accession2taxid, stageAs: 'taxonomy/*'\n\n    output:\n    tuple val(meta), path(\"$prefix\"), emit: db\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    mv \"taxonomy\" ${prefix}\n\n    echo ${fasta} |\\\\\n    tr -s \" \" \"\\\\012\" |\\\\\n    xargs -I {} -n1 kraken2-build \\\\\n        --add-to-library {} \\\\\n        --db ${prefix} \\\\\n        --threads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kraken2: \\$(echo \\$(kraken2 --version 2>&1) | sed 's/^.*Kraken version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir \"$prefix\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kraken2: \\$(echo \\$(kraken2 --version 2>&1) | sed 's/^.*Kraken version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Classifies metagenomic sequence data\nTags: classify, metagenomics, fastq, db", "answer": "process KRAKEN2_KRAKEN2 {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-8706a1dd73c6cc426e12dd4dd33a5e917b3989ae:c8cbdc8ff4101e6745f8ede6eb5261ef98bdaff4-0' :\n        'biocontainers/mulled-v2-8706a1dd73c6cc426e12dd4dd33a5e917b3989ae:c8cbdc8ff4101e6745f8ede6eb5261ef98bdaff4-0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  db\n    val save_output_fastqs\n    val save_reads_assignment\n\n    output:\n    tuple val(meta), path('*.classified{.,_}*')     , optional:true, emit: classified_reads_fastq\n    tuple val(meta), path('*.unclassified{.,_}*')   , optional:true, emit: unclassified_reads_fastq\n    tuple val(meta), path('*classifiedreads.txt')   , optional:true, emit: classified_reads_assignment\n    tuple val(meta), path('*report.txt')                           , emit: report\n    path \"versions.yml\"                                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def paired       = meta.single_end ? \"\" : \"--paired\"\n    def classified   = meta.single_end ? \"${prefix}.classified.fastq\"   : \"${prefix}.classified#.fastq\"\n    def unclassified = meta.single_end ? \"${prefix}.unclassified.fastq\" : \"${prefix}.unclassified#.fastq\"\n    def classified_option = save_output_fastqs ? \"--classified-out ${classified}\" : \"\"\n    def unclassified_option = save_output_fastqs ? \"--unclassified-out ${unclassified}\" : \"\"\n    def readclassification_option = save_reads_assignment ? \"--output ${prefix}.kraken2.classifiedreads.txt\" : \"--output /dev/null\"\n    def compress_reads_command = save_output_fastqs ? \"pigz -p $task.cpus *.fastq\" : \"\"\n\n    \"\"\"\n    kraken2 \\\\\n        --db $db \\\\\n        --threads $task.cpus \\\\\n        --report ${prefix}.kraken2.report.txt \\\\\n        --gzip-compressed \\\\\n        $unclassified_option \\\\\n        $classified_option \\\\\n        $readclassification_option \\\\\n        $paired \\\\\n        $args \\\\\n        $reads\n\n    $compress_reads_command\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kraken2: \\$(echo \\$(kraken2 --version 2>&1) | sed 's/^.*Kraken version //; s/ .*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def paired       = meta.single_end ? \"\" : \"--paired\"\n    def classified   = meta.single_end ? \"${prefix}.classified.fastq.gz\"   : \"${prefix}.classified_1.fastq.gz ${prefix}.classified_2.fastq.gz\"\n    def unclassified = meta.single_end ? \"${prefix}.unclassified.fastq.gz\" : \"${prefix}.unclassified_1.fastq.gz ${prefix}.unclassified_2.fastq.gz\"\n    def readclassification_option = save_reads_assignment ? \"--output ${prefix}.kraken2.classifiedreads.txt\" : \"--output /dev/null\"\n    def compress_reads_command = save_output_fastqs ? \"pigz -p $task.cpus *.fastq\" : \"\"\n\n    \"\"\"\n    touch ${prefix}.kraken2.report.txt\n    if [ \"$save_output_fastqs\" == \"true\" ]; then\n        touch $classified\n        touch $unclassified\n    fi\n    if [ \"$save_reads_assignment\" == \"true\" ]; then\n        touch ${prefix}.kraken2.classifiedreads.txt\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kraken2: \\$(echo \\$(kraken2 --version 2>&1) | sed 's/^.*Kraken version //; s/ .*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Builds Kraken2 database\nTags: metagenomics, db, classification, build, kraken2", "answer": "process KRAKEN2_BUILD {\n    tag \"$meta.id\"\n    label 'process_medium'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-8706a1dd73c6cc426e12dd4dd33a5e917b3989ae:c8cbdc8ff4101e6745f8ede6eb5261ef98bdaff4-0':\n        'biocontainers/mulled-v2-8706a1dd73c6cc426e12dd4dd33a5e917b3989ae:c8cbdc8ff4101e6745f8ede6eb5261ef98bdaff4-0' }\"\n\n    input:\n    tuple val(meta), path(db)\n    val cleaning\n\n    output:\n    tuple val(meta), path(\"$prefix\"), emit: db\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    runclean = cleaning ? \"kraken2-build --clean --db ${db}\" : \"\"\n    \"\"\"\n    kraken2-build \\\\\n        --build \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --db ${db}\n    $runclean\n    if [[ \\$(basename ${db}) != \"${prefix}\" ]]; then\n        mv ${db}/* ${prefix}\n    fi\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kraken2: \\$(echo \\$(kraken2 --version 2>&1) | sed 's/^.*Kraken version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p \"$prefix\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kraken2: \\$(echo \\$(kraken2 --version 2>&1) | sed 's/^.*Kraken version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: assembles bacterial plasmids\nTags: assembly, plasmid, bacterial", "answer": "process PLASMIDID {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/plasmidid:1.6.5--hdfd78af_0' :\n        'biocontainers/plasmidid:1.6.5--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(scaffold)\n    path  fasta\n\n    output:\n    tuple val(meta), path(\"${prefix}/*final_results.html\"), emit: html\n    tuple val(meta), path(\"${prefix}/*final_results.tab\") , emit: tab\n    tuple val(meta), path(\"${prefix}/images/\")            , emit: images\n    tuple val(meta), path(\"${prefix}/logs/\")              , emit: logs\n    tuple val(meta), path(\"${prefix}/data/\")              , emit: data\n    tuple val(meta), path(\"${prefix}/database/\")          , emit: database\n    tuple val(meta), path(\"${prefix}/fasta_files/\")       , emit: fasta_files\n    tuple val(meta), path(\"${prefix}/kmer/\")              , emit: kmer\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    plasmidID \\\\\n        -d $fasta \\\\\n        -s $prefix \\\\\n        -c $scaffold \\\\\n        $args \\\\\n        -o .\n\n    mv NO_GROUP/$prefix ./$prefix\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        plasmidid: \\$(echo \\$(plasmidID --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Fixes prefixes from AdapterRemoval2 output to make sure no clashing read names are in the output. For use with DeDup.\nTags: adapterremoval, fastq, dedup", "answer": "process ADAPTERREMOVALFIXPREFIX {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/adapterremovalfixprefix:0.0.5--hdfd78af_2':\n        'biocontainers/adapterremovalfixprefix:0.0.5--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n\n    output:\n    tuple val(meta), path(\"*.fq.gz\"), emit: fixed_fastq\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$fastq\" == \"${prefix}.fq.gz\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    def VERSION = '0.0.5' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    AdapterRemovalFixPrefix \\\\\n        $fastq \\\\\n        $args \\\\\n        | gzip > ${prefix}.fq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        adapterremovalfixprefix: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: geofetch is a command-line tool that downloads and organizes data and metadata from GEO and SRA\nTags: GEO, expression, microarray, sequencing", "answer": "process GEOFETCH {\n    tag \"$geo_accession\"\n    label 'process_low'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/geofetch:0.12.6--pyh7cba7a3_0':\n        'biocontainers/geofetch:0.12.6--pyh7cba7a3_0' }\"\n\n    input:\n    val geo_accession\n\n    output:\n    tuple val(\"${geo_accession}\"), path(\"${geo_accession}/*.CEL.gz\"), emit: samples\n    path \"versions.yml\"                                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    geofetch \\\\\n        -i \\\\\n        $geo_accession \\\\\n        --processed \\\\\n        -g . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        geofetch: \\$(geofetch --version|& sed '1!d ; s/geofetch //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    mkdir -p ${geo_accession}\n    cd ${geo_accession}\n    touch foo.CEL\n    gzip foo.CEL\n    cd ..\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        geofetch: \\$(geofetch --version|& sed '1!d ; s/geofetch //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Build ganon database using custom reference sequences.\nTags: ganon, metagenomics, profiling, taxonomy, k-mer, database", "answer": "process GANON_BUILDCUSTOM {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ganon:2.0.0--py39ha35b9be_0':\n        'biocontainers/ganon:2.0.0--py39ha35b9be_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path taxonomy_files\n    path genome_size_files\n\n    output:\n    tuple val(meta), path(\"*.{hibf,ibf,tax}\")     , emit: db\n    tuple val(meta), path(\"*.info.tsv\")           , emit: info            , optional: true\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def taxonomy_args     = taxonomy_files    ? \"--taxonomy-files ${taxonomy_files}\" : \"\"\n    def genome_size_args  = genome_size_files ? \"--genome-size-files ${genome_size_files}\" : \"\"\n    \"\"\"\n    ganon \\\\\n        build-custom \\\\\n        --threads ${task.cpus} \\\\\n        --input $input \\\\\n        --db-prefix ${prefix} \\\\\n        $taxonomy_args \\\\\n        $genome_size_args \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ganon: \\$(echo \\$(ganon --version 2>1) | sed 's/.*ganon //g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def taxonomy_args     = taxonomy_files    ? \"--taxonomy-files ${taxonomy_files}\" : \"\"\n    def genome_size_args  = genome_size_files ? \"--genome-size-files ${genome_size_files}\" : \"\"\n    \"\"\"\n    touch ${prefix}.hibf\n    touch ${prefix}.tax\n    touch ${prefix}.info.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ganon: \\$(echo \\$(ganon --version 2>1) | sed 's/.*ganon //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Classify FASTQ files against ganon database\nTags: ganon, metagenomics, profiling, taxonomy, k-mer, classification, classify", "answer": "process GANON_CLASSIFY {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ganon:2.0.0--py39ha35b9be_0':\n        'biocontainers/ganon:2.0.0--py39ha35b9be_0' }\"\n\n    input:\n    tuple val(meta) , path(fastqs)\n    path(db)\n\n    output:\n    tuple val(meta), path(\"*.tre\"), emit: tre\n    tuple val(meta), path(\"*.rep\"), emit: report\n    tuple val(meta), path(\"*.one\"), emit: one           , optional: true\n    tuple val(meta), path(\"*.all\"), emit: all           , optional: true\n    tuple val(meta), path(\"*.unc\"), emit: unc           , optional: true\n    tuple val(meta), path(\"*.log\"), emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input  = meta.single_end ? \"--single-reads ${fastqs}\" : \"--paired-reads ${fastqs}\"\n    \"\"\"\n    dbprefix=\\$(find -L . -name '*.*ibf' | sed 's/\\\\.h\\\\?ibf\\$//')\n\n    ganon \\\\\n        classify \\\\\n        --db-prefix \\${dbprefix%%.*ibf} \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --output-prefix ${prefix} \\\\\n        $input \\\n        2>&1 | tee ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ganon: \\$(echo \\$(ganon --version 2>1) | sed 's/.*ganon //g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input  = meta.single_end ? \"--single-reads ${fastqs}\" : \"--paired-reads ${fastqs}\"\n    \"\"\"\n    touch ${prefix}.tre\n    touch ${prefix}.rep\n    touch ${prefix}.one\n    touch ${prefix}.all\n    touch ${prefix}.unc\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ganon: \\$(echo \\$(ganon --version 2>1) | sed 's/.*ganon //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate a multi-sample report file from the output of ganon report runs\nTags: ganon, metagenomics, profiling, taxonomy, k-mer, classification, report, table", "answer": "process GANON_TABLE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ganon:2.0.0--py39ha35b9be_0':\n        'biocontainers/ganon:2.0.0--py39ha35b9be_0' }\"\n\n    input:\n    tuple val(meta), path(tre)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ganon \\\\\n        table \\\\\n        --input ${tre} \\\\\n        --output-file ${prefix}.txt \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ganon: \\$(echo \\$(ganon --version 2>1) | sed 's/.*ganon //g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ganon: \\$(echo \\$(ganon --version 2>1) | sed 's/.*ganon //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate a ganon report file from the output of ganon classify\nTags: ganon, metagenomics, profiling, taxonomy, k-mer, classification, report", "answer": "process GANON_REPORT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ganon:2.0.0--py39ha35b9be_0':\n        'biocontainers/ganon:2.0.0--py39ha35b9be_0' }\"\n\n    input:\n    tuple val(meta), path(rep)\n    path db\n\n    output:\n    tuple val(meta), path(\"*.tre\"), emit: tre\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    dbprefix=\\$(find -L . -name '*.*ibf' | sed 's/\\\\.h\\\\?ibf\\$//')\n\n    ganon \\\\\n        report \\\\\n        --input ${rep} \\\\\n        --output-prefix ${prefix} \\\\\n        --db-prefix \\${dbprefix%%.*ibf} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ganon: \\$(echo \\$(ganon --version 2>1) | sed 's/.*ganon //g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.tre\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ganon: \\$(echo \\$(ganon --version 2>1) | sed 's/.*ganon //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A method to improve mappings on circular genomes, using the BWA mapper.\nTags: sort, example, genomics", "answer": "// This module does the following:\n//creating a modified reference genome, with an elongation_factoration of the an specified amount of bases\nprocess CIRCULARMAPPER_CIRCULARGENERATOR {\n\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/circularmapper:1.93.5--h2a3209d_3':\n        'biocontainers/circularmapper:1.93.5--h2a3209d_3' }\"\n\n    input:\n    tuple val(meta), path(reference)\n    tuple val(meta2), val(elongation_factor)\n    tuple val(meta3), val(target)\n\n    output:\n    tuple val(meta), path(\"*_${elongation_factor}.fasta\")    , emit: fasta\n    tuple val(meta), path(\"*${elongation_factor}_elongated\") , emit: elongated\n    path \"versions.yml\"                                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def full_extension = reference.getName().replaceFirst(reference.getSimpleName(), \"\")\n    \"\"\"\n    circulargenerator \\\n        -e ${elongation_factor} \\\n        -i ${reference} \\\n        -s ${target} \\\n        $args\n\n    ## circulargenerator has a hardcoded output name. Rename if necessary to use prefix.\n    if [[ \"${reference.getSimpleName()}_${elongation_factor}${full_extension}\" != \"${prefix}_${elongation_factor}.fasta\" ]]; then\n        mv ${reference.getSimpleName()}_${elongation_factor}${full_extension} ${prefix}_${elongation_factor}.fasta\n        mv ${reference}_${elongation_factor}_elongated ${prefix}.fasta_${elongation_factor}_elongated\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        circulargenerator: \\$(circulargenerator -h | grep 'usage' | sed 's/usage: CircularGenerator//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_${elongation_factor}.fasta\n    touch ${prefix}.fasta_${elongation_factor}_elongated\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        circulargenerator: \\$(circulargenerator -h | grep 'usage' | sed 's/usage: CircularGenerator//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Realign reads mapped with BWA to elongated reference genome\nTags: realign, circular, map, reference, fasta, bam, short-read, bwa", "answer": "process CIRCULARMAPPER_REALIGNSAMFILE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/circularmapper:1.93.5--h4a94de4_1':\n        'biocontainers/circularmapper:1.93.5--h4a94de4_1' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), val(elongation_factor)\n    tuple val(meta4), path(elongated_chr_list)\n    // NOTE: The elongated_chr_list is not used in the script, but is an implicit input that realignsamfile requires when using the `-f true` option.\n    //          In its absence, when `-f true` is set, realignsamfile will remove all @SQ tags from the BAM header, breaking the bamfile.\n\n    output:\n    tuple val(meta), path(\"*_realigned.bam\")    , emit: bam\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.93.5' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    realignsamfile \\\\\n        -Xmx${task.memory.toGiga()}g \\\\\n        ${args} \\\\\n        -e ${elongation_factor} \\\\\n        -i ${bam} \\\\\n        -r ${fasta}\n\n    ## realignsamfile has a hardcoded output name. Rename if necessary to use prefix.\n    if [[ \"${bam.getBaseName()}_realigned.bam\" != \"${prefix}_realigned.bam\" ]]; then\n        mv ${bam.getBaseName()}_realigned.bam ${prefix}_realigned.bam\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        CircularMapper: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.93.5' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}_realigned.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        CircularMapper: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This module combines samtools and samblaster in order to use\nsamblaster capability to filter or tag SAM files, with the advantage\nof maintaining both input and output in BAM format.\nSamblaster input must contain a sequence header: for this reason it has been piped\nwith the \"samtools view -h\" command.\nAdditional desired arguments for samtools can be passed using:\noptions.args2 for the input bam file\noptions.args3 for the output bam file\n\nTags: sort, duplicate marking, bam", "answer": "process SAMBLASTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-19fa9f1a5c3966b63a24166365e81da35738c5ab:60ebac4ad9c6530c0d7bf6844f52ec6916e1e0b1-0' :\n        'biocontainers/mulled-v2-19fa9f1a5c3966b63a24166365e81da35738c5ab:60ebac4ad9c6530c0d7bf6844f52ec6916e1e0b1-0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$bam\" == \"${prefix}.bam\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    samtools view -h $args2 $bam | \\\\\n    samblaster $args | \\\\\n    samtools view $args3 -Sb - >${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samblaster: \\$( samblaster -h 2>&1 | head -n 1 | sed 's/^samblaster: Version //' )\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if( \"$bam\" == \"${prefix}.bam\" ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch \"${prefix}.bam\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samblaster: \\$( samblaster -h 2>&1 | head -n 1 | sed 's/^samblaster: Version //' )\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A fast and scalable tool for bacterial pangenome analysis\nTags: gff, pan-genome, alignment", "answer": "process PANAROO_RUN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/panaroo:1.3.2--pyhdfd78af_0':\n        'biocontainers/panaroo:1.3.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gff)\n\n    output:\n    tuple val(meta), path(\"results/*\")                                      , emit: results\n    tuple val(meta), path(\"results/core_gene_alignment.aln\"), optional: true, emit: aln\n    path \"versions.yml\"                                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    panaroo \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        -o results \\\\\n        -i $gff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        panaroo: \\$(echo \\$(panaroo --version 2>&1) | sed 's/^.*panaroo //' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A small Java tool to calculate ratios between MT and nuclear sequencing reads in a given BAM file.\nTags: mtnucratio, ratio, reads, bam, mitochondrial to nuclear ratio, mitochondria, statistics", "answer": "process MTNUCRATIO {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mtnucratio:0.7--hdfd78af_2' :\n        'biocontainers/mtnucratio:0.7--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    val(mt_id)\n\n    output:\n    tuple val(meta), path(\"*.mtnucratio\"), emit: mtnucratio\n    tuple val(meta), path(\"*.json\")      , emit: json\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mtnucratio \\\\\n        $args \\\\\n        $bam \\\\\n        $mt_id\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mtnucratio: \\$(echo \\$(mtnucratio --version 2>&1) | head -n1 | sed 's/Version: //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GRIDSS is a module software suite containing tools useful for the detection of genomic rearrangements.\nTags: gridss, structural variants, bedpe, bed, vcf", "answer": "process GRIDSS_GRIDSSGENERATEPONBEDPE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"bioconda::gridss=2.13.2\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gridss:2.13.2--h270b39a_0':\n        'biocontainers/gridss:2.13.2--h270b39a_0' }\"\n\n    input:\n    tuple val(meta),  path(vcf), path(bedpe), path(bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(bwa_index)\n\n    output:\n    tuple val(meta), path(\"*.bedpe\"), emit: bedpe\n    tuple val(meta), path(\"*.bed\")  , emit: bed\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def vcf = vcf ? \"INPUT=${vcf}\" : \"\"\n    def bedpe = bedpe ? \"INPUT_BEDPE=${bedpe}\" : \"\"\n    def bed   = bed ? \"INPUT_BED=${bed}\" : \"\"\n    def bwa = bwa_index ? \"cp -s ${bwa_index}/* .\" : \"\"\n    def ref = bwa_index ? \"REFERENCE_SEQUENCE=${fasta}\" : \"\"\n\n    \"\"\"\n    ${bwa}\n    GeneratePonBedpe \\\\\n        ${vcf} \\\\\n        ${bedpe} \\\\\n        ${bed} \\\\\n        ${ref} \\\\\n        OUTPUT_BEDPE=${prefix}.bedpe \\\\\n        OUTPUT_BED=${prefix}.bed \\\\\n        THREADS=$task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        GeneratePonBedpe: \\$(echo \\$(GeneratePonBedpe --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bedpe\n    touch ${prefix}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        GeneratePonBedpe: \\$(echo \\$(GeneratePonBedpe --version 2>&1))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GRIDSS is a module software suite containing tools useful for the detection of genomic rearrangements.\nTags: gridss, structural variants, somatic variants, vcf", "answer": "process GRIDSS_GRIDSSSOMATICFILTER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"bioconda::gridss=2.13.2\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gridss:2.13.2--h270b39a_0':\n        'biocontainers/gridss:2.13.2--h270b39a_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    tuple val(meta2), path(pondir)\n\n    output:\n    tuple val(meta), path(\"*.high_confidence_somatic.vcf.bgz\")    , emit: high_conf_sv\n    tuple val(meta), path(\"*.all_somatic.vcf.bgz\")                , emit: all_sv\n    path \"versions.yml\"                                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def pondir = pondir ? \"--pondir ${pondir}\" : \"\"\n    def VERSION = '2.13.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    gridss_somatic_filter \\\\\n        --input $vcf \\\\\n        ${pondir} \\\\\n        --output ${prefix}.high_confidence_somatic.vcf \\\\\n        --fulloutput ${prefix}.all_somatic.vcf \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gridss: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.13.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.high_confidence_somatic.vcf.bgz\n    touch ${prefix}.all_somatic.vcf.bgz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gridss: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: GRIDSS is a module software suite containing tools useful for the detection of genomic rearrangements.\nTags: gridss, structural variants, bam, cram, vcf", "answer": "process GRIDSS_GRIDSS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gridss:2.13.2--h270b39a_0':\n        'biocontainers/gridss:2.13.2--h270b39a_0' }\"\n\n    input:\n    tuple val(meta) , path(inputs)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n    tuple val(meta4), path(bwa_index)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")       , emit: vcf\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.13.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def bwa = bwa_index ? \"cp -s ${bwa_index}/* .\" : \"\"\n\n    \"\"\"\n    ${bwa}\n\n    gridss \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --reference ${fasta} \\\\\n        --threads ${task.cpus} \\\\\n        --jvmheap ${task.memory.toGiga() - 1}g \\\\\n        --otherjvmheap ${task.memory.toGiga() - 1}g \\\\\n        ${inputs}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gridss: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.13.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def steps = args.contains(\"-s \") ? args.split('-s ')[-1].split(\" \")[0] :\n                args.contains(\"--steps \") ? args.split('--steps ')[-1].split(\" \")[0] :\n                \"all\"\n    def vcf = steps.contains(\"call\") || steps.contains(\"all\") ? \"echo '' | gzip > ${prefix}.vcf.gz\" : \"\"\n    \"\"\"\n    ${vcf}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gridss: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extracts reads mapped to chromosome 6 and any HLA decoys or chromosome 6 alternates.\nTags: HLA, genotype, RNA-seq", "answer": "process ARCASHLA_EXTRACT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/arcas-hla:0.5.0--hdfd78af_0':\n        'biocontainers/arcas-hla:0.5.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.fq.gz\")                 , emit: extracted_reads_fastq\n    path \"*.log\"                                     , emit: log\n    tuple val(meta), path(\"temp_files/**.sam\")       , emit: intermediate_sam,        optional: true\n    tuple val(meta), path(\"temp_files/**.bam\")       , emit: intermediate_bam,        optional: true\n    tuple val(meta), path(\"temp_files/**.sorted.bam\"), emit: intermediate_sorted_bam, optional: true\n    path \"versions.yml\"                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def single_end  = meta.single_end ? \"--single\" : \"\"\n    def VERSION = \"0.5.0\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    arcasHLA \\\\\n        extract \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        -o . \\\\\n        --temp temp_files/ \\\\\n        --log ${prefix}.log \\\\\n        $single_end \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        arcashla: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Build a normal database for coverage normalization from all the (GC-normalized) normal coverage files. N.B. as reported in https://www.bioconductor.org/packages/devel/bioc/vignettes/PureCN/inst/doc/Quick.html, it is advised to provide a normal panel (VCF format) to precompute mapping bias for faster runtimes.\nTags: copy number alteration calling, normal database, panel of normals, hybrid capture sequencing, targeted sequencing, DNA sequencing", "answer": "process PURECN_NORMALDB {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-582ac26068889091d5e798347c637f8208d77a71:a29c64a63498b1ee8b192521fdf6ed3c65506994-0':\n        'biocontainers/mulled-v2-582ac26068889091d5e798347c637f8208d77a71:a29c64a63498b1ee8b192521fdf6ed3c65506994-0' }\"\n\n    input:\n    tuple val(meta), path(coverage_files), path(normal_vcf), path(normal_vcf_tbi)\n    val   genome\n    val   assay\n\n    output:\n    tuple val(meta), path(\"normalDB*.rds\")               , emit: rds\n    tuple val(meta), path(\"interval_weights*.png\")       , emit: png\n    tuple val(meta), path(\"mapping_bias*.rds\")           , emit: bias_rds,    optional: true\n    tuple val(meta), path(\"mapping_bias_hq_sites*.bed\")  , emit: bias_bed,    optional: true\n    tuple val(meta), path(\"low_coverage_targets*.bed\")   , emit: low_cov_bed, optional: true\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def normal_panel = normal_vcf ? \"--normal-panel ${normal_vcf}\" : \"\"\n    def VERSION = '2.4.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    echo $coverage_files | tr ' ' '\\\\n' > coverages.list\n    library_path=\\$(Rscript -e 'cat(.libPaths(), sep = \"\\\\n\")')\n    Rscript \"\\$library_path\"/PureCN/extdata/NormalDB.R --out-dir ./ \\\\\n        --coverage-files coverages.list \\\\\n        --genome ${genome} \\\\\n        --assay ${assay} \\\\\n        ${normal_panel} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purecn: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def mapping_bias = args.contains(\"--normal-panel\") ? \"\" : \"touch mapping_bias_${prefix}_${genome}.rds\"\n    def mapping_bias_hq_sites = args.contains(\"--normal-panel\") ? \"\" : \"touch mapping_bias_hq_sites_${prefix}_${genome}.bed\"\n    def VERSION = '2.4.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch normalDB_${prefix}_${genome}.rds\n    ${mapping_bias}\n    ${mapping_bias_hq_sites}\n    touch interval_weights_${prefix}_${genome}.png\n    touch low_coverage_targets_${prefix}_${genome}.bed\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purecn: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate on and off-target intervals for PureCN from a list of targets\nTags: copy number alteration calling, genomic intervals, hybrid capture sequencing, targeted sequencing, DNA sequencing", "answer": "process PURECN_INTERVALFILE {\n    tag \"${meta.id}\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-582ac26068889091d5e798347c637f8208d77a71:a29c64a63498b1ee8b192521fdf6ed3c65506994-0':\n        'biocontainers/mulled-v2-582ac26068889091d5e798347c637f8208d77a71:a29c64a63498b1ee8b192521fdf6ed3c65506994-0' }\"\n\n    input:\n    tuple val(meta), path(target_bed)\n    tuple val(meta2), path(fasta)\n    val   genome\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    // Only produced if --export is used\n    tuple val(meta), path(\"*.bed\"), emit: bed, optional: true\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.4.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    library_path=\\$(Rscript -e 'cat(.libPaths(), sep = \"\\\\n\")')\n    Rscript \"\\$library_path\"/PureCN/extdata/IntervalFile.R \\\\\n        --in-file ${target_bed} \\\\\n        --fasta ${fasta} \\\\\n        --out-file ${prefix}.txt \\\\\n        --genome ${genome} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purecn: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bed = args.contains(\"--export\") ? \"touch ${prefix}.bed\" : \"\"\n    def VERSION = '2.4.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.txt\n    ${bed}\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purecn: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run PureCN workflow to normalize, segment and determine purity and ploidy\nTags: copy number alteration calling, hybrid capture sequencing, targeted sequencing, DNA sequencing", "answer": "process PURECN_RUN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-582ac26068889091d5e798347c637f8208d77a71:a29c64a63498b1ee8b192521fdf6ed3c65506994-0':\n        'biocontainers/mulled-v2-582ac26068889091d5e798347c637f8208d77a71:a29c64a63498b1ee8b192521fdf6ed3c65506994-0' }\"\n\n    input:\n    tuple val(meta), path(intervals), path(coverage)\n    path normal_db\n    val genome\n\n    output:\n    tuple val(meta), path(\"*.pdf\")                             , emit: pdf\n    tuple val(meta), path(\"*_local_optima.pdf\")                , emit: local_optima_pdf\n    tuple val(meta), path(\"*_dnacopy.seg\")                     , emit: seg\n    tuple val(meta), path(\"*_genes.csv\")                       , emit: genes_csv                   , optional: true\n    tuple val(meta), path(\"*_amplification_pvalues.csv\")       , emit: amplification_pvalues_csv   , optional: true\n    tuple val(meta), path(\"*.vcf.gz\")                          , emit: vcf_gz                      , optional: true\n    tuple val(meta), path(\"*_variants.csv\")                    , emit: variants_csv                , optional: true\n    tuple val(meta), path(\"*_loh.csv\")                         , emit: loh_csv                     , optional: true\n    tuple val(meta), path(\"*_chromosomes.pdf\")                 , emit: chr_pdf                     , optional: true\n    tuple val(meta), path(\"*_segmentation.pdf\")                , emit: segmentation_pdf            , optional: true\n    tuple val(meta), path(\"*_multisample.seg\")                 , emit: multisample_seg             , optional: true\n    path \"versions.yml\"                                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.4.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    library_path=\\$(Rscript -e 'cat(.libPaths(), sep = \"\\\\n\")')\n    Rscript \"\\$library_path\"/PureCN/extdata/PureCN.R \\\\\n        --out ./ \\\\\n        --tumor ${coverage} \\\\\n        --sampleid ${prefix} \\\\\n        --normaldb ${normal_db} \\\\\n        --intervals ${intervals} \\\\\n        --genome ${genome} \\\\\n        --parallel \\\\\n        --cores ${task.cpus} \\\\\n        --stats-file ${prefix}_stats.txt \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purecn: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.4.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.pdf\n    touch ${prefix}_local_optima.pdf\n    touch ${prefix}_dnacopy.seg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purecn: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate intervals coverage for each sample. N.B. the tool can not handle staging files with symlinks, stageInMode should be set to 'link'.\nTags: copy number alteration calling, intervals coverage, hybrid capture sequencing, targeted sequencing, DNA sequencing", "answer": "process PURECN_COVERAGE {\n    tag \"$meta.id\"\n    label 'process_low'\n    stageInMode \"link\"\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-582ac26068889091d5e798347c637f8208d77a71:a29c64a63498b1ee8b192521fdf6ed3c65506994-0':\n        'biocontainers/mulled-v2-582ac26068889091d5e798347c637f8208d77a71:a29c64a63498b1ee8b192521fdf6ed3c65506994-0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path intervals\n\n    output:\n    tuple val(meta), path(\"*.txt.gz\")      , emit: txt\n    //Not generated when --skip-gc-norm is set\n    tuple val(meta), path(\"*.png\")         , emit: png         , optional: true\n    tuple val(meta), path(\"*_loess_qc.txt\"), emit: loess_qc_txt, optional: true\n    tuple val(meta), path(\"*_loess.txt.gz\"), emit: loess_txt   , optional: true\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '2.4.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    if (task.stageInMode != 'link') {\n        error \"purecn/coverage can not handle staging files with symlinks. Please change the stageInmode option to 'Link'\"\n    }\n\n    \"\"\"\n    library_path=\\$(Rscript -e 'cat(.libPaths(), sep = \"\\\\n\")')\n    Rscript \"\\$library_path\"/PureCN/extdata/Coverage.R \\\\\n        --out-dir ./ \\\\\n        --bam ${bam} \\\\\n        --bai ${bai} \\\\\n        --intervals ${intervals} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purecn: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def png = args.contains(\"--skip-gc-norm\") ? \"\" : \"touch ${prefix}.png\"\n    def loess_qc_txt = args.contains(\"--skip-gc-norm\") ? \"\" : \"touch ${prefix}_loess_qc.txt\"\n    def loess_txt = args.contains(\"--skip-gc-norm\") ? \"\" : \"touch ${prefix}_loess.txt.gz\"\n    def VERSION = '2.4.0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    if (task.stageInMode != 'link') {\n        error \"purecn/coverage can not handle staging files with symlinks. Please change the stageInmode option to 'Link'\"\n    }\n\n    \"\"\"\n    touch ${prefix}.txt\n    touch ${prefix}.bed\n    ${png}\n    ${loess_qc_txt}\n    ${loess_txt}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        purecn: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Determine Shigella serotype from Illumina or Oxford Nanopore reads\nTags: fastq, shigella, serotype", "answer": "process SHIGATYPER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/shigatyper%3A2.0.1--pyhdfd78af_0':\n        'biocontainers/shigatyper:2.0.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"${prefix}.tsv\")     , emit: tsv\n    tuple val(meta), path(\"${prefix}-hits.tsv\"), optional: true, emit: hits\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (meta.is_ont) {\n        \"\"\"\n        shigatyper \\\\\n            $args \\\\\n            --SE $reads \\\\\n            --ont \\\\\n            --name $prefix\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            shigatyper: \\$(echo \\$(shigatyper --version 2>&1) | sed 's/^.*ShigaTyper //' )\n        END_VERSIONS\n        \"\"\"\n    } else if (meta.single_end) {\n        \"\"\"\n        shigatyper \\\\\n            $args \\\\\n            --SE $reads \\\\\n            --name $prefix\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            shigatyper: \\$(echo \\$(shigatyper --version 2>&1) | sed 's/^.*ShigaTyper //' )\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        shigatyper \\\\\n            $args \\\\\n            --R1 ${reads[0]} \\\\\n            --R2 ${reads[1]} \\\\\n            --name $prefix\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            shigatyper: \\$(echo \\$(shigatyper --version 2>&1) | sed 's/^.*ShigaTyper //' )\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Cluster sequences using a single-pass, greedy centroid-based clustering algorithm.\nTags: vsearch, clustering, microbiome", "answer": "process VSEARCH_CLUSTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-53dae514294fca7b44842b784ed85a5303ac2d80:7b3365d778c690ca79bc85aaaeb86bb39a2dec69-0':\n        'biocontainers/mulled-v2-53dae514294fca7b44842b784ed85a5303ac2d80:7b3365d778c690ca79bc85aaaeb86bb39a2dec69-0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path('*.aln.gz')                , optional: true, emit: aln\n    tuple val(meta), path('*.biom.gz')               , optional: true, emit: biom\n    tuple val(meta), path('*.mothur.tsv.gz')         , optional: true, emit: mothur\n    tuple val(meta), path('*.otu.tsv.gz')            , optional: true, emit: otu\n    tuple val(meta), path('*.bam')                   , optional: true, emit: bam\n    tuple val(meta), path('*.out.tsv.gz')            , optional: true, emit: out\n    tuple val(meta), path('*.blast.tsv.gz')          , optional: true, emit: blast\n    tuple val(meta), path('*.uc.tsv.gz')             , optional: true, emit: uc\n    tuple val(meta), path('*.centroids.fasta.gz')    , optional: true, emit: centroids\n    tuple val(meta), path('*.clusters.fasta*.gz')    , optional: true, emit: clusters\n    tuple val(meta), path('*.profile.txt.gz')        , optional: true, emit: profile\n    tuple val(meta), path('*.msa.fasta.gz')          , optional: true, emit: msa\n    path \"versions.yml\"                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (!args2.contains(\"--cluster_fast\") && !args2.contains(\"--cluster_size\") && !args2.contains(\"--cluster_smallmem\") && !args2.contains(\"--cluster_unoise\") ) {\n            error \"Unknown clustering option provided (${args2})\"\n        }\n    def out_ext = args3.contains(\"--alnout\") ? \"aln\" :\n                    args3.contains(\"--biomout\") ? \"biom\" :\n                    args3.contains(\"--blast6out\") ? \"blast.tsv\" :\n                    args3.contains(\"--centroids\") ? \"centroids.fasta\" :\n                    args3.contains(\"--clusters\") ? \"clusters.fasta\" :\n                    args3.contains(\"--mothur_shared_out\") ? \"mothur.tsv\" :\n                    args3.contains(\"--msaout\") ? \"msa.fasta\" :\n                    args3.contains(\"--otutabout\") ? \"otu.tsv\" :\n                    args3.contains(\"--profile\") ? \"profile.txt\" :\n                    args3.contains(\"--samout\") ? \"sam\" :\n                    args3.contains(\"--uc\") ? \"uc.tsv\" :\n                    args3.contains(\"--userout\") ? \"out.tsv\" :\n                    \"\"\n    if (out_ext == \"\") { error \"Unknown output file format provided (${args3})\" }\n    \"\"\"\n    vsearch \\\\\n        $args2 $fasta \\\\\n        $args3 ${prefix}.${out_ext} \\\\\n        --threads $task.cpus \\\\\n        $args\n\n    if [[ $args3 == \"--clusters\" ]]\n    then\n        gzip -n ${prefix}.${out_ext}*\n    elif [[ $args3 != \"--samout\" ]]\n    then\n        gzip -n ${prefix}.${out_ext}\n    else\n        samtools view -T $fasta -S -b ${prefix}.${out_ext} > ${prefix}.bam\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vsearch: \\$(vsearch --version 2>&1 | head -n 1 | sed 's/vsearch //g' | sed 's/,.*//g' | sed 's/^v//' | sed 's/_.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sort fasta entries by decreasing abundance (--sortbysize) or sequence length (--sortbylength).\nTags: vsearch/sort, vsearch, sort, amplicon sequences, metagenomics, genomics, population genetics", "answer": "process VSEARCH_SORT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vsearch:2.21.1--h95f258a_0':\n        'biocontainers/vsearch:2.21.1--h95f258a_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val sort_arg\n\n    output:\n    tuple val(meta), path(\"*.fasta\"), emit: fasta\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$fasta\" == \"${prefix}.fasta\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    vsearch \\\\\n        $sort_arg $fasta \\\\\n        --threads $task.cpus \\\\\n        --output ${prefix}.fasta \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vsearch: \\$(vsearch --version 2>&1 | head -n 1 | sed 's/vsearch //g;s/,.*//g;s/^v//;s/_.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vsearch: \\$(vsearch --version 2>&1 | head -n 1 | sed 's/vsearch //g;s/,.*//g;s/^v//;s/_.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compare target sequences to fasta-formatted query sequences using global pairwise alignment.\nTags: vsearch, usearch, alignment, fasta", "answer": "process VSEARCH_USEARCHGLOBAL {\n    tag \"${meta.id}\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vsearch:2.21.1--h95f258a_0':\n        'biocontainers/vsearch:2.21.1--h95f258a_0' }\"\n\n    input:\n    tuple val(meta), path(queryfasta)\n    path db\n    val idcutoff\n    val outoption\n    val user_columns\n\n    output:\n    tuple val(meta), path('*.aln')    , optional: true, emit: aln\n    tuple val(meta), path('*.biom')   , optional: true, emit: biom\n    tuple val(meta), path('*.lca')    , optional: true, emit: lca\n    tuple val(meta), path('*.mothur') , optional: true, emit: mothur\n    tuple val(meta), path('*.otu')    , optional: true, emit: otu\n    tuple val(meta), path('*.sam')    , optional: true, emit: sam\n    tuple val(meta), path('*.tsv')    , optional: true, emit: tsv\n    tuple val(meta), path('*.txt')    , optional: true, emit: txt\n    tuple val(meta), path('*.uc')     , optional: true, emit: uc\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def columns = user_columns ? \"--userfields ${user_columns}\" : ''\n    switch ( outoption ) {\n        case \"alnout\": outfmt = \"--alnout\"; out_ext = 'aln'; break\n        case \"biomout\": outfmt = \"--biomout\"; out_ext = 'biom'; break\n        case \"blast6out\": outfmt = \"--blast6out\"; out_ext = 'txt'; break\n        case \"mothur_shared_out\": outfmt = \"--mothur_shared_out\"; out_ext = 'mothur'; break\n        case \"otutabout\": outfmt = \"--otutabout\"; out_ext = 'otu'; break\n        case \"samout\": outfmt = \"--samout\"; out_ext = 'sam'; break\n        case \"uc\": outfmt = \"--uc\"; out_ext = 'uc'; break\n        case \"userout\": outfmt = \"--userout\"; out_ext = 'tsv'; break\n        case \"lcaout\": outfmt = \"--lcaout\"; out_ext = 'lca'; break\n        default:\n            outfmt = \"--alnout\";\n            out_ext = 'aln';\n            log.warn(\"Unknown output file format provided (${outoption}): selecting pairwise alignments (alnout)\");\n            break\n    }\n    \"\"\"\n    vsearch \\\\\n        --usearch_global $queryfasta \\\\\n        --db $db \\\\\n        --id $idcutoff \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        ${columns} \\\\\n        ${outfmt} ${prefix}.${out_ext}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vsearch: \\$(vsearch --version 2>&1 | head -n 1 | sed 's/vsearch //g' | sed 's/,.*//g' | sed 's/^v//' | sed 's/_.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Taxonomic classification using the sintax algorithm.\nTags: vsearch, sintax", "answer": "process VSEARCH_SINTAX {\n    tag \"${meta.id}\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vsearch:2.21.1--h95f258a_0':\n        'biocontainers/vsearch:2.21.1--h95f258a_0' }\"\n\n    input:\n    tuple val(meta), path(queryfasta)\n    path db\n\n    output:\n    tuple val(meta), path('*.tsv')   , optional: true, emit: tsv\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    vsearch \\\\\n        --sintax $queryfasta \\\\\n        --db $db \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        --tabbedout ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vsearch: \\$(vsearch --version 2>&1 | head -n 1 | sed 's/vsearch //g' | sed 's/,.*//g' | sed 's/^v//' | sed 's/_.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: write your description here\nTags: bam, statistics, genomics", "answer": "process BAMSTATS_GENERALSTATS {\n    tag \"$meta.id\"\n    label 'process_single'\n    conda \"bioconda::bamstats=0.3.5\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bamstats:0.3.5--he881be0_0':\n        'biocontainers/bamstats:0.3.5--he881be0_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.json\"), emit: json\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // Several ARGS are available.\n    //  -a is a helpfu; one where you can add a BED file\n    //  -u, --uniq outputs genomic coverage statistics for uniqely mapped reads\n    \"\"\"\n    bamstats \\\\\n        -i $bam \\\\\n        $args \\\\\n        -c $task.cpus \\\\\n        -o ${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamstats: \\$(echo \\$(bamstats --version 2>&1) | sed 's/^.*bamstats == version://; s/Using.*\\$//' | sed 's/built.*//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bamstats: \\$(echo \\$(bamstats --version 2>&1) | sed 's/^.*bamstats == version://; s/Using.*\\$//' | sed 's/built.*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert genomic BAM/SAM files to transcriptomic BAM/RAD files.\nTags: bam, transcriptome, transcriptomic, mudskipper, sam, rad", "answer": "process MUDSKIPPER_BULK {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mudskipper:0.1.0--h9f5acd7_1':\n        'biocontainers/mudskipper:0.1.0--h9f5acd7_1' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path index\n    path gtf\n    val rad\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\"), optional:true, emit: bam\n    tuple val(meta), path(\"${prefix}.rad\"), optional:true, emit: rad\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}.transcriptome\"\n    def annot_param = \"\"\n    if (index) {\n        annot_param = \"--index ${index}\"\n    } else {\n        annot_param = \"--gtf ${gtf}\"\n    }\n    def suffix = rad ? \"rad\" : \"bam\"\n    \"\"\"\n    export RUST_BACKTRACE=full\n    mudskipper \\\\\n        bulk \\\\\n        ${annot_param} \\\\\n        --alignment ${bam} \\\\\n        --out ${prefix}.${suffix} \\\\\n        --threads ${task.cpus} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mudskipper: \\$(echo \\$(mudskipper -V 2>&1) | sed 's/^.*mudskipper //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}.transcriptome\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mudskipper: \\$(echo \\$(mudskipper -V 2>&1) | sed 's/^.*mudskipper //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Build and store a gtf index, which is useful for converting genomic BAM/SAM files to transcriptomic BAM/SAM files.\nTags: bam, transcriptome, transcriptomic, index, mudskipper, sam", "answer": "process MUDSKIPPER_INDEX {\n    tag '$gtf'\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mudskipper:0.1.0--h9f5acd7_1':\n        'biocontainers/mudskipper:0.1.0--h9f5acd7_1' }\"\n\n    input:\n    path gtf\n\n    output:\n    path \"index/\"      , emit: index\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    export RUST_BACKTRACE=full\n    mudskipper \\\\\n        index \\\\\n        --gtf $gtf \\\\\n        --dir-index index\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mudskipper: \\$(echo \\$(mudskipper -V 2>&1) | sed 's/^.*mudskipper //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir index/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mudskipper: \\$(echo \\$(mudskipper -V 2>&1) | sed 's/^.*mudskipper //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Markup VCF file using rho-calls.\nTags: roh, rhocall, runs_of_homozygosity", "answer": "process RHOCALL_ANNOTATE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rhocall:0.5.1--py39hbf8eff0_0':\n        'biocontainers/rhocall:0.5.1--py39hbf8eff0_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n    tuple val(meta2), path(roh)\n    path bed\n\n    output:\n    tuple val(meta), path(\"*_rhocall.vcf\"), emit: vcf\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def az_bed = bed ? \"-b ${bed}\" : ''\n    \"\"\"\n    rhocall \\\\\n        annotate \\\\\n        $args \\\\\n        $az_bed \\\\\n        -r $roh \\\\\n        -o ${prefix}_rhocall.vcf \\\\\n        $vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rhocall: \\$(echo \\$(rhocall --version 2>&1) | sed 's/rhocall, version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_rhocall.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rhocall: \\$(echo \\$(rhocall --version 2>&1) | sed 's/rhocall, version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Call regions of homozygosity and make tentative UPD calls\nTags: roh, bcftools, runs_of_homozygosity", "answer": "process RHOCALL_VIZ {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rhocall:0.5.1--py39hbf8eff0_0':\n        'biocontainers/rhocall:0.5.1--py39hbf8eff0_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    tuple val(meta2), path(roh)\n\n    output:\n    tuple val(meta), path(\"${prefix}/${prefix}.bed\"), emit: bed\n    tuple val(meta), path(\"${prefix}/${prefix}.wig\"), emit: wig\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    rhocall \\\\\n        viz \\\\\n        $args \\\\\n        -r $roh \\\\\n        --out_dir ${prefix} \\\\\n        $vcf\n\n    mv ${prefix}/output.bed ${prefix}/${prefix}.bed\n    mv ${prefix}/output.wig ${prefix}/${prefix}.wig\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rhocall: \\$(echo \\$(rhocall --version 2>&1) | sed 's/rhocall, version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    touch ${prefix}/${prefix}.bed\n    touch ${prefix}/${prefix}.wig\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rhocall: \\$(echo \\$(rhocall --version 2>&1) | sed 's/rhocall, version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Manipulation, validation and exploration of pedigrees\nTags: pedigrees, ped, family", "answer": "process PEDDY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/peddy:0.4.8--pyh5e36f6f_0' :\n        'biocontainers/peddy:0.4.8--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_tbi)\n    path ped\n\n    output:\n    tuple val(meta), path(\"*.html\")     , emit: html\n    tuple val(meta), path(\"*.csv\")      , emit: csv\n    tuple val(meta), path(\"*.peddy.ped\"), emit: ped\n    tuple val(meta), path(\"*.png\")      , optional: true, emit: png\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    peddy \\\\\n        $args \\\\\n        --prefix $prefix \\\\\n        --plot \\\\\n        -p $task.cpus \\\\\n        $vcf \\\\\n        $ped\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        peddy: \\$( peddy --version 2>&1 | tail -1 | sed 's/peddy, version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.ped_check.csv\n    touch ${prefix}.vs.html\n    touch ${prefix}.het_check.csv\n    touch ${prefix}.sex_check.csv\n    touch ${prefix}.peddy.ped\n    touch ${prefix}.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        peddy: \\$( peddy --version 2>&1 | tail -1 | sed 's/peddy, version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: OrthoFinder is a fast, accurate and comprehensive platform for comparative genomics.\nTags: genomics, orthogroup, orthologs, gene, duplication, tree, phylogeny", "answer": "process ORTHOFINDER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/orthofinder:2.5.5--hdfd78af_2':\n        'biocontainers/orthofinder:2.5.5--hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(fastas, stageAs: 'input/')\n\n    output:\n    tuple val(meta), path(\"$prefix\")    , emit: orthofinder\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    prefix      = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir temp_pickle\n\n    orthofinder \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        -a $task.cpus \\\\\n        -p temp_pickle \\\\\n        -f input \\\\\n        -n $prefix\n\n    mv \\\\\n        input/OrthoFinder/Results_$prefix \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        orthofinder: \\$(orthofinder -h | sed -n 's/.*version \\\\(.*\\\\) Copy.*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args    = task.ext.args ?: ''\n    prefix      = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p    $prefix/Comparative_Genomics_Statistics\n    mkdir       $prefix/Gene_Duplication_Events\n    mkdir       $prefix/Gene_Trees\n    mkdir       $prefix/Orthogroup_Sequences\n    mkdir       $prefix/Orthogroups\n    mkdir       $prefix/Orthologues\n    mkdir       $prefix/Phylogenetic_Hierarchical_Orthogroups\n    mkdir       $prefix/Phylogenetically_Misplaced_Genes\n    mkdir       $prefix/Putative_Xenologs\n    mkdir       $prefix/Resolved_Gene_Trees\n    mkdir       $prefix/Single_Copy_Orthologue_Sequences\n    mkdir       $prefix/Species_Tree\n    mkdir       $prefix/WorkingDirectory\n\n    touch       $prefix/Log.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        orthofinder: \\$(orthofinder -h | sed -n 's/.*version \\\\(.*\\\\) Copy.*/\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to raise the quality of viral genomes assembled from short-read metagenomes via resolving and joining of contigs fragmented during de novo assembly.\nTags: cobra, contig, scaffold, assembly, extension, virus, phage", "answer": "process COBRAMETA {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cobra-meta:1.2.3--pyhdfd78af_0':\n        'biocontainers/cobra-meta:1.2.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(coverage)\n    tuple val(meta3), path(query)\n    tuple val(meta4), path(bam)\n    val assembler\n    val mink\n    val maxk\n\n    output:\n    tuple val(meta), path(\"${prefix}/COBRA_category_i_self_circular.fasta.gz\")                  , emit: self_circular       , optional: true\n    tuple val(meta), path(\"${prefix}/COBRA_category_ii-a_extended_circular_unique.fasta.gz\")    , emit: extended_circular   , optional: true\n    tuple val(meta), path(\"${prefix}/COBRA_category_ii-b_extended_partial_unique.fasta.gz\")     , emit: extended_partial    , optional: true\n    tuple val(meta), path(\"${prefix}/COBRA_category_ii-c_extended_failed.fasta.gz\")             , emit: extended_failed     , optional: true\n    tuple val(meta), path(\"${prefix}/COBRA_category_iii_orphan_end.fasta.gz\")                   , emit: orphan_end          , optional: true\n    tuple val(meta), path(\"${prefix}/COBRA_all_assemblies.fasta.gz\")                            , emit: all_cobra_assemblies, optional: true\n    tuple val(meta), path(\"${prefix}/COBRA_joining_summary.txt\")                                , emit: joining_summary\n    tuple val(meta), path(\"${prefix}/log\")                                                      , emit: log\n    path \"versions.yml\"                                                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    cobra-meta \\\\\n        --fasta ${fasta} \\\\\n        --coverage ${coverage} \\\\\n        --query ${query} \\\\\n        --mapping ${bam} \\\\\n        --assembler ${assembler} \\\\\n        --mink ${mink} \\\\\n        --maxk ${maxk} \\\\\n        --threads ${task.cpus} \\\\\n        --output ${prefix} \\\\\n        $args\n\n    gzip ${prefix}/*.fasta\n    cat ${prefix}/*fasta.gz > ${prefix}/COBRA_all_assemblies.fasta.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cobra: \\$(echo \\$(cobra-meta --version 2>&1) | sed 's/^.*cobra v//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    echo \"\" | gzip > ${prefix}/COBRA_all_assemblies.fasta.gz\n    echo \"\" | gzip > ${prefix}/COBRA_category_i_self_circular.fasta.gz\n    echo \"\" | gzip > ${prefix}/COBRA_category_ii-a_extended_circular_unique.fasta.gz\n    echo \"\" | gzip > ${prefix}/COBRA_category_ii-b_extended_partial_unique.fasta.gz\n    echo \"\" | gzip > ${prefix}/COBRA_category_ii-c_extended_failed.fasta.gz\n    echo \"\" | gzip > ${prefix}/COBRA_category_iii_orphan_end.fasta.gz\n    touch ${prefix}/COBRA_joining_summary.txt\n    touch ${prefix}/log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cobra: \\$(echo \\$(cobra-meta --version 2>&1) | sed 's/^.*cobra v//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculates per-scaffold or per-base coverage information from an unsorted sam or bam file.\nTags: fasta, genome, coverage", "answer": "process BBMAP_PILEUP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-008daec56b7aaf3f162d7866758142b9f889d690:e8a286b2e789c091bac0a57302cdc78aa0112353-0' :\n        'biocontainers/mulled-v2-008daec56b7aaf3f162d7866758142b9f889d690:e8a286b2e789c091bac0a57302cdc78aa0112353-0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.stats.txt\"), emit: covstats\n    tuple val(meta), path(\"*.hist.txt\") , emit: hist\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pileup.sh \\\\\n        -Xmx${task.memory.toGiga()}g \\\\\n        in=${bam} \\\\\n        out=${prefix}.coverage.stats.txt \\\\\n        hist=${prefix}.coverage.hist.txt \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: BBNorm is designed to normalize coverage by down-sampling reads over high-depth areas of a genome, to result in a flat coverage distribution.\nTags: normalization, assembly, coverage", "answer": "process BBMAP_BBNORM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-008daec56b7aaf3f162d7866758142b9f889d690:e8a286b2e789c091bac0a57302cdc78aa0112353-0':\n        'biocontainers/mulled-v2-008daec56b7aaf3f162d7866758142b9f889d690:e8a286b2e789c091bac0a57302cdc78aa0112353-0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: fastq\n    tuple val(meta), path(\"*.log\")     , emit: log\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    input  = meta.single_end ? \"in=${fastq.join(',')}\" : \"in=${fastq[0]} in2=${fastq[1]}\"\n    output = meta.single_end ? \"out=${prefix}.fastq.gz\" : \"out1=${prefix}_1.nm.fastq.gz out2=${prefix}_2.nm.fastq.gz\"\n\n    \"\"\"\n    bbnorm.sh \\\\\n        $input \\\\\n        $output \\\\\n        $args \\\\\n        threads=$task.cpus \\\\\n        -Xmx${task.memory.toGiga()}g \\\\\n        &> ${prefix}.bbnorm.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Adapter and quality trimming of sequencing reads\nTags: trimming, adapter trimming, quality trimming, fastq", "answer": "process BBMAP_BBDUK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bbmap:39.06--h92535d8_1':\n        'biocontainers/bbmap:39.06--h92535d8_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path contaminants\n\n    output:\n    tuple val(meta), path('*.fastq.gz'), emit: reads\n    tuple val(meta), path('*.log')     , emit: log\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def raw      = meta.single_end ? \"in=${reads[0]}\" : \"in1=${reads[0]} in2=${reads[1]}\"\n    def trimmed  = meta.single_end ? \"out=${prefix}.fastq.gz\" : \"out1=${prefix}_1.fastq.gz out2=${prefix}_2.fastq.gz\"\n    def contaminants_fa = contaminants ? \"ref=$contaminants\" : ''\n    \"\"\"\n    maxmem=\\$(echo \\\"$task.memory\\\"| sed 's/ GB/g/g')\n    bbduk.sh \\\\\n        -Xmx\\$maxmem \\\\\n        $raw \\\\\n        $trimmed \\\\\n        threads=$task.cpus \\\\\n        $args \\\\\n        $contaminants_fa \\\\\n        &> ${prefix}.bbduk.log\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_command  = meta.single_end ? \"echo '' | gzip > ${prefix}.fastq.gz\" : \"echo '' | gzip > ${prefix}_1.fastq.gz ; echo '' | gzip > ${prefix}_2.fastq.gz\"\n    \"\"\"\n    touch ${prefix}.bbduk.log\n    $output_command\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create 30% Smaller, Faster Gzipped Fastq Files. And remove duplicates\nTags: clumping fastqs, smaller fastqs, deduping, fastq", "answer": "process BBMAP_CLUMPIFY {\n    tag \"$meta.id\"\n    label 'process_single'\n    label 'process_high_memory'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bbmap:39.01--h5c4e2a8_0':\n        'biocontainers/bbmap:39.01--h5c4e2a8_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path('*.fastq.gz'), emit: reads\n    tuple val(meta), path('*.log')     , emit: log\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def raw      = meta.single_end ? \"in=$reads\" : \"in1=${reads[0]} in2=${reads[1]}\"\n    def clumped  = meta.single_end ? \"out=${prefix}.clumped.fastq.gz\" : \"out1=${prefix}_1.clumped.fastq.gz out2=${prefix}_2.clumped.fastq.gz\"\n    \"\"\"\n    clumpify.sh \\\\\n        $raw \\\\\n        $clumped \\\\\n        $args \\\\\n        &> ${prefix}.clumpify.log\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filter out sequences by sequence header name(s)\nTags: fastq, fasta, filter", "answer": "process BBMAP_FILTERBYNAME {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bbmap:39.01--h5c4e2a8_0':\n        'biocontainers/bbmap:39.01--h5c4e2a8_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    val(names_to_filter)\n    val(output_format)\n    val(interleaved_output)\n\n    output:\n    tuple val(meta), path(\"*.${output_format}\"), emit: reads\n    tuple val(meta), path('*.log')             , emit: log\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input  = meta.single_end ? \"in=${reads}\" : \"in=${reads[0]} in2=${reads[1]}\"\n    def output = (meta.single_end || interleaved_output) ?\n        \"out=${prefix}.${output_format}\" :\n        \"out1=${prefix}_1.${output_format} out2=${prefix}_2.${output_format}\"\n    def names_command = names_to_filter ? \"names=${names_to_filter}\": \"\"\n\n    def avail_mem = 3\n    if (!task.memory) {\n        log.info '[filterbyname] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = task.memory.giga\n    }\n\n    \"\"\"\n    filterbyname.sh \\\\\n        -Xmx${avail_mem}g \\\\\n        $input \\\\\n        $output \\\\\n        $names_command \\\\\n        $args \\\\\n        | tee ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def filtered = (meta.single_end || interleaved_output) ?\n        \"echo '' | gzip > ${prefix}.${output_format}\" :\n        \"echo '' | gzip >${prefix}_1.${output_format} ; echo '' | gzip >${prefix}_2.${output_format}\"\n\n    \"\"\"\n    $filtered\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Align short or PacBio reads to a reference genome using BBMap\nTags: align, map, fasta, fastq, genome, reference", "answer": "process BBMAP_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-008daec56b7aaf3f162d7866758142b9f889d690:e8a286b2e789c091bac0a57302cdc78aa0112353-0' :\n        'biocontainers/mulled-v2-008daec56b7aaf3f162d7866758142b9f889d690:e8a286b2e789c091bac0a57302cdc78aa0112353-0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n    path ref\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path(\"*.log\"), emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    input = meta.single_end ? \"in=${fastq}\" : \"in=${fastq[0]} in2=${fastq[1]}\"\n\n    // Set the db variable to reflect the three possible types of reference input: 1) directory\n    // named 'ref', 2) directory named something else (containg a 'ref' subdir) or 3) a sequence\n    // file in fasta format\n    if ( ref.isDirectory() ) {\n        if ( ref ==~ /(.\\/)?ref\\/?/ ) {\n            db = ''\n        } else {\n            db = \"path=${ref}\"\n        }\n    } else {\n        db = \"ref=${ref}\"\n    }\n\n    \"\"\"\n    bbmap.sh \\\\\n        $db \\\\\n        $input \\\\\n        out=${prefix}.bam \\\\\n        $args \\\\\n        threads=$task.cpus \\\\\n        -Xmx${task.memory.toGiga()}g \\\\\n        &> ${prefix}.bbmap.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        pigz: \\$( pigz --version 2>&1 | sed 's/pigz //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compares query sketches to reference sketches hosted on a remote server via the Internet.\nTags: taxonomy, classification, sketch, query, fastq, fasta", "answer": "process BBMAP_SENDSKETCH {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bbmap:39.01--h5c4e2a8_0':\n        'biocontainers/bbmap:39.01--h5c4e2a8_0' }\"\n\n    input:\n    tuple val(meta), path(file)\n\n    output:\n    tuple val(meta), path(\"*.txt\")  , emit: hits\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def file_used = file.size() > 1 ? file[0] : file\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[bbmap sendsketch.sh] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    sendsketch.sh -Xmx${avail_mem}M \\\\\n        in=${file_used} \\\\\n        out=${prefix}.txt \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates an index from a fasta file, ready to be used by bbmap.sh in mapping mode.\nTags: map, index, fasta", "answer": "process BBMAP_INDEX {\n    tag \"$fasta\"\n    label 'process_long'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bbmap:39.01--h5c4e2a8_0':\n        'biocontainers/bbmap:39.01--h5c4e2a8_0' }\"\n\n    input:\n    path fasta\n\n    output:\n    path 'ref'                    , emit: index\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    bbmap.sh \\\\\n        ref=${fasta} \\\\\n        $args \\\\\n        threads=$task.cpus \\\\\n        -Xmx${task.memory.toGiga()}g\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merging overlapping paired reads into a single read.\nTags: paired reads merging, fastq, overlap-based merging", "answer": "process BBMAP_BBMERGE {\n    tag \"$meta.id\"\n    label 'process_single'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bbmap:39.06--h92535d8_0':\n        'biocontainers/bbmap:39.06--h92535d8_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    val(interleave)\n\n    output:\n    tuple val(meta), path(\"*_merged.fastq.gz\")  , emit: merged\n    tuple val(meta), path(\"*_unmerged.fastq.gz\"), emit: unmerged\n    tuple val(meta), path(\"*_ihist.txt\")        , emit: ihist\n    path  \"versions.yml\"                        , emit: versions\n    path  \"*.log\"                               , emit: log\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def in_reads = ( interleave ) ? \"in=${reads[0]}\" : \"in1=${reads[0]} in2=${reads[1]}\"\n    def out_reads = ( interleave ) ? \"out=${prefix}_merged.fastq.gz outu=${prefix}_unmerged.fastq.gz\" : \"out=${prefix}_merged.fastq.gz outu1=${prefix}_1_unmerged.fastq.gz outu2=${prefix}_2_unmerged.fastq.gz\"\n\n    \"\"\"\n    maxmem=\\$(echo \\\"$task.memory\\\"| sed 's/ GB/g/g')\n    bbmerge.sh \\\\\n        -Xmx\\$maxmem \\\\\n        $in_reads \\\\\n        $out_reads \\\\\n        ihist=${prefix}_ihist.txt \\\\\n        $args \\\\\n        &> ${prefix}.bbmerge.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def out_files = ( interleave ) ? \"${prefix}_merged.fastq.gz ${prefix}_unmerged.fastq.gz\" : \"${prefix}_merged.fastq.gz ${prefix}_1_unmerged.fastq.gz ${prefix}_2_unmerged.fastq.gz\"\n\n    \"\"\"\n    echo \"\" | gzip | tee $out_files\n    touch ${prefix}_ihist.txt\n    touch ${prefix}.bbmerge.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split sequencing reads by mapping them to multiple references simultaneously\nTags: align, map, fastq, genome, reference", "answer": "process BBMAP_BBSPLIT {\n    tag \"$meta.id\"\n    label 'process_high'\n    label 'error_retry'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bbmap:39.01--h5c4e2a8_0':\n        'biocontainers/bbmap:39.01--h5c4e2a8_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  index\n    path  primary_ref\n    tuple val(other_ref_names), path(other_ref_paths)\n    val   only_build_index\n\n    output:\n    path \"bbsplit\"                            , optional:true, emit: index\n    tuple val(meta), path('*primary*fastq.gz'), optional:true, emit: primary_fastq\n    tuple val(meta), path('*fastq.gz')        , optional:true, emit: all_fastq\n    tuple val(meta), path('*txt')             , optional:true, emit: stats\n    tuple val(meta), path('*.log')            , optional:true, emit: log\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[BBSplit] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    def other_refs = []\n    other_ref_names.eachWithIndex { name, index ->\n        other_refs << \"ref_${name}=${other_ref_paths[index]}\"\n    }\n\n    def fastq_in=''\n    def fastq_out=''\n    def index_files=''\n    def refstats_cmd=''\n\n    if (only_build_index) {\n        if (primary_ref && other_ref_names && other_ref_paths) {\n            index_files = 'ref_primary=' +primary_ref + ' ' + other_refs.join(' ') + ' path=bbsplit'\n        } else {\n            log.error 'ERROR: Please specify as input a primary fasta file along with names and paths to non-primary fasta files.'\n        }\n    } else {\n        if (index) {\n            index_files = \"path=$index\"\n        } else if (primary_ref && other_ref_names && other_ref_paths) {\n            index_files = \"ref_primary=${primary_ref} ${other_refs.join(' ')}\"\n        } else {\n            log.error 'ERROR: Please either specify a BBSplit index as input or a primary fasta file along with names and paths to non-primary fasta files.'\n        }\n        fastq_in  = meta.single_end ? \"in=${reads}\" : \"in=${reads[0]} in2=${reads[1]}\"\n        fastq_out = meta.single_end ? \"basename=${prefix}_%.fastq.gz\" : \"basename=${prefix}_%_#.fastq.gz\"\n        refstats_cmd = 'refstats=' + prefix + '.stats.txt'\n    }\n    \"\"\"\n\n    # When we stage in the index files the time stamps get disturbed, which\n    # bbsplit doesn't like. Fix the time stamps in its summaries. This needs to\n    # be done via Java to match what bbmap does\n\n    if [ $index ]; then\n        for summary_file in \\$(find $index/ref/genome -name summary.txt); do\n            src=\\$(grep '^source' \"\\$summary_file\" | cut -f2- -d\\$'\\\\t' | sed 's|.*/bbsplit|bbsplit|')\n            mod=\\$(echo \"System.out.println(java.nio.file.Files.getLastModifiedTime(java.nio.file.Paths.get(\\\\\"\\$src\\\\\")).toMillis());\" | jshell -J-Djdk.lang.Process.launchMechanism=vfork -)\n            sed \"s|^last modified.*|last modified\\\\t\\$mod|\" \"\\$summary_file\" > \\${summary_file}.tmp && mv \\${summary_file}.tmp \\${summary_file}\n        done\n    fi\n\n    # Run BBSplit\n\n    bbsplit.sh \\\\\n        -Xmx${avail_mem}M \\\\\n        $index_files \\\\\n        threads=$task.cpus \\\\\n        $fastq_in \\\\\n        $fastq_out \\\\\n        $refstats_cmd \\\\\n        $args 2> >(tee ${prefix}.log >&2)\n\n    # Summary files will have an absolute path that will make the index\n    # impossible to use in other processes- we can fix that\n\n    for summary_file in \\$(find bbsplit/ref/genome -name summary.txt); do\n        src=\\$(grep '^source' \"\\$summary_file\" | cut -f2- -d\\$'\\\\t' | sed 's|.*/bbsplit|bbsplit|')\n        sed \"s|^source.*|source\\\\t\\$src|\" \"\\$summary_file\" > \\${summary_file}.tmp && mv \\${summary_file}.tmp \\${summary_file}\n    done\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def other_refs = ''\n    other_ref_names.eachWithIndex { name, index ->\n        other_refs += \"echo '' | gzip > ${prefix}_${name}.fastq.gz\"\n    }\n    \"\"\"\n    if [ ! -d bbsplit ]; then\n        mkdir bbsplit\n    fi\n\n    if ! (${only_build_index}); then\n        echo '' | gzip >  ${prefix}_primary.fastq.gz\n        ${other_refs}\n        touch ${prefix}.stats.txt\n    fi\n\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bbmap: \\$(bbversion.sh | grep -v \"Duplicate cpuset\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert SV calls to a standardized format.\nTags: svtk, structural variants, SV, vcf, standardization", "answer": "process SVTK_STANDARDIZE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svtk:0.0.20190615--py37h73a75cf_2':\n        'biocontainers/svtk:0.0.20190615--py37h73a75cf_2' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    path fasta_fai\n\n    output:\n    tuple val(meta), path(\"*.std.vcf.gz\"), emit: standardized_vcf\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def arguments   = args.args     ?: ''\n    def caller      = args.caller   ?: 'delly'\n\n    def VERSION = '0.0.20190615' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def contigs = fasta_fai ? \"--contigs ${fasta_fai}\" : \"\"\n\n    \"\"\"\n    svtk standardize \\\\\n        ${arguments} \\\\\n        ${contigs} \\\\\n        ${vcf} \\\\\n        ${prefix}.std.vcf.gz \\\\\n        ${caller}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtk: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Count the instances of each SVTYPE observed in each sample in a VCF.\nTags: svtk, countsvtypes, vcf, structural variants", "answer": "process SVTK_COUNTSVTYPES {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svtk:0.0.20190615--py37h73a75cf_2':\n        'biocontainers/svtk:0.0.20190615--py37h73a75cf_2' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: counts\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.0.20190615' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    svtk count-svtypes \\\\\n        ${args} \\\\\n        ${vcf} \\\\\n        ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtk: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs tests on BAF files\nTags: svtk, svtk/baftest, baftest, baf, bed, structural variants", "answer": "process SVTK_BAFTEST {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svtk:0.0.20190615--py37h73a75cf_2':\n        'biocontainers/svtk:0.0.20190615--py37h73a75cf_2' }\"\n\n    input:\n    tuple val(meta), path(bed), path(baf), path(baf_index), path(batch)\n\n    output:\n    tuple val(meta), path(\"*.metrics\")  , emit: metrics\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def VERSION = '0.0.20190615' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    svtk baf-test \\\\\n        ${bed} \\\\\n        ${baf} \\\\\n        --batch ${batch} \\\\\n        ${args} \\\\\n        > ${prefix}.metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtk: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert an RdTest-formatted bed to the standard VCF format.\nTags: svtk, rdtest2vcf, bed, rdtest, vcf", "answer": "process SVTK_RDTEST2VCF {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svtk:0.0.20190615--py37h73a75cf_2':\n        'biocontainers/svtk:0.0.20190615--py37h73a75cf_2' }\"\n\n    input:\n    tuple val(meta), path(bed), path(samples)\n    path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")       , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\")   , emit: tbi\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.0.20190615' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def contigs = fasta_fai ? \"--contigs ${fasta_fai}\" : \"\"\n\n    \"\"\"\n    svtk rdtest2vcf \\\\\n        ${bed} \\\\\n        ${samples} \\\\\n        ${prefix}.vcf.gz \\\\\n        ${contigs}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtk: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts VCFs containing structural variants to BED format\nTags: vcf, bed, vcf2bed, svtk, structural variants", "answer": "process SVTK_VCF2BED {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/svtk:0.0.20190615--py37h73a75cf_2':\n        'biocontainers/svtk:0.0.20190615--py37h73a75cf_2' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def VERSION = '0.0.20190615' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    svtk vcf2bed \\\\\n        ${vcf} \\\\\n        ${prefix}.bed \\\\\n        ${args} \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        svtk: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download and prepare database for Ariba analysis\nTags: fastq, assembly, resistance, virulence", "answer": "process ARIBA_GETREF {\n    tag \"$db_name\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ariba:2.14.6--py39h67e14b5_3':\n        'biocontainers/ariba:2.14.6--py39h67e14b5_3' }\"\n\n    input:\n    tuple val(meta), val(db_name)\n\n    output:\n    tuple val(meta), path(\"${db_name}.tar.gz\"), emit: db\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    \"\"\"\n    # Download, format database, and tarball it\n    ariba \\\\\n        getref \\\\\n        ${db_name} \\\\\n        ${db_name}\n\n    ariba \\\\\n        prepareref \\\\\n        -f ${db_name}.fa \\\\\n        -m ${db_name}.tsv \\\\\n        ${db_name}\n\n    tar -zcvf ${db_name}.tar.gz ${db_name}/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ariba:  \\$(echo \\$(ariba version 2>&1) | sed 's/^.*ARIBA version: //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    echo \"\" | gzip > ${db_name}.tar.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ariba:  \\$(echo \\$(ariba version 2>&1) | sed 's/^.*ARIBA version: //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Query input FASTQs against Ariba formatted databases\nTags: fastq, assembly, resistance, virulence", "answer": "process ARIBA_RUN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ariba:2.14.6--py39h67e14b5_3':\n        'biocontainers/ariba:2.14.6--py39h67e14b5_3' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta), path(db)\n\n    output:\n    tuple val(meta), path(\"${prefix}/*\"), emit: results\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def db_name = db.getName().replace('.tar.gz', '')\n    \"\"\"\n    tar -xzvf ${db}\n    ariba \\\\\n        run \\\\\n        ${db_name}/ \\\\\n        ${reads} \\\\\n        ${prefix} \\\\\n        $args \\\\\n        --threads $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ariba:  \\$(echo \\$(ariba version 2>&1) | sed 's/^.*ARIBA version: //;s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Run FastQC on sequenced reads\nTags: quality control, qc, adapters, fastq", "answer": "process FASTQC {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fastqc:0.12.1--hdfd78af_0' :\n        'biocontainers/fastqc:0.12.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.html\"), emit: html\n    tuple val(meta), path(\"*.zip\") , emit: zip\n    path  \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // Make list of old name and new name pairs to use for renaming in the bash while loop\n    def old_new_pairs = reads instanceof Path || reads.size() == 1 ? [[ reads, \"${prefix}.${reads.extension}\" ]] : reads.withIndex().collect { entry, index -> [ entry, \"${prefix}_${index + 1}.${entry.extension}\" ] }\n    def rename_to = old_new_pairs*.join(' ').join(' ')\n    def renamed_files = old_new_pairs.collect{ old_name, new_name -> new_name }.join(' ')\n\n    def memory_in_mb = MemoryUnit.of(\"${task.memory}\").toUnit('MB')\n    // FastQC memory value allowed range (100 - 10000)\n    def fastqc_memory = memory_in_mb > 10000 ? 10000 : (memory_in_mb < 100 ? 100 : memory_in_mb)\n\n    \"\"\"\n    printf \"%s %s\\\\n\" $rename_to | while read old_name new_name; do\n        [ -f \"\\${new_name}\" ] || ln -s \\$old_name \\$new_name\n    done\n\n    fastqc \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --memory $fastqc_memory \\\\\n        $renamed_files\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastqc: \\$( fastqc --version | sed '/FastQC v/!d; s/.*v//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.html\n    touch ${prefix}.zip\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastqc: \\$( fastqc --version | sed '/FastQC v/!d; s/.*v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The hap-ibd program detects identity-by-descent (IBD) segments and homozygosity-by-descent (HBD) segments in phased genotype data. The hap-ibd program can analyze data sets with hundreds of thousands of samples.\nTags: ibd, hbd, beagle", "answer": "process HAPIBD {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/hap-ibd:1.0.rev20May22.818--hdfd78af_0':\n        'biocontainers/hap-ibd:1.0.rev20May22.818--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    path(map)\n    path(exclude)\n\n\n    output:\n    tuple val(meta), path(\"*.hbd.gz\"), emit: hbd\n    tuple val(meta), path(\"*.ibd.gz\"), emit: ibd\n    tuple val(meta), path(\"*.log\")   , emit: log\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def excludesamples_command = exclude ? \"excludesamples=$exclude\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[hapibd] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    hap-ibd -Xmx${avail_mem}M \\\\\n        gt=${vcf} \\\\\n        map=${map} \\\\\n        out=${prefix} \\\\\n        $args \\\\\n        ${excludesamples_command}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        hapibd: \\$(hap-ibd 2>&1 |head -n1 | sed 's/^hap-ibd.jar  \\\\[ version //; s/, /rev/; s/ \\\\]//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: endorS.py calculates endogenous DNA from samtools flagstat files and print to screen\nTags: endogenous DNA, ancient DNA, percent on target, statistics", "answer": "process ENDORSPY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/endorspy:1.3--hdfd78af_0':\n        'biocontainers/endorspy:1.3--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(stats_raw), path(stats_qualityfiltered), path(stats_deduplicated)\n\n    output:\n    tuple val(meta), path(\"*_mqc.json\"), emit: json\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def optionalraw = stats_raw ? \"-r ${stats_raw}\" : ''\n    def optionalqualityfiltered = stats_qualityfiltered ? \"-q ${stats_qualityfiltered}\" : ''\n    def optionaldeduplicated = stats_deduplicated ? \"-d ${stats_deduplicated}\" : ''\n\n    if ( stats_qualityfiltered && !stats_raw && !stats_deduplicated ) error \"ERROR: only input channel stats_qualityfiltered provided. No stats can be calculated. Add at least one additional input channel: stats_raw or stats_deduplicated\"\n\n\n    \"\"\"\n    endorspy \\\\\n        $optionalraw \\\\\n        $optionalqualityfiltered \\\\\n        $optionaldeduplicated \\\\\n        $args \\\\\n        -o json \\\\\n        -n $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        endorspy: \\$(echo \\$(endorspy --version 2>&1) | sed 's/^endorS.py //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: converts sam/bam/cram/pairs into genome contact map\nTags: contact, bam, map", "answer": "\nprocess PRETEXTMAP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-f3591ce8609c7b3b33e5715333200aa5c163aa61%3A44321ab4d64f0b6d0c93abbd1406369d1b3da684-0':\n        'biocontainers/mulled-v2-f3591ce8609c7b3b33e5715333200aa5c163aa61:44321ab4d64f0b6d0c93abbd1406369d1b3da684-0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    tuple val(meta2), path(fasta), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.pretext\")  , emit: pretext\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args     ?: ''\n    def prefix      = task.ext.prefix   ?: \"${meta.id}\"\n    def reference   = fasta             ? \"--reference ${fasta}\" : \"\"\n\n    \"\"\"\n    if [[ $input == *.pairs.gz ]]; then\n        zcat $input | PretextMap \\\\\n            $args \\\\\n            -o ${prefix}.pretext\n    else\n        samtools \\\\\n            view \\\\\n            $reference \\\\\n            -h \\\\\n            $input | PretextMap \\\\\n            $args \\\\\n            -o ${prefix}.pretext\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pretextmap: \\$(PretextMap | grep \"Version\" | sed 's/PretextMap Version //g')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix      = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.pretext\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pretextmap: \\$(PretextMap | grep \"Version\" | sed 's/PretextMap Version //g')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Combine output of metagenomic samples analyzed by bracken.\nTags: bracken, metagenomics, postprocessing, reporting", "answer": "process BRACKEN_COMBINEBRACKENOUTPUTS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bracken:2.9--py38h2494328_0':\n        'biocontainers/bracken:2.9--py38h2494328_0' }\"\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // WARN: Version information not provided by tool on CLI.\n    // Please update version string below when bumping container versions.\n    def VERSION = '2.9'\n    \"\"\"\n    combine_bracken_outputs.py \\\\\n        $args \\\\\n        --files ${input} \\\\\n        -o ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        combine_bracken_output: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // WARN: Version information not provided by tool on CLI.\n    // Please update version string below when bumping container versions.\n    def VERSION = '2.9'\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        combine_bracken_output: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Re-estimate taxonomic abundance of metagenomic samples analyzed by kraken.\nTags: bracken, metagenomics, abundance, kraken2", "answer": "process BRACKEN_BRACKEN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bracken:2.9--py38h2494328_0':\n        'biocontainers/bracken:2.9--py38h2494328_0' }\"\n\n    input:\n    tuple val(meta), path(kraken_report)\n    path database\n\n    output:\n    tuple val(meta), path(bracken_report)        , emit: reports\n    tuple val(meta), path(bracken_kraken_style_report), emit: txt\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    bracken_report = \"${prefix}.tsv\"\n    bracken_kraken_style_report = \"${prefix}.kraken2.report_bracken.txt\"\n    \"\"\"\n    bracken \\\\\n        ${args} \\\\\n        -d '${database}' \\\\\n        -i '${kraken_report}' \\\\\n        -o '${bracken_report}' \\\\\n        -w '${bracken_kraken_style_report}'\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bracken: \\$(echo \\$(bracken -v) | cut -f2 -d'v')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    bracken_report = \"${prefix}.tsv\"\n    bracken_kraken_style_report = \"${prefix}.kraken2.report_bracken.txt\"\n    \"\"\"\n    touch ${prefix}.tsv\n    touch ${bracken_kraken_style_report}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bracken: \\$(echo \\$(bracken -v) | cut -f2 -d'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extends a Kraken2 database to be compatible with Bracken\nTags: kraken2, bracken, database, build", "answer": "process BRACKEN_BUILD {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bracken:2.9--py38h2494328_0':\n        'biocontainers/bracken:2.9--py38h2494328_0' }\"\n\n    input:\n    tuple val(meta), path(kraken2db)\n\n    output:\n    tuple val(meta), path(kraken2db               , includeInputs: true), emit: db\n    tuple val(meta), path(\"${kraken2db}/database*\", includeInputs: true), emit: bracken_files\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    bracken-build \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        -d $kraken2db\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bracken: \\$(echo \\$(bracken -v) | cut -f2 -d'v')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${kraken2db}/database100mers.kmer_distrib\n    touch ${kraken2db}/database100mers.kraken\n    touch ${kraken2db}/database.kraken\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bracken: \\$(echo \\$(bracken -v) | cut -f2 -d'v')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Pindel can detect breakpoints of large deletions, medium sized insertions, inversions, tandem duplications and other structural variants at single-based resolution from next-gen sequence data\nTags: deletions, insertions, tandem duplications", "answer": "process PINDEL_PINDEL {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pindel:0.2.5b9--h06e5f0a_6':\n        'biocontainers/pindel:0.2.5b9--h06e5f0a_6' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path fasta\n    path fai\n    path bed\n\n    output:\n    tuple val(meta), path(\"*_BP\")            , emit: bp\n    tuple val(meta), path(\"*_CloseEndMapped\"), emit: cem\n    tuple val(meta), path(\"*_D\")             , emit: del\n    tuple val(meta), path(\"*_DD\")            , emit: dd, optional:true\n    tuple val(meta), path(\"*_INT_final\")     , emit: int_final\n    tuple val(meta), path(\"*_INV\")           , emit: inv\n    tuple val(meta), path(\"*_LI\")            , emit: li\n    tuple val(meta), path(\"*_RP\")            , emit: rp\n    tuple val(meta), path(\"*_SI\")            , emit: si\n    tuple val(meta), path(\"*_TD\")            , emit: td\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: '500'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (bam instanceof nextflow.util.BlankSeparatedList) {\n        error \"pindel/pindel only takes a single bam file as input\"\n    }\n\n    \"\"\"\n    echo -e \"${bam}\\t${args2}\\t${prefix}\" > pindel.cfg\n\n    pindel \\\\\n        $args \\\\\n        -T $task.cpus \\\\\n        -o $prefix \\\\\n        -f $fasta \\\\\n        -j $bed \\\\\n        -i pindel.cfg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pindel: \\$(pindel | grep '^Pindel version' | uniq | sed 's/Pindel version //; s/, [0-9]\\\\+.//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generates a VCF stream where AC and NS have been generated for each record using sample genotypes.\nTags: vcf, vcflib, vcflib/vcffixup, AC/NS/AF", "answer": "process VCFLIB_VCFFIXUP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vcflib:1.0.3--hecb563c_1':\n        'biocontainers/vcflib:1.0.3--hecb563c_1' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    vcffixup \\\\\n        $vcf | bgzip -c $args > ${prefix}_fixed.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcflib: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.fixup.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcflib: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: List unique genotypes. Like GNU uniq, but for VCF records. Remove records which have the same position, ref, and alt as the previous record.\nTags: vcf, uniq, deduplicate", "answer": "process VCFLIB_VCFUNIQ {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vcflib:1.0.3--hecb563c_1':\n        'biocontainers/vcflib:1.0.3--hecb563c_1' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n\n    output:\n    tuple val(meta), path(\"*.gz\"), emit: vcf\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    vcfuniq \\\\\n        $vcf \\\\\n        | bgzip -c $args > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcflib: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Command line tools for parsing and manipulating VCF files.\nTags: filter, variant, vcf, quality", "answer": "process VCFLIB_VCFFILTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vcflib:1.0.3--ha025227_0':\n        'biocontainers/vcflib:1.0.3--ha025227_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    if ( !(args.contains(\"-f\") || args.contains(\"--info-filter\") || args.contains(\"-g\") || args.contains(\"--genotype-filter\")) ) {\n        error \"VCFLIB_VCFFILTER requires either the -f/--info-filter or -g/--genotype-filter arguments to be supplied using ext.args.\"\n    }\n    if ( \"$vcf\" == \"${prefix}.vcf.gz\" ) {\n        error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    }\n    \"\"\"\n    vcffilter \\\\\n        $args \\\\\n        $vcf \\\\\n        | bgzip -c $args2 > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcflib: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: If multiple alleles are specified in a single record, break the record into several lines preserving allele-specific INFO fields\nTags: vcflib, vcflib/vcfbreakmulti", "answer": "process VCFLIB_VCFBREAKMULTI {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/vcflib:1.0.3--hecb563c_1':\n        'biocontainers/vcflib:1.0.3--ha025227_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    vcfbreakmulti \\\\\n        $vcf \\\\\n        $args \\\\\n        | bgzip -c $args2 > ${prefix}.breakmulti.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcflib: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.breakmulti.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcflib: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module to run UniverSC an open-source pipeline to demultiplex and process single-cell RNA-Seq data\nTags: demultiplex, align, single-cell, scRNA-Seq, count, umi", "answer": "process UNIVERSC {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    container \"nf-core/universc:1.2.5.1\"\n    if (workflow.containerEngine == 'docker'){\n        containerOptions = \"--privileged\"\n    }\n    if ( workflow.containerEngine == 'podman'){\n        containerOptions = \"--runtime crun --userns=keep-id --systemd=always\"\n    }\n    if (workflow.containerEngine == 'singularity'){\n        containerOptions = \"-B /var/tmp --writable-tmpfs\"\n        params.singularity_autoMounts = true\n    }\n\n    input:\n    tuple val(meta), path(reads)\n    path  reference\n\n\n    output:\n    tuple val(meta), path(\"sample-${meta.id}/outs/*\"), emit: outs\n    path \"versions.yml\"                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"UNIVERSC module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def sample_arg = meta.samples.unique().join(\",\")\n    def reference_name = reference.name\n    def input_reads = meta.single_end ? \"--file $reads\" : \"-R1 ${reads[0]} -R2 ${reads[1]}\"\n    \"\"\"\n    universc \\\\\n        --id 'sample-${meta.id}' \\\\\n        ${input_reads} \\\\\n        --technology '${meta.technology}' \\\\\n        --chemistry '${meta.chemistry}' \\\\\n        --reference ${reference_name} \\\\\n        --description ${sample_arg} \\\\\n        --jobmode \"local\" \\\\\n        --localcores ${task.cpus} \\\\\n        --localmem ${task.memory.toGiga()} \\\\\n        --per-cell-data \\\\\n        $args 1> _log 2> _err\n\n    # save log files\n    echo !! > sample-${meta.id}/outs/_invocation\n    cp _log sample-${meta.id}/outs/_log\n    cp _err sample-${meta.id}/outs/_err\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger:  \\$(echo \\$(cellranger count --version 2>&1 | head -n 2 | tail -n 1 | sed 's/^.* //g' | sed 's/(//g' | sed 's/)//g' ))\n        universc:  \\$(echo \\$(bash /universc/launch_universc.sh --version | grep version | grep universc  | sed 's/^.* //g' ))\n    END_VERSIONS\n    \"\"\"\n\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"UNIVERSC module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    \"\"\"\n    mkdir -p \"sample-${meta.id}/outs/\"\n    touch sample-${meta.id}/outs/fake_file.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cellranger:  \\$(echo \\$(cellranger count --version 2>&1 | head -n 2 | tail -n 1 | sed 's/^.* //g' | sed 's/(//g' | sed 's/)//g' ))\n        universc:  \\$(echo \\$(bash /universc/launch_universc.sh --version | grep version | grep universc | sed 's/^.* //g' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A very fast OLC-based de novo assembler for noisy long reads\nTags: assembly, pacbio, nanopore", "answer": "process MINIASM {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/miniasm:0.3_r179--h5bf99c6_2' :\n        'biocontainers/miniasm:0.3_r179--h5bf99c6_2' }\"\n\n    input:\n    tuple val(meta), path(reads), path(paf)\n\n    output:\n    tuple val(meta), path(\"*.gfa.gz\")  , emit: gfa\n    tuple val(meta), path(\"*.fasta.gz\"), emit: assembly\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    miniasm \\\\\n        $args \\\\\n        -f $reads \\\\\n        $paf > \\\\\n        ${prefix}.gfa\n\n    awk '/^S/{print \">\"\\$2\"\\\\n\"\\$3}' \"${prefix}.gfa\" | fold > ${prefix}.fasta\n\n    gzip -n ${prefix}.gfa\n    gzip -n ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        miniasm: \\$( miniasm -V 2>&1 )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.gfa.gz\n    echo \"\" | gzip > ${prefix}.fasta.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        miniasm: \\$( miniasm -V 2>&1 )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Demultiplex Illumina BCL files\nTags: demultiplex, illumina, fastq", "answer": "process BCL2FASTQ {\n    tag {\"$meta.lane\" ? \"$meta.id\"+\".\"+\"$meta.lane\" : \"$meta.id\" }\n    label 'process_high'\n\n    container \"nf-core/bcl2fastq:2.20.0.422\"\n\n    input:\n    tuple val(meta), path(samplesheet), path(run_dir)\n\n    output:\n    tuple val(meta), path(\"output/**_S[1-9]*_R?_00?.fastq.gz\")          , emit: fastq\n    tuple val(meta), path(\"output/**_S[1-9]*_I?_00?.fastq.gz\")          , optional:true, emit: fastq_idx\n    tuple val(meta), path(\"output/**Undetermined_S0*_R?_00?.fastq.gz\")  , optional:true, emit: undetermined\n    tuple val(meta), path(\"output/**Undetermined_S0*_I?_00?.fastq.gz\")  , optional:true, emit: undetermined_idx\n    tuple val(meta), path(\"output/Reports\")                             , emit: reports\n    tuple val(meta), path(\"output/Stats\")                               , emit: stats\n    tuple val(meta), path(\"InterOp/*.bin\")                       , emit: interop\n    path(\"versions.yml\")                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"BCL2FASTQ module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def input_tar = run_dir.toString().endsWith(\".tar.gz\") ? true : false\n    def input_dir = input_tar ? run_dir.toString() - '.tar.gz' : run_dir\n    \"\"\"\n    if [ ! -d ${input_dir} ]; then\n        mkdir -p ${input_dir}\n    fi\n\n    if ${input_tar}; then\n        ## Ensures --strip-components only applied when top level of tar contents is a directory\n        ## If just files or multiple directories, place all in $input_dir\n\n        if [[ \\$(tar -taf ${run_dir} | grep -o -P \"^.*?\\\\/\" | uniq | wc -l) -eq 1 ]]; then\n            tar \\\\\n                -C $input_dir --strip-components 1 \\\\\n                -xavf \\\\\n                $args2 \\\\\n                $run_dir \\\\\n                $args3\n        else\n            tar \\\\\n                -C $input_dir \\\\\n                -xavf \\\\\n                $args2 \\\\\n                $run_dir \\\\\n                $args3\n        fi\n    fi\n\n    bcl2fastq \\\\\n        $args \\\\\n        --output-dir output \\\\\n        --runfolder-dir ${input_dir} \\\\\n        --sample-sheet ${samplesheet} \\\\\n        --processing-threads ${task.cpus}\n\n    cp -r ${input_dir}/InterOp .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bcl2fastq: \\$(bcl2fastq -V 2>&1 | grep -m 1 bcl2fastq | sed 's/^.*bcl2fastq v//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes equivalence classes for reads and quantifies abundances\nTags: quant, kallisto, pseudoalignment", "answer": "process KALLISTO_QUANT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kallisto:0.48.0--h15996b6_2':\n        'biocontainers/kallisto:0.48.0--h15996b6_2' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(index)\n    path gtf\n    path chromosomes\n    val fragment_length\n    val fragment_length_sd\n\n    output:\n    tuple val(meta), path(\"${prefix}\")        , emit: results\n    tuple val(meta), path(\"*.run_info.json\")  , emit: json_info\n    tuple val(meta), path(\"*.log\")            , emit: log\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def gtf_input = gtf ? \"--gtf ${gtf}\" : ''\n    def chromosomes_input = chromosomes ? \"--chromosomes ${chromosomes}\" : ''\n\n    def single_end_params = ''\n    if (meta.single_end) {\n        if (!(fragment_length =~ /^\\d+$/)) {\n            error \"fragment_length must be set and numeric for single-end data\"\n        }\n        if (!(fragment_length_sd =~ /^\\d+$/)) {\n            error \"fragment_length_sd must be set and numeric for single-end data\"\n        }\n        single_end_params = \"--single --fragment-length=${fragment_length} --sd=${fragment_length_sd}\"\n    }\n\n    def strandedness = ''\n    if (!args.contains('--fr-stranded') && !args.contains('--rf-stranded')) {\n        strandedness =  (meta.strandedness == 'forward') ? '--fr-stranded' :\n                        (meta.strandedness == 'reverse') ? '--rf-stranded' : ''\n    }\n\n    \"\"\"\n    mkdir -p $prefix && kallisto quant \\\\\n            --threads ${task.cpus} \\\\\n            --index ${index} \\\\\n            ${gtf_input} \\\\\n            ${chromosomes_input} \\\\\n            ${single_end_params} \\\\\n            ${strandedness} \\\\\n            ${args} \\\\\n            -o $prefix \\\\\n            ${reads} 2> >(tee -a ${prefix}/kallisto_quant.log >&2)\n\n    cp ${prefix}/kallisto_quant.log ${prefix}.log\n    cp ${prefix}/run_info.json ${prefix}.run_info.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kallisto: \\$(echo \\$(kallisto version) | sed \"s/kallisto, version //g\" )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mkdir -p $prefix\n    touch ${prefix}.log\n    touch ${prefix}.run_info.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kallisto: \\$(echo \\$(kallisto version) | sed \"s/kallisto, version //g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create kallisto index\nTags: kallisto, kallisto/index, index", "answer": "process KALLISTO_INDEX {\n    tag \"$fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kallisto:0.48.0--h15996b6_2':\n        'biocontainers/kallisto:0.48.0--h15996b6_2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"kallisto\")  , emit: index\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    kallisto \\\\\n        index \\\\\n        $args \\\\\n        -i kallisto \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kallisto: \\$(echo \\$(kallisto 2>&1) | sed 's/^kallisto //; s/Usage.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir kallisto\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kallisto: \\$(echo \\$(kallisto 2>&1) | sed 's/^kallisto //; s/Usage.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download database for GUNC detection of Chimerism and Contamination in Prokaryotic Genomes\nTags: download, prokaryote, assembly, genome, quality control, chimeras", "answer": "process GUNC_DOWNLOADDB {\n    tag \"$db_name\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gunc:1.0.5--pyhdfd78af_0' :\n        'biocontainers/gunc:1.0.5--pyhdfd78af_0' }\"\n\n    input:\n    val db_name\n\n    output:\n    path \"*.dmnd\"       , emit: db\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    gunc download_db . -db $db_name $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gunc: \\$( gunc --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merging of CheckM and GUNC results in one summary table\nTags: gunc, checkm, summary, prokaryote, assembly, genome, quality control, chimeras", "answer": "process GUNC_MERGECHECKM {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gunc:1.0.5--pyhdfd78af_0' :\n        'biocontainers/gunc:1.0.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gunc_file), path(checkm_file)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gunc \\\\\n        merge_checkm \\\\\n        $args \\\\\n        -g $gunc_file \\\\\n        -c $checkm_file \\\\\n        -o .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gunc: \\$( gunc --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Detection of Chimerism and Contamination in Prokaryotic Genomes\nTags: prokaryote, assembly, genome, quality control, chimeras", "answer": "process GUNC_RUN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gunc:1.0.5--pyhdfd78af_0' :\n        'biocontainers/gunc:1.0.5--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path(db)\n\n    output:\n    tuple val(meta), path(\"*maxCSS_level.tsv\")                  , emit: maxcss_level_tsv\n    tuple val(meta), path(\"*all_levels.tsv\")    , optional: true, emit: all_levels_tsv\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gunc \\\\\n        run \\\\\n        --input_fasta $fasta \\\\\n        --db_file $db \\\\\n        --threads $task.cpus \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gunc: \\$( gunc --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: gives an estimation of the sequencing bias based on known invariant sites\nTags: sequencing_bias, ATLAS", "answer": "process ATLAS_RECAL {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/atlas:0.9.9--h082e891_0':\n        'biocontainers/atlas:0.9.9--h082e891_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(empiric), path(readgroups)\n    path(alleles)\n    path(invariant_sites)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit:recal_patterns\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def PMD = empiric ? \"pmdFile=${empiric}\" : \"\"\n    def ALLELES = alleles ? \"alleleFile=${alleles}\" : \"\"\n    def INVARIANTS = invariant_sites ? \"window=${invariant_sites}\" : \"\"\n    def READGROUPS = readgroups ? \"poolReadGroups=${readgroups}\" : \"\"\n\n    \"\"\"\n    atlas \\\\\n        task=recal \\\\\n        bam=$bam \\\\\n        $PMD \\\\\n        $READGROUPS \\\\\n        $ALLELES \\\\\n        $INVARIANTS \\\\\n        out=$prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        atlas: \\$((atlas 2>&1) | grep Atlas | head -n 1 | sed -e 's/^[ \\t]*Atlas //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: split single end read groups by length and merge paired end reads\nTags: split, merge, bam, read group", "answer": "process ATLAS_SPLITMERGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/atlas:0.9.9--h082e891_0':\n        'biocontainers/atlas:0.9.9--h082e891_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(read_group_settings), path(blacklist)\n\n    output:\n    tuple val(meta), path(\"*_mergedReads.bam\"), path(\"*.txt.gz\"), emit: data\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def optional = blacklist ? 'blacklist=${blacklist}' : ''\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    atlas \\\\\n        task=splitMerge bam=${bam} \\\\\n        readGroupSettings=${read_group_settings}\\\\\n        $optional \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        atlas: \\$((atlas 2>&1) | grep Atlas | head -n 1 | sed -e 's/^[ \\t]*Atlas //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: generate VCF file from a BAM file using various calling methods\nTags: atlas, variant calling, vcf, population genetics", "answer": "process ATLAS_CALL {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/atlas:0.9.9--h082e891_0':\n        'biocontainers/atlas:0.9.9--h082e891_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(pmd), path(recal)\n    path fasta\n    path fai\n    path known_alleles\n    val method\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args               = task.ext.args ?: ''\n    def prefix             = task.ext.prefix ?: \"${meta.id}\"\n    def recal_file         = recal ? \"recal=${recal}\" : \"\"\n    def pmd_file           = pmd ? \"pmdFile=${pmd}\" : \"\"\n    def known_alleles_file = known_alleles ? \"alleles=${known_alleles}\" : \"\"\n\n    def valid_method = ['MLE', 'Bayesian', 'allelePresence', 'randomBase', 'majorityBase']\n    if ( !valid_method.contains(method) )  { error \"Unrecognised calling method for ATLAS_CALL. Options: MLE, Bayesian, allelePresence, randomBase, majorityBase\" }\n\n    \"\"\"\n    atlas \\\\\n        task=call \\\\\n        bam=${bam} \\\\\n        fasta=${fasta} \\\\\n        $recal_file \\\\\n        $pmd_file \\\\\n        $known_alleles_file \\\\\n        method=${method} \\\\\n        $args\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        atlas: \\$((atlas 2>&1) | grep Atlas | head -n 1 | sed -e 's/^[ \\t]*Atlas //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Estimate the post-mortem damage patterns of DNA\nTags: ancient DNA, post mortem damage, bam", "answer": "process ATLAS_PMD {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/atlas:0.9.9--h082e891_0':\n        'biocontainers/atlas:0.9.9--h082e891_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(pool_rg_txt)\n    path(fasta)\n    path(fai)\n\n    output:\n    tuple val(meta), path(\"*_PMD_input_Empiric.txt\")    , emit: empiric\n    tuple val(meta), path(\"*_PMD_input_Exponential.txt\"), emit: exponential\n    tuple val(meta), path(\"*_PMD_Table_counts.txt\")     , emit: counts\n    tuple val(meta), path(\"*_PMD_Table.txt\")            , emit: table\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def pool_rg_txt = pool_rg_txt ? \"poolReadGroups=${pool_rg_txt}\" : \"\"\n    \"\"\"\n    atlas \\\\\n        $pool_rg_txt \\\\\n        task=PMD \\\\\n        bam=${bam} \\\\\n        fasta=${fasta} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        atlas: \\$((atlas 2>&1) | grep Atlas | head -n 1 | sed -e 's/^[ \\t]*Atlas //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: create mappability files for a genome\nTags: mappability, index, fasta, bedgraph, csv, wig", "answer": "process GENMAP_MAP {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genmap:1.3.0--h1b792b2_1' :\n        'biocontainers/genmap:1.3.0--h1b792b2_1' }\"\n\n    input:\n    tuple val(meta), path(index)\n    tuple val(meta2), path(regions)\n\n    output:\n    tuple val(meta), path(\"*.wig\")      , optional:true, emit: wig\n    tuple val(meta), path(\"*.bedgraph\") , optional:true, emit: bedgraph\n    tuple val(meta), path(\"*.txt\")      , optional:true, emit: txt\n    tuple val(meta), path(\"*.csv\")      , optional:true, emit: csv\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n    def bed = regions ? \"--selection ${regions}\" : \"\"\n\n    if (\"$index\" == \"${prefix}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    genmap \\\\\n        map \\\\\n        ${args} \\\\\n        ${bed} \\\\\n        --threads ${task.cpus} \\\\\n        --index ${index} \\\\\n        --output ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmap: \\$(genmap --version | sed 's/GenMap version: //; s/SeqAn.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n    def token_args = args.tokenize(\" \")\n    def wig = token_args.contains(\"-w\") || token_args.contains(\"--wig\") ?       \"touch ${prefix}.wig\"       : \"\"\n    def bg =  token_args.contains(\"-bg\") || token_args.contains(\"--bedgraph\") ? \"touch ${prefix}.bedgraph\"  : \"\"\n    def txt = token_args.contains(\"-t\") || token_args.contains(\"--txt\") ?       \"touch ${prefix}.txt\"       : \"\"\n    def csv = token_args.contains(\"-d\") || token_args.contains(\"--csv\") ?       \"touch ${prefix}.csv\"       : \"\"\n\n    if (\"$index\" == \"${prefix}\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    ${wig}\n    ${bg}\n    ${txt}\n    ${csv}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmap: \\$(genmap --version | sed 's/GenMap version: //; s/SeqAn.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: create index file for genmap\nTags: index, mappability, fasta", "answer": "process GENMAP_INDEX {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genmap:1.3.0--h1b792b2_1' :\n        'biocontainers/genmap:1.3.0--h1b792b2_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${prefix}\") , emit: index\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"$meta.id\"\n\n    \"\"\"\n    genmap \\\\\n        index \\\\\n        --fasta-file ${fasta} \\\\\n        --index ${prefix} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmap: \\$(genmap --version | sed 's/GenMap version: //; s/SeqAn.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"$meta.id\"\n\n    \"\"\"\n    touch ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genmap: \\$(genmap --version | sed 's/GenMap version: //; s/SeqAn.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Annotates output files from ExpansionHunter with the pathologic implications of the repeat sizes.\nTags: STR, repeat_expansions, annotate, vcf", "answer": "process STRANGER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/stranger:0.9.1--pyh7e72e81_0':\n        'biocontainers/stranger:0.9.1--pyh7e72e81_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    tuple val(meta2), path(variant_catalog)\n\n    output:\n    tuple val(meta), path(\"*.gz\"), emit: vcf\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def options_variant_catalog = variant_catalog ? \"--repeats-file $variant_catalog\" : \"\"\n    \"\"\"\n    stranger \\\\\n        $args \\\\\n        $vcf \\\\\n        $options_variant_catalog | gzip --no-name > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stranger: \\$( stranger --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stranger: \\$( stranger --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to detect resistance and lineages of M. tuberculosis genomes\nTags: Mycobacterium tuberculosis, resistance, serotype", "answer": "process TBPROFILER_PROFILE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/tb-profiler:3.0.8--pypyh5e36f6f_0' :\n        'biocontainers/tb-profiler:3.0.8--pypyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"bam/*.bam\")     , emit: bam\n    tuple val(meta), path(\"results/*.csv\") , emit: csv, optional: true\n    tuple val(meta), path(\"results/*.json\"), emit: json\n    tuple val(meta), path(\"results/*.txt\") , emit: txt, optional: true\n    tuple val(meta), path(\"vcf/*.vcf.gz\")  , emit: vcf\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def input_reads = meta.single_end ? \"--read1 $reads\" : \"--read1 ${reads[0]} --read2 ${reads[1]}\"\n    \"\"\"\n    tb-profiler \\\\\n        profile \\\\\n        $args \\\\\n        --prefix ${prefix} \\\\\n        --threads $task.cpus \\\\\n        $input_reads\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tbprofiler:  \\$( echo \\$(tb-profiler --version 2>&1) | sed 's/TBProfiler version //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Concatenate BAM or CRAM file\nTags: merge, bam, sam, cram", "answer": "process SAMTOOLS_CAT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta),  path(input_files, stageAs: \"?/*\")\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\") , optional:true, emit: bam\n    tuple val(meta), path(\"${prefix}.cram\"), optional:true, emit: cram\n    path  \"versions.yml\"                                  , emit: versions\n\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def file_type = input_files instanceof List ? input_files[0].getExtension() : input_files.getExtension()\n    \"\"\"\n    samtools \\\\\n        cat \\\\\n        --threads ${task.cpus-1} \\\\\n        $args \\\\\n        -o ${prefix}.${file_type} \\\\\n        $input_files\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.suffix ? \"${meta.id}${task.ext.suffix}\" : \"${meta.id}\"\n    def file_type = input_files instanceof List ? input_files[0].getExtension() : input_files.getExtension()\n    \"\"\"\n    touch ${prefix}.${file_type}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produces a consensus FASTA/FASTQ/PILEUP\nTags: consensus, bam, fastq, fasta, pileup", "answer": "process SAMTOOLS_CONSENSUS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_1':\n        'biocontainers/samtools:1.20--h50ea8bc_1' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.fasta\") , emit: fasta , optional: true\n    tuple val(meta), path(\"*.fastq\") , emit: fastq , optional: true\n    tuple val(meta), path(\"*.pileup\"), emit: pileup, optional: true\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"-f fastq\") ? \"fastq\" :\n                    args.contains(\"-f pileup\") ? \"pileup\" :\n                    args.contains(\"-f fasta\") ? \"fasta\" :\n                    \"fasta\"\n\n    \"\"\"\n    samtools \\\\\n        consensus \\\\\n        $args \\\\\n        -@ $task.cpus \\\\\n        -o ${prefix}.${extension} \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(samtools --version |& sed '1!d ; s/samtools //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"-f fastq\") ? \"fastq\" :\n                    args.contains(\"-f pileup\") ? \"pileup\" :\n                    args.contains(\"-f fasta\") ? \"fasta\" :\n                    \"fasta\"\n\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(samtools --version |& sed '1!d ; s/samtools //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: mark duplicate alignments in a coordinate sorted file\nTags: bam, duplicates, markduplicates, samtools", "answer": "process SAMTOOLS_MARKDUP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"),  emit: bam, optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram, optional: true\n    tuple val(meta), path(\"*.sam\"),  emit: sam,  optional: true\n    path \"versions.yml\",             emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    def extension = args.contains(\"--output-fmt sam\") ? \"sam\" :\n                    args.contains(\"--output-fmt bam\") ? \"bam\" :\n                    args.contains(\"--output-fmt cram\") ? \"cram\" :\n                    \"bam\"\n    if (\"$input\" == \"${prefix}.${extension}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    samtools \\\\\n        markdup \\\\\n        $args \\\\\n        ${reference} \\\\\n        -@ $task.cpus \\\\\n        -T $prefix \\\\\n        $input \\\\\n        ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-fmt sam\") ? \"sam\" :\n                    args.contains(\"--output-fmt bam\") ? \"bam\" :\n                    args.contains(\"--output-fmt cram\") ? \"cram\" :\n                    \"bam\"\n    if (\"$input\" == \"${prefix}.${extension}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The module uses bam2fq method from samtools to\nconvert a SAM, BAM or CRAM file to FASTQ format\n\nTags: bam2fq, samtools, fastq", "answer": "process SAMTOOLS_BAM2FQ {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(inputbam)\n    val split\n\n    output:\n    tuple val(meta), path(\"*.fq.gz\"), emit: reads\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (split){\n        \"\"\"\n        samtools \\\\\n            bam2fq \\\\\n            $args \\\\\n            -@ $task.cpus \\\\\n            -1 ${prefix}_1.fq.gz \\\\\n            -2 ${prefix}_2.fq.gz \\\\\n            -0 ${prefix}_other.fq.gz \\\\\n            -s ${prefix}_singleton.fq.gz \\\\\n            $inputbam\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        samtools \\\\\n            bam2fq \\\\\n            $args \\\\\n            -@ $task.cpus \\\\\n            $inputbam | gzip --no-name > ${prefix}_interleaved.fq.gz\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Samtools fixmate is a tool that can fill in information (insert size, cigar, mapq) about paired end reads onto the corresponding other read. Also has options to remove secondary/unmapped alignments and recalculate whether reads are proper pairs.\nTags: fixmate, samtools, insert size, repair, bam, paired, read pairs", "answer": "process SAMTOOLS_FIXMATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    samtools \\\\\n        fixmate  \\\\\n        $args \\\\\n        --threads ${task.cpus-1} \\\\\n        $bam \\\\\n        ${prefix}.bam \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes the depth at each position or region.\nTags: depth, samtools, statistics, coverage", "answer": "process SAMTOOLS_DEPTH {\n    tag \"$meta1.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta1), path(bam)\n    tuple val(meta2), path(intervals)\n\n    output:\n    tuple val(meta1), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta1.id}\"\n    def positions = intervals ? \"-b ${intervals}\" : \"\"\n    \"\"\"\n    samtools \\\\\n        depth \\\\\n        --threads ${task.cpus-1} \\\\\n        $args \\\\\n        $positions \\\\\n        -o ${prefix}.tsv \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sort SAM/BAM/CRAM file\nTags: sort, bam, sam, cram", "answer": "process SAMTOOLS_SORT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta) , path(bam)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"),     emit: bam,  optional: true\n    tuple val(meta), path(\"*.cram\"),    emit: cram, optional: true\n    tuple val(meta), path(\"*.crai\"),    emit: crai, optional: true\n    tuple val(meta), path(\"*.csi\"),     emit: csi,  optional: true\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-fmt sam\") ? \"sam\" :\n                    args.contains(\"--output-fmt cram\") ? \"cram\" :\n                    \"bam\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    samtools cat \\\\\n        --threads $task.cpus \\\\\n        ${bam} \\\\\n    | \\\\\n    samtools sort \\\\\n        $args \\\\\n        -T ${prefix} \\\\\n        --threads $task.cpus \\\\\n        ${reference} \\\\\n        -o ${prefix}.${extension} \\\\\n        -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--output-fmt sam\") ? \"sam\" :\n                    args.contains(\"--output-fmt cram\") ? \"cram\" :\n                    \"bam\"\n    \"\"\"\n    touch ${prefix}.${extension}\n    if [ \"${extension}\" == \"bam\" ];\n    then\n        touch ${prefix}.${extension}.csi\n    elif [ \"${extension}\" == \"cram\" ];\n    then\n        touch ${prefix}.${extension}.crai\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: shuffles and groups reads together by their names\nTags: collate, bam, sam, cram", "answer": "process SAMTOOLS_COLLATE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0':\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"),  emit: bam, optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram, optional: true\n    tuple val(meta), path(\"*.sam\"),  emit: sam,  optional: true\n    path \"versions.yml\",             emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    def extension = args.contains(\"--output-fmt sam\") ? \"sam\" :\n                    args.contains(\"--output-fmt bam\") ? \"bam\" :\n                    args.contains(\"--output-fmt cram\") ? \"cram\" :\n                    \"bam\"\n    if (\"$input\" == \"${prefix}.${extension}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    samtools \\\\\n        collate \\\\\n        $args \\\\\n        ${reference} \\\\\n        -@ $task.cpus \\\\\n        -o ${prefix}.${extension} \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge BAM or CRAM file\nTags: merge, bam, sam, cram", "answer": "process SAMTOOLS_MERGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input_files, stageAs: \"?/*\")\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\") , optional:true, emit: bam\n    tuple val(meta), path(\"${prefix}.cram\"), optional:true, emit: cram\n    tuple val(meta), path(\"*.csi\")         , optional:true, emit: csi\n    tuple val(meta), path(\"*.crai\")        , optional:true, emit: crai\n    path  \"versions.yml\"                                  , emit: versions\n\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def file_type = input_files instanceof List ? input_files[0].getExtension() : input_files.getExtension()\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    \"\"\"\n    samtools \\\\\n        merge \\\\\n        --threads ${task.cpus-1} \\\\\n        $args \\\\\n        ${reference} \\\\\n        ${prefix}.${file_type} \\\\\n        $input_files\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args   ?: ''\n    prefix = task.ext.suffix ? \"${meta.id}${task.ext.suffix}\" : \"${meta.id}\"\n    def file_type = input_files instanceof List ? input_files[0].getExtension() : input_files.getExtension()\n    def index_type = file_type == \"bam\" ? \"csi\" : \"crai\"\n    def index = args.contains(\"--write-index\") ? \"touch ${prefix}.${index_type}\" : \"\"\n    \"\"\"\n    touch ${prefix}.${file_type}\n    ${index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collate/Fixmate/Sort/Markdup SAM/BAM/CRAM file\nTags: cat, collate, fixmate, sort, markduplicates, bam, sam, cram, multi-tool", "answer": "process SAMTOOLS_SORMADUP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\")      , emit: bam,  optional: true\n    tuple val(meta), path(\"*.cram\")     , emit: cram, optional: true\n    tuple val(meta), path(\"*.csi\")      , emit: csi,  optional: true\n    tuple val(meta), path(\"*.crai\")     , emit: crai, optional: true\n    tuple val(meta), path(\"*.metrics\")  , emit: metrics\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def args4 = task.ext.args4 ?: ''\n    def args5 = task.ext.args5 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args5.contains(\"--output-fmt sam\") ? \"sam\" :\n                    args5.contains(\"--output-fmt cram\") ? \"cram\" :\n                    \"bam\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    def sort_memory = (task.memory.mega/task.cpus*0.75).intValue()\n\n    \"\"\"\n    samtools cat \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        ${input}  \\\\\n    | \\\\\n    samtools collate \\\\\n        $args2 \\\\\n        -O \\\\\n        -u \\\\\n        -T ${prefix}.collate \\\\\n        --threads $task.cpus \\\\\n        ${reference} \\\\\n        - \\\\\n    | \\\\\n    samtools fixmate \\\\\n        $args3 \\\\\n        -m \\\\\n        -u \\\\\n        --threads $task.cpus \\\\\n        - \\\\\n        - \\\\\n    | \\\\\n    samtools sort \\\\\n        $args4 \\\\\n        -u \\\\\n        -T ${prefix}.sort \\\\\n        --threads $task.cpus \\\\\n        -m ${sort_memory}M \\\\\n        - \\\\\n    | \\\\\n    samtools markdup \\\\\n        -T ${prefix} \\\\\n        -f ${prefix}.metrics \\\\\n        --threads $task.cpus \\\\\n        $args5 \\\\\n        - \\\\\n        ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args5 = task.ext.args5 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args5.contains(\"--output-fmt sam\") ? \"sam\" :\n                    args5.contains(\"--output-fmt cram\") ? \"cram\" :\n                    \"bam\"\n\n    \"\"\"\n    touch ${prefix}.${extension}\n    touch ${prefix}.metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: BAM\nTags: mpileup, bam, sam, cram", "answer": "process SAMTOOLS_MPILEUP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n    input:\n    tuple val(meta), path(input), path(intervals)\n    path  fasta\n\n    output:\n    tuple val(meta), path(\"*.mpileup.gz\"), emit: mpileup\n    path  \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def intervals = intervals ? \"-l ${intervals}\" : \"\"\n    \"\"\"\n    samtools mpileup \\\\\n        --fasta-ref $fasta \\\\\n        --output ${prefix}.mpileup \\\\\n        $args \\\\\n        $intervals \\\\\n        $input\n    bgzip ${prefix}.mpileup\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: calculates MD and NM tags\nTags: calmd, bam, cram", "answer": "process SAMTOOLS_CALMD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    samtools calmd \\\\\n        -@ $task.cpus \\\\\n        $args \\\\\n        $bam \\\\\n        $fasta \\\\\n        > ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Reports alignment summary statistics for a BAM/CRAM/SAM file\nTags: stats, mapping, counts, chromosome, bam, sam, cram", "answer": "process SAMTOOLS_IDXSTATS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path(\"*.idxstats\"), emit: idxstats\n    path  \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    samtools \\\\\n        idxstats \\\\\n        --threads ${task.cpus-1} \\\\\n        $bam \\\\\n        > ${prefix}.idxstats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.idxstats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Replace the header in the bam file with the header generated by the command.\nThis command is much faster than replacing the header with a BAM\u2192SAM\u2192BAM conversion.\n\nTags: reheader, cram, bam, genomics", "answer": "process SAMTOOLS_REHEADER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0':\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    samtools \\\\\n        reheader \\\\\n        $args \\\\\n        $bam \\\\\n        > ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    ccat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a SAM/BAM/CRAM file to FASTA\nTags: bam, sam, cram, fasta", "answer": "process SAMTOOLS_FASTA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    val(interleave)\n\n    output:\n    tuple val(meta), path(\"*_{1,2}.fasta.gz\")      , optional:true, emit: fasta\n    tuple val(meta), path(\"*_interleaved.fasta.gz\"), optional:true, emit: interleaved\n    tuple val(meta), path(\"*_singleton.fasta.gz\")  , optional:true, emit: singleton\n    tuple val(meta), path(\"*_other.fasta.gz\")      , optional:true, emit: other\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output = ( interleave && ! meta.single_end ) ? \"| gzip > ${prefix}_interleaved.fasta.gz\" :\n        meta.single_end ? \"-1 ${prefix}_1.fasta.gz -s ${prefix}_singleton.fasta.gz\" :\n        \"-1 ${prefix}_1.fasta.gz -2 ${prefix}_2.fasta.gz -s ${prefix}_singleton.fasta.gz\"\n    \"\"\"\n    samtools \\\\\n        fasta \\\\\n        $args \\\\\n        --threads ${task.cpus-1} \\\\\n        -0 ${prefix}_other.fasta.gz \\\\\n        $input \\\\\n        $output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Clips read alignments where they match BED file defined regions\nTags: amplicon, clipping, ampliconclip, samtools", "answer": "process SAMTOOLS_AMPLICONCLIP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path bed\n    val save_cliprejects\n    val save_clipstats\n\n    output:\n    tuple val(meta), path(\"*.clipallowed.bam\")  , emit: bam\n    tuple val(meta), path(\"*.clipstats.txt\")    , optional:true, emit: stats\n    tuple val(meta), path(\"*.cliprejects.bam\")  , optional:true, emit: rejects_bam\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def rejects = save_cliprejects ? \"--rejects-file ${prefix}.cliprejects.bam\" : \"\"\n    def stats   = save_clipstats   ? \"-f ${prefix}.clipstats.txt\"               : \"\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    samtools \\\\\n        ampliconclip \\\\\n        --threads ${task.cpus-1} \\\\\n        $args \\\\\n        $rejects \\\\\n        $stats \\\\\n        -b $bed \\\\\n        -o ${prefix}.clipallowed.bam \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Index FASTA file\nTags: index, fasta, faidx", "answer": "process SAMTOOLS_FAIDX {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(fai)\n\n    output:\n    tuple val(meta), path (\"*.{fa,fasta}\") , emit: fa , optional: true\n    tuple val(meta), path (\"*.fai\")        , emit: fai, optional: true\n    tuple val(meta), path (\"*.gzi\")        , emit: gzi, optional: true\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    samtools \\\\\n        faidx \\\\\n        $fasta \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def match = (task.ext.args =~ /-o(?:utput)?\\s(.*)\\s?/).findAll()\n    def fastacmd = match[0] ? \"touch ${match[0][1]}\" : ''\n    \"\"\"\n    ${fastacmd}\n    touch ${fasta}.fai\n\n    cat <<-END_VERSIONS > versions.yml\n\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: filter/convert SAM/BAM/CRAM file\nTags: view, bam, sam, cram", "answer": "process SAMTOOLS_VIEW {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(index)\n    tuple val(meta2), path(fasta)\n    path qname\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\"),                                    emit: bam,              optional: true\n    tuple val(meta), path(\"${prefix}.cram\"),                                   emit: cram,             optional: true\n    tuple val(meta), path(\"${prefix}.sam\"),                                    emit: sam,              optional: true\n    tuple val(meta), path(\"${prefix}.${file_type}.bai\"),                       emit: bai,              optional: true\n    tuple val(meta), path(\"${prefix}.${file_type}.csi\"),                       emit: csi,              optional: true\n    tuple val(meta), path(\"${prefix}.${file_type}.crai\"),                      emit: crai,             optional: true\n    tuple val(meta), path(\"${prefix}.unselected.${file_type}\"),                emit: unselected,       optional: true\n    tuple val(meta), path(\"${prefix}.unselected.${file_type}.{bai,csi,crsi}\"), emit: unselected_index, optional: true\n    path  \"versions.yml\",                                                      emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    file_type = args.contains(\"--output-fmt sam\") ? \"sam\" :\n                args.contains(\"--output-fmt bam\") ? \"bam\" :\n                args.contains(\"--output-fmt cram\") ? \"cram\" :\n                input.getExtension()\n    readnames = qname ? \"--qname-file ${qname} --output-unselected ${prefix}.unselected.${file_type}\": \"\"\n    if (\"$input\" == \"${prefix}.${file_type}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    samtools \\\\\n        view \\\\\n        --threads ${task.cpus-1} \\\\\n        ${reference} \\\\\n        ${readnames} \\\\\n        $args \\\\\n        -o ${prefix}.${file_type} \\\\\n        $input \\\\\n        $args2\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    file_type = args.contains(\"--output-fmt sam\") ? \"sam\" :\n                args.contains(\"--output-fmt bam\") ? \"bam\" :\n                args.contains(\"--output-fmt cram\") ? \"cram\" :\n                input.getExtension()\n    if (\"$input\" == \"${prefix}.${file_type}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    def index = args.contains(\"--write-index\") ? \"touch ${prefix}.${file_type}.csi\" : \"\"\n\n    \"\"\"\n    touch ${prefix}.${file_type}\n    ${index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Index SAM/BAM/CRAM file\nTags: index, bam, sam, cram", "answer": "process SAMTOOLS_INDEX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.bai\") , optional:true, emit: bai\n    tuple val(meta), path(\"*.csi\") , optional:true, emit: csi\n    tuple val(meta), path(\"*.crai\"), optional:true, emit: crai\n    path  \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    samtools \\\\\n        index \\\\\n        -@ ${task.cpus-1} \\\\\n        $args \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def extension = file(input).getExtension() == 'cram' ?\n                    \"crai\" : args.contains(\"-c\") ?  \"csi\" : \"bai\"\n    \"\"\"\n    touch ${input}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: filter/convert SAM/BAM/CRAM file\nTags: view, bam, sam, cram, readgroup", "answer": "process SAMTOOLS_GETRG {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), file(\"readgroups.txt\"),    emit: readgroup\n    path  \"versions.yml\",                       emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    samtools \\\\\n        view \\\\\n        -H \\\\\n        $args \\\\\n        $input \\\\\n    | grep '^@RG' > readgroups.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n\n    echo -e \"@RG\\\\tID:${prefix}\\\\tSM:${prefix}\\\\tPL:ILLUMINA\" > readgroups.txt\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: List CRAM Content-ID and Data-Series sizes\nTags: cram-size, cram, size", "answer": "process SAMTOOLS_CRAMSIZE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(cram)\n\n    output:\n    tuple val(meta), path(\"*.size\"), emit: size\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n    \"\"\"\n    samtools \\\\\n        cram-size \\\\\n        $args \\\\\n        -o ${prefix}.size \\\\\n        $cram\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"$meta.id\"\n    \"\"\"\n    touch ${prefix}.size\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The module uses collate and then fastq methods from samtools to\nconvert a SAM, BAM or CRAM file to FASTQ format\n\nTags: bam2fq, samtools, fastq", "answer": "process SAMTOOLS_COLLATEFASTQ {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    tuple val(meta2), path(fasta)\n    val(interleave)\n\n    output:\n    tuple val(meta), path(\"*_{1,2}.fq.gz\")          , optional:true, emit: fastq\n    tuple val(meta), path(\"*_interleaved.fq.gz\")    , optional:true, emit: fastq_interleaved\n    tuple val(meta), path(\"*_other.fq.gz\")          , emit: fastq_other\n    tuple val(meta), path(\"*_singleton.fq.gz\")      , optional:true, emit: fastq_singleton\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    def output =    (interleave && ! meta.single_end) ? \"> ${prefix}_interleaved.fq.gz\"                     :\n                    meta.single_end                   ? \"-1 ${prefix}_1.fq.gz -s ${prefix}_singleton.fq.gz\" :\n                    \"-1 ${prefix}_1.fq.gz -2 ${prefix}_2.fq.gz -s ${prefix}_singleton.fq.gz\"\n\n    \"\"\"\n    samtools collate \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        ${reference} \\\\\n        -O \\\\\n        $input \\\\\n        . |\n\n    samtools fastq \\\\\n        $args2 \\\\\n        --threads $task.cpus \\\\\n        ${reference} \\\\\n        -0 ${prefix}_other.fq.gz \\\\\n        $output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Counts the number of alignments in a BAM/CRAM/SAM file for each FLAG type\nTags: stats, mapping, counts, bam, sam, cram", "answer": "process SAMTOOLS_FLAGSTAT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path(\"*.flagstat\"), emit: flagstat\n    path  \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    samtools \\\\\n        flagstat \\\\\n        --threads ${task.cpus} \\\\\n        $bam \\\\\n        > ${prefix}.flagstat\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.flagstat\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: converts FASTQ files to unmapped SAM/BAM/CRAM\nTags: import, fastq, bam, sam, cram", "answer": "process SAMTOOLS_IMPORT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0':\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.sam\") , emit: sam,     optional: true\n    tuple val(meta), path(\"*.bam\") , emit: bam,     optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram,    optional: true\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = args.contains(\"--output-fmt sam\") ? \"sam\" :\n                args.contains(\"--output-fmt bam\") ? \"bam\" :\n                args.contains(\"--output-fmt cram\") ? \"cram\" :\n                \"bam\"\n    def input = reads instanceof List && meta.single_end ? reads.join(\" -0\") :               // multiple single-end files\n                reads instanceof List && !meta.single_end ? \"-1 ${reads[0]} -2 ${reads[1]}\": // paired end file\n                meta.single_end ? \"-0 $reads\" :                                              // single single-end file\n                !meta.single_end ? \"-s $reads\":                                              // interleave paired-end file\n                reads                                                                        // if all else fails, just add the reads without flags\n    \"\"\"\n    samtools \\\\\n        import \\\\\n        $input \\\\\n        $args \\\\\n        -@ $task.cpus \\\\\n        -o ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a SAM/BAM/CRAM file to FASTQ\nTags: bam, sam, cram, fastq", "answer": "process SAMTOOLS_FASTQ {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    val(interleave)\n\n    output:\n    tuple val(meta), path(\"*_{1,2}.fastq.gz\")      , optional:true, emit: fastq\n    tuple val(meta), path(\"*_interleaved.fastq\")   , optional:true, emit: interleaved\n    tuple val(meta), path(\"*_singleton.fastq.gz\")  , optional:true, emit: singleton\n    tuple val(meta), path(\"*_other.fastq.gz\")      , optional:true, emit: other\n    path  \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output = ( interleave && ! meta.single_end ) ? \"> ${prefix}_interleaved.fastq\" :\n        meta.single_end ? \"-1 ${prefix}_1.fastq.gz -s ${prefix}_singleton.fastq.gz\" :\n        \"-1 ${prefix}_1.fastq.gz -2 ${prefix}_2.fastq.gz -s ${prefix}_singleton.fastq.gz\"\n    \"\"\"\n    samtools \\\\\n        fastq \\\\\n        $args \\\\\n        --threads ${task.cpus-1} \\\\\n        -0 ${prefix}_other.fastq.gz \\\\\n        $input \\\\\n        $output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a sequence dictionary file from a FASTA file\nTags: dict, fasta, sequence", "answer": "process SAMTOOLS_DICT {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path (\"*.dict\"), emit: dict\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    samtools \\\\\n        dict \\\\\n        $args \\\\\n        $fasta \\\\\n        > ${fasta}.dict\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${fasta}.dict\n    cat <<-END_VERSIONS > versions.yml\n\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: produces a histogram or table of coverage per chromosome\nTags: depth, samtools, bam", "answer": "process SAMTOOLS_COVERAGE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: coverage\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    samtools \\\\\n        coverage \\\\\n        $args \\\\\n        -o ${prefix}.txt \\\\\n        --reference ${fasta} \\\\\n        $input\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produces comprehensive statistics from SAM/BAM/CRAM file\nTags: statistics, counts, bam, sam, cram", "answer": "process SAMTOOLS_STATS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.stats\"), emit: stats\n    path  \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    \"\"\"\n    samtools \\\\\n        stats \\\\\n        --threads ${task.cpus} \\\\\n        ${reference} \\\\\n        ${input} \\\\\n        > ${prefix}.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: convert and then index CRAM -> BAM or BAM -> CRAM file\nTags: view, index, bam, cram", "answer": "process SAMTOOLS_CONVERT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.bam\")  , emit: bam ,   optional: true\n    tuple val(meta), path(\"*.cram\") , emit: cram,   optional: true\n    tuple val(meta), path(\"*.bai\")  , emit: bai ,   optional: true\n    tuple val(meta), path(\"*.crai\") , emit: crai,   optional: true\n    path  \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args  ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_extension = input.getExtension() == \"bam\" ? \"cram\" : \"bam\"\n\n    \"\"\"\n    samtools view \\\\\n        --threads ${task.cpus} \\\\\n        --reference ${fasta} \\\\\n        $args \\\\\n        $input \\\\\n        -o ${prefix}.${output_extension}\n\n    samtools index -@${task.cpus} ${prefix}.${output_extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output_extension = input.getExtension() == \"bam\" ? \"cram\" : \"bam\"\n    def index_extension = output_extension == \"bam\" ? \"bai\" : \"crai\"\n\n    \"\"\"\n    touch ${prefix}.${output_extension}\n    touch ${prefix}.${index_extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: CheckM provides a set of tools for assessing the quality of genomes recovered from isolates, single cells, or metagenomes.\nTags: checkm, mag, metagenome, quality, isolates, microbes, single cells, completeness, contamination, bins, genome bins", "answer": "process CHECKM_LINEAGEWF {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/checkm-genome:1.2.3--pyhdfd78af_0' :\n        'biocontainers/checkm-genome:1.2.3--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta, stageAs: \"input_bins/*\")\n    val fasta_ext\n    path db\n\n    output:\n    tuple val(meta), path(\"${prefix}\")           , emit: checkm_output\n    tuple val(meta), path(\"${prefix}/lineage.ms\"), emit: marker_file\n    tuple val(meta), path(\"${prefix}.tsv\")       , emit: checkm_tsv\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args  = task.ext.args   ?: ''\n    prefix    = task.ext.prefix ?: \"${meta.id}\"\n    checkm_db = db ? \"export CHECKM_DATA_PATH=${db}\" : \"\"\n    \"\"\"\n    $checkm_db\n\n    checkm \\\\\n        lineage_wf \\\\\n        -t $task.cpus \\\\\n        -f ${prefix}.tsv \\\\\n        --tab_table \\\\\n        --pplacer_threads $task.cpus \\\\\n        -x $fasta_ext \\\\\n        $args \\\\\n        input_bins/ \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkm: \\$( checkm 2>&1 | grep '...:::' | sed 's/.*CheckM v//;s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: CheckM provides a set of tools for assessing the quality of genomes recovered from isolates, single cells, or metagenomes.\nTags: checkm, mag, metagenome, quality, isolates, microbes, single cells, completeness, contamination, bins, genome bins, qa, quality assurnce", "answer": "process CHECKM_QA {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/checkm-genome:1.2.1--pyhdfd78af_0' :\n        'biocontainers/checkm-genome:1.2.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(analysis_dir), path(marker_file), path(coverage_file)\n    path exclude_marker_file\n\n    output:\n    tuple val(meta), path(\"${prefix}.txt\")  , optional: true, emit: output\n    tuple val(meta), path(\"${prefix}.fasta\"), optional: true, emit: fasta\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args     = task.ext.args ?: ''\n    prefix       = task.ext.prefix ?: \"${meta.id}\"\n    suffix       = task.ext.args?.matches(\".*-o 9.*|.*--out_file 9.*\") ? \"fasta\" : \"txt\"\n    def coverage = coverage_file                                   ? \"--coverage_file ${coverage_file}\"  : \"\"\n    def exclude  = exclude_marker_file                             ? \"--exclude_markers ${marker_filer}\" : \"\"\n    \"\"\"\n    checkm \\\\\n        qa \\\\\n        --threads ${task.cpus} \\\\\n        --file ${prefix}.${suffix} \\\\\n        $marker_file \\\\\n        $analysis_dir \\\\\n        $coverage \\\\\n        $exclude \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkm: \\$( checkm 2>&1 | grep '...:::' | sed 's/.*CheckM v//;s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A deep learning based approach to predict Antibiotic Resistance Genes (ARGs) from metagenomes\nTags: deeparg, antimicrobial resistance, antimicrobial resistance genes, arg, deep learning, prediction, contigs, metagenomes", "answer": "process DEEPARG_PREDICT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeparg:1.0.4--pyhdfd78af_0' :\n        'biocontainers/deeparg:1.0.4--pyhdfd78af_0' }\"\n\n    /*\n    We have to force docker/singularity to mount a fake file to allow reading of a problematic file with borked read-write permissions in an upstream dependency (theanos).\n    Original report: https://github.com/nf-core/funcscan/issues/23\n    */\n    containerOptions {\n        \"${workflow.containerEngine}\" == 'singularity' ? '-B $(which bash):/usr/local/lib/python2.7/site-packages/Theano-0.8.2-py2.7.egg-info/PKG-INFO' :\n        \"${workflow.containerEngine}\" == 'docker'      ? '-v $(which bash):/usr/local/lib/python2.7/site-packages/Theano-0.8.2-py2.7.egg-info/PKG-INFO' :\n        ''\n    }\n\n    input:\n    tuple val(meta), path(fasta), val(model)\n    path(db)\n\n    output:\n    tuple val(meta), path(\"*.align.daa\")            , emit: daa\n    tuple val(meta), path(\"*.align.daa.tsv\")        , emit: daa_tsv\n    tuple val(meta), path(\"*.mapping.ARG\")          , emit: arg\n    tuple val(meta), path(\"*.mapping.potential.ARG\"), emit: potential_arg\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION='1.0.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    DATABASE=`find -L $db -type d -name \"database\" | sed 's/database//'`\n\n    # Theano needs a writable space and uses the home directory by default,\n    # but the latter is not always writable, for instance when Singularity\n    # is run in --no-home mode\n    mkdir -p theano\n    export THEANO_FLAGS=\"base_compiledir=\\$PWD/theano\"\n\n    deeparg \\\\\n        predict \\\\\n        $args \\\\\n        -i $fasta \\\\\n        -o ${prefix} \\\\\n        -d \\$DATABASE \\\\\n        --model $model\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeparg: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION='1.0.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.align.daa\n    touch ${prefix}.align.daa.tsv\n    touch ${prefix}.mapping.ARG\n    touch ${prefix}.mapping.potential.ARG\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeparg: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A deep learning based approach to predict Antibiotic Resistance Genes (ARGs) from metagenomes\nTags: download, database, deeparg, antimicrobial resistance genes, deep learning, prediction", "answer": "process DEEPARG_DOWNLOADDATA {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/deeparg:1.0.4--pyhdfd78af_0' :\n        'biocontainers/deeparg:1.0.4--pyhdfd78af_0' }\"\n\n    /*\n    We have to force docker/singularity to mount a fake file to allow reading of a problematic file with borked read-write permissions in an upstream dependency (theanos).\n    Original report: https://github.com/nf-core/funcscan/issues/23\n    */\n    containerOptions {\n        \"${workflow.containerEngine}\" == 'singularity' ? '-B $(which bash):/usr/local/lib/python2.7/site-packages/Theano-0.8.2-py2.7.egg-info/PKG-INFO' :\n        \"${workflow.containerEngine}\" == 'docker'      ? '-v $(which bash):/usr/local/lib/python2.7/site-packages/Theano-0.8.2-py2.7.egg-info/PKG-INFO' :\n        ''\n    }\n\n    input:\n\n    output:\n    path \"db/\"          , emit: db\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def VERSION='1.0.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n\n    # Theano needs a writable space and uses the home directory by default,\n    # but the latter is not always writable, for instance when Singularity\n    # is run in --no-home mode\n    mkdir -p theano\n    export THEANO_FLAGS=\"base_compiledir=\\$PWD/theano\"\n\n    deeparg \\\\\n        download_data \\\\\n        $args \\\\\n        -o db/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeparg: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def VERSION='1.0.4' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    mkdir db/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deeparg: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generally applicable transcriptome-wide analysis of translational efficiency using anota2seq\nTags: riboseq, rnaseq, translation, differential", "answer": "process ANOTA2SEQ_ANOTA2SEQRUN {\n    tag \"$meta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-anota2seq:1.24.0--r43hdfd78af_0' :\n        'biocontainers/bioconductor-anota2seq:1.24.0--r43hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), val(sample_treatment_col), val(reference), val(target)\n    tuple val(meta2), path(samplesheet), path(counts)\n\n    output:\n    tuple val(meta), path(\"*.translated_mRNA.anota2seq.results.tsv\")            , emit: translated_mrna\n    tuple val(meta), path(\"*.total_mRNA.anota2seq.results.tsv\")                 , emit: total_mrna\n    tuple val(meta), path(\"*.translation.anota2seq.results.tsv\")                , emit: translation\n    tuple val(meta), path(\"*.buffering.anota2seq.results.tsv\")                  , emit: buffering\n    tuple val(meta), path(\"*.mRNA_abundance.anota2seq.results.tsv\")             , emit: mrna_abundance\n    tuple val(meta), path(\"*.Anota2seqDataSet.rds\")                             , emit: rdata\n    tuple val(meta), path(\"*.fold_change.png\")                                  , emit: fold_change_plot\n    tuple val(meta), path(\"*.interaction_p_distribution.pdf\")                   , emit: interaction_p_distribution_plot, optional: true\n    tuple val(meta), path(\"*.residual_distribution_summary.jpeg\")               , emit: residual_distribution_summary_plot, optional: true\n    tuple val(meta), path(\"*.residual_vs_fitted.jpeg\")                          , emit: residual_vs_fitted_plot, optional: true\n    tuple val(meta), path(\"*.rvm_fit_for_all_contrasts_group.jpg\")              , emit: rvm_fit_for_all_contrasts_group_plot, optional: true\n    tuple val(meta), path(\"*.rvm_fit_for_interactions.jpg\")                     , emit: rvm_fit_for_interactions_plot, optional: true\n    tuple val(meta), path(\"*.rvm_fit_for_omnibus_group.jpg\")                    , emit: rvm_fit_for_omnibus_group_plot, optional: true\n    tuple val(meta), path(\"*.simulated_vs_obt_dfbetas_without_interaction.pdf\") , emit: simulated_vs_obt_dfbetas_without_interaction_plot, optional: true\n    tuple val(meta), path(\"*.R_sessionInfo.log\")                                , emit: session_info\n    path \"versions.yml\"                                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'anota2seqrun.r'\n}\n"}
{"question": "Description: Trim sequencing adapters and collapse overlapping reads\nTags: trimming, adapters, merging, fastq", "answer": "process ADAPTERREMOVAL {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/adapterremoval:2.3.2--hb7ba0dd_0' :\n        'biocontainers/adapterremoval:2.3.2--hb7ba0dd_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path(adapterlist)\n\n    output:\n    tuple val(meta), path(\"${prefix}.truncated.fastq.gz\")            , optional: true, emit: singles_truncated\n    tuple val(meta), path(\"${prefix}.discarded.fastq.gz\")            , optional: true, emit: discarded\n    tuple val(meta), path(\"${prefix}.pair{1,2}.truncated.fastq.gz\")  , optional: true, emit: paired_truncated\n    tuple val(meta), path(\"${prefix}.collapsed.fastq.gz\")            , optional: true, emit: collapsed\n    tuple val(meta), path(\"${prefix}.collapsed.truncated.fastq.gz\")  , optional: true, emit: collapsed_truncated\n    tuple val(meta), path(\"${prefix}.paired.fastq.gz\")               , optional: true, emit: paired_interleaved\n    tuple val(meta), path('*.settings')                              , emit: settings\n    path \"versions.yml\"                                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def list = adapterlist ? \"--adapter-list ${adapterlist}\" : \"\"\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (meta.single_end) {\n        \"\"\"\n        AdapterRemoval  \\\\\n            --file1 $reads \\\\\n            $args \\\\\n            $list \\\\\n            --basename ${prefix} \\\\\n            --threads ${task.cpus} \\\\\n            --seed 42 \\\\\n            --gzip\n\n        ensure_fastq() {\n            if [ -f \"\\${1}\" ]; then\n                mv \"\\${1}\" \"\\${1::-3}.fastq.gz\"\n            fi\n\n        }\n\n        ensure_fastq '${prefix}.truncated.gz'\n        ensure_fastq '${prefix}.discarded.gz'\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            adapterremoval: \\$(AdapterRemoval --version 2>&1 | sed -e \"s/AdapterRemoval ver. //g\")\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        AdapterRemoval  \\\\\n            --file1 ${reads[0]} \\\\\n            --file2 ${reads[1]} \\\\\n            $args \\\\\n            $list \\\\\n            --basename ${prefix} \\\\\n            --threads $task.cpus \\\\\n            --seed 42 \\\\\n            --gzip\n\n        ensure_fastq() {\n            if [ -f \"\\${1}\" ]; then\n                mv \"\\${1}\" \"\\${1::-3}.fastq.gz\"\n            fi\n\n        }\n\n        ensure_fastq '${prefix}.truncated.gz'\n        ensure_fastq '${prefix}.discarded.gz'\n        ensure_fastq '${prefix}.pair1.truncated.gz'\n        ensure_fastq '${prefix}.pair2.truncated.gz'\n        ensure_fastq '${prefix}.collapsed.gz'\n        ensure_fastq '${prefix}.collapsed.truncated.gz'\n        ensure_fastq '${prefix}.paired.gz'\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            adapterremoval: \\$(AdapterRemoval --version 2>&1 | sed -e \"s/AdapterRemoval ver. //g\")\n        END_VERSIONS\n        \"\"\"\n    }\n\n}\n"}
{"question": "Description: Dereplicate FASTX sequences, removing duplicate sequences and printing the number of identical sequences in the sequence header. Can dereplicate already dereplicated FASTA files, summing the numbers found in the headers.\nTags: dereplicate, fasta, uniques", "answer": "process SEQFU_DEREP {\n    tag \"$meta.id\"\n    label 'process_low'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqfu:1.20.3--h1eb128b_2':\n        'biocontainers/seqfu:1.20.3--h1eb128b_2' }\"\n\n    input:\n    tuple val(meta), path(fastas)\n\n    output:\n    tuple val(meta), path(\"*_derep.fasta.gz\"), emit: fasta\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_derep\"\n    def fasta_files = fastas.collect { it.getName() }\n    if (fasta_files.any { it == \"${prefix}.fasta.gz\" }) {\n        error \"Input file name coincides with the output file name: ${prefix}.fasta.gz. Please set a unique prefix.\"\n    }\n\n    \"\"\"\n    seqfu \\\\\n        derep \\\\\n        $args \\\\\n        $fastas | gzip -c > \"${prefix}.fasta.gz\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqfu: \\$(seqfu version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_derep\"\n    \"\"\"\n    echo \"\" | gzip -c > \"${prefix}.fasta.gz\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqfu: \\$(seqfu version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Statistics for FASTA or FASTQ files\nTags: seqfu, stats, n50", "answer": "process SEQFU_STATS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqfu:1.20.3--h1eb128b_0':\n        'biocontainers/seqfu:1.20.3--h1eb128b_0' }\"\n\n\n    input:\n    // stats can get one or more fasta or fastq files\n    tuple val(meta), path(files)\n\n    output:\n    tuple val(meta), path(\"*.tsv\")    ,  emit: stats\n    tuple val(meta), path(\"*_mqc.txt\"), emit: multiqc\n    path \"versions.yml\"               ,  emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    seqfu \\\\\n        stats \\\\\n        $args \\\\\n        --multiqc ${prefix}_mqc.txt \\\\\n        $files > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqfu: \\$(seqfu version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_mqc.txt\n    seqfu stats ${prefix}_mqc.txt > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqfu: \\$(samtools --version |& sed '1!d ; s/samtools //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Chromograph is a python package to create PNG images from genetics data such as BED and WIG files.\nTags: chromosome_visualization, bed, wig, png", "answer": "process CHROMOGRAPH {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/chromograph:1.3.1--pyhdfd78af_2':\n        'biocontainers/chromograph:1.3.1--pyhdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(autozyg)\n    tuple val(meta2), path(coverage)\n    tuple val(meta3), path(exome)\n    tuple val(meta4), path(fracsnp)\n    tuple val(meta5), path(ideogram)\n    tuple val(meta6), path(regions)\n    tuple val(meta7), path(sites)\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), emit: plots\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args           = task.ext.args   ?: ''\n    def autozyg_param  = autozyg         ? \"--autozyg ${autozyg}\"   : ''\n    def coverage_param = coverage        ? \"--coverage ${coverage}\" : ''\n    def exome_param    = exome           ? \"--exom ${exome}\"        : ''\n    def fracsnp_param  = fracsnp         ? \"--fracsnp ${fracsnp}\"   : ''\n    def ideogram_param = ideogram        ? \"--ideogram ${ideogram}\" : ''\n    def regions_param  = regions         ? \"--regions ${regions}\"   : ''\n    def sites_param    = sites           ? \"--sites ${sites}\"       : ''\n\n    if (autozyg) {\n        prefix         = task.ext.prefix ?: \"${meta.id}\"\n    } else if (coverage) {\n        prefix         = task.ext.prefix ?: \"${meta2.id}\"\n    } else if (exome) {\n        prefix         = task.ext.prefix ?: \"${meta3.id}\"\n    } else if (fracsnp) {\n        prefix         = task.ext.prefix ?: \"${meta4.id}\"\n    } else if (ideogram) {\n        prefix         = task.ext.prefix ?: \"${meta5.id}\"\n    } else if (regions) {\n        prefix         = task.ext.prefix ?: \"${meta6.id}\"\n    } else {\n        prefix         = task.ext.prefix ?: \"${meta7.id}\"\n    }\n    \"\"\"\n    chromograph \\\\\n        $args \\\\\n        $autozyg_param \\\\\n        $coverage_param \\\\\n        $exome_param \\\\\n        $fracsnp_param \\\\\n        $ideogram_param \\\\\n        $regions_param \\\\\n        $sites_param \\\\\n        --outd ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        chromograph: \\$(echo \\$(chromograph --version 2>&1) | sed 's/chromograph //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args               = task.ext.args   ?: ''\n\n    if (autozyg) {\n        prefix             = task.ext.prefix ?: \"${meta.id}\"\n    } else if (coverage) {\n        prefix             = task.ext.prefix ?: \"${meta2.id}\"\n    } else if (exome) {\n        prefix             = task.ext.prefix ?: \"${meta3.id}\"\n    } else if (fracsnp) {\n        prefix             = task.ext.prefix ?: \"${meta4.id}\"\n    } else if (ideogram) {\n        prefix             = task.ext.prefix ?: \"${meta5.id}\"\n    } else if (regions) {\n        prefix             = task.ext.prefix ?: \"${meta6.id}\"\n    } else {\n        prefix             = task.ext.prefix ?: \"${meta7.id}\"\n    }\n    \"\"\"\n    mkdir ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        chromograph: \\$(echo \\$(chromograph --version 2>&1) | sed 's/chromograph //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Accelerated implementation of the Picard CollectVariantCallingMetrics tool.\nTags: vcf, sentieon, genomics", "answer": "process SENTIEON_COLLECTVCMETRICS {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta) , path(vcf), path(tbi)\n    tuple val(meta2), path(dbsnp), path(dbsnp_tbi)\n    tuple val(meta3), path(fasta)\n    tuple val(meta4), path(fai)\n    tuple val(meta5), path(interval)\n\n    output:\n    tuple val(meta), path(\"*.variant_calling_detail_metrics\") , emit: metrics\n    tuple val(meta), path(\"*.variant_calling_summary_metrics\"), emit: summary\n    path \"versions.yml\"                                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix        = task.ext.prefix ?: \"${meta.id}\"\n    def args         = task.ext.args  ?: ''\n    def args2        = task.ext.args2 ?: ''\n    def interval_cmd = interval ? \"--interval $interval\" : \"\"\n    \"\"\"\n    sentieon \\\\\n        driver \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        $interval_cmd \\\\\n        $args \\\\\n        --algo CollectVCMetrics \\\\\n        -v ${vcf} \\\\\n        -d ${dbsnp} \\\\\n        $args2 \\\\\n        ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.variant_calling_detail_metrics\n    touch ${prefix}.variant_calling_summary_metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Perform joint genotyping on one or more samples pre-called with Sentieon's Haplotyper.\n\nTags: joint genotyping, genotype, gvcf", "answer": "process SENTIEON_GVCFTYPER {\n    tag \"$meta.id\"\n    label 'process_high'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(gvcfs), path(tbis), path(intervals)\n    tuple val(meta1), path(fasta)\n    tuple val(meta2), path(fai)\n    tuple val(meta3), path(dbsnp)\n    tuple val(meta4), path(dbsnp_tbi)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")    , emit: vcf_gz\n    tuple val(meta), path(\"*.vcf.gz.tbi\"), emit: vcf_gz_tbi\n    path(\"versions.yml\")                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def gvcfs_input = '-v ' + gvcfs.join(' -v ')\n    def dbsnp_cmd = dbsnp ? \"--dbsnp $dbsnp\" : \"\"\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver -r ${fasta} --algo GVCFtyper ${gvcfs_input} ${dbsnp_cmd} ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip >${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: TNscope algorithm performs somatic variant calling on the tumor-normal matched pair or the tumor only data, using a Haplotyper algorithm.\nTags: tnscope, sentieon, variant_calling", "answer": "process SENTIEON_TNSCOPE {\n    tag \"$meta.id\"\n    label 'process_high'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(cosmic), path(cosmic_tbi)\n    tuple val(meta5), path(pon), path(pon_tbi)\n    tuple val(meta6), path(dbsnp), path(dbsnp_tbi)\n    tuple val(meta7), path(interval)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")    , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\"), emit: index\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args         = task.ext.args   ?: ''\n    def args2        = task.ext.args2  ?: ''\n    def interval_str = interval      ? \"--interval ${interval}\" : ''\n    def cosmic_str = cosmic          ? \"--cosmic ${cosmic}\"          : ''\n    def dbsnp_str  = dbsnp           ? \"--dbsnp ${dbsnp}\"            : ''\n    def pon_str    = pon             ? \"--pon ${pon}\"                : ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        -i $bam \\\\\n        $interval_str \\\\\n        $args \\\\\n        --algo TNscope \\\\\n        --tumor_sample ${meta.id} \\\\\n        $args2 \\\\\n        $cosmic_str \\\\\n        $dbsnp_str \\\\\n        $pon_str \\\\\n        ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create BWA index for reference genome\nTags: index, fasta, genome, reference, sentieon", "answer": "process SENTIEON_BWAINDEX {\n    tag \"$fasta\"\n    label 'process_high'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(bwa), emit: index\n    path \"versions.yml\"       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ? \"bwa/${task.ext.prefix}\" : \"bwa/${fasta.baseName}\"\n    \"\"\"\n    mkdir bwa\n\n    sentieon \\\\\n        bwa index \\\\\n        $args \\\\\n        -p $prefix \\\\\n        $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n        bwa: \\$(echo \\$(sentieon bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir bwa\n\n    touch bwa/genome.amb\n    touch bwa/genome.ann\n    touch bwa/genome.bwt\n    touch bwa/genome.pac\n    touch bwa/genome.sa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n        bwa: \\$(echo \\$(sentieon bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Tnhaplotyper2 performs somatic variant calling on the tumor-normal matched pairs.\nTags: tnseq, tnhaplotyper2, sentieon, variant_calling", "answer": "process SENTIEON_TNHAPLOTYPER2 {\n    tag \"$meta.id\"\n    label 'process_high'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(intervals)\n    tuple val(meta2), path(dict)\n    tuple val(meta3), path(fasta)\n    tuple val(meta4), path(fai)\n    tuple val(meta5), path(germline_resource)\n    tuple val(meta6), path(germline_resource_tbi)\n    tuple val(meta7), path(panel_of_normals)\n    tuple val(meta8), path(panel_of_normals_tbi)\n    val(emit_orientation_data)\n    val(emit_contamination_data)\n\n    output:\n    tuple val(meta), path(\"*.orientation_data.tsv\")  , optional:true , emit: orientation_data\n    tuple val(meta), path(\"*.contamination_data.tsv\"), optional:true , emit: contamination_data\n    tuple val(meta), path(\"*.segments\")              , optional:true , emit: contamination_segments\n    tuple val(meta), path(\"*.stats\")                 , emit: stats\n    tuple val(meta), path(\"*.vcf.gz\")                , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\")            , emit: index\n    path \"versions.yml\"                              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args                      = task.ext.args                      ?: ''  // options for \"sentieon driver\"\n    def args2                     = task.ext.args2                     ?: ''  // options for the TNhaplotyper2 algorithm. It could be something like \"--tumor_sample <tumour_id> --normal_sample <normal_id>\"\n    def args3                     = task.ext.args3                     ?: ''  // options for the OrientationBias algorithm. It could be something like \"--tumor_sample <tumour_id>\"\n    def args4                     = task.ext.args4                     ?: ''  // options for the ContaminationModel algorithm. It could be something like \"--tumor_sample <tumour_id> --normal_sample <normal_id>\"\n    def prefix                    = task.ext.prefix                    ?: \"${meta.id}\"\n    def gr_command                = germline_resource                  ? \"--germline_vcf $germline_resource\" : \"\"\n    def interval_command          = intervals                          ? \"--interval $intervals\"             : \"\"\n    def pon_command               = panel_of_normals                   ? \"--pon $panel_of_normals\"           : \"\"\n    def inputs                    = input.collect{ \"-i $it\"}.join(\" \")\n    def orientation_bias_cmd      = \"\"\n    def contamination_cmd         = \"\"\n\n    if (emit_orientation_data) {\n        orientation_bias_cmd = \"--algo OrientationBias $args3 ${prefix}.orientation_data.tsv\"\n    }\n\n    if (emit_contamination_data) {\n        contamination_cmd = \"--algo ContaminationModel $args4 --vcf $germline_resource --tumor_segments ${prefix}.segments ${prefix}.contamination_data.tsv\"\n    }\n\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        $args \\\\\n        $inputs \\\\\n        $interval_command \\\\\n        --algo TNhaplotyper2 \\\\\n        $args2 \\\\\n        $gr_command \\\\\n        $pon_command \\\\\n        ${prefix}.vcf.gz \\\\\n        $orientation_bias_cmd \\\\\n        $contamination_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n    touch ${prefix}.contamination_data.tsv\n    touch ${prefix}.orientation_data.tsv\n    touch ${prefix}.segments\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: modifies the input VCF file by adding the MLrejected FILTER to the variants\nTags: dnamodelapply, vcf, filter, sentieon", "answer": "process SENTIEON_DNAMODELAPPLY {\n    tag \"$meta.id\"\n    label 'process_high'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(idx)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(ml_model)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")    , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\"), emit: index\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args      = task.ext.args   ?: ''\n    def prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        $args \\\\\n        --algo DNAModelApply \\\\\n        --model $ml_model \\\\\n        -v $vcf \\\\\n        ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs fastq alignment to a fasta reference using Sentieon's BWA MEM\nTags: mem, bwa, alignment, map, fastq, bam, sentieon", "answer": "process SENTIEON_BWAMEM {\n    tag \"$meta.id\"\n    label 'process_high'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    tuple val(meta2), path(index)\n    tuple val(meta3), path(fasta)\n    tuple val(meta4), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"${prefix}\"), path(\"${prefix}.{bai,crai}\"), emit: bam_and_bai\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}.bam\"\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n\n    \"\"\"\n    $sentieonLicense\n    export bwt_max_mem=\"${(task.memory * 0.9).toGiga()}G\"\n\n    INDEX=`find -L ./ -name \"*.amb\" | sed 's/.amb//'`\n\n    sentieon bwa mem \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        \\$INDEX \\\\\n        $reads \\\\\n        | sentieon util sort -r $fasta -t $task.cpus -o ${prefix} --sam2bam -\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n        bwa: \\$(echo \\$(sentieon bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}.bam\"\n    index  = prefix.tokenize('.')[-1] == \"bam\" ? \"bai\" : \"crai\"\n\n    \"\"\"\n    touch ${prefix}\n    touch ${prefix}.${index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n        bwa: \\$(echo \\$(sentieon bwa 2>&1) | sed 's/^.*Version: //; s/Contact:.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Accelerated implementation of the GATK DepthOfCoverage tool.\nTags: coverage, sentieon, genomics", "answer": "process SENTIEON_COVERAGEMETRICS {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta) , path(bam), path(bai)\n    tuple val(meta2), path(interval)\n    tuple val(meta3), path(fasta)\n    tuple val(meta4), path(fai)\n    tuple val(meta5), path(gene_list)\n\n    output:\n    tuple val(meta), path(\"$prefix\")                                                       , optional: true, emit: per_locus\n    tuple val(meta), path(\"${prefix}.${partitions_output}_summary\")                        , optional: true, emit: sample_summary\n    tuple val(meta), path(\"${prefix}.${partitions_output}_interval_statistics\")            , optional: true, emit: statistics\n    tuple val(meta), path(\"${prefix}.${partitions_output}_cumulative_coverage_counts\")     , optional: true, emit: coverage_counts\n    tuple val(meta), path(\"${prefix}.${partitions_output}_cumulative_coverage_proportions\"), optional: true, emit: coverage_proportions\n    tuple val(meta), path(\"${prefix}.${partitions_output}_interval_summary\")               , optional: true, emit: interval_summary\n    path \"versions.yml\"                                                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def args           = task.ext.args  ?: ''\n    def args2          = task.ext.args2 ?: ''\n    def input          = bam.sort().collect{\"-i $it\"}.join(' ')\n    def interval_cmd   = interval   ? \"--interval $interval\"                : \"\"\n    def gene_list_cmd  = gene_list  ? \"--gene_list ${gene_list}\"            : \"\"\n    // Glob that matches any version of 'sample_library_platform_center'.\n    partitions_output = \"{sample,}{_library,}{_platform,}{_center,}{_readgroup,}\"\n    \"\"\"\n    sentieon \\\\\n        driver \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        $interval_cmd \\\\\n        $input \\\\\n        $args \\\\\n        --algo CoverageMetrics \\\\\n        $args2 \\\\\n        ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}\n    touch ${prefix}.sample_interval_statistics\n    touch ${prefix}.sample_cumulative_coverage_counts\n    touch ${prefix}.sample_cumulative_coverage_proportions\n    touch ${prefix}.sample_interval_summary\n    touch ${prefix}.sample_cumulative_coverage_counts\n    touch ${prefix}.sample_cumulative_coverage_proportions\n    touch ${prefix}.sample_interval_summary\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate recalibration table and optionally perform base quality recalibration\nTags: base quality score recalibration, bqsr, sentieon", "answer": "process SENTIEON_QUALCAL {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(known_sites)\n    tuple val(meta5), path(known_sites_tbi)\n    tuple val(meta6), path(recalibration_table)\n    val generate_recalibrated_bams\n\n    output:\n    tuple val(meta), path (\"*.table\")       , emit: table           , optional: true\n    tuple val(meta), path (\"*.table.post\")  , emit: table_post      , optional: true\n    tuple val(meta), path (\"*.{cram,bam}\")  , emit: recal_alignment , optional: true\n    tuple val(meta), path (\"*.csv\")         , emit: csv             , optional: true\n    tuple val(meta), path (\"*.pdf\")         , emit: pdf             , optional: true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = input.collect{\"-i $it\"}.join(' ')\n    def knownSites = known_sites ? known_sites.collect{\"-k $it\"}.join(' ') : \"\"\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n\n    // Create recalibration table. Actual base quality recalibration can be done during Variant calling with Sentieon\n    if(!recalibration_table) {\n        \"\"\"\n        $sentieonLicense\n\n        sentieon driver \\\\\n            -t $task.cpus \\\\\n            -r $fasta \\\\\n            $input_list \\\\\n            --algo QualCal \\\\\n            $args \\\\\n            $knownSites \\\\\n            ${prefix}.table\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n        END_VERSIONS\n        \"\"\"\n    } else {\n    // Runs basequality recalibration with a previous generated table\n        def file_suffix = input.name.endsWith(\".bam\") ? \"bam\" : \"cram\"\n        def recalibrated_bam = generate_recalibrated_bams ? \"--algo ReadWriter ${prefix}.recalibrated.${file_suffix}\" : \"\"\n        \"\"\"\n        $sentieonLicense\n\n        sentieon driver \\\\\n            -t $task.cpus \\\\\n            -r $fasta \\\\\n            -i $input \\\\\n            -q $recalibration_table \\\\\n            --algo QualCal \\\\\n            $args \\\\\n            $knownSites \\\\\n            ${prefix}.table.post \\\\\n            $recalibrated_bam \\\\\n\n        sentieon driver \\\\\n            -t $task.cpus \\\\\n            --algo QualCal \\\\\n            --plot \\\\\n            --before ${prefix}.table \\\\\n            --after ${prefix}.table.post \\\\\n            $args \\\\\n            ${prefix}.csv\n\n        sentieon plot QualCal -o ${prefix}.pdf ${prefix}.csv\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def file_suffix = input.name.endsWith(\".bam\") ? \"bam\" : \"cram\"\n    def recalibrated_bam = generate_recalibrated_bams ? \"${prefix}.recalibrated.${file_suffix}\" : \"\"\n    def recalibrated_bam_cmd = generate_recalibrated_bams ? \"touch $recalibrated_bam\" : \"\"\n    \"\"\"\n    touch ${prefix}.table\n    touch ${prefix}.table.post\n    ${recalibrated_bam_cmd}\n    touch ${prefix}.csv\n    touch ${prefix}.pdf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges BAM files, and/or convert them into cram files. Also, outputs the result of applying the Base Quality Score Recalibration to a file.\nTags: merge, convert, readwriter, sentieon", "answer": "process SENTIEON_READWRITER {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(input), path(index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"${prefix}\"),                             emit: output\n    tuple val(meta), path(\"${prefix}.${index}\"),                    emit: index\n    tuple val(meta), path(\"${prefix}\"), path(\"${prefix}.${index}\"), emit: output_index\n    path  \"versions.yml\",                                           emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n\n\n    def args            = task.ext.args   ?: ''\n    def args2           = task.ext.args2  ?: ''\n    def input_str       = input.sort{ it.getName() }.collect{\"-i $it\"}.join(' ')\n    def reference       = fasta ? \"-r $fasta\" : ''\n\n    // bam -> bam: prefix = \"<filename>.bam\"\n    // bam -> cram: prefix = \"<filename>.cram\"\n    // cram -> cram: prefix = \"<filename>.cram\"\n    prefix          = task.ext.prefix ?: \"${meta.id}.bam\"\n    index           = prefix.tokenize('.')[-1] == \"bam\" ? \"bai\" : \"crai\"\n\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon \\\\\n        driver \\\\\n        -t $task.cpus \\\\\n        $reference \\\\\n        $args \\\\\n        $input_str \\\\\n        --algo ReadWriter \\\\\n        $args2 \\\\\n        ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix          = task.ext.prefix ?: \"${meta.id}.cram\"\n    index           = prefix.tokenize('.')[-1] == \"bam\" ? \"bai\" : \"crai\"\n    \"\"\"\n\n    touch ${prefix}\n    touch ${prefix}.${index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply a score cutoff to filter variants based on a recalibration table.\nSentieon's Aplyvarcal performs the second pass in a two-stage process called Variant Quality Score Recalibration (VQSR).\nSpecifically, it applies filtering to the input variants based on the recalibration table produced\nin the previous step VarCal and a target sensitivity value.\nhttps://support.sentieon.com/manual/usages/general/#applyvarcal-algorithm\n\nTags: sentieon, applyvarcal, varcal, VQSR", "answer": "process SENTIEON_APPLYVARCAL {\n    tag \"$meta.id\"\n    label 'process_low'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_tbi), path(recal), path(recal_index), path(tranches)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")   , emit: tbi\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver -r ${fasta}  --algo ApplyVarCal \\\\\n        -v $vcf \\\\\n        --recal $recal \\\\\n        --tranches_file $tranches \\\\\n        $args \\\\\n        ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Module for Sentieons VarCal. The VarCal algorithm calculates the Variant Quality Score Recalibration (VQSR).\nVarCal builds a recalibration model for scoring variant quality.\nhttps://support.sentieon.com/manual/usages/general/#varcal-algorithm\n\nTags: sentieon, varcal, variant recalibration", "answer": "process SENTIEON_VARCAL {\n    tag \"$meta.id\"\n    label 'process_low'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi) // input vcf and tbi of variants to recalibrate\n    path resource_vcf   // resource vcf\n    path resource_tbi   // resource tbi\n    val labels          // string (or list of strings) containing dedicated resource labels already formatted with '--resource:' tag\n    path  fasta\n    path  fai\n\n    output:\n    tuple val(meta), path(\"*.recal\")   , emit: recal\n    tuple val(meta), path(\"*.idx\")     , emit: idx\n    tuple val(meta), path(\"*.tranches\"), emit: tranches\n    tuple val(meta), path(\"*plots.R\")  , emit: plots, optional:true\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference_command = fasta ? \"--reference $fasta \" : ''\n    def labels_command = ''\n\n    // labels is a list. Here is an example of what labels might look like:\n    // ['--resource:dbsnp,known=false,training=true,truth=false,prior=2.0 dbsnp_146.hg38.vcf.gz', '--resource:gatk,known=false,training=true,truth=true,prior=10.0 Homo_sapiens_assembly38.known_indels.vcf.gz --resource:mills,known=false,training=true,truth=true,prior=10.0 Mills_and_1000G_gold_standard.indels.hg38.vcf.gz']\n    for(label in labels){\n        for(gatk_resource_string in label.split('--resource:').findAll()){  // The findAll cmd is there to remove any empty string elements in the list\n            def items = gatk_resource_string.split(' ')\n            // Here is an example of what the list items might look like:\n            // ['dbsnp,known=false,training=true,truth=false,prior=2.0', 'dbsnp_146.hg38.vcf.gz']\n            if (items.size() != 2) {\n                error(\"Expected the list '${items}' to contain two elements.\")\n            }\n            labels_command +=  \"--resource ${items[1]} --resource_param ${items[0]} \"\n        }\n    }\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver -r ${fasta}  --algo VarCal \\\\\n        -v $vcf \\\\\n        --tranches_file ${prefix}.tranches \\\\\n        $labels_command \\\\\n        $args \\\\\n        ${prefix}.recal\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.recal\n    touch ${prefix}.idx\n    touch ${prefix}.tranches\n    touch ${prefix}plots.R\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filters the raw output of sentieon/tnhaplotyper2.\n\nTags: tnfilter, filter, sentieon, tnhaplotyper2, vcf", "answer": "process SENTIEON_TNFILTER {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_tbi), path(stats), path(contamination), path(segments), path(orientation_priors)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")      , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\")  , emit: vcf_tbi\n    tuple val(meta), path(\"*.vcf.gz.stats\"), emit: stats\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args                       = task.ext.args                      ?: '' // options for the driver\n    def args2                      = task.ext.args2                     ?: '' // options for --algo TNfilter\n    def prefix                     = task.ext.prefix                    ?: \"${meta.id}\"\n    def contamination_command      = contamination                      ? \" --contamination ${contamination} \"                             : ''\n    def segments_command           = segments                           ? segments.collect{\"--tumor_segments $it\"}.join(' ')               : ''\n    def orientation_priors_command = orientation_priors                 ? orientation_priors.collect{\"--orientation_priors $it\"}.join(' ') : ''\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver -r $fasta \\\\\n    $args \\\\\n    --algo TNfilter \\\\\n    $args2 \\\\\n    -v $vcf \\\\\n    $contamination_command \\\\\n    $segments_command \\\\\n    $orientation_priors_command \\\\\n    ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n    touch ${prefix}.vcf.gz.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collects multiple quality metrics from a bam file\nTags: metrics, bam, sentieon", "answer": "process SENTIEON_DATAMETRICS {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path('*mq_metrics.txt') , emit: mq_metrics\n    tuple val(meta), path('*qd_metrics.txt') , emit: qd_metrics\n    tuple val(meta), path('*gc_summary.txt') , emit: gc_summary\n    tuple val(meta), path('*gc_metrics.txt') , emit: gc_metrics\n    tuple val(meta), path('*aln_metrics.txt'), emit: aln_metrics\n    tuple val(meta), path('*is_metrics.txt') , emit: is_metrics\n    path  \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input  = bam.sort().collect{\"-i $it\"}.join(' ')\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon \\\\\n        driver \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        $input \\\\\n        $args \\\\\n        --algo GCBias --summary ${prefix}_gc_summary.txt ${prefix}_gc_metrics.txt \\\\\n        --algo MeanQualityByCycle ${prefix}_mq_metrics.txt \\\\\n        --algo QualDistribution ${prefix}_qd_metrics.txt \\\\\n        --algo InsertSizeMetricAlgo ${prefix}_is_metrics.txt  \\\\\n        --algo AlignmentStat ${prefix}_aln_metrics.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_mq_metrics.txt\n    touch ${prefix}_qd_metrics.txt\n    touch ${prefix}_gc_summary.txt\n    touch ${prefix}_gc_metrics.txt\n    touch ${prefix}_aln_metrics.txt\n    touch ${prefix}_is_metrics.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: DNAscope algorithm performs an improved version of Haplotype variant calling.\nTags: dnascope, sentieon, variant_calling", "answer": "process SENTIEON_DNASCOPE {\n    tag \"$meta.id\"\n    label 'process_high'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dbsnp)\n    tuple val(meta5), path(dbsnp_tbi)\n    tuple val(meta6), path(ml_model)\n    val(pcr_indel_model)\n    val(emit_vcf)\n    val(emit_gvcf)\n\n    output:\n    tuple val(meta), path(\"*.unfiltered.vcf.gz\")    , optional:true, emit: vcf   // added the substring \".unfiltered\" in the filename of the vcf-files since without that the g.vcf.gz-files were ending up in the vcf-channel\n    tuple val(meta), path(\"*.unfiltered.vcf.gz.tbi\"), optional:true, emit: vcf_tbi\n    tuple val(meta), path(\"*.g.vcf.gz\")             , optional:true, emit: gvcf   // these output-files have to have the extension \".vcf.gz\", otherwise the subsequent GATK-MergeVCFs will fail.\n    tuple val(meta), path(\"*.g.vcf.gz.tbi\")         , optional:true, emit: gvcf_tbi\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args                      = task.ext.args                      ?: ''  // options for the driver\n    def args2                     = task.ext.args2                     ?: ''  // options for the vcf generation\n    def args3                     = task.ext.args3                     ?: ''  // options for the gvcf generation\n    def interval                  = intervals                          ? \"--interval ${intervals}\"               : ''\n    def dbsnp_cmd                 = dbsnp                              ? \"-d ${dbsnp}\"                           : ''\n    def model_cmd                 = ml_model                           ? \" --model ${ml_model}\"                  : ''\n    def pcr_indel_model_cmd       = pcr_indel_model                    ? \" --pcr_indel_model ${pcr_indel_model}\" : ''\n    def prefix                    = task.ext.prefix                    ?: \"${meta.id}\"\n    def vcf_cmd                   = \"\"\n    def gvcf_cmd                  = \"\"\n    def base_cmd                  = '--algo DNAscope ' + dbsnp_cmd + ' '\n\n    if (emit_vcf) {  // emit_vcf can be the empty string, 'variant', 'confident' or 'all' but NOT 'gvcf'\n        vcf_cmd = base_cmd + args2 + ' ' + model_cmd + pcr_indel_model_cmd + ' --emit_mode ' + emit_vcf + ' ' + prefix + '.unfiltered.vcf.gz'\n    }\n\n    if (emit_gvcf) { // emit_gvcf can be either true or false\n        gvcf_cmd = base_cmd + args3 + ' ' + model_cmd + pcr_indel_model_cmd + ' --emit_mode gvcf ' + prefix + '.g.vcf.gz'\n    }\n\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver $args -r $fasta -t $task.cpus -i $bam $interval $vcf_cmd $gvcf_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.unfiltered.vcf.gz\n    touch ${prefix}.unfiltered.vcf.gz.tbi\n    touch ${prefix}.g.vcf.gz\n    touch ${prefix}.g.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\" )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collects whole genome quality metrics from a bam file\nTags: metrics, bam, sentieon", "answer": "process SENTIEON_WGSMETRICS {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(intervals_list)\n\n    output:\n    tuple val(meta), path('*.txt'), emit: wgs_metrics\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args     = task.ext.args ?: ''\n    def input    = bam.sort().collect{\"-i $it\"}.join(' ')\n    def prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def interval = intervals_list ? \"--interval ${intervals_list}\" : \"\"\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon \\\\\n        driver \\\\\n        -t $task.cpus \\\\\n        -r $fasta \\\\\n        $input \\\\\n        $interval \\\\\n        $args \\\\\n        --algo WgsMetricsAlgo ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Runs Sentieon's haplotyper for germline variant calling.\nTags: sentieon, haplotypecaller, haplotype", "answer": "process SENTIEON_HAPLOTYPER {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(intervals), path(recal_table)\n    tuple val(meta1), path(fasta)\n    tuple val(meta2), path(fai)\n    tuple val(meta3), path(dbsnp)\n    tuple val(meta4), path(dbsnp_tbi)\n    val(emit_vcf)\n    val(emit_gvcf)\n\n    output:\n    tuple val(meta), path(\"*.unfiltered.vcf.gz\")    , optional:true, emit: vcf   // added the substring \".unfiltered\" in the filename of the vcf-files since without that the g.vcf.gz-files were ending up in the vcf-channel\n    tuple val(meta), path(\"*.unfiltered.vcf.gz.tbi\"), optional:true, emit: vcf_tbi\n    tuple val(meta), path(\"*.g.vcf.gz\")             , optional:true, emit: gvcf   // these output-files have to have the extension \".vcf.gz\", otherwise the subsequent GATK-MergeVCFs will fail.\n    tuple val(meta), path(\"*.g.vcf.gz.tbi\")         , optional:true, emit: gvcf_tbi\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''    // options for the driver\n    def args2 = task.ext.args2 ?: ''  // options for the vcf generation\n    def args3 = task.ext.args3 ?: ''  // options for the gvcf generation\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list          = input instanceof List ? input.collect{\"-i $it\"}.join(' ') : \"-i $input\"\n    def dbsnp_command       = dbsnp       ? \"-d $dbsnp \"            : \"\"\n    def interval_command    = intervals   ? \"--interval $intervals\" : \"\"\n    def recal_table_command = recal_table ? \"-q $recal_table\"       : \"\"\n    def base_cmd = '--algo Haplotyper ' + dbsnp_command\n\n    // The Sentieon --algo Haplotyper can create a VCF or gVCF but not both\n    // Luckily, we can run it twice while reading the BAM once, therefore we construct the two separate commands\n    // and run them twice while using the sentieon driver once. This allows us to create both types of VCF indels\n    // one process\n\n    // Create VCF command to export a VCF\n    def vcf_cmd = emit_vcf ?\n        base_cmd + args2 + ' --emit_mode ' + emit_vcf + ' ' + prefix + '.unfiltered.vcf.gz' :\n        \"\"\n\n    // Create a gVCF command to export a gVCF\n    def gvcf_cmd = emit_gvcf ?\n        gvcf_cmd = base_cmd + args3 + ' --emit_mode gvcf ' + prefix + '.g.vcf.gz' :\n        \"\"\n\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver \\\\\n        $args \\\\\n        -r $fasta \\\\\n        -t $task.cpus \\\\\n        $interval_command \\\\\n        ${input_list} \\\\\n        $recal_table_command \\\\\n        $vcf_cmd \\\\\n        $gvcf_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.unfiltered.vcf.gz\n    touch ${prefix}.unfiltered.vcf.gz.tbi\n    echo \"\" | gzip > ${prefix}.g.vcf.gz\n    touch ${prefix}.g.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Runs the sentieon tool LocusCollector followed by Dedup. LocusCollector collects read information that is used by Dedup which in turn marks or removes duplicate reads.\nTags: mem, dedup, map, bam, cram, sentieon", "answer": "process SENTIEON_DEDUP {\n    tag \"$meta.id\"\n    label 'process_medium'\n    label 'sentieon'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/sentieon:202308.02--ffce1b7074ce9924' :\n        'nf-core/sentieon:202308.02--c641bc397cbf79d5' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.cram\")               , emit: cram, optional: true\n    tuple val(meta), path(\"*.crai\")               , emit: crai, optional: true\n    tuple val(meta), path(\"*.bam\")                , emit: bam , optional: true\n    tuple val(meta), path(\"*.bai\")                , emit: bai\n    tuple val(meta), path(\"*.score\")              , emit: score\n    tuple val(meta), path(\"*.metrics\")            , emit: metrics\n    tuple val(meta), path(\"*.metrics.multiqc.tsv\"), emit: metrics_multiqc_tsv\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def args3 = task.ext.args3 ?: ''\n    def args4 = task.ext.args4 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}.cram\"\n    def metrics = task.ext.metrics ?: \"${prefix}.metrics\"\n    def input_list = bam.collect{\"-i $it\"}.join(' ')\n    def prefix_basename = prefix.substring(0, prefix.lastIndexOf(\".\"))\n    def sentieonLicense = secrets.SENTIEON_LICENSE_BASE64 ?\n        \"export SENTIEON_LICENSE=\\$(mktemp);echo -e \\\"${secrets.SENTIEON_LICENSE_BASE64}\\\" | base64 -d > \\$SENTIEON_LICENSE; \" :\n        \"\"\n    \"\"\"\n    $sentieonLicense\n\n    sentieon driver $args -t $task.cpus $input_list -r ${fasta} --algo LocusCollector $args2 --fun score_info ${prefix_basename}.score\n    sentieon driver $args3 -t $task.cpus $input_list -r ${fasta} --algo Dedup $args4 --score_info ${prefix_basename}.score --metrics ${metrics} ${prefix}\n\n    # This following tsv-file is produced in order to get a proper tsv-file with Dedup-metrics for importing in MultiQC as \"custom content\".\n    # It should be removed once MultiQC has a module for displaying Dedup-metrics.\n    head -3 ${metrics} > ${metrics}.multiqc.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}.cram\"\n    def metrics = task.ext.metrics ?: \"${prefix}.metrics\"\n    def prefix_basename = prefix.substring(0, prefix.lastIndexOf(\".\"))\n\n    \"\"\"\n    touch \"${prefix}\"\n    touch \"${prefix}.crai\"\n    touch \"${prefix}.bai\"\n    touch \"${metrics}\"\n    touch \"${metrics}.multiqc.tsv\"\n    touch \"${prefix_basename}.score\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sentieon: \\$(echo \\$(sentieon driver --version 2>&1) | sed -e \"s/sentieon-genomics-//g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produces a Newick format phylogeny from a multiple sequence alignment using a Neighbour-Joining algorithm. Capable of bacterial genome size alignments.\nTags: phylogeny, newick, neighbour-joining", "answer": "process RAPIDNJ {\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-805c6e0f138f952f9c61cdd57c632a1a263ea990:3c52e4c8da6b3e4d69b9ca83fa4d366168898179-0' :\n        'biocontainers/mulled-v2-805c6e0f138f952f9c61cdd57c632a1a263ea990:3c52e4c8da6b3e4d69b9ca83fa4d366168898179-0' }\"\n\n    input:\n    path alignment\n\n    output:\n    path \"*.sth\"       , emit: stockholm_alignment\n    path \"*.tre\"       , emit: phylogeny\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def VERSION = '2.3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    python \\\\\n        -c 'from Bio import SeqIO; SeqIO.convert(\"$alignment\", \"fasta\", \"alignment.sth\", \"stockholm\")'\n\n    rapidnj \\\\\n        alignment.sth \\\\\n        $args \\\\\n        -i sth \\\\\n        -c $task.cpus \\\\\n        -x rapidnj_phylogeny.tre\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rapidnj: $VERSION\n        biopython: \\$(python -c \"import Bio; print(Bio.__version__)\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filtering, downsampling and profiling alignments in BAM/CRAM formats\nTags: filter, bam, subsample, downsample, downsample bam, subsample bam", "answer": "process VARIANTBAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/variantbam:1.4.4a--h7d7f7ad_5' :\n        'biocontainers/variantbam:1.4.4a--h7d7f7ad_5' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.4.4a' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    variant \\\\\n        $bam \\\\\n        -o ${prefix}.bam \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        variantbam: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Demultiplex paired-end FASTQ files from QuantSeq-Pool\nTags: demultiplex, lexogen, fastq", "answer": "process IDEMUX {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"bioconda::idemux=0.1.6\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/idemux:0.1.6--pyhdfd78af_0':\n        'biocontainers/idemux:0.1.6--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads), path(samplesheet)\n\n    output:\n    tuple val(meta), path(\"[!undetermined]*.fastq.gz\")          , emit: fastq\n    tuple val(meta), path(\"undetermined_R?.fastq.gz\")  , optional:true, emit: undetermined\n    path \"demultipexing_stats.tsv\" , emit: stats\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    idemux \\\\\n        --r1 ${reads[0]} \\\\\n        --r2 ${reads[1]} \\\\\n        --sample-sheet ${samplesheet} \\\\\n        --out . \\\\\n        $args\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        idemux: \\$(idemux --version |& sed '1!d ; s/idemux //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    echo -e \"sample_name\\twritten_reads\" > demultipexing_stats.tsv\n\n    sed 1d ${samplesheet} | while IFS=, read -r sampleName _ _ _; do\n        touch \"\\${sampleName}_R1.fastq\"\n        touch \"\\${sampleName}_R2.fastq\"\n        echo -e \"\\${sampleName}\\t100\" >> demultipexing_stats.tsv\n    done\n\n    touch undetermined_R1.fastq\n    touch undetermined_R2.fastq\n    gzip *.fastq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        idemux: \\$(idemux --version |& sed '1!d ; s/idemux //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to create consensus sequences and variant calls from nanopore sequencing data\nTags: assembly, polishing, nanopore", "answer": "process MEDAKA {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/medaka:1.4.4--py38h130def0_0' :\n        'biocontainers/medaka:1.4.4--py38h130def0_0' }\"\n\n    input:\n    tuple val(meta), path(reads), path(assembly)\n\n    output:\n    tuple val(meta), path(\"*.fa.gz\"), emit: assembly\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    medaka_consensus \\\\\n        -t $task.cpus \\\\\n        $args \\\\\n        -i $reads \\\\\n        -d $assembly \\\\\n        -o ./\n\n    mv consensus.fasta ${prefix}.fa\n\n    gzip -n ${prefix}.fa\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        medaka: \\$( medaka --version 2>&1 | sed 's/medaka //g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Quickly compute statistics over a fasta file in windows.\nTags: genome, fasta, tsv, bed", "answer": "process FASTAWINDOWS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fasta_windows:0.2.4--hec16e2b_0':\n        'biocontainers/fasta_windows:0.2.4--hec16e2b_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"fw_out/*_freq_windows.tsv\")    , emit: freq\n    tuple val(meta), path(\"fw_out/*_mononuc_windows.tsv\") , emit: mononuc\n    tuple val(meta), path(\"fw_out/*_dinuc_windows.tsv\")   , emit: dinuc\n    tuple val(meta), path(\"fw_out/*_trinuc_windows.tsv\")  , emit: trinuc\n    tuple val(meta), path(\"fw_out/*_tetranuc_windows.tsv\"), emit: tetranuc\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    rm -rf fw_out\n    env RAYON_NUM_THREADS=$task.cpus \\\\\n    fasta_windows \\\\\n        $args \\\\\n        --fasta $fasta \\\\\n        --output ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fasta_windows: \\$(fasta_windows --version | cut -d' ' -f3)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: command line tool for CNV/CNA analysis. This step imports the read depth data into a root pytor file.\nTags: read depth, cnv calling", "answer": "process CNVPYTOR_IMPORTREADDEPTH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvpytor:1.2.1--pyhdfd78af_0':\n        'biocontainers/cnvpytor:1.2.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input_file), path(index)\n    path fasta\n    path fai\n\n    output:\n    tuple val(meta), path(\"*.pytor\")\t, emit: pytor\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"-T ${fasta}\" : ''\n    \"\"\"\n    cnvpytor \\\\\n        -root ${prefix}.pytor \\\\\n        -rd $input_file \\\\\n        $args \\\\\n        $reference\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.pytor\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: view function to generate vcfs\nTags: cnv calling", "answer": "process CNVPYTOR_VIEW {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvpytor:1.2.1--pyhdfd78af_0':\n        'biocontainers/cnvpytor:1.2.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(pytor_files)\n    val bin_sizes\n    val output_format\n\n    output:\n    tuple val(meta), path(\"*.vcf\"), emit: vcf      , optional: true\n    tuple val(meta), path(\"*.tsv\"), emit: tsv      , optional: true\n    tuple val(meta), path(\"*.xls\"), emit: xls      , optional: true\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def output_suffix = output_format ?: 'vcf'\n    def bins   = bin_sizes ?: '1000'\n    def input  = pytor_files.join(\" \")\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n\n    python3 <<CODE\n    import cnvpytor,os\n    binsizes = \"${bins}\".split(\" \")\n    for binsize in binsizes:\n        file_list = \"${input}\".split(\" \")\n        app = cnvpytor.Viewer(file_list, params={} )\n        outputfile = \"{}_{}.{}\".format(\"${prefix}\",binsize.strip(),\"${output_suffix}\")\n        app.print_filename = outputfile\n        app.bin_size = int(binsize)\n        app.print_calls_file()\n    CODE\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def output_suffix = output_format ?: 'vcf'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.${output_suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: partitioning read depth histograms\nTags: cnv calling, partition histograms", "answer": "process CNVPYTOR_PARTITION {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvpytor:1.2.1--pyhdfd78af_0':\n        'biocontainers/cnvpytor:1.2.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(pytor)\n    val bin_sizes\n\n    output:\n    tuple val(meta), path(\"${pytor.baseName}.pytor\"), emit: pytor\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def bins = bin_sizes ?: '1000'\n    \"\"\"\n    cnvpytor \\\\\n        -root $pytor \\\\\n        -partition $bins\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${pytor.baseName}.pytor\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: calculates read depth histograms\nTags: cnv calling, histogram", "answer": "process CNVPYTOR_HISTOGRAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvpytor:1.2.1--pyhdfd78af_0':\n        'biocontainers/cnvpytor:1.2.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(pytor)\n    val bin_sizes\n\n\n    output:\n    tuple val(meta), path(\"${pytor.baseName}.pytor\")\t, emit: pytor\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def bins = bin_sizes ?: '1000'\n    \"\"\"\n    cnvpytor \\\\\n        -root $pytor \\\\\n        -his $bins\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${pytor.baseName}.pytor\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: command line tool for calling CNVs in whole genome sequencing data\nTags: CNV calling", "answer": "process CNVPYTOR_CALLCNVS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cnvpytor:1.2.1--pyhdfd78af_0':\n        'biocontainers/cnvpytor:1.2.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(pytor)\n    val bin_sizes\n\n    output:\n    tuple val(meta), path(\"${pytor.baseName}.pytor\")\t, emit: pytor\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def bins = bin_sizes ?: '1000'\n    \"\"\"\n    cnvpytor \\\\\n        -root $pytor \\\\\n        -call $bin_sizes\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${pytor.baseName}.pytor\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        cnvpytor: \\$(echo \\$(cnvpytor --version 2>&1) | sed 's/CNVpytor //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: a module to generate images from Pretext contact maps.\nTags: pretext, image, hic, png, jpg, bmp, contact maps", "answer": "process PRETEXTSNAPSHOT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pretextsnapshot:0.0.4--h7d875b9_0':\n        'biocontainers/pretextsnapshot:0.0.4--h7d875b9_0' }\"\n\n    input:\n    tuple val(meta), path(pretext_map)\n\n    output:\n    tuple val(meta), path('*.{jpeg,png,bmp}'), emit: image\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}.\"\n    \"\"\"\n    PretextSnapshot \\\\\n        $args \\\\\n        --map $pretext_map \\\\\n        --prefix $prefix \\\\\n        --folder .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pretextsnapshot: \\$(echo \\$(PretextSnapshot --version 2>&1) | sed 's/^.*PretextSnapshot Version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: index creation for kb count quantification of single-cell data.\nTags: scRNA-seq, count, single-cell, kallisto, bustools, index", "answer": "process KALLISTOBUSTOOLS_REF {\n    tag \"$fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kb-python:0.28.2--pyhdfd78af_2' :\n        'biocontainers/kb-python:0.28.2--pyhdfd78af_2' }\"\n\n    input:\n    path fasta\n    path gtf\n    val  workflow_mode\n\n    output:\n    path \"versions.yml\"   , emit: versions\n    path \"kb_ref_out.idx\" , emit: index\n    path \"t2g.txt\"        , emit: t2g\n    path \"cdna.fa\"        , emit: cdna\n    path \"intron.fa\"      , optional:true, emit: intron\n    path \"cdna_t2c.txt\"   , optional:true, emit: cdna_t2c\n    path \"intron_t2c.txt\" , optional:true, emit: intron_t2c\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    if (workflow_mode == \"standard\") {\n        \"\"\"\n        kb \\\\\n            ref \\\\\n            -i kb_ref_out.idx \\\\\n            -g t2g.txt \\\\\n            -f1 cdna.fa \\\\\n            --workflow $workflow_mode \\\\\n            $fasta \\\\\n            $gtf\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            kallistobustools: \\$(echo \\$(kb --version 2>&1) | sed 's/^.*kb_python //;s/positional arguments.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        kb \\\\\n            ref \\\\\n            -i kb_ref_out.idx \\\\\n            -g t2g.txt \\\\\n            -f1 cdna.fa \\\\\n            -f2 intron.fa \\\\\n            -c1 cdna_t2c.txt \\\\\n            -c2 intron_t2c.txt \\\\\n            --workflow $workflow_mode \\\\\n            $fasta \\\\\n            $gtf\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            kallistobustools: \\$(echo \\$(kb --version 2>&1) | sed 's/^.*kb_python //;s/positional arguments.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    if (workflow_mode == \"standard\") {\n        \"\"\"\n        touch kb_ref_out.idx \\\\\n        touch t2g.txt \\\\\n        touch cdna.fa\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            kallistobustools: \\$(echo \\$(kb --version 2>&1) | sed 's/^.*kb_python //;s/positional arguments.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        touch kb_ref_out.idx \\\\\n        touch t2g.txt \\\\\n        touch cdna.fa\n        touch intron.fa \\\\\n        touch cdna_t2c.txt \\\\\n        touch intron_t2c.txt\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            kallistobustools: \\$(echo \\$(kb --version 2>&1) | sed 's/^.*kb_python //;s/positional arguments.*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: quantifies scRNA-seq data from fastq files using kb-python.\nTags: scRNA-seq, count, single-cell, kallisto, bustools", "answer": "process KALLISTOBUSTOOLS_COUNT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/kb-python:0.28.2--pyhdfd78af_2' :\n        'biocontainers/kb-python:0.28.2--pyhdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  index\n    path  t2g\n    path  t1c\n    path  t2c\n    val   technology\n    val   workflow_mode\n\n    output:\n    tuple val(meta), path (\"*.count\")   , emit: count\n    path \"versions.yml\"                 , emit: versions\n    path \"*.count/*/*.mtx\"              , emit: matrix //Ensure that kallisto finished and produced outputs\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args ?: ''\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def cdna    = t1c ? \"-c1 $t1c\" : ''\n    def intron  = t2c ? \"-c2 $t2c\" : ''\n    def memory  = task.memory.toGiga() - 1\n    \"\"\"\n    kb \\\\\n        count \\\\\n        -t $task.cpus \\\\\n        -i $index \\\\\n        -g $t2g \\\\\n        $cdna \\\\\n        $intron \\\\\n        -x $technology \\\\\n        --workflow $workflow_mode \\\\\n        $args \\\\\n        -o ${prefix}.count \\\\\n        -m ${memory}G \\\\\n        ${reads.join( \" \" )}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kallistobustools: \\$(echo \\$(kb --version 2>&1) | sed 's/^.*kb_python //;s/positional arguments.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}.count/counts_unfiltered/\n    touch ${prefix}.count/counts_unfiltered/cells_x_genes.mtx\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        kallistobustools: \\$(echo \\$(kb --version 2>&1) | sed 's/^.*kb_python //;s/positional arguments.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Ilastik is a tool that utilizes machine learning algorithms to classify pixels, segment, track and count cells in images. Ilastik contains a graphical user interface to interactively label pixels. However, this nextflow module will implement the --headless mode, to apply pixel classification using a pre-trained .ilp file on an input image.\nTags: multicut, segmentation, pixel classification", "answer": "process ILASTIK_MULTICUT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    container \"docker.io/biocontainers/ilastik:1.4.0_cv1\"\n\n    input:\n    tuple val(meta), path(h5)\n    tuple val(meta2), path (ilp)\n    tuple val(meta3), path (probs)\n\n    output:\n    tuple val(meta), path(\"*.tiff\") , emit: out_tiff\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"ILASTIK_MULTICUT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    /opt/ilastik-1.4.0-Linux/run_ilastik.sh \\\\\n        --headless \\\\\n        --readonly 1 \\\\\n        --project=$ilp \\\\\n        --raw_data=$h5 \\\\\n        --probabilities=$probs \\\\\n        --export_source=\"Multicut Segmentation\" \\\\\n        --output_filename_format=${prefix}.tiff \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ilastik: \\$(/opt/ilastik-1.4.0-Linux/run_ilastik.sh --headless --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"ILASTIK_MULTICUT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = \"1.4.0\" // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.tiff\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ilastik:: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Ilastik is a tool that utilizes machine learning algorithms to classify pixels, segment, track and count cells in images. Ilastik contains a graphical user interface to interactively label pixels. However, this nextflow module will implement the --headless mode, to apply pixel classification using a pre-trained .ilp file on an input image.\nTags: pixel_classification, segmentation, probability_maps", "answer": "process ILASTIK_PIXELCLASSIFICATION {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    container \"docker.io/biocontainers/ilastik:1.4.0_cv1\"\n\n    input:\n    tuple val(meta), path(input_img)\n    tuple val(meta2), path(ilp)\n\n    output:\n    tuple val(meta), path(\"*.${suffix}\") , emit: output\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"ILASTIK_PIXELCLASSIFICATION module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.suffix ?: \"h5\"\n\n    \"\"\"\n    /opt/ilastik-1.4.0-Linux/run_ilastik.sh \\\\\n        --headless \\\\\n        --readonly 1 \\\\\n        --project=$ilp \\\\\n        --output_filename_format=${prefix}.${suffix} \\\\\n        $args \\\\\n        $input_img\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ilastik: \\$(/opt/ilastik-1.4.0-Linux/run_ilastik.sh --headless --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"ILASTIK_PIXELCLASSIFICATION module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.suffix ?: \"h5\"\n\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ilastik:: \\$(/opt/ilastik-1.4.0-Linux/run_ilastik.sh --headless --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compare multiple runs of long read sequencing data and alignments\nTags: bam, fasta, fastq, qc, nanopore", "answer": "process NANOCOMP {\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nanocomp:1.21.0--pyhdfd78af_0':\n        'biocontainers/nanocomp:1.21.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(filelist)\n\n    output:\n    tuple val(meta), path(\"*NanoComp-report.html\"), emit: report_html\n    tuple val(meta), path(\"*NanoComp_lengths_violin.html\"), emit: lengths_violin_html\n    tuple val(meta), path(\"*NanoComp_log_length_violin.html\"), emit: log_length_violin_html\n    tuple val(meta), path(\"*NanoComp_N50.html\"), emit: n50_html\n    tuple val(meta), path(\"*NanoComp_number_of_reads.html\"), emit: number_of_reads_html\n    tuple val(meta), path(\"*NanoComp_OverlayHistogram.html\"), emit: overlay_histogram_html\n    tuple val(meta), path(\"*NanoComp_OverlayHistogram_Normalized.html\"), emit: overlay_histogram_normalized_html\n    tuple val(meta), path(\"*NanoComp_OverlayLogHistogram.html\"), emit: overlay_log_histogram_html\n    tuple val(meta), path(\"*NanoComp_OverlayLogHistogram_Normalized.html\"), emit: overlay_log_histogram_normalized_html\n    tuple val(meta), path(\"*NanoComp_total_throughput.html\"), emit: total_throughput_html\n    tuple val(meta), path(\"*NanoComp_quals_violin.html\"), emit: quals_violin_html, optional: true\n    tuple val(meta), path(\"*NanoComp_OverlayHistogram_Identity.html\"), emit: overlay_histogram_identity_html, optional: true\n    tuple val(meta), path(\"*NanoComp_OverlayHistogram_PhredScore.html\"), emit: overlay_histogram_phredscore_html, optional: true\n    tuple val(meta), path(\"*NanoComp_percentIdentity_violin.html\"), emit: percent_identity_violin_html, optional: true\n    tuple val(meta), path(\"*NanoComp_ActivePoresOverTime.html\"), emit: active_pores_over_time_html, optional: true\n    tuple val(meta), path(\"*NanoComp_CumulativeYieldPlot_Gigabases.html\"), emit: cumulative_yield_plot_gigabases_html, optional: true\n    tuple val(meta), path(\"*NanoComp_sequencing_speed_over_time.html\"), emit: sequencing_speed_over_time_html, optional: true\n    tuple val(meta), path(\"*NanoStats.txt\"), emit: stats_txt\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (prefix == \"\"){\n        prefixflag = \"\"\n    } else {\n        prefixflag = \"--prefix \" + prefix\n    }\n\n    //determine input file type\n    filetypes = []\n    for (file in filelist){\n        tokenized_filename = file.getName().tokenize('.')\n        if (tokenized_filename.size() < 2){\n            throw new java.lang.IndexOutOfBoundsException(\"Every input file to nanocomp has to have a file ending.\")\n        }\n\n        first_namepart = true\n        extension_found = false\n\n        for (namepart in tokenized_filename){\n            if (namepart == \"\"){\n                continue\n            }\n\n            // prevent the file name to be seen as extension\n            if (first_namepart == true){\n                first_namepart = false\n                continue\n            }\n\n            if ([\"fq\",\"fastq\"].contains(namepart)){\n                filetypes.add(\"fastq\")\n                extension_found = true\n                break\n            } else if ([\"fasta\", \"fna\", \"ffn\", \"faa\", \"frn\", \"fa\"].contains(namepart)) {\n                filetypes.add(\"fasta\")\n                extension_found = true\n                break\n            } else if (namepart == \"bam\") {\n                filetypes.add(\"bam\")\n                extension_found = true\n                break\n            } else if (namepart == \"txt\") {\n                filetypes.add(\"summary\")\n                extension_found = true\n                break\n            }\n        }\n\n        if (extension_found == false){\n            throw new java.lang.IllegalArgumentException(\"There was no suitable filetype found for \" + file.getName() +\n            \". NanoComp only accepts fasta (fasta, fna, ffn, faa, frn, fa), fastq (fastq, fq), bam and Nanopore sequencing summary (txt).\")\n        }\n    }\n\n    filetypes.unique()\n    if (filetypes.size() < 1){\n        throw new java.lang.IllegalArgumentException(\"There was no suitable filetype found in NanoComp input. Please use fasta, fastq, bam or Nanopore sequencing summary.\")\n    }\n    if (filetypes.size() > 1){\n        throw new java.lang.IllegalArgumentException(\"You gave different filetypes to NanoComp. Please use only *one* of fasta, fastq, bam or Nanopore sequencing summary.\")\n    }\n    filetype = filetypes[0]\n\n    \"\"\"\n    NanoComp \\\\\n        --$filetype $filelist \\\\\n        --threads $task.cpus \\\\\n        $prefixflag \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanocomp: \\$(echo \\$(NanoComp --version 2>&1) | sed 's/^.*NanoComp //; s/Using.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch versions.yml\n    touch \"${prefix}\"NanoComp_lengths_violin.html\n    touch \"${prefix}\"NanoComp_log_length_violin.html\n    touch \"${prefix}\"NanoComp_N50.html\n    touch \"${prefix}\"NanoComp_number_of_reads.html\n    touch \"${prefix}\"NanoComp_OverlayHistogram.html\n    touch \"${prefix}\"NanoComp_OverlayHistogram_Normalized.html\n    touch \"${prefix}\"NanoComp_OverlayLogHistogram.html\n    touch \"${prefix}\"NanoComp_OverlayLogHistogram_Normalized.html\n    touch \"${prefix}\"NanoComp-report.html\n    touch \"${prefix}\"NanoComp_total_throughput.html\n    touch \"${prefix}\"NanoComp_quals_violin.html\n    touch \"${prefix}\"NanoComp_OverlayHistogram_Identity.html\n    touch \"${prefix}\"NanoComp_OverlayHistogram_PhredScore.html\n    touch \"${prefix}\"NanoComp_percentIdentity_violin.html\n    touch \"${prefix}\"NanoComp_ActivePoresOverTime.html\n    touch \"${prefix}\"NanoComp_CumulativeYieldPlot_Gigabases.html\n    touch \"${prefix}\"NanoComp_sequencing_speed_over_time.html\n    touch \"${prefix}\"NanoStats.txt\n    \"\"\"\n}\n"}
{"question": "Description: Contrast-limited adjusted histogram equalization (CLAHE) on single-channel tif images.\nTags: clahe, image_processing, imaging, correction", "answer": "process MOLKARTGARAGE_CLAHE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    container \"ghcr.io/schapirolabor/molkart-local:v0.1.1\"\n\n    input:\n    tuple val(meta), path(image)\n\n    output:\n    tuple val(meta), path(\"*.tiff\") , emit: img_clahe\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"Molkartgarage/clahe module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    python /local/scripts/molkart_clahe.py \\\n        --input ${image} \\\n        --output ${prefix}.tiff \\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        molkart_clahe: \\$(python /local/scripts/molkart_clahe.py --version)\n        scikit-image: 0.19.2\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tiff\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        molkart_clahe: \\$(python3 /local/scripts/molkart_clahe.py  --version)\n        scikit-image: 0.19.2\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: mkarv function of a corresponding ataqv tool\nTags: ataqv, ATAC-seq, qc, ataqv, mkarv", "answer": "process ATAQV_MKARV {\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ataqv:1.3.1--py310ha155cf9_1':\n        'biocontainers/ataqv:1.3.1--py310ha155cf9_1' }\"\n\n    input:\n    path \"jsons/*\"\n\n    output:\n    path \"html\"        , emit: html\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkarv \\\\\n        $args \\\\\n        --concurrency $task.cpus \\\\\n        --force \\\\\n        ./html/ \\\\\n        jsons/*\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        # mkarv: \\$( mkarv --version ) # Use this when version string has been fixed\n        ataqv: \\$( ataqv --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: ataqv function of a corresponding ataqv tool\nTags: ATAC-seq, qc, ataqv", "answer": "process ATAQV_ATAQV {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ataqv:1.3.1--py310ha155cf9_1' :\n        'biocontainers/ataqv:1.3.1--py310ha155cf9_1' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(peak_file)\n    val organism\n    val mito_name\n    path tss_file\n    path excl_regs_file\n    path autosom_ref_file\n\n    output:\n    tuple val(meta), path(\"*.ataqv.json\"), emit: json\n    tuple val(meta), path(\"*.problems\")  , emit: problems, optional: true\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def mito = mito_name ? \"--mitochondrial-reference-name ${mito_name}\" : ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def peak        = peak_file        ? \"--peak-file $peak_file\"                       : ''\n    def tss         = tss_file         ? \"--tss-file $tss_file\"                         : ''\n    def excl_regs   = excl_regs_file   ? \"--excluded-region-file $excl_regs_file\"       : ''\n    def autosom_ref = autosom_ref_file ? \"--autosomal-reference-file $autosom_ref_file\" : ''\n    \"\"\"\n    ataqv \\\\\n        $args \\\\\n        $mito \\\\\n        $peak \\\\\n        $tss \\\\\n        $excl_regs \\\\\n        $autosom_ref \\\\\n        --metrics-file \"${prefix}.ataqv.json\" \\\\\n        --threads $task.cpus \\\\\n        --name $prefix \\\\\n        $organism \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ataqv: \\$( ataqv --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Beagle v5.2 is a software package for phasing genotypes and for imputing ungenotyped markers.\nTags: phasing, imputation", "answer": "process BEAGLE5_BEAGLE {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/beagle:5.2_21Apr21.304--hdfd78af_0':\n        'biocontainers/beagle:5.2_21Apr21.304--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    path(refpanel)\n    path(genmap)\n    path(exclsamples)\n    path(exclmarkers)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")     , emit: vcf\n    tuple val(meta), path(\"*.log\")        , emit: log\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}.bglout\"\n    def ref_command = refpanel ? \"ref=$refpanel\" : \"\"\n    def map_command = genmap ? \"map=$genmap\" : \"\"\n    def excludesamples_command = exclsamples ? \"excludesamples=$exclsamples\" : \"\"\n    def excludemarkers_command = exclmarkers ? \"excludemarkers=$exclmarkers\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[beagle] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    beagle -Xmx${avail_mem}M \\\\\n        gt=${vcf} \\\\\n        out=${prefix} \\\\\n        $args \\\\\n        ${ref_command} \\\\\n        ${map_command} \\\\\n        ${excludesamples_command} \\\\\n        ${excludemarkers_command} \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        beagle: \\$(beagle 2>&1 |head -n1 | sed -rn 's/beagle\\\\.(.*)\\\\.jar \\\\(version (.*)\\\\)/\\\\2rev\\\\1/p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Construct the database necessary for checkv's quality assessment\nTags: checkv, checkm, mag, metagenome, quality, isolates, virus, completeness, contamination", "answer": "process CHECKV_UPDATEDATABASE {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/checkv:1.0.1--pyhdfd78af_0':\n        'biocontainers/checkv:1.0.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path (fasta)\n    path db\n\n    output:\n    tuple val(meta), path(\"${prefix}/*\")        , emit: checkv_db\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def checkv_db = db ?: ''\n    def update_sequence = fasta ?: ''\n    \"\"\"\n    checkv update_database \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $checkv_db \\\\\n        ./$prefix/  \\\\\n        $update_sequence \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkv: \\$(checkv -h 2>&1  | sed -n 's/^.*CheckV v//; s/: assessing.*//; 1p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix    = task.ext.prefix ?: \"${meta.id}\"\n    def checkv_db = db ?: ''\n    def update_sequence = fasta ?: ''\n    \"\"\"\n    touch -p ${prefix}/**\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkv: \\$(checkv -h 2>&1  | sed -n 's/^.*CheckV v//; s/: assessing.*//; 1p')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Construct the database necessary for checkv's quality assessment\nTags: checkv, checkm, mag, metagenome, quality, isolates, virus, completeness, contamination, download, database", "answer": "process CHECKV_DOWNLOADDATABASE {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/checkv:1.0.1--pyhdfd78af_0':\n        'biocontainers/checkv:1.0.1--pyhdfd78af_0' }\"\n\n    output:\n    path \"${prefix}/*\"         , emit: checkv_db\n    path \"versions.yml\"        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"checkv_db\"\n\n    \"\"\"\n    checkv download_database \\\\\n        $args \\\\\n        ./$prefix/\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkv: \\$(checkv -h 2>&1  | sed -n 's/^.*CheckV v//; s/: assessing.*//; 1p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"checkv_db\"\n\n    \"\"\"\n    mkdir ${prefix}\n    touch ${prefix}/README.txt\n    mkdir ${prefix}/genome_db\n    touch ${prefix}/genome_db/changelog.tsv\n    touch ${prefix}/genome_db/checkv_error.tsv\n    touch ${prefix}/genome_db/checkv_info.tsv\n    touch ${prefix}/genome_db/checkv_reps.faa\n    touch ${prefix}/genome_db/checkv_reps.fna\n    touch ${prefix}/genome_db/checkv_reps.tsv\n    mkdir ${prefix}/hmm_db\n    touch ${prefix}/hmm_db/checkv_hmms.tsv\n    touch ${prefix}/hmm_db/genome_lengths.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkv: \\$(checkv -h 2>&1  | sed -n 's/^.*CheckV v//; s/: assessing.*//; 1p')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Assess the quality of metagenome-assembled viral genomes.\nTags: checkv, checkm, mag, metagenome, quality, isolates, virus, completeness, contamination", "answer": "process CHECKV_ENDTOEND {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/checkv:1.0.1--pyhdfd78af_0':\n        'biocontainers/checkv:1.0.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path db\n\n    output:\n    tuple val(meta), path (\"${prefix}/quality_summary.tsv\") , emit: quality_summary\n    tuple val(meta), path (\"${prefix}/completeness.tsv\")    , emit: completeness\n    tuple val(meta), path (\"${prefix}/contamination.tsv\")   , emit: contamination\n    tuple val(meta), path (\"${prefix}/complete_genomes.tsv\"), emit: complete_genomes\n    tuple val(meta), path (\"${prefix}/proviruses.fna\")      , emit: proviruses\n    tuple val(meta), path (\"${prefix}/viruses.fna\")         , emit: viruses\n    path \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    checkv \\\\\n        end_to_end \\\\\n        $args \\\\\n        -t $task.cpus \\\\\n        -d $db \\\\\n        $fasta \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkv: \\$(checkv -h 2>&1  | sed -n 's/^.*CheckV v//; s/: assessing.*//; 1p')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mkdir -p ${prefix}\n    touch ${prefix}/quality_summary.tsv\n    touch ${prefix}/completeness.tsv\n    touch ${prefix}/contamination.tsv\n    touch ${prefix}/complete_genomes.tsv\n    touch ${prefix}/proviruses.fna\n    touch ${prefix}/viruses.fna\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        checkv: \\$(checkv -h 2>&1  | sed -n 's/^.*CheckV v//; s/: assessing.*//; 1p')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: merge gVCF files and perform joint variant calling\nTags: merge, gvcf", "answer": "process GLNEXUS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glnexus:1.4.1--h40d77a6_0' :\n        'biocontainers/glnexus:1.4.1--h40d77a6_0' }\"\n\n    input:\n    tuple val(meta), path(gvcfs)\n\n    output:\n    tuple val(meta), path(\"*.bcf\"), emit: bcf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    // Make list of GVCFs to merge\n    def input = gvcfs.collect { it.toString() }\n    def avail_mem = 3\n    if (!task.memory) {\n        log.info '[Glnexus] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = task.memory.giga\n    }\n    \"\"\"\n    glnexus_cli \\\\\n        --threads $task.cpus \\\\\n        --mem-gbytes $avail_mem \\\\\n        $args \\\\\n        ${input.join(' ')} \\\\\n        > ${prefix}.bcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glnexus: \\$( echo \\$(glnexus_cli 2>&1) | head -n 1 | sed 's/^.*release v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glnexus: \\$( echo \\$(glnexus_cli 2>&1) | head -n 1 | sed 's/^.*release v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assembles bacterial genomes\nTags: genome, assembly, genome assembler, small genome", "answer": "process UNICYCLER {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/unicycler:0.5.0--py312hc60241a_5' :\n        'biocontainers/unicycler:0.5.0--py312hc60241a_5' }\"\n\n    input:\n    tuple val(meta), path(shortreads), path(longreads)\n\n    output:\n    tuple val(meta), path('*.scaffolds.fa.gz'), emit: scaffolds\n    tuple val(meta), path('*.assembly.gfa.gz'), emit: gfa\n    tuple val(meta), path('*.log')            , emit: log\n    path  \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def short_reads = shortreads ? ( meta.single_end ? \"-s $shortreads\" : \"-1 ${shortreads[0]} -2 ${shortreads[1]}\" ) : \"\"\n    def long_reads  = longreads ? \"-l $longreads\" : \"\"\n    \"\"\"\n    unicycler \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $short_reads \\\\\n        $long_reads \\\\\n        --out ./\n\n    mv assembly.fasta ${prefix}.scaffolds.fa\n    gzip -n ${prefix}.scaffolds.fa\n    mv assembly.gfa ${prefix}.assembly.gfa\n    gzip -n ${prefix}.assembly.gfa\n    mv unicycler.log ${prefix}.unicycler.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        unicycler: \\$(echo \\$(unicycler --version 2>&1) | sed 's/^.*Unicycler v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n\n    cat \"\" | gzip > ${prefix}.scaffolds.fa.gz\n    cat \"\" | gzip >  ${prefix}.assembly.gfa.gz\n    touch ${prefix}.unicycler.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        unicycler: \\$(echo \\$(unicycler --version 2>&1) | sed 's/^.*Unicycler v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Generates a count of coverage of alleles\nTags: allele, count, coverage", "answer": "process ALLELECOUNTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/cancerit-allelecount:4.3.0--h41abebc_0' :\n        'biocontainers/cancerit-allelecount:4.3.0--h41abebc_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index)\n    path loci\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*.alleleCount\"), emit: allelecount\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference_options = fasta ? \"-r $fasta\": \"\"\n    \"\"\"\n    alleleCounter \\\\\n        $args \\\\\n        -l $loci \\\\\n        -b $input \\\\\n        $reference_options \\\\\n        -o ${prefix}.alleleCount\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        allelecounter: \\$(alleleCounter --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.alleleCount\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        allelecounter: \\$(alleleCounter --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge STR profiles into a multi-sample STR profile\nTags: expansionhunterdenovo, merge, str", "answer": "process EXPANSIONHUNTERDENOVO_MERGE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/expansionhunterdenovo:0.9.0--hdc99072_3':\n        'biocontainers/expansionhunterdenovo:0.9.0--hdc99072_3' }\"\n\n    input:\n    tuple val(meta), path(manifest)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.multisample_profile.json\"), emit: merged_profiles\n    path \"versions.yml\"                                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    ExpansionHunterDenovo merge \\\\\n        --manifest ${manifest} \\\\\n        --reference ${fasta} \\\\\n        --output-prefix ${prefix} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        expansionhunterdenovo: \\$(echo \\$(ExpansionHunterDenovo --help 2>&1) | sed -e \"s/ExpansionHunter Denovo v//;s/ Usage.*//\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compute genome-wide STR profile\nTags: expansionhunterdenovo, profile, STR, genome, bam, cram", "answer": "process EXPANSIONHUNTERDENOVO_PROFILE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/expansionhunterdenovo:0.9.0--hdc99072_3':\n        'biocontainers/expansionhunterdenovo:0.9.0--hdc99072_3' }\"\n\n    input:\n    tuple val(meta), path(alignment_file), path(alignment_index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.locus.tsv\")        , emit: locus_tsv\n    tuple val(meta), path(\"*.motif.tsv\")        , emit: motif_tsv\n    tuple val(meta), path(\"*.str_profile.json\") , emit: str_profile\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    ExpansionHunterDenovo profile \\\\\n        --reads ${alignment_file} \\\\\n        --reference ${fasta} \\\\\n        --output-prefix ${prefix} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        expansionhunterdenovo: \\$(echo \\$(ExpansionHunterDenovo --help 2>&1) | sed -e \"s/ExpansionHunter Denovo v//;s/ Usage.*//\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download a mitochondrial genome to be used as reference for MitoHiFi\nTags: mitochondrial genome, reference genome, NCBI", "answer": "process MITOHIFI_FINDMITOREFERENCE {\n    tag \"$species\"\n    label 'process_single'\n\n    // Docker image available at the project github repository\n    container 'ghcr.io/marcelauliano/mitohifi:master'\n\n    input:\n    tuple val(meta), val(species)\n\n    output:\n    tuple val(meta), path(\"*.fasta\"), emit: fasta\n    tuple val(meta), path(\"*.gb\")   , emit: gb\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    findMitoReference.py \\\\\n        --species \"$species\" \\\\\n        --outfolder . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mitohifi: \\$( mitohifi.py -v | sed 's/.* //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch accession.fasta\n    touch accession.gb\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mitohifi: \\$( mitohifi.py -v | sed 's/.* //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A python workflow that assembles mitogenomes from Pacbio HiFi reads\nTags: mitochondrion, chloroplast, PacBio", "answer": "process MITOHIFI_MITOHIFI {\n    tag \"$meta.id\"\n    label 'process_high'\n\n\n    // Docker image available at the project github repository\n    container 'ghcr.io/marcelauliano/mitohifi:master'\n\n    input:\n    tuple val(meta), path(input)\n    path ref_fa\n    path ref_gb\n    val input_mode\n    val mito_code\n\n    output:\n    tuple val(meta), path(\"*fasta\")                          , emit: fasta\n    tuple val(meta), path(\"*contigs_stats.tsv\")              , emit: stats\n    tuple val(meta), path(\"*gb\")                             , emit: gb, optional: true\n    tuple val(meta), path(\"*gff\")                            , emit: gff, optional: true\n    tuple val(meta), path(\"*all_potential_contigs.fa\")       , emit: all_potential_contigs, optional: true\n    tuple val(meta), path(\"*contigs_annotations.png\")        , emit: contigs_annotations, optional: true\n    tuple val(meta), path(\"*contigs_circularization\")        , emit: contigs_circularization, optional: true\n    tuple val(meta), path(\"*contigs_filtering\")              , emit: contigs_filtering, optional: true\n    tuple val(meta), path(\"*coverage_mapping\")               , emit: coverage_mapping, optional: true\n    tuple val(meta), path(\"*coverage_plot.png\")              , emit: coverage_plot, optional: true\n    tuple val(meta), path(\"*final_mitogenome.annotation.png\"), emit: final_mitogenome_annotation, optional: true\n    tuple val(meta), path(\"*final_mitogenome_choice\")        , emit: final_mitogenome_choice, optional: true\n    tuple val(meta), path(\"*final_mitogenome.coverage.png\")  , emit: final_mitogenome_coverage, optional: true\n    tuple val(meta), path(\"*potential_contigs\")              , emit: potential_contigs, optional: true\n    tuple val(meta), path(\"*reads_mapping_and_assembly\")     , emit: reads_mapping_and_assembly, optional: true\n    tuple val(meta), path(\"*shared_genes.tsv\")               , emit: shared_genes, optional: true\n    path  \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"MitoHiFi module does not support Conda. Please use Docker / Singularity instead.\"\n    }\n\n    def args = task.ext.args ?: ''\n    if (! [\"c\", \"r\"].contains(input_mode)) {\n        error \"r for reads or c for contigs must be specified\"\n    }\n    \"\"\"\n    mitohifi.py -${input_mode} ${input} \\\\\n        -f ${ref_fa} \\\\\n        -g ${ref_gb} \\\\\n        -o ${mito_code} \\\\\n        -t $task.cpus ${args}\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mitohifi: \\$( mitohifi.py --version 2>&1 | head -n1 | sed 's/^.*MitoHiFi //; s/ .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch final_mitogenome.fasta\n    touch final_mitogenome.fasta\n    touch contigs_stats.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mitohifi: \\$( mitohifi.py --version 2>&1 | head -n1 | sed 's/^.*MitoHiFi //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate a consensus sequence from a BAM file using iVar\nTags: amplicon sequencing, consensus, fasta", "answer": "process IVAR_CONSENSUS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ivar:1.4--h6b7c446_1' :\n        'biocontainers/ivar:1.4--h6b7c446_1' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path fasta\n    val save_mpileup\n\n    output:\n    tuple val(meta), path(\"*.fa\")      , emit: fasta\n    tuple val(meta), path(\"*.qual.txt\"), emit: qual\n    tuple val(meta), path(\"*.mpileup\") , optional:true, emit: mpileup\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def mpileup = save_mpileup ? \"| tee ${prefix}.mpileup\" : \"\"\n    \"\"\"\n    samtools \\\\\n        mpileup \\\\\n        --reference $fasta \\\\\n        $args2 \\\\\n        $bam \\\\\n        $mpileup \\\\\n        | ivar \\\\\n            consensus \\\\\n            $args \\\\\n            -p $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ivar: \\$(echo \\$(ivar version 2>&1) | sed 's/^.*iVar version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Call variants from a BAM file using iVar\nTags: amplicon sequencing, variants, fasta", "answer": "process IVAR_VARIANTS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ivar:1.4--h6b7c446_1' :\n        'biocontainers/ivar:1.4--h6b7c446_1' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  fasta\n    path  fai\n    path  gff\n    val   save_mpileup\n\n    output:\n    tuple val(meta), path(\"*.tsv\")    , emit: tsv\n    tuple val(meta), path(\"*.mpileup\"), optional:true, emit: mpileup\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def features = gff ? \"-g $gff\" : \"\"\n    def mpileup = save_mpileup ? \"| tee ${prefix}.mpileup\" : \"\"\n    \"\"\"\n    samtools \\\\\n        mpileup \\\\\n        $args2 \\\\\n        --reference $fasta \\\\\n        $bam \\\\\n        $mpileup \\\\\n        | ivar \\\\\n            variants \\\\\n            $args \\\\\n            $features \\\\\n            -r $fasta \\\\\n            -p $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ivar: \\$(echo \\$(ivar version 2>&1) | sed 's/^.*iVar version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Trim primer sequences rom a BAM file with iVar\nTags: amplicon sequencing, trimming, fasta", "answer": "process IVAR_TRIM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ivar:1.4--h6b7c446_1' :\n        'biocontainers/ivar:1.4--h6b7c446_1' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    path bed\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path('*.log'), emit: log\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ivar trim \\\\\n        $args \\\\\n        -i $bam \\\\\n        -b $bed \\\\\n        -p $prefix \\\\\n        > ${prefix}.ivar.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ivar: \\$(echo \\$(ivar version 2>&1) | sed 's/^.*iVar version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Produces a Newick format phylogeny from a multiple sequence alignment using the maxium likelihood algorithm. Capable of bacterial genome size alignments.\nTags: phylogeny, newick, maximum likelihood", "answer": "process IQTREE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/iqtree:2.3.4--h21ec9f0_0' :\n        'biocontainers/iqtree:2.3.4--h21ec9f0_0' }\"\n\n    input:\n    tuple val(meta), path(alignment), path(tree)\n    path(tree_te)\n    path(lmclust)\n    path(mdef)\n    path(partitions_equal)\n    path(partitions_proportional)\n    path(partitions_unlinked)\n    path(guide_tree)\n    path(sitefreq_in)\n    path(constraint_tree)\n    path(trees_z)\n    path(suptree)\n    path(trees_rf)\n\n    output:\n    tuple val(meta), path(\"*.treefile\")      , emit: phylogeny     , optional: true\n    tuple val(meta), path(\"*.iqtree\")        , emit: report        , optional: true\n    tuple val(meta), path(\"*.mldist\")        , emit: mldist        , optional: true\n    tuple val(meta), path(\"*.lmap.svg\")      , emit: lmap_svg      , optional: true\n    tuple val(meta), path(\"*.lmap.eps\")      , emit: lmap_eps      , optional: true\n    tuple val(meta), path(\"*.lmap.quartetlh\"), emit: lmap_quartetlh, optional: true\n    tuple val(meta), path(\"*.sitefreq\")      , emit: sitefreq_out  , optional: true\n    tuple val(meta), path(\"*.ufboot\")        , emit: bootstrap     , optional: true\n    tuple val(meta), path(\"*.state\")         , emit: state         , optional: true\n    tuple val(meta), path(\"*.contree\")       , emit: contree       , optional: true\n    tuple val(meta), path(\"*.nex\")           , emit: nex           , optional: true\n    tuple val(meta), path(\"*.splits\")        , emit: splits        , optional: true\n    tuple val(meta), path(\"*.suptree\")       , emit: suptree       , optional: true\n    tuple val(meta), path(\"*.alninfo\")       , emit: alninfo       , optional: true\n    tuple val(meta), path(\"*.partlh\")        , emit: partlh        , optional: true\n    tuple val(meta), path(\"*.siteprob\")      , emit: siteprob      , optional: true\n    tuple val(meta), path(\"*.sitelh\")        , emit: sitelh        , optional: true\n    tuple val(meta), path(\"*.treels\")        , emit: treels        , optional: true\n    tuple val(meta), path(\"*.rate  \")        , emit: rate          , optional: true\n    tuple val(meta), path(\"*.mlrate\")        , emit: mlrate        , optional: true\n    tuple val(meta), path(\"GTRPMIX.nex\")     , emit: exch_matrix   , optional: true\n    tuple val(meta), path(\"*.log\")           , emit: log\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args                        = task.ext.args           ?: ''\n    def alignment_arg               = alignment               ? \"-s $alignment\"                 : ''\n    def tree_arg                    = tree                    ? \"-t $tree\"                      : ''\n    def tree_te_arg                 = tree_te                 ? \"-te $tree_te\"                  : ''\n    def lmclust_arg                 = lmclust                 ? \"-lmclust $lmclust\"             : ''\n    def mdef_arg                    = mdef                    ? \"-mdef $mdef\"                   : ''\n    def partitions_equal_arg        = partitions_equal        ? \"-q $partitions_equal\"          : ''\n    def partitions_proportional_arg = partitions_proportional ? \"-spp $partitions_proportional\" : ''\n    def partitions_unlinked_arg     = partitions_unlinked     ? \"-sp $partitions_unlinked\"      : ''\n    def guide_tree_arg              = guide_tree              ? \"-ft $guide_tree\"               : ''\n    def sitefreq_in_arg             = sitefreq_in             ? \"-fs $sitefreq_in\"              : ''\n    def constraint_tree_arg         = constraint_tree         ? \"-g $constraint_tree\"           : ''\n    def trees_z_arg                 = trees_z                 ? \"-z $trees_z\"                   : ''\n    def suptree_arg                 = suptree                 ? \"-sup $suptree\"                 : ''\n    def trees_rf_arg                = trees_rf                ? \"-rf $trees_rf\"                 : ''\n    def prefix                      = task.ext.prefix         ?: meta.id\n    def memory                      = task.memory.toString().replaceAll(' ', '')\n    \"\"\"\n    iqtree \\\\\n        $args \\\\\n        $alignment_arg \\\\\n        $tree_arg \\\\\n        $tree_te_arg \\\\\n        $lmclust_arg \\\\\n        $mdef_arg \\\\\n        $partitions_equal_arg \\\\\n        $partitions_proportional_arg \\\\\n        $partitions_unlinked_arg \\\\\n        $guide_tree_arg \\\\\n        $sitefreq_in_arg \\\\\n        $constraint_tree_arg \\\\\n        $trees_z_arg \\\\\n        $suptree_arg \\\\\n        $trees_rf\\\\\n        -pre $prefix \\\\\n        -nt AUTO \\\\\n        -ntmax $task.cpus \\\\\n        -mem $memory \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iqtree: \\$(echo \\$(iqtree -version 2>&1) | sed 's/^IQ-TREE multicore version //;s/ .*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: meta.id\n    \"\"\"\n    touch \"${prefix}.treefile\"\n    touch \"${prefix}.iqtree\"\n    touch \"${prefix}.mldist\"\n    touch \"${prefix}.lmap.svg\"\n    touch \"${prefix}.lmap.eps\"\n    touch \"${prefix}.lmap.quartetlh\"\n    touch \"${prefix}.sitefreq\"\n    touch \"${prefix}.ufboot\"\n    touch \"${prefix}.state\"\n    touch \"${prefix}.contree\"\n    touch \"${prefix}.nex\"\n    touch \"${prefix}.splits\"\n    touch \"${prefix}.suptree\"\n    touch \"${prefix}.alninfo\"\n    touch \"${prefix}.partlh\"\n    touch \"${prefix}.siteprob\"\n    touch \"${prefix}.sitelh\"\n    touch \"${prefix}.treels\"\n    touch \"${prefix}.rate\"\n    touch \"${prefix}.mlrate\"\n    touch \"GTRPMIX.nex\"\n    touch \"${prefix}.log\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iqtree: \\$(echo \\$(iqtree -version 2>&1) | sed 's/^IQ-TREE multicore version //;s/ .*//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Filter a gtf file to keep only regions that are located on a chromosome represented in a given fasta file\nTags: gtf, fasta, filter", "answer": "process CUSTOM_GTFFILTER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/python:3.9--1' :\n        'biocontainers/python:3.9--1' }\"\n\n    input:\n    tuple val(meta), path(gtf)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${prefix}.${suffix}\"), emit: gtf\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.suffix ?: \"gtf\" + (gtf.extension == 'gz' ? '.gz' : '')\n    template 'gtffilter.py'\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    suffix = task.ext.suffix ?: \"gtf\" + (gtf.extension == 'gz' ? '.gz' : '')\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        python: \\$(python --version 2>&1 | cut -d ' ' -f 2)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: filter a matrix based on a minimum value and numbers of samples that must pass.\nTags: matrix, filter, abundance, na", "answer": "process CUSTOM_MATRIXFILTER {\n    tag \"$meta\"\n    label 'process_single'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-base:4.2.1' :\n        'biocontainers/r-base:4.2.1' }\"\n\n    input:\n    tuple val(meta), path(abundance)\n    tuple val(samplesheet_meta), path(samplesheet)\n\n    output:\n    tuple val(meta), path(\"*.filtered.tsv\")             , emit: filtered\n    tuple val(meta), path(\"*.tests.tsv\")                , emit: tests\n    tuple val(meta), path(\"R_sessionInfo.log\")          , emit: session_info\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Note: params are passed at line 100 of the template like:\n    //\n    // opt <- parse_args('$task.ext.args', opt)\n    //\n    // (new variables defined here don't seem to be available in templates, so\n    // we have to access $task directly)\n    template 'matrixfilter.R'\n}\n"}
{"question": "Description: Test for the presence of suitable NCBI settings or create them on the fly.\nTags: NCBI, settings, sra-tools, prefetch, fasterq-dump", "answer": "process CUSTOM_SRATOOLSNCBISETTINGS {\n    tag 'ncbi-settings'\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sra-tools:3.0.8--h9f5acd7_0' :\n        'biocontainers/sra-tools:3.0.8--h9f5acd7_0' }\"\n\n    input:\n    val ids\n\n    output:\n    path('*.mkfg')     , emit: ncbi_settings\n    path 'versions.yml', emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    shell:\n    config = \"/LIBS/GUID = \\\"${UUID.randomUUID().toString()}\\\"\\\\n/libs/cloud/report_instance_identity = \\\"true\\\"\\\\n\"\n    template 'detect_ncbi_settings.sh'\n}\n"}
{"question": "Description: Custom module to Add a new fasta file to an old one and update an associated GTF\nTags: fasta, gtf, genomics", "answer": "process CUSTOM_CATADDITIONALFASTA {\n    tag \"$meta.id\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/python:3.9--1' :\n        'biocontainers/python:3.9--1' }\"\n\n    input:\n    tuple val(meta), path(fasta), path(gtf)\n    tuple val(meta2), path(add_fasta)\n    val  biotype\n\n    output:\n    tuple val(meta), path(\"*/*.fasta\") , emit: fasta\n    tuple val(meta), path(\"*/*.gtf\")   , emit: gtf\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'fasta2gtf.py'\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir out\n    touch out/genome_transcriptome.fasta\n    touch out/genome_transcriptome.gtf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        python: \\$(python --version | grep -v \"Python \")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert a TSV or CSV with features by row and observations by column to a GCT format file as consumed by GSEA\nTags: gsea, gct, tabular", "answer": "process CUSTOM_TABULARTOGSEAGCT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:20.04' :\n        'nf-core/ubuntu:20.04' }\"\n\n    input:\n    tuple val(meta), path(tabular)\n\n    output:\n    tuple val(meta), path(\"*.gct\"), emit: gct\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: []\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def separator = args.separator ? \"${args.separator}\" : ( tabular.getName().endsWith(\".csv\") ? ',': '\\t' )\n    separator = separator == '\\t' ? '\\\\t': separator\n\n    \"\"\"\n    n_columns=\\$(head -n 1 $tabular | tr \"$separator\" \"\\\\n\" | wc -l)\n    n_lines=\\$(wc -l < $tabular)\n    gct_file=${prefix}.gct\n\n    echo -e \"#1.2\\$(printf '\\\\t%.0s' {1..\\$n_columns})\\\\n\\$((n_lines-1))\\\\t\\$((n_columns-1))\\$(printf '\\\\t%.0s' {1..\\$((n_columns-1))})\" > \\$gct_file\n    echo -e \"NAME\\\\tDESCRIPTION\\\\t\\$(head -n 1 $tabular | cut -f1 -d\\$'$separator' --complement | awk -F'$separator' 'BEGIN { OFS = \"\\\\t\"}; {\\$1=\\$1}1' )\" >> \\$gct_file\n    cat $tabular | tail -n +2 | awk -F'$separator' 'BEGIN { OFS = \"\\\\t\"} {\\$1=\\$1\"\\\\tNA\"}1' >> \\$gct_file\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bash: \\$(echo \\$(bash --version | grep -Eo 'version [[:alnum:].]+' | sed 's/version //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Make a transcript/gene mapping from a GTF and cross-reference with transcript quantifications.\nTags: gene, gtf, pseudoalignment, transcript", "answer": "process CUSTOM_TX2GENE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/python:3.9--1' :\n        'biocontainers/python:3.9--1' }\"\n\n    input:\n    tuple val(meta), path(gtf)\n    tuple val(meta2), path (\"quants/*\")\n    val quant_type\n    val id\n    val extra\n\n    output:\n    tuple val(meta), path(\"*tx2gene.tsv\"), emit: tx2gene\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'tx2gene.py'\n\n    stub:\n    \"\"\"\n    touch ${meta.id}.tx2gene.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        python: \\$(python --version | sed 's/Python //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Make a GSEA class file (.cls) from tabular inputs\nTags: gsea, cls, convert, tabular", "answer": "process CUSTOM_TABULARTOGSEACLS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:20.04' :\n        'nf-core/ubuntu:20.04' }\"\n\n    input:\n    tuple val(meta), path(samples)\n\n    output:\n    tuple val(meta), path(\"*.cls\"), emit: cls\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: []\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def separator = args.separator ? \"${args.separator}\" : ( samples.getName().endsWith(\".tsv\") ? '\\t': ',' )\n    separator = separator == '\\t' ? '\\\\t': separator\n    def variable = args.variable\n    if ( !variable ) error \"Supply a variable in the sample sheet from which to derive classes\"\n    \"\"\"\n    cls_file=${prefix}.cls\n\n    column_number=\\$(cat $samples | head -n 1 | tr '$separator' \"\\\\n\" | grep -En \"^$variable\\$\" | awk -F':' '{print \\$1}')\n    classes=\\$(tail -n +2 $samples | awk -F'$separator' '{print \\$'\\$column_number'}' | sed 's/^\\$/empty/g')\n    unique_classes=\\$(echo -e \"\\$classes\" | awk '!x[\\$0]++')\n\n    echo -e \"\\$(echo -e \\\"\\$classes\\\" | wc -l) \\$(echo -e \\\"\\$unique_classes\\\" | wc -l) 1\" > \\$cls_file\n    echo -e \"#\\$(echo -e \\\"\\$unique_classes\\\" | tr '\\\\n' ' ')\" | sed \"s/ \\$//\" >> \\$cls_file\n    echo -e \"\\$classes\" | tr '\\\\n' ' ' | sed \"s/ \\$//\" >> \\$cls_file\n    echo -e \"\\\\n\" >> \\$cls_file\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bash: \\$(echo \\$(bash --version | grep -Eo 'version [[:alnum:].]+' | sed 's/version //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generates a FASTA file of chromosome sizes and a fasta index file\nTags: fasta, chromosome, indexing", "answer": "process CUSTOM_GETCHROMSIZES {\n    tag \"$fasta\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/samtools:1.20--h50ea8bc_0' :\n        'biocontainers/samtools:1.20--h50ea8bc_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path (\"*.sizes\"), emit: sizes\n    tuple val(meta), path (\"*.fai\")  , emit: fai\n    tuple val(meta), path (\"*.gzi\")  , emit: gzi, optional: true\n    path  \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    samtools faidx $fasta\n    cut -f 1,2 ${fasta}.fai > ${fasta}.sizes\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        getchromsizes: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${fasta}.fai\n    touch ${fasta}.sizes\n    if [[ \"${fasta.extension}\" == \"gz\" ]]; then\n        touch ${fasta}.gzi\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        getchromsizes: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Custom module used to dump software versions within the nf-core pipeline template\nTags: custom, dump, version", "answer": "process CUSTOM_DUMPSOFTWAREVERSIONS {\n    label 'process_single'\n\n    // Requires `pyyaml` which does not have a dedicated container but is in the MultiQC container\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/multiqc:1.20--pyhdfd78af_0' :\n        'biocontainers/multiqc:1.20--pyhdfd78af_0' }\"\n\n    input:\n    path versions\n\n    output:\n    path \"software_versions.yml\"    , emit: yml\n    path \"software_versions_mqc.yml\", emit: mqc_yml\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    template 'dumpsoftwareversions.py'\n}\n"}
{"question": "Description: Demultiplex Element Biosciences bases files\nTags: demultiplex, element, fastq", "answer": "process BASES2FASTQ {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    container \"docker.io/elembio/bases2fastq:1.8.0\"\n\n    input:\n    tuple val(meta), path(run_manifest), path(run_dir)\n\n    output:\n    tuple val(meta), path('output/Samples/**/*_R*.fastq.gz'), emit: sample_fastq\n    tuple val(meta), path('output/Samples/**/*_stats.json') , emit: sample_json\n    tuple val(meta), path('output/*.html')                  , emit: qc_report\n    tuple val(meta), path('output/RunStats.json')           , emit: run_stats\n    tuple val(meta), path('output/RunManifest.json')        , emit: generated_run_manifest\n    tuple val(meta), path('output/Metrics.csv')             , emit: metrics\n    tuple val(meta), path('output/UnassignedSequences.csv') , emit: unassigned\n    path \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"BASES2FASTQ module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def runManifest = run_manifest ? \"-r ${run_manifest}\" : \"\"\n    \"\"\"\n    bases2fastq \\\\\n        -p $task.cpus \\\\\n        $runManifest \\\\\n        $args \\\\\n        $run_dir \\\\\n        output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bases2fastq: \\$(bases2fastq --version | sed -e \"s/bases2fastq version //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir output\n    mkdir output/Samples\n    mkdir output/Samples/DefaultSample\n\n    touch output/Metrics.csv\n    touch output/RunManifest.json\n    touch output/UnassignedSequences.csv\n    echo | gzip > output/Samples/DefaultSample/DefaultSample_R1.fastq.gz\n    echo | gzip > output/Samples/DefaultSample/DefaultSample_R2.fastq.gz\n    touch output/Bases2Fastq-Sim_QC.html\n    touch output/RunStats.json\n    touch output/Samples/DefaultSample/DefaultSample_stats.json\n    touch versions.yml\n    \"\"\"\n}\n"}
{"question": "Description: sage is a search software for proteomics data\nTags: proteomics, sage, mass spectrometry", "answer": "process SAGEPROTEOMICS_SAGE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sage-proteomics:0.14.7--h031d066_0' :\n        'biocontainers/sage-proteomics:0.14.7--h031d066_0' }\"\n\n    input:\n    tuple val(meta),  path(\"*.mzML\")\n    tuple val(meta2), path(fasta_proteome)\n    tuple val(meta3), path(base_config)\n\n    output:\n    tuple val(meta), path(\"results.sage.tsv\"),        emit: results_tsv\n    tuple val(meta), path(\"results.json\"),            emit: results_json\n    tuple val(meta), path(\"results.sage.pin\"),        emit: results_pin\n    path \"versions.yml\",                              emit: versions\n\n    //optional outs\n    tuple val(meta), path(\"tmt.tsv\"), optional: true, emit: tmt_tsv\n    tuple val(meta), path(\"lfq.tsv\"), optional: true, emit: lfq_tsv\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    export RAYON_NUM_THREADS=$task.cpus\n\n    sage $base_config \\\\\n        --disable-telemetry-i-dont-want-to-improve-sage \\\\\n        --fasta $fasta_proteome \\\\\n        --write-pin \\\\\n        *.mzML\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sageproteomics: \\$(sage --version |& sed '1!d ; s/sage //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch results.json\n    touch results.sage.tsv\n    touch results.sage.pin\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sageproteomics: \\$(sage --version |& sed '1!d ; s/sage //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Muscle is a program for creating multiple alignments of amino acid or nucleotide sequences. This particular module uses the super5 algorithm for very big alignments. It can permutate the guide tree according to a set of flags.\nTags: align, msa, multiple sequence alignment", "answer": "process MUSCLE5_SUPER5 {\n    tag \"$meta.id\"\n    label 'process_medium'\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-8eb01a3c2755c935d070dd03ff2dee698eeb4466:ceb6e65e00346ed20d0d8078dddf9858a7af0fe2-0':\n        'biocontainers/mulled-v2-8eb01a3c2755c935d070dd03ff2dee698eeb4466:ceb6e65e00346ed20d0d8078dddf9858a7af0fe2-0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"*.aln{.gz,}\"), emit: alignment\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    prefix = args.contains('-perm all') ? \"${prefix}@\" : \"${prefix}\"\n    def write_output = (compress && !args.contains('-perm all')) ? \" -output >(pigz -cp ${task.cpus} > ${prefix}.aln.gz)\" : \"-output ${prefix}.aln\"\n    // muscle internally expands the shell pipe to a file descriptor of the form /dev/fd/<id>\n    // this causes it to fail, unless -output is left at the end of the call\n    // see also clustalo/align\n    // using >() is necessary to preserve the return value,\n    // so nextflow knows to display an error when it failed\n    \"\"\"\n    muscle \\\\\n        -super5 ${fasta} \\\\\n        ${args} \\\\\n        -threads ${task.cpus} \\\\\n        $write_output\n\n\n    # output may be multiple files if -perm all is set\n    # compress these individually if set to compress output\n    if ${args.contains('-perm all') && compress}; then\n        pigz -p ${task.cpus} *.aln\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        muscle: \\$(muscle -version | head -n 1 | cut -d ' ' -f 2 | sed 's/.linux64//')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.aln${compress ? '.gz' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        muscle: \\$(muscle -version | head -n 1 | cut -d ' ' -f 2 | sed 's/.linux64//')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Serovar prediction of salmonella assemblies\nTags: bacteria, fasta, salmonella", "answer": "process SISTR {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sistr_cmd:1.1.1--pyh864c0ab_2':\n        'biocontainers/sistr_cmd:1.1.1--pyh864c0ab_2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tab\")         , emit: tsv\n    tuple val(meta), path(\"*-allele.fasta\"), emit: allele_fasta\n    tuple val(meta), path(\"*-allele.json\") , emit: allele_json\n    tuple val(meta), path(\"*-cgmlst.csv\")  , emit: cgmlst_csv\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def is_compressed = fasta.getName().endsWith(\".gz\") ? true : false\n    def fasta_name = fasta.getName().replace(\".gz\", \"\")\n    \"\"\"\n    if [ \"$is_compressed\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    sistr \\\\\n        --qc \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        --alleles-output ${prefix}-allele.json \\\\\n        --novel-alleles ${prefix}-allele.fasta \\\\\n        --cgmlst-profiles ${prefix}-cgmlst.csv \\\\\n        --output-prediction ${prefix} \\\\\n        --output-format tab \\\\\n        $fasta_name\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sistr: \\$(echo \\$(sistr --version 2>&1) | sed 's/^.*sistr_cmd //; s/ .*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Accurate assembly of segmental duplications, satellites, and allelic variants from high-fidelity long reads.\nTags: Assembly, pacbio, hifi, nanopore", "answer": "process CANU {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/canu:2.2--ha47f30e_0':\n        'biocontainers/canu:2.2--ha47f30e_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    val mode\n    val genomesize\n\n    output:\n    tuple val(meta), path(\"*.report\")                   , emit: report\n    tuple val(meta), path(\"*.contigs.fasta.gz\")         , emit: assembly                , optional: true\n    tuple val(meta), path(\"*.unassembled.fasta.gz\")     , emit: contigs\n    tuple val(meta), path(\"*.correctedReads.fasta.gz\")\t, emit: corrected_reads         , optional: true\n    tuple val(meta), path(\"*.trimmedReads.fasta.gz\")\t, emit: corrected_trimmed_reads , optional: true\n    tuple val(meta), path(\"*.contigs.layout\")           , emit: metadata                , optional: true\n    tuple val(meta), path(\"*.contigs.layout.readToTig\") , emit: contig_position         , optional: true\n    tuple val(meta), path(\"*.contigs.layout.tigInfo\")   , emit: contig_info             , optional: true\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def valid_mode = [\"-pacbio\", \"-nanopore\", \"-pacbio-hifi\"]\n    if ( !valid_mode.contains(mode) )  { error \"Unrecognised mode to run Canu. Options: ${valid_mode.join(', ')}\" }\n    \"\"\"\n    canu \\\\\n        -p ${prefix} \\\\\n        $mode \\\\\n        genomeSize=${genomesize} \\\\\n        $args \\\\\n        maxThreads=$task.cpus \\\\\n        $reads\n\n    gzip *.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        canu: \\$(echo \\$(canu --version 2>&1) | sed 's/^.*canu //; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: copy number profiles of tumour cells.\nTags: bam, copy number, cram", "answer": "process ASCAT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-c278c7398beb73294d78639a864352abef2931ce:ba3e6d2157eac2d38d22e62ec87675e12adb1010-0':\n        'biocontainers/mulled-v2-c278c7398beb73294d78639a864352abef2931ce:ba3e6d2157eac2d38d22e62ec87675e12adb1010-0' }\"\n\n    input:\n    tuple val(meta), path(input_normal), path(index_normal), path(input_tumor), path(index_tumor)\n    path(allele_files)\n    path(loci_files)\n    path(bed_file)  // optional\n    path(fasta)     // optional\n    path(gc_file)   // optional\n    path(rt_file)   // optional\n\n    output:\n    tuple val(meta), path(\"*alleleFrequencies_chr*.txt\"),      emit: allelefreqs\n    tuple val(meta), path(\"*BAF.txt\"),                         emit: bafs\n    tuple val(meta), path(\"*cnvs.txt\"),                        emit: cnvs\n    tuple val(meta), path(\"*LogR.txt\"),                        emit: logrs\n    tuple val(meta), path(\"*metrics.txt\"),                     emit: metrics\n    tuple val(meta), path(\"*png\"),                             emit: png\n    tuple val(meta), path(\"*purityploidy.txt\"),                emit: purityploidy\n    tuple val(meta), path(\"*segments.txt\"),                    emit: segments\n    path \"versions.yml\",                                       emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args           = task.ext.args        ?: ''\n    def prefix         = task.ext.prefix      ?: \"${meta.id}\"\n    def gender         = args.gender          ?  \"$args.gender\" :        \"NULL\"\n    def genomeVersion  = args.genomeVersion   ?  \"$args.genomeVersion\" : \"NULL\"\n    def purity         = args.purity          ?  \"$args.purity\" :        \"NULL\"\n    def ploidy         = args.ploidy          ?  \"$args.ploidy\" :        \"NULL\"\n    def gc_input       = gc_file              ?  \"$gc_file\" :            \"NULL\"\n    def rt_input       = rt_file              ?  \"$rt_file\" :            \"NULL\"\n\n    def minCounts_arg                    = args.minCounts                     ?  \",minCounts = $args.minCounts\" : \"\"\n    def bed_file_arg                     = bed_file                           ?  \",BED_file = '$bed_file'\": \"\"\n    def chrom_names_arg                  = args.chrom_names                   ?  \",chrom_names = $args.chrom_names\" : \"\"\n    def min_base_qual_arg                = args.min_base_qual                 ?  \",min_base_qual = $args.min_base_qual\" : \"\"\n    def min_map_qual_arg                 = args.min_map_qual                  ?  \",min_map_qual = $args.min_map_qual\" : \"\"\n    def fasta_arg                        = fasta                              ?  \",ref.fasta = '$fasta'\" : \"\"\n    def skip_allele_counting_tumour_arg  = args.skip_allele_counting_tumour   ?  \",skip_allele_counting_tumour = $args.skip_allele_counting_tumour\" : \"\"\n    def skip_allele_counting_normal_arg  = args.skip_allele_counting_normal   ?  \",skip_allele_counting_normal = $args.skip_allele_counting_normal\" : \"\"\n\n    \"\"\"\n    #!/usr/bin/env Rscript\n    library(RColorBrewer)\n    library(ASCAT)\n    options(bitmapType='cairo')\n\n    #build prefixes: <abspath_to_files/prefix_chr>\n    allele_path = normalizePath(\"$allele_files\")\n    allele_prefix = paste0(allele_path, \"/\", \"$allele_files\", \"_chr\")\n\n    loci_path = normalizePath(\"$loci_files\")\n    loci_prefix = paste0(loci_path, \"/\", \"$loci_files\", \"_chr\")\n\n    #prepare from BAM files\n    ascat.prepareHTS(\n        tumourseqfile = \"$input_tumor\",\n        normalseqfile = \"$input_normal\",\n        tumourname = paste0(\"$prefix\", \".tumour\"),\n        normalname = paste0(\"$prefix\", \".normal\"),\n        allelecounter_exe = \"alleleCounter\",\n        alleles.prefix = allele_prefix,\n        loci.prefix = loci_prefix,\n        gender = \"$gender\",\n        genomeVersion = \"$genomeVersion\",\n        nthreads = $task.cpus\n        $minCounts_arg\n        $bed_file_arg\n        $chrom_names_arg\n        $min_base_qual_arg\n        $min_map_qual_arg\n        $fasta_arg\n        $skip_allele_counting_tumour_arg\n        $skip_allele_counting_normal_arg,\n        seed = 42\n    )\n\n\n    #Load the data\n    ascat.bc = ascat.loadData(\n        Tumor_LogR_file = paste0(\"$prefix\", \".tumour_tumourLogR.txt\"),\n        Tumor_BAF_file = paste0(\"$prefix\", \".tumour_tumourBAF.txt\"),\n        Germline_LogR_file = paste0(\"$prefix\", \".tumour_normalLogR.txt\"),\n        Germline_BAF_file = paste0(\"$prefix\", \".tumour_normalBAF.txt\"),\n        genomeVersion = \"$genomeVersion\",\n        gender = \"$gender\"\n    )\n\n    #Plot the raw data\n    ascat.plotRawData(ascat.bc, img.prefix = paste0(\"$prefix\", \".before_correction.\"))\n\n    # optional LogRCorrection\n    if(\"$gc_input\" != \"NULL\") {\n        gc_input = paste0(normalizePath(\"$gc_input\"), \"/\", \"$gc_input\", \".txt\")\n\n        if(\"$rt_input\" != \"NULL\"){\n            rt_input = paste0(normalizePath(\"$rt_input\"), \"/\", \"$rt_input\", \".txt\")\n            ascat.bc = ascat.correctLogR(ascat.bc, GCcontentfile = gc_input, replictimingfile = rt_input)\n            #Plot raw data after correction\n            ascat.plotRawData(ascat.bc, img.prefix = paste0(\"$prefix\", \".after_correction_gc_rt.\"))\n        }\n        else {\n            ascat.bc = ascat.correctLogR(ascat.bc, GCcontentfile = gc_input, replictimingfile = $rt_input)\n            #Plot raw data after correction\n            ascat.plotRawData(ascat.bc, img.prefix = paste0(\"$prefix\", \".after_correction_gc.\"))\n        }\n    }\n\n    #Segment the data\n    ascat.bc = ascat.aspcf(ascat.bc, seed=42)\n\n    #Plot the segmented data\n    ascat.plotSegmentedData(ascat.bc)\n\n    #Run ASCAT to fit every tumor to a model, inferring ploidy, normal cell contamination, and discrete copy numbers\n    #If psi and rho are manually set:\n    if (!is.null($purity) && !is.null($ploidy)){\n        ascat.output <- ascat.runAscat(ascat.bc, gamma=1, rho_manual=$purity, psi_manual=$ploidy)\n    } else if(!is.null($purity) && is.null($ploidy)){\n        ascat.output <- ascat.runAscat(ascat.bc, gamma=1, rho_manual=$purity)\n    } else if(!is.null($ploidy) && is.null($purity)){\n        ascat.output <- ascat.runAscat(ascat.bc, gamma=1, psi_manual=$ploidy)\n    } else {\n        ascat.output <- ascat.runAscat(ascat.bc, gamma=1)\n    }\n\n    #Extract metrics from ASCAT profiles\n    QC = ascat.metrics(ascat.bc,ascat.output)\n\n    #Write out segmented regions (including regions with one copy of each allele)\n    write.table(ascat.output[[\"segments\"]], file=paste0(\"$prefix\", \".segments.txt\"), sep=\"\\t\", quote=F, row.names=F)\n\n    #Write out CNVs in bed format\n    cnvs=ascat.output[[\"segments\"]][2:6]\n    write.table(cnvs, file=paste0(\"$prefix\",\".cnvs.txt\"), sep=\"\\t\", quote=F, row.names=F, col.names=T)\n\n    #Write out purity and ploidy info\n    summary <- tryCatch({\n            matrix(c(ascat.output[[\"aberrantcellfraction\"]], ascat.output[[\"ploidy\"]]), ncol=2, byrow=TRUE)}, error = function(err) {\n                # error handler picks up where error was generated\n                print(paste(\"Could not find optimal solution:  \",err))\n                return(matrix(c(0,0),nrow=1,ncol=2,byrow = TRUE))\n        }\n    )\n    colnames(summary) <- c(\"AberrantCellFraction\",\"Ploidy\")\n    write.table(summary, file=paste0(\"$prefix\",\".purityploidy.txt\"), sep=\"\\t\", quote=F, row.names=F, col.names=T)\n\n    write.table(QC, file=paste0(\"$prefix\", \".metrics.txt\"), sep=\"\\t\", quote=F, row.names=F)\n\n    # version export\n    f <- file(\"versions.yml\",\"w\")\n    alleleCounter_version = system(paste(\"alleleCounter --version\"), intern = T)\n    ascat_version = sessionInfo()\\$otherPkgs\\$ASCAT\\$Version\n    writeLines(paste0('\"', \"$task.process\", '\"', \":\"), f)\n    writeLines(paste(\"    alleleCounter:\", alleleCounter_version), f)\n    writeLines(paste(\"    ascat:\", ascat_version), f)\n    close(f)\n\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo stub > ${prefix}.after_correction.gc_rt.test.tumour.germline.png\n    echo stub > ${prefix}.after_correction.gc_rt.test.tumour.tumour.png\n    echo stub > ${prefix}.before_correction.test.tumour.germline.png\n    echo stub > ${prefix}.before_correction.test.tumour.tumour.png\n    echo stub > ${prefix}.cnvs.txt\n    echo stub > ${prefix}.metrics.txt\n    echo stub > ${prefix}.normal_alleleFrequencies_chr21.txt\n    echo stub > ${prefix}.normal_alleleFrequencies_chr22.txt\n    echo stub > ${prefix}.purityploidy.txt\n    echo stub > ${prefix}.segments.txt\n    echo stub > ${prefix}.tumour.ASPCF.png\n    echo stub > ${prefix}.tumour.sunrise.png\n    echo stub > ${prefix}.tumour_alleleFrequencies_chr21.txt\n    echo stub > ${prefix}.tumour_alleleFrequencies_chr22.txt\n    echo stub > ${prefix}.tumour_normalBAF.txt\n    echo stub > ${prefix}.tumour_normalLogR.txt\n    echo stub > ${prefix}.tumour_tumourBAF.txt\n    echo stub > ${prefix}.tumour_tumourLogR.txt\n\n    echo \"${task.process}:\" > versions.yml\n    echo ' alleleCounter: 4.3.0' >> versions.yml\n    echo ' ascat: 3.0.0' >> versions.yml\n\n    \"\"\"\n\n\n}\n"}
{"question": "Description: DeepVariant is an analysis pipeline that uses a deep neural network to call genetic variants from next-generation DNA sequencing data\nTags: variant calling, machine learning, neural network", "answer": "process DEEPVARIANT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    // FIXME Conda is not supported at the moment\n    // BUG https://github.com/nf-core/modules/issues/1754\n    // BUG https://github.com/bioconda/bioconda-recipes/issues/30310\n    container \"nf-core/deepvariant:1.6.1\"\n\n    input:\n    tuple val(meta), path(input), path(index), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(gzi)\n    tuple val(meta5), path(par_bed)\n\n    output:\n    tuple val(meta), path(\"${prefix}.vcf.gz\")      ,  emit: vcf\n    tuple val(meta), path(\"${prefix}.vcf.gz.tbi\")  ,  emit: vcf_tbi\n    tuple val(meta), path(\"${prefix}.g.vcf.gz\")    ,  emit: gvcf\n    tuple val(meta), path(\"${prefix}.g.vcf.gz.tbi\"),  emit: gvcf_tbi\n    path \"versions.yml\"                            ,  emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"DEEPVARIANT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def regions = intervals ? \"--regions=${intervals}\" : \"\"\n    def par_regions = par_bed ? \"--par_regions_bed=${par_bed}\" : \"\"\n    // WARN https://github.com/nf-core/modules/pull/5801#issuecomment-2194293755\n    // FIXME Revert this on next version bump\n    def VERSION = '1.6.1'\n\n    \"\"\"\n    /opt/deepvariant/bin/run_deepvariant \\\\\n        --ref=${fasta} \\\\\n        --reads=${input} \\\\\n        --output_vcf=${prefix}.vcf.gz \\\\\n        --output_gvcf=${prefix}.g.vcf.gz \\\\\n        ${args} \\\\\n        ${regions} \\\\\n        ${par_regions} \\\\\n        --intermediate_results_dir=tmp \\\\\n        --num_shards=${task.cpus}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deepvariant: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"DEEPVARIANT module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    // WARN https://github.com/nf-core/modules/pull/5801#issuecomment-2194293755\n    // FIXME Revert this on next version bump\n    def VERSION = '1.6.1'\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n    touch ${prefix}.g.vcf.gz\n    touch ${prefix}.g.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deepvariant: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate recalibration table for Base Quality Score Recalibration (BQSR)\nTags: base quality score recalibration, table, bqsr, gatk4spark, sort", "answer": "process GATK4SPARK_BASERECALIBRATOR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4-spark:4.5.0.0--hdfd78af_0':\n        'biocontainers/gatk4-spark:4.5.0.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(intervals)\n    path  fasta\n    path  fai\n    path  dict\n    path  known_sites\n    path  known_sites_tbi\n\n    output:\n    tuple val(meta), path(\"*.table\"), emit: table\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n    def sites_command = known_sites.collect{\"--known-sites $it\"}.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK BaseRecalibratorSpark] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        BaseRecalibratorSpark \\\\\n        --input $input \\\\\n        --output ${prefix}.table \\\\\n        --reference $fasta \\\\\n        $interval_command \\\\\n        $sites_command \\\\\n        --spark-master local[${task.cpus}] \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply base quality score recalibration (BQSR) to a bam file\nTags: bam, base quality score recalibration, bqsr, cram, gatk4spark", "answer": "process GATK4SPARK_APPLYBQSR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4-spark:4.5.0.0--hdfd78af_0':\n        'biocontainers/gatk4-spark:4.5.0.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(bqsr_table), path(intervals)\n    path  fasta\n    path  fai\n    path  dict\n\n    output:\n    tuple val(meta), path(\"*.bam\") , emit: bam,  optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram, optional: true\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK ApplyBQSRSpark] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk \\\\\n        --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        ApplyBQSRSpark \\\\\n        --input $input \\\\\n        --output ${prefix}.${input.getExtension()} \\\\\n        --reference $fasta \\\\\n        --bqsr-recal-file $bqsr_table \\\\\n        $interval_command \\\\\n        --spark-master local[${task.cpus}] \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix}.cram\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This tool locates and tags duplicate reads in a BAM or SAM file, where duplicate reads are defined as originating from a single fragment of DNA.\nTags: bam, gatk4spark, markduplicates, sort", "answer": "process GATK4SPARK_MARKDUPLICATES {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4-spark:4.5.0.0--hdfd78af_0':\n        'biocontainers/gatk4-spark:4.5.0.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  fasta\n    path  fasta_fai\n    path  dict\n\n    output:\n    tuple val(meta), path(\"${prefix}\"),     emit: output\n    tuple val(meta), path(\"${prefix}.bai\"), emit: bam_index, optional:true\n    tuple val(meta), path(\"*.metrics\"),     emit: metrics, optional: true\n    path \"versions.yml\"               ,     emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}.bam\"\n    def input_list = bam.collect{\"--input $it\"}.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK MarkDuplicatesSpark] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        MarkDuplicatesSpark \\\\\n        $input_list \\\\\n        --output $prefix \\\\\n        --reference $fasta \\\\\n        --spark-master local[${task.cpus}] \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}.bam\"\n    \"\"\"\n    touch ${prefix}\n    touch ${prefix}.bai\n    touch ${prefix}.metrics\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Returns the gender of a .npz resulting from convert, based on a Gaussian mixture model trained during the newref phase\nTags: copy number analysis, gender determination, npz", "answer": "process WISECONDORX_GENDER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/wisecondorx:1.2.7--pyhdfd78af_0':\n        'biocontainers/wisecondorx:1.2.7--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(npz)\n    tuple val(meta2), path(reference)\n\n    output:\n    tuple val(meta), stdout , emit: gender\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def VERSION = '1.2.7' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    WisecondorX gender \\\\\n        ${npz} \\\\\n        ${reference}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wisecondorx: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def VERSION = '1.2.7' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    echo male\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wisecondorx: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Find copy number aberrations\nTags: copy number variation, bed, npz, png", "answer": "process WISECONDORX_PREDICT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/wisecondorx:1.2.7--pyhdfd78af_0':\n        'biocontainers/wisecondorx:1.2.7--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(npz)\n    tuple val(meta2), path(reference)\n    tuple val(meta3), path(blacklist)\n\n    output:\n    tuple val(meta), path(\"*_aberrations.bed\")      , emit: aberrations_bed, optional:true\n    tuple val(meta), path(\"*_bins.bed\")             , emit: bins_bed, optional:true\n    tuple val(meta), path(\"*_segments.bed\")         , emit: segments_bed, optional:true\n    tuple val(meta), path(\"*_chr_statistics.txt\")   , emit: chr_statistics, optional:true\n    tuple val(meta), path(\"[!genome_wide]*.png\")    , emit: chr_plots, optional:true\n    tuple val(meta), path(\"genome_wide.png\")        , emit: genome_plot, optional:true\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: '--bed --plot'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bed = blacklist ? \"--blacklist ${blacklist}\" : \"\"\n\n    def plots = args.contains(\"--plot\") ? \"mv ${prefix}.plots/* .\" : \"\"\n\n    def VERSION = '1.2.7' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    WisecondorX predict \\\\\n        ${npz} \\\\\n        ${reference} \\\\\n        ${prefix} \\\\\n        ${bed} \\\\\n        ${args}\n\n    ${plots}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wisecondorx: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: '--bed --plot'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2.7' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def bed = args.contains(\"--bed\") ? \"touch ${prefix}_aberrations.bed && touch ${prefix}_bins.bed && touch ${prefix}_chr_statistics.txt && touch ${prefix}_segments.bed\" : \"\"\n    def plot = args.contains(\"--plot\") ? \"touch genome_wide.png && touch chr22.png && touch chr1.png\" : \"\"\n\n    \"\"\"\n    ${bed}\n    ${plot}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wisecondorx: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a new reference using healthy reference samples\nTags: reference, copy number alterations, npz", "answer": "process WISECONDORX_NEWREF {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/wisecondorx:1.2.7--pyhdfd78af_0':\n        'biocontainers/wisecondorx:1.2.7--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(inputs)\n\n    output:\n    tuple val(meta), path(\"*.npz\"), emit: npz\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2.7' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    inputs.each { if(\"${it}\" == \"${prefix}.npz\") error \"${it} has the same name as the output file, set prefix in module configuration to disambiguate!\"}\n\n    \"\"\"\n    WisecondorX \\\\\n        newref \\\\\n        *.npz \\\\\n        ${prefix}.npz \\\\\n        --cpus ${task.cpus} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wisecondorx: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2.7' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    inputs.each { if(\"${it}\" == \"${prefix}.npz\") error \"${it} has the same name as the output file, set prefix in module configuration to disambiguate!\"}\n\n    \"\"\"\n    touch ${prefix}.npz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wisecondorx: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert and filter aligned reads to .npz\nTags: bam, cram, copy-number", "answer": "process WISECONDORX_CONVERT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/wisecondorx:1.2.7--pyhdfd78af_0':\n        'biocontainers/wisecondorx:1.2.7--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n\n    output:\n    tuple val(meta), path(\"*.npz\"), emit: npz\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    def VERSION = '1.2.7' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    WisecondorX convert \\\\\n        ${bam} \\\\\n        ${prefix}.npz \\\\\n        ${reference} \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wisecondorx: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.2.7' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    \"\"\"\n    touch ${prefix}.npz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        wisecondorx: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges output abundance tables from MetaPhlAn4\nTags: metagenomics, classification, merge, table, profiles", "answer": "process METAPHLAN_MERGEMETAPHLANTABLES {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metaphlan:4.0.6--pyhca03a8a_0' :\n        'biocontainers/metaphlan:4.0.6--pyhca03a8a_0' }\"\n\n    input:\n    tuple val(meta), path(profiles)\n\n    output:\n    tuple val(meta), path(\"${prefix}.txt\") , emit: txt\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    merge_metaphlan_tables.py \\\\\n        $args \\\\\n        -o ${prefix}.txt \\\\\n        ${profiles}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metaphlan: \\$(metaphlan --version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Build MetaPhlAn database for taxonomic profiling.\nTags: metaphlan, index, database, metagenomics", "answer": "process METAPHLAN_MAKEDB {\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metaphlan:4.0.6--pyhca03a8a_0' :\n        'biocontainers/metaphlan:4.0.6--pyhca03a8a_0' }\"\n\n    output:\n    path \"metaphlan_db_latest\"      , emit: db\n    path \"versions.yml\"         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    metaphlan \\\\\n        --install \\\\\n        --nproc $task.cpus \\\\\n        --bowtie2db metaphlan_db_latest \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metaphlan: \\$(metaphlan --version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    \"\"\"\n    mkdir metaphlan_db_latest\n    touch metaphlan_db_latest/mpa_latest\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.1.bt2\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.2.bt2\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.3.bt2\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.4.bt2\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.fna.bz2\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.md5\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.pkl\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.rev.1.bt2\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.rev.2.bt2\n    touch metaphlan_db_latest/mpa_v31_CHOCOPhlAn_201901.tar\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metaphlan: \\$(metaphlan --version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MetaPhlAn is a tool for profiling the composition of microbial communities from metagenomic shotgun sequencing data.\nTags: metagenomics, classification, fastq, fasta, sam", "answer": "process METAPHLAN_METAPHLAN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/metaphlan:4.0.6--pyhca03a8a_0' :\n        'biocontainers/metaphlan:4.0.6--pyhca03a8a_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path metaphlan_db_latest\n\n    output:\n    tuple val(meta), path(\"*_profile.txt\")   ,                emit: profile\n    tuple val(meta), path(\"*.biom\")          ,                emit: biom\n    tuple val(meta), path('*.bowtie2out.txt'), optional:true, emit: bt2out\n    path \"versions.yml\"                      ,                emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_type = \"$input\" =~ /.*\\.(fastq|fq)/ ? \"--input_type fastq\" : \"$input\" =~ /.*\\.(fasta|fna|fa)/ ? \"--input_type fasta\" : \"$input\".endsWith(\".bowtie2out.txt\") ? \"--input_type bowtie2out\" : \"--input_type sam\"\n    def input_data  = (\"$input_type\".contains(\"fastq\")) && !meta.single_end ? \"${input[0]},${input[1]}\" : \"$input\"\n    def bowtie2_out = \"$input_type\" == \"--input_type bowtie2out\" || \"$input_type\" == \"--input_type sam\" ? '' : \"--bowtie2out ${prefix}.bowtie2out.txt\"\n\n    \"\"\"\n    BT2_DB=`find -L \"${metaphlan_db_latest}\" -name \"*rev.1.bt2*\" -exec dirname {} \\\\;`\n    BT2_DB_INDEX=`find -L ${metaphlan_db_latest} -name \"*.rev.1.bt2*\" | sed 's/\\\\.rev.1.bt2.*\\$//' | sed 's/.*\\\\///'`\n\n    metaphlan \\\\\n        --nproc $task.cpus \\\\\n        $input_type \\\\\n        $input_data \\\\\n        $args \\\\\n        $bowtie2_out \\\\\n        --bowtie2db \\$BT2_DB \\\\\n        --index \\$BT2_DB_INDEX \\\\\n        --biom ${prefix}.biom \\\\\n        --output_file ${prefix}_profile.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        metaphlan: \\$(metaphlan --version 2>&1 | awk '{print \\$3}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Serogrouping Listeria monocytogenes assemblies\nTags: fasta, Listeria monocytogenes, serogroup", "answer": "process LISSERO {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lissero:0.4.9--py_0' :\n        'biocontainers/lissero:0.4.9--py_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    lissero \\\\\n        $args \\\\\n        $fasta \\\\\n        > ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lissero: \\$( echo \\$(lissero --version 2>&1) | sed 's/^.*LisSero //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collapses identical sequences in a FASTQ/A file into a single sequence (while maintaining reads counts)\nTags: collapse, genomics, fasta, fastq", "answer": "process FASTX_COLLAPSER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fastx_toolkit:0.0.14--hdbdd923_11':\n        'biocontainers/fastx_toolkit:0.0.14--hdbdd923_11' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"${prefix}.fasta\"), emit: fasta\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    fastx_collapser \\\\\n        $args \\\\\n        -i $fastx \\\\\n        -o ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastx:  \\$(echo \\$(fastx_collapser -h) | sed -nE 's/.*([0-9]+\\\\.[0-9]+\\\\.[0-9]+).*/\\\\1/p' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastx:  \\$(echo \\$(fastx_collapser -h) | sed -nE 's/.*([0-9]+\\\\.[0-9]+\\\\.[0-9]+).*/\\\\1/p' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Multiple sequence alignment using MAFFT\nTags: fasta, msa, multiple sequence alignment", "answer": "process MAFFT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-12eba4a074f913c639117640936668f5a6a01da6:425707898cf4f85051b77848be253b88f1d2298a-0':\n        'biocontainers/mulled-v2-12eba4a074f913c639117640936668f5a6a01da6:425707898cf4f85051b77848be253b88f1d2298a-0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(add)\n    tuple val(meta3), path(addfragments)\n    tuple val(meta4), path(addfull)\n    tuple val(meta5), path(addprofile)\n    tuple val(meta6), path(addlong)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"*.fas{.gz,}\"), emit: fas\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args         = task.ext.args   ?: ''\n    def prefix       = task.ext.prefix ?: \"${meta.id}\"\n    def add          = add             ? \"--add <(unpigz -cdf ${add})\"                   : ''\n    def addfragments = addfragments    ? \"--addfragments <(unpigz -cdf ${addfragments})\" : ''\n    def addfull      = addfull         ? \"--addfull <(unpigz -cdf ${addfull})\"           : ''\n    def addprofile   = addprofile      ? \"--addprofile <(unpigz -cdf ${addprofile})\"     : ''\n    def addlong      = addlong         ? \"--addlong <(unpigz -cdf ${addlong})\"           : ''\n    def write_output = compress ? \" | pigz -cp ${task.cpus} > ${prefix}.fas.gz\" : \"> ${prefix}.fas\"\n    // this will not preserve MAFFTs return value, but mafft crashes when it receives a process substitution\n    if (\"$fasta\" == \"${prefix}.fas\" ) error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    mafft \\\\\n        --thread ${task.cpus} \\\\\n        ${add} \\\\\n        ${addfragments} \\\\\n        ${addfull} \\\\\n        ${addprofile} \\\\\n        ${addlong} \\\\\n        ${args} \\\\\n        ${fasta} \\\\\n        ${write_output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mafft: \\$(mafft --version 2>&1 | sed 's/^v//' | sed 's/ (.*)//')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args         = task.ext.args   ?: ''\n    def prefix       = task.ext.prefix ?: \"${meta.id}\"\n    def add          = add             ? \"--add ${add}\"                   : ''\n    def addfragments = addfragments    ? \"--addfragments ${addfragments}\" : ''\n    def addfull      = addfull         ? \"--addfull ${addfull}\"           : ''\n    def addprofile   = addprofile      ? \"--addprofile ${addprofile}\"     : ''\n    def addlong      = addlong         ? \"--addlong ${addlong}\"           : ''\n    if (\"$fasta\" == \"${prefix}.fas\" )  error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.fas${compress ? '.gz' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mafft: \\$(mafft --version 2>&1 | sed 's/^v//' | sed 's/ (.*)//')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Demultiplexing cell nucleus hashing data, using the estimated antibody background probability.\nTags: demultiplexing, hashing-based deconvoltion, single-cell", "answer": "process DEMUXEM {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/demuxem:0.1.7.post1--pyhdfd78af_0' :\n        'biocontainers/demuxem:0.1.7.post1--pyhdfd78af_0' }\"\n    input:\n    tuple val(meta), path(input_raw_gene_bc_matrices_h5), path(input_hto_csv_file)\n    val output_name\n    val generate_gender_plot\n    val genome\n    val generate_diagnostic_plots\n    output:\n    tuple val(meta), path(\"*_demux.zarr.zip\"), emit: zarr\n    tuple val(meta), path(\"*.out.demuxEM.zarr.zip\"), emit: out_zarr\n    path \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args               = task.ext.args ?: ''\n    def prefix             = task.ext.prefix ?: \"${meta.id}\"\n    def generateGenderPlot = generate_gender_plot ? \"--generate-gender-plot $generate_gender_plot\" : \"\"\n    def genome_file        = genome ? \"--genome $genome\" : \"\"\n    def diagnostic_plots   = generate_diagnostic_plots ? \"--generate-diagnostic-plots $generate_diagnostic_plots\" : \"\"\n    \"\"\"\n    demuxEM $input_raw_gene_bc_matrices_h5 \\\\\n    $input_hto_csv_file $output_name \\\\\n    $args \\\\\n    $generateGenderPlot\\\\\n    $genome_file\\\\\n    $diagnostic_plots\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":g\n    echo \\$(demuxEM --version  2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.out.demuxEM.zarr.zip\n    touch ${prefix}_demux.zarr.zip\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        echo \\$(demuxEM --version  2>&1)\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Runs iCount peaks on a BED file of crosslinks\nTags: iCLIP, bed, genomics", "answer": "process ICOUNTMINI_PEAKS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/icount-mini:2.0.3--pyh5e36f6f_0':\n        'biocontainers/icount-mini:2.0.3--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(bed), path(sigxls)\n\n    output:\n    tuple val(meta), path(\"*.peaks.bed.gz\"), emit: peaks\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    iCount-Mini peaks \\\\\n        $bed \\\\\n        $sigxls \\\\\n        ${prefix}.peaks.bed.gz \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.peaks.bed.gz\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Runs iCount sigxls on a BED file of crosslinks\nTags: CLIP, iCLIP, bed, genomics", "answer": "process ICOUNTMINI_SIGXLS {\n    tag \"$meta.id\"\n    label \"process_low\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/icount-mini:2.0.3--pyh5e36f6f_0' :\n        'biocontainers/icount-mini:2.0.3--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path segmentation\n\n    output:\n    tuple val(meta), path(\"*.sigxls.bed.gz\"), emit: sigxls\n    tuple val(meta), path(\"*.scores.tsv\")   , emit: scores\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    iCount-Mini sigxls \\\\\n        $segmentation \\\\\n        $bed \\\\\n        ${prefix}.sigxls.bed.gz \\\\\n        --scores ${prefix}.scores.tsv \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.sigxls.bed.gz\n    touch ${prefix}.scores.tsv\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Plot a metagene of cross-link events/sites around various transcriptomic landmarks.\nTags: iCLIP, gtf, genomics", "answer": "process ICOUNTMINI_METAGENE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/icount-mini:3.0.1--pyh7cba7a3_0':\n        'biocontainers/icount-mini:3.0.1--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path segmentation\n\n    output:\n    tuple val(meta), path(\"metagene_*/*plot_data.tsv\"), emit: tsv\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    mv $bed ${prefix}.bed\n\n    iCount-Mini metagene \\\\\n        ${prefix}.bed \\\\\n        $segmentation \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch metagene_${prefix}/${prefix}_plot_data.tsv\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Formats a GTF file for use with iCount sigxls\nTags: iCLIP, gtf, genomics", "answer": "process ICOUNTMINI_SEGMENT {\n    tag \"$gtf\"\n    label \"process_single\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/icount-mini:2.0.3--pyh5e36f6f_0' :\n        'biocontainers/icount-mini:2.0.3--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(gtf)\n    path fai\n\n    output:\n    tuple val(meta), path(\"*_seg.gtf\")         ,  emit: gtf\n    tuple val(meta), path(\"*_regions.gtf.gz\")  ,  emit: regions\n    path \"versions.yml\"                        ,  emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${gtf.simpleName}_seg\"\n    def regions_prefix = task.ext.regions_prefix ?: \"${gtf.simpleName}\"\n    \"\"\"\n    iCount-Mini segment \\\\\n        $gtf \\\\\n        ${prefix}.gtf \\\\\n        $fai\n\n    mv regions.gtf.gz ${regions_prefix}_regions.gtf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Report proportion of cross-link events/sites on each region type.\nTags: iCLIP, gtf, genomics", "answer": "process ICOUNTMINI_SUMMARY {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/icount-mini:2.0.3--pyh5e36f6f_0':\n        'biocontainers/icount-mini:2.0.3--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    path segmentation\n\n    output:\n    tuple val(meta), path(\"*summary_type.tsv\")   , emit: summary_type\n    tuple val(meta), path(\"*summary_subtype.tsv\"), emit: summary_subtype\n    tuple val(meta), path(\"*summary_gene.tsv\")   , emit: summary_gene\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    iCount-Mini summary \\\\\n        $segmentation \\\\\n        $bed \\\\\n        . \\\\\n        $args\n\n    mv summary_type.tsv ${prefix}.summary_type.tsv\n    mv summary_subtype.tsv ${prefix}.summary_subtype.tsv\n    mv summary_gene.tsv ${prefix}.summary_gene.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.summary_type.tsv\n    touch ${prefix}.summary_subtype.tsv\n    touch ${prefix}.summary_gene.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iCount-Mini: \\$(iCount-Mini -v)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate confidence scores from Kraken2 output\nTags: classify, metagenomics, kraken2, confidence", "answer": "process CONIFER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/conifer%3A1.0.2--he4a0461_0':\n        'biocontainers/conifer:1.0.2--he4a0461_0' }\"\n\n    input:\n    tuple val(meta), path(kraken_result)\n    path kraken_taxon_db\n\n    output:\n    tuple val(meta), path(\"*.score\"), emit: score\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    conifer \\\\\n        $args \\\\\n        --input $kraken_result \\\\\n        --db $kraken_taxon_db > ${prefix}.score\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        conifer: \\$(echo \\$(conifer --version 2>&1) | sed 's/^.*Conifer //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.score\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        conifer: \\$(echo \\$(conifer --version 2>&1) | sed 's/^.*Conifer //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: The VCFeval tool of RTG tools. It is used to evaluate called variants for agreement with a baseline variant set\nTags: benchmarking, vcf, rtg-tools", "answer": "process RTGTOOLS_VCFEVAL {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rtg-tools:3.12.1--hdfd78af_0':\n        'biocontainers/rtg-tools:3.12.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(query_vcf), path(query_vcf_tbi), path(truth_vcf), path(truth_vcf_tbi), path(truth_bed), path(evaluation_bed)\n    tuple val(meta2), path(sdf)\n\n    output:\n    tuple val(meta), path(\"*.tp.vcf.gz\")                , emit: tp_vcf\n    tuple val(meta), path(\"*.tp.vcf.gz.tbi\")            , emit: tp_tbi\n    tuple val(meta), path(\"*.fn.vcf.gz\")                , emit: fn_vcf\n    tuple val(meta), path(\"*.fn.vcf.gz.tbi\")            , emit: fn_tbi\n    tuple val(meta), path(\"*.fp.vcf.gz\")                , emit: fp_vcf\n    tuple val(meta), path(\"*.fp.vcf.gz.tbi\")            , emit: fp_tbi\n    tuple val(meta), path(\"*.tp-baseline.vcf.gz\")       , emit: baseline_vcf\n    tuple val(meta), path(\"*.tp-baseline.vcf.gz.tbi\")   , emit: baseline_tbi\n    tuple val(meta), path(\"*.snp_roc.tsv.gz\")           , emit: snp_roc\n    tuple val(meta), path(\"*.non_snp_roc.tsv.gz\")       , emit: non_snp_roc\n    tuple val(meta), path(\"*.weighted_roc.tsv.gz\")      , emit: weighted_roc\n    tuple val(meta), path(\"*.summary.txt\")              , emit: summary\n    tuple val(meta), path(\"*.phasing.txt\")              , emit: phasing\n    path \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bed_regions = truth_bed ? \"--bed-regions=${truth_bed}\" : \"\"\n    def eval_regions = evaluation_bed ? \"--evaluation-regions=${evaluation_bed}\" : \"\"\n    def truth_index = truth_vcf_tbi ? \"\" : \"rtg index ${truth_vcf}\"\n    def query_index = query_vcf_tbi ? \"\" : \"rtg index ${query_vcf}\"\n    def avail_mem = task.memory.toGiga() + \"G\"\n\n    \"\"\"\n    ${truth_index}\n    ${query_index}\n\n    rtg RTG_MEM=$avail_mem vcfeval \\\\\n        ${args} \\\\\n        --baseline=${truth_vcf} \\\\\n        ${bed_regions} \\\\\n        ${eval_regions} \\\\\n        --calls=${query_vcf} \\\\\n        --output=output \\\\\n        --template=${sdf} \\\\\n        --threads=${task.cpus}\n\n    cd output/\n    mv done progress ..\n    for f in * ; do mv \"\\$f\" \"../${prefix}.\\$f\" ; done\n    cd ..\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rtg-tools: \\$(echo \\$(rtg version | head -n 1 | awk '{print \\$4}'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.tp.vcf.gz\n    touch ${prefix}.tp.vcf.gz.tbi\n    touch ${prefix}.fn.vcf.gz\n    touch ${prefix}.fn.vcf.gz.tbi\n    touch ${prefix}.fp.vcf.gz\n    touch ${prefix}.fp.vcf.gz.tbi\n    touch ${prefix}.tp-baseline.vcf.gz\n    touch ${prefix}.tp-baseline.vcf.gz.tbi\n    touch ${prefix}.snp_roc.tsv.gz\n    touch ${prefix}.non_snp_roc.tsv.gz\n    touch ${prefix}.weighted_roc.tsv.gz\n    touch ${prefix}.summary.txt\n    touch ${prefix}.phasing.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rtg-tools: \\$(echo \\$(rtg version | head -n 1 | awk '{print \\$4}'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts a PED file to VCF headers\nTags: rtgtools, pedfilter, vcf, ped", "answer": "process RTGTOOLS_PEDFILTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rtg-tools:3.12.1--hdfd78af_0':\n        'biocontainers/rtg-tools:3.12.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.{vcf.gz,ped}\") , emit: output\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = args.contains(\"--vcf\") ? \"vcf.gz\" : \"ped\"\n\n    if( \"${prefix}.${extension}\" == \"${input}\" ) {\n        error \"The input and output file have the same name, please use another ext.prefix.\"\n    }\n\n    def postprocess = extension == \"vcf.gz\" ? \"| rtg bgzip ${args2} -\" : \"\"\n\n    \"\"\"\n    rtg pedfilter \\\\\n        ${args} \\\\\n        ${input} \\\\\n    ${postprocess} > ${prefix}.${extension}\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rtgtools: \\$(echo \\$(rtg version | head -n 1 | awk '{print \\$4}'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def extension = args.contains(\"--vcf\") ? \"vcf.gz\" : \"ped\"\n\n    if( \"${prefix}.${extension}\" == \"${input}\" ) {\n        error \"The input and output file have the same name, please use another ext.prefix.\"\n    }\n\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rtgtools: \\$(echo \\$(rtg version | head -n 1 | awk '{print \\$4}'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts the contents of sequence data files (FASTA/FASTQ/SAM/BAM) into the RTG Sequence Data File (SDF) format.\nTags: rtg, fasta, fastq, bam, sam", "answer": "process RTGTOOLS_FORMAT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rtg-tools:3.12.1--hdfd78af_0':\n        'biocontainers/rtg-tools:3.12.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input1), path(input2), path(sam_rg)\n\n    output:\n    tuple val(meta), path(\"*.sdf\"), emit: sdf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def single = meta.containsKey(\"single_end\") ? meta.single_end : true\n\n    def input = single ? \"${input1}\" : \"--left ${input1} --right ${input2}\"\n    def rg = sam_rg ? \"--sam-rg ${sam_rg}\" : \"\"\n\n    def avail_mem = \"3G\"\n    if (!task.memory) {\n        log.info '[RTG format] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue() + \"M\"\n    }\n\n    \"\"\"\n    rtg RTG_MEM=${avail_mem} format \\\\\n        ${args} \\\\\n        ${rg} \\\\\n        --output ${prefix}.sdf \\\\\n        ${input}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rtg-tools: \\$(echo \\$(rtg version | head -n 1 | awk '{print \\$4}'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = \"3G\"\n    if (!task.memory) {\n        log.info '[RTG format] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue() + \"M\"\n    }\n    \"\"\"\n    touch ${prefix}.sdf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rtg-tools: \\$(echo \\$(rtg version | head -n 1 | awk '{print \\$4}'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Plot ROC curves from vcfeval ROC data files, either to an image, or an interactive GUI. The interactive GUI isn't possible for nextflow.\nTags: rtgtools, rocplot, validation, vcf", "answer": "process RTGTOOLS_ROCPLOT {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rtg-tools:3.12.1--hdfd78af_0':\n        'biocontainers/rtg-tools:3.12.1--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.png\"), emit: png\n    tuple val(meta), path(\"*.svg\"), emit: svg\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def avail_mem = task.memory.toGiga() + \"G\"\n    \"\"\"\n    rtg RTG_MEM=${avail_mem} rocplot \\\\\n        ${args} \\\\\n        --png ${prefix}.png \\\\\n        --svg ${prefix}.svg \\\\\n        ${input}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rtg-tools: \\$(echo \\$(rtg version | head -n 1 | awk '{print \\$4}'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.png\n    touch ${prefix}.svg\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rtg-tools: \\$(echo \\$(rtg version | head -n 1 | awk '{print \\$4}'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Group reads based on their UMI and mapping coordinates\nTags: umitools, umi, deduplication, dedup, clustering", "answer": "process UMITOOLS_GROUP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/umi_tools:1.1.5--py39hf95cd2a_0' :\n        'biocontainers/umi_tools:1.1.5--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    val create_bam\n    val get_group_info\n\n    output:\n    tuple val(meta), path(\"*.log\")        , emit: log\n    tuple val(meta), path(\"${prefix}.bam\"), optional: true, emit: bam\n    tuple val(meta), path(\"*.tsv\")        , optional: true, emit: tsv\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args    = task.ext.args   ?: ''\n    prefix      = task.ext.prefix ?: \"${meta.id}\"\n    def paired  = meta.single_end ? \"\" : \"--paired\"\n    output_bam  = create_bam      ? \"--output-bam -S ${prefix}.bam\" : \"\"\n    group_info  = get_group_info  ? \"--group-out ${prefix}.tsv\"     : \"\"\n\n    if (create_bam && \"$bam\" == \"${prefix}.bam\") { error \"Input and output names are the same, set prefix in module configuration to disambiguate!\" }\n\n    if (!(args ==~ /.*--random-seed.*/)) {args += \" --random-seed=100\"}\n    \"\"\"\n    PYTHONHASHSEED=0 umi_tools \\\\\n        group \\\\\n        -I $bam \\\\\n        $output_bam \\\\\n        -L ${prefix}.log \\\\\n        $group_info \\\\\n        $paired \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix}.log\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Make the output from umi_tools dedup or group compatible with RSEM\nTags: umitools, rsem, salmon, dedup", "answer": "process UMITOOLS_PREPAREFORRSEM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/umi_tools:1.1.5--py39hf95cd2a_0' :\n        'biocontainers/umi_tools:1.1.5--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n\n    output:\n    tuple val(meta), path('*.bam'), emit: bam\n    tuple val(meta), path('*.log'), emit: log\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    umi_tools prepare-for-rsem \\\\\n        --stdin=$bam \\\\\n        --stdout=${prefix}.bam \\\\\n        --log=${prefix}.prepare_for_rsem.log \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${meta.id}.bam\n    touch ${meta.id}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Extracts UMI barcode from a read and add it to the read name, leaving any sample barcode in place\nTags: UMI, barcode, extract, umitools", "answer": "process UMITOOLS_EXTRACT {\n    tag \"$meta.id\"\n    label \"process_single\"\n    label \"process_long\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/umi_tools:1.1.5--py39hf95cd2a_0' :\n        'biocontainers/umi_tools:1.1.5--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: reads\n    tuple val(meta), path(\"*.log\")     , emit: log\n    path  \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.single_end) {\n        \"\"\"\n        umi_tools \\\\\n            extract \\\\\n            -I $reads \\\\\n            -S ${prefix}.umi_extract.fastq.gz \\\\\n            $args \\\\\n            > ${prefix}.umi_extract.log\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n        END_VERSIONS\n        \"\"\"\n    }  else {\n        \"\"\"\n        umi_tools \\\\\n            extract \\\\\n            -I ${reads[0]} \\\\\n            --read2-in=${reads[1]} \\\\\n            -S ${prefix}.umi_extract_1.fastq.gz \\\\\n            --read2-out=${prefix}.umi_extract_2.fastq.gz \\\\\n            $args \\\\\n            > ${prefix}.umi_extract.log\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.single_end) {\n        output_command = \"echo '' | gzip > ${prefix}.umi_extract.fastq.gz\"\n    } else {\n        output_command = \"echo '' | gzip > ${prefix}.umi_extract_1.fastq.gz ;\"\n        output_command += \"echo '' | gzip > ${prefix}.umi_extract_2.fastq.gz\"\n    }\n    \"\"\"\n    touch ${prefix}.umi_extract.log\n    ${output_command}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Deduplicate reads based on the mapping co-ordinate and the UMI attached to the read.\nTags: umitools, deduplication, dedup", "answer": "process UMITOOLS_DEDUP {\n    tag \"$meta.id\"\n    label \"process_medium\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/umi_tools:1.1.5--py39hf95cd2a_0' :\n        'biocontainers/umi_tools:1.1.5--py39hf95cd2a_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    val get_output_stats\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\")     , emit: bam\n    tuple val(meta), path(\"*.log\")             , emit: log\n    tuple val(meta), path(\"*edit_distance.tsv\"), optional:true, emit: tsv_edit_distance\n    tuple val(meta), path(\"*per_umi.tsv\")      , optional:true, emit: tsv_per_umi\n    tuple val(meta), path(\"*per_position.tsv\") , optional:true, emit: tsv_umi_per_position\n    path  \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def paired = meta.single_end ? \"\" : \"--paired\"\n    stats = get_output_stats ? \"--output-stats ${prefix}\" : \"\"\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n\n    if (!(args ==~ /.*--random-seed.*/)) {args += \" --random-seed=100\"}\n    \"\"\"\n    PYTHONHASHSEED=0 umi_tools \\\\\n        dedup \\\\\n        -I $bam \\\\\n        -S ${prefix}.bam \\\\\n        -L ${prefix}.log \\\\\n        $stats \\\\\n        $paired \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n    touch ${prefix}.log\n    touch ${prefix}_edit_distance.tsv\n    touch ${prefix}_per_umi.tsv\n    touch ${prefix}_per_position.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umitools: \\$( umi_tools --version | sed '/version:/!d; s/.*: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assembly summary statistics in JSON format\nTags: assembly, statistics, summary, json", "answer": "process ASSEMBLYSCAN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/assembly-scan:0.4.1--pyhdfd78af_0' :\n        'biocontainers/assembly-scan:0.4.1--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(assembly)\n\n    output:\n    tuple val(meta), path(\"*.json\"), emit: json\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    assembly-scan $assembly > ${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        assemblyscan: \\$( assembly-scan --version 2>&1 | sed 's/^.*assembly-scan //; s/Using.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Visualise metagenome redundancy curve in PNG format from a single Nonpareil npo file\nTags: metagenomics, statistics, coverage, complexity, redundancy, diversity, visualisation", "answer": "process NONPAREIL_CURVE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nonpareil:3.5.5--r43hdcf5f25_0':\n        'biocontainers/nonpareil:3.5.5--r43hdcf5f25_0' }\"\n\n    input:\n    tuple val(meta), path(npo)\n\n    output:\n    tuple val(meta), path(\"*.png\"), emit: png\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args_cmd = args != '' ? \", ${args}\" : \"\"\n    \"\"\"\n    #!/usr/bin/env Rscript\n    library(Nonpareil)\n\n    png(file='${prefix}.png')\n    Nonpareil.curve('${npo}'${args_cmd})\n    dev.off()\n\n    version_file_path <- \"versions.yml\"\n    version_nonpareil <- paste(unlist(packageVersion(\"Nonpareil\")), collapse = \".\")\n    f <- file(version_file_path, \"w\")\n    writeLines('\"${task.process}\":', f)\n    writeLines(\"    nonpareil: \", f, sep = \"\")\n    writeLines(version_nonpareil, f)\n    close(f)\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\": \\$(Rscript -e 'library('Nonpareil'); cat(paste(unlist(packageVersion(\"Nonpareil\")),collapse=\".\"))')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Visualise metagenome redundancy curves in PNG format from multiple Nonpareil npo files in a single image\nTags: metagenomics, statistics, coverage, complexity, redundancy, diversity, visualisation", "answer": "process NONPAREIL_SET {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nonpareil:3.5.5--r43hdcf5f25_0':\n        'biocontainers/nonpareil:3.5.5--r43hdcf5f25_0' }\"\n\n    input:\n    tuple val(meta), path(npos)\n\n    output:\n    tuple val(meta), path(\"*.png\"), emit: png\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args_cmd = args != '' ? \", ${args}\" : \"\"\n    \"\"\"\n    #!/usr/bin/env Rscript\n    library(Nonpareil)\n\n    png(file='${prefix}.png')\n    Nonpareil.set(list.files(pattern='*.npo')${args_cmd})\n    dev.off()\n\n    version_file_path <- \"versions.yml\"\n    version_nonpareil <- paste(unlist(packageVersion(\"Nonpareil\")), collapse = \".\")\n    f <- file(version_file_path, \"w\")\n    writeLines('\"${task.process}\":', f)\n    writeLines(\"    nonpareil: \", f, sep = \"\")\n    writeLines(version_nonpareil, f)\n    close(f)\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.png\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\": \\$(Rscript -e 'library('Nonpareil'); cat(paste(unlist(packageVersion(\"Nonpareil\")),collapse=\".\"))')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculate metagenome redundancy curve from FASTQ files\nTags: metagenomics, statistics, coverage, redundancy, diversity, complexity", "answer": "process NONPAREIL_NONPAREIL {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nonpareil:3.5.5--r43hdcf5f25_0':\n        'biocontainers/nonpareil:3.5.5--r43hdcf5f25_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    val format\n    val mode\n\n    output:\n    tuple val(meta), path(\"*.npa\"), emit: npa\n    tuple val(meta), path(\"*.npc\"), emit: npc\n    tuple val(meta), path(\"*.npl\"), emit: npl\n    tuple val(meta), path(\"*.npo\"), emit: npo\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def mem_mb = task.memory.toMega()\n    \"\"\"\n    nonpareil \\\\\n        -s $reads \\\\\n        -f $format \\\\\n        -T ${mode} \\\\\n        -t $task.cpus \\\\\n        -R ${mem_mb} \\\\\n        -b $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nonpareil: \\$(echo \\$(nonpareil -V 2>&1) | sed 's/Nonpareil v//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.npa\n    touch ${prefix}.npc\n    touch ${prefix}.npl\n    touch ${prefix}.npo\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nonpareil: \\$(echo \\$(nonpareil -V 2>&1) | sed 's/Nonpareil v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate summary reports with raw data for Nonpareil NPO curves, including MultiQC compatible JSON/TSV files\nTags: metagenomics, statistics, coverage, redundancy, diversity, complexity, multiqc", "answer": "process NONPAREIL_NONPAREILCURVESR {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nonpareil:3.5.5--r43hdcf5f25_0':\n        'biocontainers/nonpareil:3.5.5--r43hdcf5f25_0' }\"\n\n    input:\n    tuple val(meta), path(npos)\n\n    output:\n    tuple val(meta), path(\"*.json\"), emit: json, optional: true\n    tuple val(meta), path(\"*.tsv\" ), emit: tsv , optional: true\n    tuple val(meta), path(\"*.csv\" ), emit: csv , optional: true\n    tuple val(meta), path(\"*.pdf\" ), emit: pdf , optional: true\n\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    NonpareilCurves.R \\\\\n        $args \\\\\n        --json ${prefix}.json \\\\\n        --tsv ${prefix}.tsv \\\\\n        --csv ${prefix}.csv \\\\\n        --pdf ${prefix}.pdf \\\\\n        $npos\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nonpareil: \\$(echo \\$(nonpareil -V 2>&1) | sed 's/Nonpareil v//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.json\n    touch ${prefix}.tsv\n    touch ${prefix}.csv\n    touch ${prefix}.pdf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nonpareil: \\$(echo \\$(nonpareil -V 2>&1) | sed 's/Nonpareil v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Multiple Sequence Alignment using Graph Clustering\nTags: MSA, guidetree, genomics, graph", "answer": "process MAGUS_GUIDETREE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/magus-msa:0.2.0--pyhdfd78af_0':\n        'biocontainers/magus-msa:0.2.0--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.tree\"), emit: tree\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    magus \\\\\n        -np $task.cpus \\\\\n        -i $fasta \\\\\n        -o ${prefix}.tree \\\\\n        --onlyguidetree TRUE \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        MAGUS: \\$(magus --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tree\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        MAGUS: \\$(magus --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Multiple Sequence Alignment using Graph Clustering\nTags: MSA, alignment, genomics, graph", "answer": "process MAGUS_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-ae4ea1182e75371808710b6c081bef8b228c4815:10b41722a6b9471a0945fe6baeb9aff444d8eb1d-0':\n        'biocontainers/mulled-v2-ae4ea1182e75371808710b6c081bef8b228c4815:10b41722a6b9471a0945fe6baeb9aff444d8eb1d-0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(tree)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"*.aln{.gz,}\"), emit: alignment\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def loadtree = tree ? \"-t $tree\" : ''\n    def write_output = compress ? \"--overwrite -o >(pigz -cp ${task.cpus} > ${prefix}.aln.gz)\" : \"-o ${prefix}.aln\"\n    // using >() is necessary to preserve the return value,\n    // so nextflow knows to display an error when it failed\n    // using --overwrite is necessary, as the file descriptor generated by the named file will already exist\n    \"\"\"\n    magus \\\\\n        -np $task.cpus \\\\\n        -i $fasta \\\\\n        -d ./ \\\\\n        $write_output \\\\\n        $loadtree \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        MAGUS: \\$(magus --version)\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.aln${compress ? '.gz' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        MAGUS: \\$(magus --version)\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Aligns protein structures using mTM-align\nTags: alignment, MSA, genomics, structure", "answer": "\n\nprocess MTMALIGN_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-5bcf71dc66dac33d8e003c5e78043b80f5c7f269:8f0e486d46f7ab38892c1a8f78d2894a549d03b5-0':\n        'biocontainers/mulled-v2-5bcf71dc66dac33d8e003c5e78043b80f5c7f269:8f0e486d46f7ab38892c1a8f78d2894a549d03b5-0' }\"\n\n    input:\n    tuple val(meta), path(pdbs)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"${prefix}.aln${compress ? '.gz' : ''}\"), emit: alignment\n    tuple val(meta), path(\"${prefix}.pdb${compress ? '.gz' : ''}\"), emit: structure\n    path \"versions.yml\"                                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    // mTMalign is not capable of writing to stdout\n    // if -o /dev/stdout is specified, the output file will be polluted with debug messages emitted by mTMalign\n    \"\"\"\n    # decompress input files if required\n    if ls ./*.pdb.gz 2&> /dev/null; then # check if any files are compressed; calling unpigz with an empty arg will cause it to panic\n        unpigz -d ./*.pdb.gz\n    fi\n\n    # construct input file for mtmalign\n    ls *.pdb | sed s/\\\\ /\\\\n/ > input_list.txt\n\n    mtm-align -i input_list.txt -o ${prefix}.pdb\n    # -o does not affect the fasta naming, so move it to the new name\n    mv ./mTM_result/result.fasta ./mTM_result/${prefix}.aln\n    # Remove \".pdb\" from the ids in the alignment file\n    sed -i 's/\\\\.pdb//g' ./mTM_result/${prefix}.aln\n\n    # compress both output files\n    if ${compress}; then\n        pigz -p ${task.cpus} ./mTM_result/${prefix}.aln ./mTM_result/${prefix}.pdb\n    fi\n\n    # move everything in mTM_result to the working directory\n    mv ./mTM_result/* .\n\n    # mtm-align -v prints the wrong version 20180725, so extract it from the cosmetic output in the help message\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mTM-align: \\$( mtm-align -h | grep -e \"\\\\(Version [[:digit:]]*\\\\)\" | grep -oe \"[[:digit:]]*\" )\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.aln${compress ? '.gz' : ''}\n    touch ${prefix}.pdb${compress ? '.gz' : ''}\n\n    # mtm-align -v prints the wrong version 20180725, so extract it from the cosmetic output in the help message\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        mTM-align: \\$( mtm-align -h | grep -e \"\\\\(Version [[:digit:]]*\\\\)\" | grep -oe \"[[:digit:]]*\" )\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Identify insertion sites positions in bacterial genomes\nTags: fastq, insertion sequences", "answer": "process ISMAPPER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ismapper:2.0.2--pyhdfd78af_1' :\n        'biocontainers/ismapper:2.0.2--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(reads), path(reference), path(query)\n\n    output:\n    tuple val(meta), path(\"results/*\"), emit: results\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ismap \\\\\n        $args \\\\\n        --t $task.cpus \\\\\n        --output_dir results \\\\\n        --queries $query \\\\\n        --reference $reference \\\\\n        --reads $reads\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ismapper: \\$( echo \\$( ismap --version 2>&1 ) | sed 's/^.*ismap //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Predict recomination events in bacterial genomes\nTags: fasta, multiple sequence alignment, recombination", "answer": "process CLONALFRAMEML {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/clonalframeml:1.12--h7d875b9_1' :\n        'biocontainers/clonalframeml:1.12--h7d875b9_1' }\"\n\n    input:\n    tuple val(meta), path(newick), path(msa)\n\n    output:\n    tuple val(meta), path(\"*.emsim.txt\")                   , emit: emsim, optional: true\n    tuple val(meta), path(\"*.em.txt\")                      , emit: em\n    tuple val(meta), path(\"*.importation_status.txt\")      , emit: status\n    tuple val(meta), path(\"*.labelled_tree.newick\")        , emit: newick\n    tuple val(meta), path(\"*.ML_sequence.fasta\")           , emit: fasta\n    tuple val(meta), path(\"*.position_cross_reference.txt\"), emit: pos_ref\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    ClonalFrameML \\\\\n        $newick \\\\\n        <(gzip -cdf $msa) \\\\\n        $prefix \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        clonalframeml: \\$( echo \\$(ClonalFrameML -version 2>&1) | sed 's/^.*ClonalFrameML v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Install the AnnotSV annotations\nTags: annotation, download, installation, structural variants", "answer": "process ANNOTSV_INSTALLANNOTATIONS {\n    tag 'AnnotSV annotations'\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/annotsv:3.4.2--141a0ee560de1897' :\n        'community.wave.seqera.io/library/annotsv:3.4.2--010fa21247b5b64b' }\"\n\n    output:\n    path \"AnnotSV_annotations\", emit: annotations\n    path \"versions.yml\"       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    \"\"\"\n    INSTALL_annotations.sh\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        annotsv: \\$(echo \\$(AnnotSV --version | sed 's/AnnotSV //'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir AnnotSV_annotations\n    touch AnnotSV_annotations/stub_file.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        annotsv: \\$(echo \\$(AnnotSV --version | sed 's/AnnotSV //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Annotation and Ranking of Structural Variation\nTags: annotation, structural variants, vcf, bed, tsv", "answer": "process ANNOTSV_ANNOTSV {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'oras://community.wave.seqera.io/library/annotsv:3.4.2--141a0ee560de1897' :\n        'community.wave.seqera.io/library/annotsv:3.4.2--010fa21247b5b64b' }\"\n\n    input:\n    tuple val(meta), path(sv_vcf), path(sv_vcf_index), path(candidate_small_variants)\n    tuple val(meta2), path(annotations)\n    tuple val(meta3), path(candidate_genes)\n    tuple val(meta4), path(false_positive_snv)\n    tuple val(meta5), path(gene_transcripts)\n\n    output:\n    tuple val(meta), path(\"*.tsv\")              , emit: tsv\n    tuple val(meta), path(\"*.unannotated.tsv\")  , emit: unannotated_tsv, optional: true\n    tuple val(meta), path(\"*.vcf\")              , emit: vcf, optional: true\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def cand_genes = candidate_genes ? \"-candidateGenesFile ${candidate_genes}\" : \"\"\n    def small_variants = candidate_small_variants ? \"-candidateSnvIndelFiles ${candidate_small_variants}\" : \"\"\n    def fp_snv = false_positive_snv ? \"-snvIndelFiles ${false_positive_snv}\" : \"\"\n    def transcripts = gene_transcripts ? \"-txFile ${gene_transcripts}\" : \"\"\n\n    \"\"\"\n    AnnotSV \\\\\n        -annotationsDir ${annotations} \\\\\n        ${cand_genes} \\\\\n        ${small_variants} \\\\\n        ${fp_snv} \\\\\n        ${transcripts} \\\\\n        -outputFile ${prefix}.tsv \\\\\n        -SVinputFile ${sv_vcf} \\\\\n        ${args}\n\n    mv *_AnnotSV/* .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        annotsv: \\$(echo \\$(AnnotSV -help 2>&1 | head -n1 | sed 's/^AnnotSV //'))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def create_vcf = args.contains(\"-vcf 1\") ? \"touch ${prefix}.vcf\" : \"\"\n\n    \"\"\"\n    touch ${prefix}.tsv\n    touch ${prefix}.unannotated.tsv\n    ${create_vcf}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        annotsv: \\$(echo \\$(AnnotSV -help 2>&1 | head -n1 | sed 's/^AnnotSV //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Preprocess the CARD database for RGI to predict antibiotic resistance from protein or nucleotide data\nTags: bacteria, fasta, antibiotic resistance", "answer": "process RGI_CARDANNOTATION {\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rgi:6.0.3--pyha8f3691_1':\n        'biocontainers/rgi:6.0.3--pyha8f3691_1' }\"\n\n    input:\n    path(card)\n\n    output:\n    path(\"card_database_processed\") , emit: db\n    env RGI_VERSION                 , emit: tool_version\n    env DB_VERSION                  , emit: db_version\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    \"\"\"\n    rgi card_annotation \\\\\n        -i ${card}/card.json \\\\\n        $args\n\n    DB_VERSION=\\$(ls card_database_*_all.fasta | sed \"s/card_database_v\\\\([0-9].*[0-9]\\\\).*/\\\\1/\")\n\n    mkdir card_database_processed\n    mv card*.fasta card_database_processed\n    cp ${card}/* card_database_processed\n\n    RGI_VERSION=\\$(rgi main --version)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rgi: \\$(echo \\$RGI_VERSION)\n        rgi-database: \\$(echo \\$DB_VERSION)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch card.fasta\n    touch card_all.fasta\n\n    mkdir card_database_processed\n    mv card*.fasta card_database_processed\n\n    RGI_VERSION=\\$(rgi main --version)\n    DB_VERSION=stub_version\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rgi: \\$(echo \\$RGI_VERSION)\n        rgi-database: \\$(echo \\$DB_VERSION)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Predict antibiotic resistance from protein or nucleotide data\nTags: bacteria, fasta, antibiotic resistance", "answer": "process RGI_MAIN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/rgi:6.0.3--pyha8f3691_1':\n        'biocontainers/rgi:6.0.3--pyha8f3691_1' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path(card)\n    path(wildcard)\n\n    output:\n    tuple val(meta), path(\"*.json\"), emit: json\n    tuple val(meta), path(\"*.txt\") , emit: tsv\n    tuple val(meta), path(\"temp/\") , emit: tmp\n    env RGI_VERSION                , emit: tool_version\n    env DB_VERSION                 , emit: db_version\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: '' // This customizes the command: rgi load\n    def args2 = task.ext.args ?: '' // This customizes the command: rgi main\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def load_wildcard = \"\"\n\n    if (wildcard) {\n        load_wildcard = \"\"\" \\\\\n            --wildcard_annotation ${wildcard}/wildcard_database_v\\$DB_VERSION.fasta \\\\\n            --wildcard_annotation_all_models ${wildcard}/wildcard_database_v\\$DB_VERSION\\\\_all.fasta \\\\\n            --wildcard_index ${wildcard}/wildcard/index-for-model-sequences.txt \\\\\n            --amr_kmers ${wildcard}/wildcard/all_amr_61mers.txt \\\\\n            --kmer_database ${wildcard}/wildcard/61_kmer_db.json \\\\\n            --kmer_size 61\n        \"\"\"\n    }\n\n    \"\"\"\n    DB_VERSION=\\$(ls ${card}/card_database_*_all.fasta | sed \"s/${card}\\\\/card_database_v\\\\([0-9].*[0-9]\\\\).*/\\\\1/\")\n\n    rgi \\\\\n        load \\\\\n        $args \\\\\n        --card_json ${card}/card.json \\\\\n        --debug --local \\\\\n        --card_annotation ${card}/card_database_v\\$DB_VERSION.fasta \\\\\n        --card_annotation_all_models ${card}/card_database_v\\$DB_VERSION\\\\_all.fasta \\\\\n        $load_wildcard\n\n    rgi \\\\\n        main \\\\\n        $args2 \\\\\n        --num_threads $task.cpus \\\\\n        --output_file $prefix \\\\\n        --input_sequence $fasta\n\n    mkdir temp/\n    for FILE in *.xml *.fsa *.{nhr,nin,nsq} *.draft *.potentialGenes *{variant,rrna,protein,predictedGenes,overexpression,homolog}.json; do [[ -e \\$FILE ]] && mv \\$FILE temp/; done\n\n    RGI_VERSION=\\$(rgi main --version)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rgi: \\$(echo \\$RGI_VERSION)\n        rgi-database: \\$(echo \\$DB_VERSION)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir -p temp\n    touch test.json\n    touch test.txt\n\n    RGI_VERSION=\\$(rgi main --version)\n    DB_VERSION=stub_version\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        rgi: \\$(echo \\$RGI_VERSION)\n        rgi-database: \\$(echo \\$DB_VERSION)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Retrieves GEO data from the Gene Expression Omnibus (GEO)\nTags: geo, expression, microarray", "answer": "process GEOQUERY_GETGEO {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bioconductor-geoquery:2.66.0--r42hdfd78af_0' :\n        'biocontainers/bioconductor-geoquery:2.66.0--r42hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), val(querygse)\n\n    output:\n    tuple val(meta), path(\"*.rds\")            , emit: rds\n    tuple val(meta), path(\"*matrix.tsv\")      , emit: expression\n    tuple val(meta), path(\"*annotation.tsv\")  , emit: annotation\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template 'getgeo.R'\n}\n"}
{"question": "Description: Estimate genome heterozygosity, repeat content, and size from sequencing reads using a kmer-based statistical approach\nTags: genome size, genome heterozygosity, repeat content", "answer": "process GENOMESCOPE2 {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/genomescope2:2.0--py311r42hdfd78af_6':\n        'biocontainers/genomescope2:2.0--py311r42hdfd78af_6' }\"\n\n    input:\n    tuple val(meta), path(histogram)\n\n    output:\n    tuple val(meta), path(\"${prefix}_linear_plot.png\")            , emit: linear_plot_png\n    tuple val(meta), path(\"${prefix}_transformed_linear_plot.png\"), emit: transformed_linear_plot_png\n    tuple val(meta), path(\"${prefix}_log_plot.png\")               , emit: log_plot_png\n    tuple val(meta), path(\"${prefix}_transformed_log_plot.png\")   , emit: transformed_log_plot_png\n    tuple val(meta), path(\"${prefix}_model.txt\")                  , emit: model\n    tuple val(meta), path(\"${prefix}_summary.txt\")                , emit: summary\n    tuple val(meta), path(\"${prefix}_lookup_table.txt\")           , emit: lookup_table, optional: true\n    tuple val(meta), path(\"${prefix}_fitted_hist.png\")            , emit: fitted_histogram_png, optional: true\n    path \"versions.yml\"                                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    genomescope2 \\\\\n        --input $histogram \\\\\n        $args \\\\\n        --output . \\\\\n        --name_prefix $prefix\n\n    test -f \"fitted_hist.png\" && mv fitted_hist.png ${prefix}_fitted_hist.png\n    test -f \"lookup_table.txt\" && mv lookup_table.txt ${prefix}_lookup_table.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    '${task.process}':\n        genomescope2: \\$( genomescope2 -v | sed 's/GenomeScope //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_linear_plot.png\n    touch ${prefix}_transformed_linear_plot.png\n    touch ${prefix}_log_plot.png\n    touch ${prefix}_transformed_log_plot.png\n    touch ${prefix}_model.txt\n    touch ${prefix}_summary.txt\n    touch ${prefix}_fitted_hist.png\n    touch ${prefix}_lookup_table.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    '${task.process}':\n        genomescope2: \\$( genomescope2 -v | sed 's/GenomeScope //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A bioinformatics tool for working with modified bases\nTags: methylation, ont, long-read", "answer": "process MODKIT_PILEUP {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ont-modkit:0.3.0--h5c23e0d_0':\n        'biocontainers/ont-modkit:0.3.0--h5c23e0d_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(bed)\n\n    output:\n    tuple val(meta), path(\"*.bed\")     , emit: bed     , optional: true\n    tuple val(meta), path(\"*.bedgraph\"), emit: bedgraph, optional: true\n    tuple val(meta), path(\"*.log\")     , emit: log     , optional: true\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def prefix      = task.ext.prefix ?: \"${meta.id}\"\n    def reference   = fasta ? \"--ref ${fasta}\" : \"\"\n    def include_bed = bed ? \"--include-bed ${bed}\" : ''\n\n    \"\"\"\n    modkit \\\\\n        pileup \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --prefix ${prefix} \\\\\n        $reference \\\\\n        $include_bed \\\\\n        $bam \\\\\n        ${prefix}.tmp\n\n    if test -d ${prefix}.tmp; then\n        for file in ${prefix}.tmp/*; do\n            if test -f \\$file; then\n                mv \\$file \\$(basename \\$file)\n            fi\n        done\n    else\n        mv ${prefix}.tmp ${prefix}.bed\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        modkit: \\$( modkit --version | sed 's/mod_kit //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bed\n    touch ${prefix}.bedgraph\n    touch ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        modkit: \\$( modkit --version | sed 's/mod_kit //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This tool looks for low-complexity STR sequences along the reference that are later used to estimate the Dragstr model during single sample auto calibration CalibrateDragstrModel.\nTags: composestrtablefile, dragstr, gatk4", "answer": "process GATK4_COMPOSESTRTABLEFILE {\n    tag \"$fasta\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    path(fasta)\n    path(fasta_fai)\n    path(dict)\n\n    output:\n    path \"*.zip\"            , emit: str_table\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    def avail_mem = 6144\n    if (!task.memory) {\n        log.info '[GATK ComposeSTRTableFile] Available memory not known - defaulting to 6GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        ComposeSTRTableFile \\\\\n        --reference $fasta \\\\\n        --output ${fasta.baseName}.zip \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${fasta.baseName}.zip\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Combine per-sample gVCF files produced by HaplotypeCaller into a multi-sample gVCF file\nTags: gvcf, gatk4, vcf, combinegvcfs, short variant discovery", "answer": "process GATK4_COMBINEGVCFS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_idx)\n    path  fasta\n    path  fai\n    path  dict\n\n    output:\n    tuple val(meta), path(\"*.combined.g.vcf.gz\"), emit: combined_gvcf\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = vcf.collect{\"--variant $it\"}.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK COMBINEGVCFS] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CombineGVCFs \\\\\n        $input_list \\\\\n        --output ${prefix}.combined.g.vcf.gz \\\\\n        --reference ${fasta} \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Clusters structural variants based on coordinates, event type, and supporting algorithms\nTags: gatk4, structural variants, svcluster, vcf", "answer": "process GATK4_SVCLUSTER {\n    tag \"${meta.id}\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcfs), path(indices)\n    path ploidy_table\n    path fasta\n    path fasta_fai\n    path dict\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")       , emit: clustered_vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\")   , emit: clustered_vcf_index\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def input = vcfs.collect({\"--variant ${it}\"}).join(\" \")\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK SVCluster] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        SVCluster \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --ploidy-table ${ploidy_table} \\\\\n        ${input} \\\\\n        --reference ${fasta} \\\\\n        --tmp-dir . \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merge unmapped with mapped BAM files\nTags: alignment, bam, gatk4, merge, mergebamalignment", "answer": "process GATK4_MERGEBAMALIGNMENT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(aligned), path(unmapped)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(dict)\n\n    output:\n    tuple val(meta), path('*.bam'), emit: bam\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK MergeBamAlignment] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        MergeBamAlignment \\\\\n        --UNMAPPED_BAM $unmapped \\\\\n        --ALIGNED_BAM $aligned \\\\\n        --OUTPUT ${prefix}.bam \\\\\n        --REFERENCE_SEQUENCE $fasta \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Prepares bins for coverage collection.\nTags: bed, gatk4, interval, preprocessintervals", "answer": "process GATK4_PREPROCESSINTERVALS {\n    tag \"$fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(fai)\n    tuple val(meta3), path(dict)\n    tuple val(meta4), path(intervals)\n    tuple val(meta5), path(exclude_intervals)\n\n    output:\n    tuple val(meta), path(\"*.interval_list\"), emit: interval_list\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def include_command = intervals         ? \"--intervals $intervals\"                 : \"\"\n    def exclude_command = exclude_intervals ? \"--exclude-intervals $exclude_intervals\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK PreprocessIntervals] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        PreprocessIntervals \\\\\n        $include_command \\\\\n        $exclude_command \\\\\n        --reference $fasta \\\\\n        --output ${prefix}.interval_list \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.interval_list\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates an index for a feature file, e.g. VCF or BED file.\nTags: feature, gatk4, index, indexfeaturefile", "answer": "process GATK4_INDEXFEATUREFILE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(feature_file)\n\n    output:\n    tuple val(meta), path(\"*.{tbi,idx}\"), emit: index\n    path  \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK IndexFeatureFile] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        IndexFeatureFile \\\\\n        --input $feature_file \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Left align and trim variants using GATK4 LeftAlignAndTrimVariants.\nTags: gatk4, leftalignandtrimvariants, norm, normalize, vcf", "answer": "process GATK4_LEFTALIGNANDTRIMVARIANTS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(intervals)\n    path  fasta\n    path  fai\n    path  dict\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")   , emit: tbi\n    path \"versions.yml\"\t\t         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args             = task.ext.args   ?: ''\n    def prefix           = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals       ? \"--intervals $intervals\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK LeftAlignAndTrimVariants] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        LeftAlignAndTrimVariants \\\\\n        $interval_command \\\\\n        --variant $vcf \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --reference $fasta \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Filter variants\nTags: filter, gatk4, variantfiltration, vcf", "answer": "process GATK4_VARIANTFILTRATION {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")   , emit: tbi\n    path \"versions.yml\"\t\t         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK VariantFiltration] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        VariantFiltration \\\\\n        --variant $vcf \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --reference $fasta \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts an Picard IntervalList file to a BED file.\nTags: bed, conversion, gatk4, interval", "answer": "process GATK4_INTERVALLISTTOBED {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(intervals)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK IntervalListToBed] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        IntervalListToBed \\\\\n        --INPUT $intervals \\\\\n        --OUTPUT ${prefix}.bed \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculates the fraction of reads from cross-sample contamination based on summary tables from getpileupsummaries. Output to be used with filtermutectcalls.\n\nTags: gatk4, calculatecontamination, cross-samplecontamination, getpileupsummaries, filtermutectcalls", "answer": "process GATK4_CALCULATECONTAMINATION {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(pileup), path(matched)\n\n    output:\n    tuple val(meta), path('*.contamination.table'), emit: contamination\n    tuple val(meta), path('*.segmentation.table') , emit: segmentation, optional:true\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def matched_command = matched ? \"--matched-normal $matched\" : ''\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK CalculateContamination] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CalculateContamination \\\\\n        --input $pileup \\\\\n        --output ${prefix}.contamination.table \\\\\n        $matched_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.contamination.table\n    touch ${prefix}.segmentation.table\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Denoises read counts to produce denoised copy ratios\nTags: copyratios, denoisereadcounts, gatk4", "answer": "process GATK4_DENOISEREADCOUNTS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(counts)\n    tuple val(meta2), path(pon)\n\n    output:\n    tuple val(meta), path(\"*_standardizedCR.tsv\"), emit: standardized\n    tuple val(meta), path(\"*_denoisedCR.tsv\")    , emit: denoised\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK DenoiseReadCounts] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        DenoiseReadCounts \\\\\n        ${args} \\\\\n        --tmp-dir . \\\\\n        --input ${counts} \\\\\n        --count-panel-of-normals ${pon} \\\\\n        --standardized-copy-ratios ${prefix}_standardizedCR.tsv \\\\\n        --denoised-copy-ratios ${prefix}_denoisedCR.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_standardizedCR.tsv\n    touch ${prefix}_denoisedCR.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Determines the baseline contig ploidy for germline samples given counts data\nTags: copy number, counts, determinegermlinecontigploidy, gatk4", "answer": "\nprocess GATK4_DETERMINEGERMLINECONTIGPLOIDY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    //Conda is not supported at the moment: https://github.com/broadinstitute/gatk/issues/7811\n    container \"nf-core/gatk:4.5.0.0\" //Biocontainers is missing a package\n\n    input:\n    tuple val(meta), path(counts), path(bed), path(exclude_beds)\n    tuple val(meta2), path(ploidy_model)\n    path(contig_ploidy_table)\n\n    output:\n    tuple val(meta), path(\"${prefix}-calls\"), emit: calls\n    tuple val(meta), path(\"${prefix}-model\"), emit: model, optional: true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"GATK4_DETERMINEGERMLINECONTIGPLOIDY module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args          = task.ext.args       ?: ''\n    prefix            = task.ext.prefix     ?: \"${meta.id}\"\n    def intervals     = bed                 ? \"--intervals ${bed}\" : \"\"\n    def exclude       = exclude_beds        ? exclude_beds.collect(){\"--exclude-intervals $it\"}.join(\" \") : \"\"\n    def contig_ploidy = contig_ploidy_table ? \"--contig-ploidy-priors ${contig_ploidy_table}\" : \"\"\n    def model         = ploidy_model        ? \"--model ${ploidy_model}\" : \"\"\n    def input_list    = counts.collect(){\"--input $it\"}.join(\" \")\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK DetermineGermlineContigPloidy] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    export THEANO_FLAGS=\"base_compiledir=\\$PWD\"\n\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        DetermineGermlineContigPloidy \\\\\n        ${input_list} \\\\\n        --output ./ \\\\\n        --output-prefix ${prefix} \\\\\n        ${intervals} \\\\\n        ${exclude} \\\\\n        ${contig_ploidy} \\\\\n        ${model} \\\\\n        --tmp-dir . \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"GATK4_DETERMINEGERMLINECONTIGPLOIDY module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}-calls\n    touch ${prefix}-model\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Condenses homRef blocks in a single-sample GVCF\nTags: gatk4, gvcf, reblockgvcf", "answer": "process GATK4_REBLOCKGVCF {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gvcf), path(tbi), path(intervals)\n    path fasta\n    path fai\n    path dict\n    path dbsnp\n    path dbsnp_tbi\n\n    output:\n    tuple val(meta), path(\"*.rb.g.vcf.gz\"), path(\"*.tbi\")  , emit: vcf\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def dbsnp_command = dbsnp ? \"--dbsnp $dbsnp\" : \"\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK ReblockGVCF] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        ReblockGVCF \\\\\n        --variant $gvcf \\\\\n        --output ${prefix}.rb.g.vcf.gz \\\\\n        --reference $fasta \\\\\n        $dbsnp_command \\\\\n        $interval_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.rb.g.vcf.gz\n    touch ${prefix}.rb.g.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collects read counts at specified intervals. The count for each interval is calculated by counting the number of read starts that lie in the interval.\nTags: collectreadcounts, bam, cram, gatk4", "answer": "process GATK4_COLLECTREADCOUNTS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path(\"*.hdf5\"), optional: true, emit: hdf5\n    tuple val(meta), path(\"*.tsv\") , optional: true, emit: tsv\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def reference = fasta ? \"--reference $fasta\" : \"\"\n    def extension = args.contains(\"--format HDF5\") ? \"hdf5\" :\n                    args.contains(\"--format TSV\")  ? \"tsv\" :\n                    \"hdf5\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK COLLECTREADCOUNTS] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CollectReadCounts \\\\\n        --input $input \\\\\n        --intervals $intervals \\\\\n        --output ${prefix}.$extension \\\\\n        $reference \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = args.contains(\"--format HDF5\") ? \"hdf5\" :\n                    args.contains(\"--format TSV\")  ? \"tsv\" :\n                    \"hdf5\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Adds predicted functional consequence, gene overlap, and noncoding element overlap annotations to SV VCF from GATK-SV pipeline. Input files are an SV VCF, a GTF file containing primary or canonical transcripts, and a BED file containing noncoding elements. Output file is an annotated SV VCF.\nTags: annotate, gatk4, structural variants, svannotate, vcf", "answer": "process GATK4_SVANNOTATE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(bed)\n    path(fasta)\n    path(fasta_fai)\n    path(dict)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")       , emit: annotated_vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\")   , emit: index\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def intervals = bed ? \"--intervals ${bed}\" : \"\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK SVAnnotate] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        SVAnnotate \\\\\n        --variant ${vcf} \\\\\n        --output ${prefix}.vcf.gz \\\\\n        ${intervals} \\\\\n        ${reference} \\\\\n        --tmp-dir . \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges adjacent DepthEvidence records\nTags: condensedepthevidence, evidence, gatk4", "answer": "process GATK4_CONDENSEDEPTHEVIDENCE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(depth_evidence), path(depth_evidence_index)\n    path(fasta)\n    path(fasta_fai)\n    path(dict)\n\n    output:\n    tuple val(meta), path(\"*.rd.txt.gz\")    , emit: condensed_evidence\n    tuple val(meta), path(\"*.rd.txt.gz.tbi\"), emit: condensed_evidence_index\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (depth_evidence == \"${prefix}.rd.txt.gz\"){\n        error(\"File name collision - Please specify a different prefix.\")\n    }\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK CondenseDepthEvidence] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CondenseDepthEvidence \\\\\n        --depth-evidence ${depth_evidence} \\\\\n        --output ${prefix}.rd.txt.gz \\\\\n        --reference ${fasta} \\\\\n        --tmp-dir . \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calculates the allele-specific read counts for alle-specific expression analysis of RNAseq data\nTags: allele-specific, asereadcounter, gatk4, vcf", "answer": "process GATK4_ASEREADCOUNTER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta),  path(bam), path(bai), path(vcf), path(tbi)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n    path intervals\n\n    output:\n    tuple val(meta), file(\"*_ase.csv\"), emit: csv\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference_command = fasta ? \"--reference $fasta\" : \"\"\n    def dictionary_command = fasta ? \"--sequence-dictionary $dict\" : \"\"\n    def intervals_command = intervals ? \"--intervals $intervals\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK ASEReadCounter] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        ASEReadCounter \\\\\n        --output ${prefix}_ase.csv \\\\\n        --input ${bam} \\\\\n        --variant ${vcf} \\\\\n        $reference_command \\\\\n        $intervals_command \\\\\n        $dictionary_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}_ase.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filters the raw output of mutect2, can optionally use outputs of calculatecontamination and learnreadorientationmodel to improve filtering.\n\nTags: filtermutectcalls, filter, gatk4, mutect2, vcf", "answer": "process GATK4_FILTERMUTECTCALLS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_tbi), path(stats), path(orientationbias), path(segmentation), path(table), val(estimate)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")            , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\")        , emit: tbi\n    tuple val(meta), path(\"*.filteringStats.tsv\"), emit: stats\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def orientationbias_command = orientationbias ? orientationbias.collect{\"--orientation-bias-artifact-priors $it\"}.join(' ') : ''\n    def segmentation_command    = segmentation    ? segmentation.collect{\"--tumor-segmentation $it\"}.join(' ')                  : ''\n    def estimate_command        = estimate        ? \" --contamination-estimate ${estimate} \"                                    : ''\n    def table_command           = table           ? table.collect{\"--contamination-table $it\"}.join(' ')                        : ''\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK FilterMutectCalls] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        FilterMutectCalls \\\\\n        --variant $vcf \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --reference $fasta \\\\\n        $orientationbias_command \\\\\n        $segmentation_command \\\\\n        $estimate_command \\\\\n        $table_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n    touch ${prefix}.vcf.gz.filteringStats.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply a score cutoff to filter variants based on a recalibration table.\nAplyVQSR performs the second pass in a two-stage process called Variant Quality Score Recalibration (VQSR).\nSpecifically, it applies filtering to the input variants based on the recalibration table produced\nin the first step by VariantRecalibrator and a target sensitivity value.\n\nTags: gatk4, variant quality score recalibration, vcf, vqsr", "answer": "process GATK4_APPLYVQSR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_tbi), path(recal), path(recal_index), path(tranches)\n    path  fasta\n    path  fai\n    path  dict\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")   , emit: tbi\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference_command = fasta ? \"--reference $fasta\" : ''\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK ApplyVQSR] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        ApplyVQSR \\\\\n        --variant ${vcf} \\\\\n        --output ${prefix}.vcf.gz \\\\\n        $reference_command \\\\\n        --tranches-file $tranches \\\\\n        --recal-file $recal \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts FastQ file to SAM/BAM format\nTags: bam, convert, fastq, gatk4", "answer": "process GATK4_FASTQTOSAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reads_command = meta.single_end ? \"--FASTQ $reads\" : \"--FASTQ ${reads[0]} --FASTQ2 ${reads[1]}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK FastqToSam] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        FastqToSam \\\\\n        $reads_command \\\\\n        --OUTPUT ${prefix}.bam \\\\\n        --SAMPLE_NAME $prefix \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Filters intervals based on annotations and/or count statistics.\nTags: filterintervals, gatk4, interval_list", "answer": "process GATK4_FILTERINTERVALS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(intervals)\n    tuple val(meta2), path(read_counts)\n    tuple val(meta3), path(annotated_intervals)\n\n    output:\n    tuple val(meta), path(\"*.interval_list\"), emit: interval_list\n    path  \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def annotated_command   = annotated_intervals ? \"--annotated-intervals $annotated_intervals\" : \"\"\n    def read_counts_command = read_counts ? read_counts.collect{\"--input $it\"}.join(\" \") : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK FilterIntervals] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        FilterIntervals \\\\\n        $annotated_command \\\\\n        $read_counts_command \\\\\n        --intervals $intervals \\\\\n        --output ${prefix}.interval_list \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.interval_list\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Gathers paired-end and split read evidence files for use in the GATK-SV pipeline. Output files are a file containing the location of and orientation of read pairs marked as discordant, and a file containing the clipping location of all soft clipped reads and the orientation of the clipping.\nTags: gatk4, collectsvevidence, structural variants, metrics", "answer": "process GATK4_COLLECTSVEVIDENCE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(site_depth_vcf), path(site_depth_vcf_tbi)\n    path fasta\n    path fasta_fai\n    path dict\n\n    output:\n    tuple val(meta), path(\"*.sr.txt.gz\")    , emit: split_read_evidence\n    tuple val(meta), path(\"*.sr.txt.gz.tbi\"), emit: split_read_evidence_index\n    tuple val(meta), path(\"*.pe.txt.gz\")    , emit: paired_end_evidence\n    tuple val(meta), path(\"*.pe.txt.gz.tbi\"), emit: paired_end_evidence_index\n    tuple val(meta), path(\"*.sd.txt.gz\")    , emit: site_depths, optional:true\n    tuple val(meta), path(\"*.sd.txt.gz.tbi\"), emit: site_depths_index, optional:true\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def sd_vcf = site_depth_vcf ? \"--sd-file ${prefix}.sd.txt.gz --site-depth-locs-vcf ${site_depth_vcf}\" : \"\"\n    def reference  = fasta ? \"--reference ${fasta}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK COLLECTSVEVIDENCE] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CollectSVEvidence \\\\\n        ${args} \\\\\n        --input ${input} \\\\\n        --sr-file ${prefix}.sr.txt.gz \\\\\n        --pe-file ${prefix}.pe.txt.gz \\\\\n        ${sd_vcf} \\\\\n        ${reference} \\\\\n        --tmp-dir . \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: estimates the parameters for the DRAGstr model\nTags: gatk4, bam, cram, sam, calibratedragstrmodel", "answer": "process GATK4_CALIBRATEDRAGSTRMODEL {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bam_index)\n    path  fasta\n    path  fasta_fai\n    path  dict\n    path  strtablefile\n\n    output:\n    tuple val(meta), path(\"*.txt\")   , emit: dragstr_model\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK CalibrateDragstrModel] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CalibrateDragstrModel \\\\\n        --input ${bam} \\\\\n        --output ${prefix}.txt \\\\\n        --reference ${fasta} \\\\\n        --str-table-path ${strtablefile} \\\\\n        --threads ${task.cpus} \\\\\n        --tmp-dir . \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: merge GVCFs from multiple samples. For use in joint genotyping or somatic panel of normal creation.\nTags: gatk4, genomicsdb, genomicsdbimport, jointgenotyping, panelofnormalscreation", "answer": "process GATK4_GENOMICSDBIMPORT {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(interval_file), val(interval_value), path(wspace)\n    val   run_intlist\n    val   run_updatewspace\n    val   input_map\n\n    output:\n    tuple val(meta), path(\"$prefix\")        , optional:true, emit: genomicsdb\n    tuple val(meta), path(\"$updated_db\")    , optional:true, emit: updatedb\n    tuple val(meta), path(\"*.interval_list\"), optional:true, emit: intervallist\n    path \"versions.yml\"                                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n\n    // settings for running default create gendb mode\n    input_command = input_map ? \"--sample-name-map ${vcf[0]}\" : vcf.collect(){\"--variant $it\"}.join(' ')\n\n    genomicsdb_command = \"--genomicsdb-workspace-path ${prefix}\"\n    interval_command = interval_file ? \"--intervals ${interval_file}\" : \"--intervals ${interval_value}\"\n    updated_db = \"\"\n\n    // settings changed for running get intervals list mode if run_intlist is true\n    if (run_intlist) {\n        genomicsdb_command = \"--genomicsdb-update-workspace-path ${wspace}\"\n        interval_command = \"--output-interval-list-to-file ${prefix}.interval_list\"\n    }\n\n    // settings changed for running update gendb mode. input_command same as default, update_db forces module to emit the updated gendb\n    if (run_updatewspace) {\n        genomicsdb_command = \"--genomicsdb-update-workspace-path ${wspace}\"\n        interval_command = ''\n        updated_db = \"${wspace}\"\n    }\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK GenomicsDBImport] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        GenomicsDBImport \\\\\n        $input_command \\\\\n        $genomicsdb_command \\\\\n        $interval_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n\n    genomicsdb_command = \"--genomicsdb-workspace-path ${prefix}\"\n    interval_command = interval_file ? \"--intervals ${interval_file}\" : \"--intervals ${interval_value}\"\n    updated_db = \"\"\n\n    // settings changed for running get intervals list mode if run_intlist is true\n    if (run_intlist) {\n        genomicsdb_command = \"--genomicsdb-update-workspace-path ${wspace}\"\n        interval_command = \"--output-interval-list-to-file ${prefix}.interval_list\"\n    }\n\n    // settings changed for running update gendb mode. input_command same as default, update_db forces module to emit the updated gendb\n    if (run_updatewspace) {\n        genomicsdb_command = \"--genomicsdb-update-workspace-path ${wspace}\"\n        interval_command = ''\n        updated_db = \"${wspace}\"\n    }\n\n    def stub_genomicsdb = genomicsdb_command == \"--genomicsdb-workspace-path ${prefix}\" ? \"touch ${prefix}\" : \"\"\n    def stub_interval   = interval_command == \"--output-interval-list-to-file ${prefix}.interval_list\" ? \"touch ${prefix}.interval_list\" : \"\"\n    def stub_update     = updated_db != \"\" ? \"touch ${wspace}\" : \"\"\n\n    \"\"\"\n    ${stub_genomicsdb}\n    ${stub_interval}\n    ${stub_update}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Uses f1r2 counts collected during mutect2 to Learn the prior probability of read orientation artifacts\n\nTags: gatk4, learnreadorientationmodel, mutect2, readorientationartifacts", "answer": "process GATK4_LEARNREADORIENTATIONMODEL {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(f1r2)\n\n    output:\n    tuple val(meta), path(\"*.tar.gz\"), emit: artifactprior\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = f1r2.collect{\"--input $it\"}.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK LearnReadOrientationModel] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        LearnReadOrientationModel \\\\\n        $input_list \\\\\n        --output ${prefix}.tar.gz \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split intervals into sub-interval files.\nTags: bed, gatk4, interval, splitintervals", "answer": "process GATK4_SPLITINTERVALS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path(\"**.interval_list\"), emit: split_intervals\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference = fasta ? \"--reference $fasta\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK SplitIntervals] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        SplitIntervals \\\\\n        --output ${prefix} \\\\\n        --intervals $intervals \\\\\n        $reference \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    touch ${prefix}/0000-scattered.interval_list\n    touch ${prefix}/0001-scattered.interval_list\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Build a recalibration model to score variant quality for filtering purposes.\nIt is highly recommended to follow GATK best practices when using this module,\nthe gaussian mixture model requires a large number of samples to be used for the\ntool to produce optimal results. For example, 30 samples for exome data. For more details see\nhttps://gatk.broadinstitute.org/hc/en-us/articles/4402736812443-Which-training-sets-arguments-should-I-use-for-running-VQSR-\n\nTags: gatk4, recalibration model, variantrecalibrator", "answer": "process GATK4_VARIANTRECALIBRATOR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi) // input vcf and tbi of variants to recalibrate\n    path resource_vcf   // resource vcf\n    path resource_tbi   // resource tbi\n    val labels          // string (or list of strings) containing dedicated resource labels already formatted with '--resource:' tag\n    path  fasta\n    path  fai\n    path  dict\n\n    output:\n    tuple val(meta), path(\"*.recal\")   , emit: recal\n    tuple val(meta), path(\"*.idx\")     , emit: idx\n    tuple val(meta), path(\"*.tranches\"), emit: tranches\n    tuple val(meta), path(\"*plots.R\")  , emit: plots, optional:true\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def reference_command = fasta ? \"--reference $fasta \" : ''\n    def labels_command = labels.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK VariantRecalibrator] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        VariantRecalibrator \\\\\n        --variant $vcf \\\\\n        --output ${prefix}.recal \\\\\n        --tranches-file ${prefix}.tranches \\\\\n        $reference_command \\\\\n        --tmp-dir . \\\\\n        $labels_command \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.recal\n    touch ${prefix}.idx\n    touch ${prefix}.tranches\n    touch ${prefix}plots.R\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Converts BAM/SAM file to FastQ format\nTags: bed, gatk4, interval_list", "answer": "process GATK4_SAMTOFASTQ {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path('*.fastq.gz'), emit: fastq\n    path  \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def output = meta.single_end ? \"--FASTQ ${prefix}.fastq.gz\" : \"--FASTQ ${prefix}_1.fastq.gz --SECOND_END_FASTQ ${prefix}_2.fastq.gz\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK SamToFastq] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        SamToFastq \\\\\n        --INPUT $bam \\\\\n        $output \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fastq.gz\n    touch ${prefix}_1.fastq.gz\n    touch ${prefix}_2.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Gathers scattered BQSR recalibration reports into a single file\nTags: base quality score recalibration, bqsr, gatherbqsrreports, gatk4", "answer": "process GATK4_GATHERBQSRREPORTS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(table)\n\n    output:\n    tuple val(meta), path(\"*.table\"), emit: table\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = table.collect{\"--input $it\"}.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK GatherBQSRReports] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        GatherBQSRReports \\\\\n        $input_list \\\\\n        --output ${prefix}.table \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Summarizes counts of reads that support reference, alternate and other alleles for given sites. Results can be used with CalculateContamination. Requires a common germline variant sites file, such as from gnomAD.\n\nTags: gatk4, germlinevariantsites, getpileupsumaries, readcountssummary", "answer": "process GATK4_GETPILEUPSUMMARIES {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(index), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n    path  variants\n    path  variants_tbi\n\n    output:\n    tuple val(meta), path('*.pileups.table'), emit: table\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"--intervals $variants\"\n    def reference_command = fasta ? \"--reference $fasta\" : ''\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK GetPileupSummaries] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        GetPileupSummaries \\\\\n        --input $input \\\\\n        --variant $variants \\\\\n        --output ${prefix}.pileups.table \\\\\n        $reference_command \\\\\n        $interval_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.pileups.table\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Perform joint genotyping on one or more samples pre-called with HaplotypeCaller.\n\nTags: gatk4, genotype, gvcf, joint genotyping", "answer": "process GATK4_GENOTYPEGVCFS {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(gvcf), path(gvcf_index), path(intervals), path(intervals_index)\n    path  fasta\n    path  fai\n    path  dict\n    path  dbsnp\n    path  dbsnp_tbi\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")   , emit: tbi\n    path  \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def gvcf_command = gvcf.name.endsWith(\".vcf\") || gvcf.name.endsWith(\".vcf.gz\") ? \"$gvcf\" : \"gendb://$gvcf\"\n    def dbsnp_command = dbsnp ? \"--dbsnp $dbsnp\" : \"\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK GenotypeGVCFs] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        GenotypeGVCFs \\\\\n        --variant $gvcf_command \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --reference $fasta \\\\\n        $interval_command \\\\\n        $dbsnp_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates a sequence dictionary for a reference sequence\nTags: createsequencedictionary, dictionary, fasta, gatk4", "answer": "process GATK4_CREATESEQUENCEDICTIONARY {\n    tag \"$fasta\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path('*.dict')  , emit: dict\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n\n    def avail_mem = 6144\n    if (!task.memory) {\n        log.info '[GATK CreateSequenceDictionary] Available memory not known - defaulting to 6GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CreateSequenceDictionary \\\\\n        --REFERENCE $fasta \\\\\n        --URI $fasta \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch ${fasta.baseName}.dict\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: write your description here\nTags: gatk4, mpileup, sort", "answer": "process GATK4_GATHERPILEUPSUMMARIES {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n\n    input:\n    tuple val(meta), path(pileup)\n    path  dict\n\n    output:\n    tuple val(meta), path(\"*.pileups.table\"), emit: table\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = pileup.collect{ \"--I $it\" }.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK GatherPileupSummaries] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        GatherPileupSummaries \\\\\n        $input_list \\\\\n        --O ${prefix}.pileups.table \\\\\n        --sequence-dictionary $dict \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: WARNING - this tool is still experimental and shouldn't be used in a production setting. Gathers paired-end and split read evidence files for use in the GATK-SV pipeline. Output files are a file containing the location of and orientation of read pairs marked as discordant, and a file containing the clipping location of all soft clipped reads and the orientation of the clipping.\nTags: gatk4, printsvevidence, structural variants", "answer": "process GATK4_PRINTSVEVIDENCE {\n    tag \"${meta.id}\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(evidence_files), path(evidence_indices)\n    path bed\n    path fasta\n    path fasta_fai\n    path dict\n\n    output:\n    tuple val(meta), path(\"*.txt.gz\")       , emit: printed_evidence\n    tuple val(meta), path(\"*.txt.gz.tbi\")   , emit: printed_evidence_index\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def intervals = bed ? \"--intervals ${bed}\" : \"\"\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n    def input_files = evidence_files.collect({\"--evidence-file $it\"}).join(' ')\n\n    def file_name = evidence_files[0].getFileName()\n\n    def file_type = file_name =~ \".sr.txt\" ? \"sr\" :\n                    file_name =~ \".pe.txt\" ? \"pe\" :\n                    file_name =~ \".baf.txt\" ? \"baf\" :\n                    file_name =~ \".rd.txt\" ? \"rd\" :\n                    false\n\n    if (!file_type){\n        error(\"The input file name should contain one of the following: '.sr.txt', '.pe.txt', '.baf.txt', '.rd.txt'\")\n    }\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK PRINTSVEVIDENCE] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        PrintSVEvidence \\\\\n        ${input_files} \\\\\n        --sequence-dictionary ${dict} \\\\\n        ${intervals} \\\\\n        ${reference} \\\\\n        --output ${prefix}.${file_type}.txt.gz \\\\\n        --tmp-dir . \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Postprocesses the output of GermlineCNVCaller and generates VCFs and denoised copy ratios\nTags: copy number, gatk4, postprocessgermlinecnvcalls", "answer": "process GATK4_POSTPROCESSGERMLINECNVCALLS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    //Conda is not supported at the moment: https://github.com/broadinstitute/gatk/issues/7811\n    container \"nf-core/gatk:4.5.0.0\" //Biocontainers is missing a package\n\n    input:\n    tuple val(meta), path(calls), path(model), path(ploidy)\n\n    output:\n    tuple val(meta), path(\"*_genotyped_intervals.vcf.gz\") , emit: intervals, optional: true\n    tuple val(meta), path(\"*_genotyped_segments.vcf.gz\")  , emit: segments, optional: true\n    tuple val(meta), path(\"*_denoised.vcf.gz\")            , emit: denoised, optional: true\n    path  \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"GATK4_POSTPROCESSGERMLINECNVCALLS module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def calls_command  = calls   ? calls.collect{\"--calls-shard-path $it\"}.join(' ')  : \"\"\n    def model_command  = model   ? model.collect{\"--model-shard-path $it\"}.join(' ')  : \"\"\n    def ploidy_command = ploidy  ? \"--contig-ploidy-calls ${ploidy}\"                  : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK GermlineCNVCaller] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    export THEANO_FLAGS=\"base_compiledir=\\$PWD\"\n\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        PostprocessGermlineCNVCalls \\\\\n        $calls_command \\\\\n        $model_command \\\\\n        $ploidy_command \\\\\n        --output-genotyped-intervals ${prefix}_genotyped_intervals.vcf.gz \\\\\n        --output-genotyped-segments ${prefix}_genotyped_segments.vcf.gz \\\\\n        --output-denoised-copy-ratios ${prefix}_denoised.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"GATK4_POSTPROCESSGERMLINECNVCALLS module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_genotyped_intervals.vcf.gz\n    touch ${prefix}_genotyped_segments.vcf.gz\n    touch ${prefix}_denoised.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates a panel of normals (PoN) for read-count denoising given the read counts for samples in the panel.\nTags: createreadcountpanelofnormals, gatk4, panelofnormals", "answer": "process GATK4_CREATEREADCOUNTPANELOFNORMALS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(counts)\n\n    output:\n    tuple val(meta), path(\"*.hdf5\"), emit: pon\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args       = task.ext.args ?: ''\n    def prefix     = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = counts.collect(){\"--input $it\"}.join(\" \")\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK CreateReadCountPanelOfNormals] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CreateReadCountPanelOfNormals \\\\\n        ${args} \\\\\n        ${input_list} \\\\\n        --output ${prefix}.hdf5\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.hdf5\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Splits reads that contain Ns in their cigar string\nTags: gatk4, merge, vcf", "answer": "process GATK4_SPLITNCIGARREADS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path('*.bam'), emit: bam\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK SplitNCigarReads] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        SplitNCigarReads \\\\\n        --input $bam \\\\\n        --output ${prefix}.bam \\\\\n        --reference $fasta \\\\\n        $interval_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Estimates the numbers of unique molecules in a sequencing library.\nTags: duplication metrics, estimatelibrarycomplexity, gatk4, reporting", "answer": "process GATK4_ESTIMATELIBRARYCOMPLEXITY {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input)\n    path  fasta\n    path  fai\n    path  dict\n\n    output:\n    tuple val(meta), path('*.metrics'), emit: metrics\n    path \"versions.yml\"               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = input.collect(){\"--INPUT $it\"}.join(\" \")\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK EstimateLibraryComplexity] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        EstimateLibraryComplexity \\\\\n        $input_list \\\\\n        --OUTPUT ${prefix}.metrics \\\\\n        $reference \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Call germline SNPs and indels via local re-assembly of haplotypes\nTags: gatk4, haplotype, haplotypecaller", "answer": "process GATK4_HAPLOTYPECALLER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta),  path(input), path(input_index), path(intervals), path(dragstr_model)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n    tuple val(meta5), path(dbsnp)\n    tuple val(meta6), path(dbsnp_tbi)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")       , emit: vcf\n    tuple val(meta), path(\"*.tbi\")          , optional:true, emit: tbi\n    tuple val(meta), path(\"*.realigned.bam\"), optional:true, emit: bam\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def dbsnp_command = dbsnp ? \"--dbsnp $dbsnp\" : \"\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n    def dragstr_command = dragstr_model ? \"--dragstr-params-path $dragstr_model\" : \"\"\n    def bamout_command = args.contains(\"--bam-writer-type\") ? \"--bam-output ${prefix.replaceAll('.g\\\\s*$', '')}.realigned.bam\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK HaplotypeCaller] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        HaplotypeCaller \\\\\n        --input $input \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --reference $fasta \\\\\n        $dbsnp_command \\\\\n        $interval_command \\\\\n        $dragstr_command \\\\\n        $bamout_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def bamout_command = args.contains(\"--bam-writer-type\") ? \"--bam-output ${prefix.replaceAll('.g\\\\s*$', '')}.realigned.bam\" : \"\"\n\n    def stub_realigned_bam = bamout_command ? \"touch ${prefix.replaceAll('.g\\\\s*$', '')}.realigned.bam\" : \"\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n    ${stub_realigned_bam}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Annotates intervals with GC content, mappability, and segmental-duplication content\nTags: annotateintervals, annotation, bed, gatk4, intervals", "answer": "process GATK4_ANNOTATEINTERVALS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n    tuple val(meta4), path(dict)\n    tuple val(meta5), path(mappable_regions)\n    tuple val(meta6), path(mappable_regions_tbi)\n    tuple val(meta7), path(segmental_duplication_regions)\n    tuple val(meta8), path(segmental_duplication_regions_tbi)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: annotated_intervals\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def inputs = intervals.collect(){ \"--intervals ${it}\" }.join(\" \")\n    def mappability_track = mappable_regions ? \"--mappability-track ${mappable_regions}\" : \"\"\n    def segmental_duplication_tracks = segmental_duplication_regions ? \"--segmental-duplication-track ${segmental_duplication_regions}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK AnnotateIntervals] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        AnnotateIntervals \\\\\n        ${inputs} \\\\\n        --reference ${fasta} \\\\\n        --output ${prefix}.tsv \\\\\n        ${mappability_track} \\\\\n        ${segmental_duplication_tracks} \\\\\n        --tmp-dir . \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply a Convolutional Neural Net to filter annotated variants\nTags: cnnscorevariants, gatk4, variants", "answer": "process GATK4_CNNSCOREVARIANTS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    //Conda is not supported at the moment: https://github.com/broadinstitute/gatk/issues/7811\n    container \"nf-core/gatk:4.5.0.0\" //Biocontainers is missing a package\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(aligned_input), path(intervals)\n    path fasta\n    path fai\n    path dict\n    path architecture\n    path weights\n\n    output:\n    tuple val(meta), path(\"*cnn.vcf.gz\")    , emit: vcf\n    tuple val(meta), path(\"*cnn.vcf.gz.tbi\"), emit: tbi\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"GATK4_CNNSCOREVARIANTS module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def aligned_input = aligned_input ? \"--input $aligned_input\" : \"\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n    def architecture = architecture ? \"--architecture $architecture\" : \"\"\n    def weights = weights ? \"--weights $weights\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK CnnScoreVariants] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    export THEANO_FLAGS=\"base_compiledir=\\$PWD\"\n\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CNNScoreVariants \\\\\n        --variant $vcf \\\\\n        --output ${prefix}.cnn.vcf.gz \\\\\n        --reference $fasta \\\\\n        $interval_command \\\\\n        $aligned_input \\\\\n        $architecture \\\\\n        $weights \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Splits CRAM files efficiently by taking advantage of their container based structure\nTags: cram, gatk4, split, splitcram", "answer": "process GATK4_SPLITCRAM {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(cram)\n\n    output:\n    tuple val(meta), path(\"*.cram\"), emit: split_crams\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK SplitCRAM] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        SplitCRAM \\\\\n        ${args} \\\\\n        --input ${cram} \\\\\n        --output ${prefix}.%04d.cram \\\\\n        --tmp-dir .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Select a subset of variants from a VCF file\nTags: gatk4, selectvariants, vcf", "answer": "process GATK4_SELECTVARIANTS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(vcf_idx), path (intervals)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")       , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\")   , emit: tbi\n    path \"versions.yml\"\t\t                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval = intervals ? \"--intervals ${intervals}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK SelectVariants] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        SelectVariants \\\\\n        --variant $vcf \\\\\n        --output ${prefix}.vcf.gz \\\\\n        $interval \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Splits the interval list file into unique, equally-sized interval files and place it under a directory\nTags: bed, gatk4, interval_list, sort", "answer": "process GATK4_INTERVALLISTTOOLS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(intervals)\n\n    output:\n    tuple val(meta), path(\"*_split/*/*.interval_list\"), emit: interval_list\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK IntervalListTools] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n\n    mkdir ${prefix}_split\n\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        IntervalListTools \\\\\n        --INPUT $intervals \\\\\n        --OUTPUT ${prefix}_split \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    python3 <<CODE\n    import glob, os\n    # The following python code snippet rename the output files into different name to avoid overwriting or name conflict\n    intervals = sorted(glob.glob(\"*_split/*/*.interval_list\"))\n    for i, interval in enumerate(intervals):\n        (directory, filename) = os.path.split(interval)\n        newName = os.path.join(directory, str(i + 1) + filename)\n        os.rename(interval, newName)\n    CODE\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}_split/temp_0001_of_6\n    mkdir -p ${prefix}_split/temp_0002_of_6\n    mkdir -p ${prefix}_split/temp_0003_of_6\n    mkdir -p ${prefix}_split/temp_0004_of_6\n    touch ${prefix}_split/temp_0001_of_6/1scattered.interval_list\n    touch ${prefix}_split/temp_0002_of_6/2scattered.interval_list\n    touch ${prefix}_split/temp_0003_of_6/3scattered.interval_list\n    touch ${prefix}_split/temp_0004_of_6/4scattered.interval_list\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generate recalibration table for Base Quality Score Recalibration (BQSR)\nTags: base quality score recalibration, table, bqsr, gatk4, sort", "answer": "process GATK4_BASERECALIBRATOR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(intervals)\n    path  fasta\n    path  fai\n    path  dict\n    path  known_sites\n    path  known_sites_tbi\n\n    output:\n    tuple val(meta), path(\"*.table\"), emit: table\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n    def sites_command = known_sites.collect{\"--known-sites $it\"}.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK BaseRecalibrator] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        BaseRecalibrator  \\\\\n        --input $input \\\\\n        --output ${prefix}.table \\\\\n        --reference $fasta \\\\\n        $interval_command \\\\\n        $sites_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.table\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply base quality score recalibration (BQSR) to a bam file\nTags: bam, base quality score recalibration, bqsr, cram, gatk4", "answer": "process GATK4_APPLYBQSR {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(bqsr_table), path(intervals)\n    path  fasta\n    path  fai\n    path  dict\n\n    output:\n    tuple val(meta), path(\"*.bam\") , emit: bam,  optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram, optional: true\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK ApplyBQSR] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        ApplyBQSR \\\\\n        --input $input \\\\\n        --output ${prefix}.${input.getExtension()} \\\\\n        --reference $fasta \\\\\n        --bqsr-recal-file $bqsr_table \\\\\n        $interval_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Reverts SAM or BAM files to a previous state.\nTags: gatk4, revert, sam", "answer": "process GATK4_REVERTSAM {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path('*.bam'), emit: bam\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK RevertSam] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        RevertSam \\\\\n        --INPUT $bam \\\\\n        --OUTPUT ${prefix}.reverted.bam \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.reverted.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a panel of normals contraining germline and artifactual sites for use with mutect2.\nTags: createsomaticpanelofnormals, gatk4, panelofnormals", "answer": "process GATK4_CREATESOMATICPANELOFNORMALS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(genomicsdb)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    tuple val(meta), path(\"*.tbi\")   , emit: tbi\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK CreateSomaticPanelOfNormals] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        CreateSomaticPanelOfNormals \\\\\n        --variant gendb://$genomicsdb \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --reference $fasta \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a fasta with the bases shifted by offset\nTags: gatk4, mitochondria, shiftchain, shiftfasta, shiftintervals", "answer": "process GATK4_SHIFTFASTA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    tuple val(meta2), path(fasta_fai)\n    tuple val(meta3), path(dict)\n\n    output:\n    tuple val(meta), path(\"*_shift.fasta\")       , emit: shift_fa\n    tuple val(meta), path(\"*_shift.fasta.fai\")   , emit: shift_fai\n    tuple val(meta), path(\"*_shift.back_chain\")  , emit: shift_back_chain\n    tuple val(meta), path(\"*_shift.dict\")        , emit: dict              , optional: true\n    tuple val(meta), path(\"*.intervals\")         , emit: intervals         , optional: true\n    tuple val(meta), path(\"*.shifted.intervals\") , emit: shift_intervals   , optional: true\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def seq_dict = dict ? \"--sequence-dictionary ${dict}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK ShiftFasta] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        ShiftFasta \\\\\n        --reference $fasta \\\\\n        --output ${prefix}_shift.fasta \\\\\n        --shift-back-output ${prefix}_shift.back_chain \\\\\n        $args \\\\\n        $seq_dict \\\\\n        --tmp-dir .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch test.intervals\n    touch test_shift.back_chain\n    touch test_shift.dict\n    touch test.shifted.intervals\n    touch test_shift.fasta\n    touch test_shift.fasta.fai\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Creates an interval list from a bed file and a reference dict\nTags: bed, bedtointervallist, gatk4, interval list", "answer": "process GATK4_BEDTOINTERVALLIST {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bed)\n    tuple val(meta2), path(dict)\n\n    output:\n    tuple val(meta), path('*.interval_list'), emit: interval_list\n    path  \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK BedToIntervalList] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        BedToIntervalList \\\\\n        --INPUT $bed \\\\\n        --OUTPUT ${prefix}.interval_list \\\\\n        --SEQUENCE_DICTIONARY $dict \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.interval_list\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges several vcf files\nTags: gatk4, merge, vcf", "answer": "process GATK4_MERGEVCFS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n    tuple val(meta2), path(dict)\n\n    output:\n    tuple val(meta), path('*.vcf.gz'), emit: vcf\n    tuple val(meta), path(\"*.tbi\")   , emit: tbi\n    path  \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = vcf.collect{ \"--INPUT $it\"}.join(' ')\n    def reference_command = dict ? \"--SEQUENCE_DICTIONARY $dict\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK MergeVcfs] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        MergeVcfs \\\\\n        $input_list \\\\\n        --OUTPUT ${prefix}.vcf.gz \\\\\n        $reference_command \\\\\n        --TMP_DIR . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Assigns all the reads in a file to a single new read-group\nTags: add, replace, read-group, picard, gatk", "answer": "process GATK4_ADDORREPLACEREADGROUPS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_index)\n\n    output:\n    tuple val(meta), path(\"*.bam\") , emit: bam,  optional: true\n    tuple val(meta), path(\"*.bai\") , emit: bai,  optional: true\n    tuple val(meta), path(\"*.cram\"), emit: cram, optional: true\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args        ?: ''\n    def prefix = task.ext.prefix    ?: \"${meta.id}\"\n    def suffix = task.ext.suffix    ?: \"${bam.getExtension()}\"\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n    def create_index = ( suffix == \"bam\" )? \"--CREATE_INDEX\" : \"\"\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK AddOrReplaceReadGroups] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    if (\"$bam\" == \"${prefix}.${suffix}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        AddOrReplaceReadGroups \\\\\n        $args \\\\\n        $reference \\\\\n        $create_index \\\\\n        --INPUT ${bam} \\\\\n        --OUTPUT ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk AddOrReplaceReadGroups --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix    ?: \"${meta.id}\"\n    def suffix = task.ext.suffix    ?: \"${bam.getExtension()}\"\n    if (\"$bam\" == \"${prefix}.${suffix}\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    def create_index = \"\"\n    if (suffix == \"bam\") {\n        create_index = \"touch ${prefix}.${suffix}.bai\"\n    }\n    \"\"\"\n    touch ${prefix}.${suffix}\n    ${create_index}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk AddOrReplaceReadGroups --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Print reads in the SAM/BAM/CRAM file\nTags: bam, cram, gatk4, printreads, sam", "answer": "process GATK4_PRINTREADS {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(index)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n\n    output:\n    tuple val(meta), path(\"${prefix}.bam\") , emit: bam,   optional: true\n    tuple val(meta), path(\"${prefix}.cram\"), emit: cram,  optional: true\n    tuple val(meta), path(\"${prefix}.sam\") , emit: sam,   optional: true\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK PrintReads] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    if (\"${input}\" == \"${prefix}.${input.extension}\") {\n        error(\"Output filename is the same as input filename. Please specify a different prefix.\")\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        PrintReads \\\\\n        $args \\\\\n        --reference $fasta \\\\\n        --input $input \\\\\n        --read-index $index \\\\\n        --output ${prefix}.${input.getExtension()}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.${input.getExtension()}\n    touch ${prefix}.${input.getExtension()}\n    touch ${prefix}.${input.getExtension()}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Apply tranche filtering\nTags: filtervarianttranches, gatk4, tranche filtering", "answer": "process GATK4_FILTERVARIANTTRANCHES {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(vcf), path(tbi), path(intervals)\n    path resources\n    path resources_index\n    path fasta\n    path fai\n    path dict\n\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")    , emit: vcf\n    tuple val(meta), path(\"*.vcf.gz.tbi\"), emit: tbi\n    path \"versions.yml\"                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def resources = resources.collect{\"--resource $it\"}.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK FilterVariantTranches] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        FilterVariantTranches \\\\\n        --variant $vcf \\\\\n        $resources \\\\\n        --output ${prefix}.filtered.vcf.gz \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: This tool locates and tags duplicate reads in a BAM or SAM file, where duplicate reads are defined as originating from a single fragment of DNA.\nTags: bam, gatk4, markduplicates, sort", "answer": "process GATK4_MARKDUPLICATES {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-d9e7bad0f7fbc8f4458d5c3ab7ffaaf0235b59fb:7cc3d06cbf42e28c5e2ebfc7c858654c7340a9d5-0':\n        'biocontainers/mulled-v2-d9e7bad0f7fbc8f4458d5c3ab7ffaaf0235b59fb:7cc3d06cbf42e28c5e2ebfc7c858654c7340a9d5-0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path  fasta\n    path  fasta_fai\n\n    output:\n    tuple val(meta), path(\"*cram\"),     emit: cram,  optional: true\n    tuple val(meta), path(\"*bam\"),      emit: bam,   optional: true\n    tuple val(meta), path(\"*.crai\"),    emit: crai,  optional: true\n    tuple val(meta), path(\"*.bai\"),     emit: bai,   optional: true\n    tuple val(meta), path(\"*.metrics\"), emit: metrics\n    path \"versions.yml\",                emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}.bam\"\n\n    // If the extension is CRAM, then change it to BAM\n    prefix_bam = prefix.tokenize('.')[-1] == 'cram' ? \"${prefix.substring(0, prefix.lastIndexOf('.'))}.bam\" : prefix\n\n    def input_list = bam.collect{\"--INPUT $it\"}.join(' ')\n    def reference = fasta ? \"--REFERENCE_SEQUENCE ${fasta}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK MarkDuplicates] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    // Using samtools and not Markduplicates to compress to CRAM speeds up computation:\n    // https://medium.com/@acarroll.dna/looking-at-trade-offs-in-compression-levels-for-genomics-tools-eec2834e8b94\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        MarkDuplicates \\\\\n        $input_list \\\\\n        --OUTPUT ${prefix_bam} \\\\\n        --METRICS_FILE ${prefix}.metrics \\\\\n        --TMP_DIR . \\\\\n        ${reference} \\\\\n        $args\n\n    # If cram files are wished as output, the run samtools for conversion\n    if [[ ${prefix} == *.cram ]]; then\n        samtools view -Ch -T ${fasta} -o ${prefix} ${prefix_bam}\n        rm ${prefix_bam}\n        samtools index ${prefix}\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}.bam\"\n    prefix_no_suffix = task.ext.prefix ? prefix.tokenize('.')[0] : \"${meta.id}\"\n    \"\"\"\n    touch ${prefix_no_suffix}.bam\n    touch ${prefix_no_suffix}.cram\n    touch ${prefix_no_suffix}.cram.crai\n    touch ${prefix_no_suffix}.bai\n    touch ${prefix}.metrics\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n        samtools: \\$(echo \\$(samtools --version 2>&1) | sed 's/^.*samtools //; s/Using.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: EXPERIMENTAL TOOL! Convert SiteDepth to BafEvidence\nTags: baf, gatk4, site depth", "answer": "process GATK4_SITEDEPTHTOBAF {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(site_depths), path(site_depths_indices)\n    tuple path(vcf), path(tbi)\n    path fasta\n    path fasta_fai\n    path dict\n\n    output:\n    tuple val(meta), path(\"*.baf.txt.gz\")       , emit: baf\n    tuple val(meta), path(\"*.baf.txt.gz.tbi\")   , emit: baf_tbi\n    path \"versions.yml\"                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def site_depth_input = site_depths.collect({\"--site-depth ${it}\"}).join(\" \")\n    def reference = fasta ? \"--reference ${fasta}\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK SiteDepthtoBAF] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        SiteDepthtoBAF \\\\\n        --baf-evidence-output ${prefix}.baf.txt.gz \\\\\n        --baf-sites-vcf ${vcf} \\\\\n        ${site_depth_input} \\\\\n        ${reference} \\\\\n        --tmp-dir . \\\\\n        ${args}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Call somatic SNVs and indels via local assembly of haplotypes.\nTags: gatk4, haplotype, indels, mutect2, snvs, somatic", "answer": "process GATK4_MUTECT2 {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n    tuple val(meta4), path(dict)\n    path(germline_resource)\n    path(germline_resource_tbi)\n    path(panel_of_normals)\n    path(panel_of_normals_tbi)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")     , emit: vcf\n    tuple val(meta), path(\"*.tbi\")        , emit: tbi\n    tuple val(meta), path(\"*.stats\")      , emit: stats\n    tuple val(meta), path(\"*.f1r2.tar.gz\"), optional:true, emit: f1r2\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def inputs = input.collect{ \"--input $it\"}.join(\" \")\n    def interval_command = intervals ? \"--intervals $intervals\" : \"\"\n    def pon_command = panel_of_normals ? \"--panel-of-normals $panel_of_normals\" : \"\"\n    def gr_command = germline_resource ? \"--germline-resource $germline_resource\" : \"\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK Mutect2] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        Mutect2 \\\\\n        $inputs \\\\\n        --output ${prefix}.vcf.gz \\\\\n        --reference $fasta \\\\\n        $pon_command \\\\\n        $gr_command \\\\\n        $interval_command \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz\n    touch ${prefix}.vcf.gz.tbi\n    touch ${prefix}.vcf.gz.stats\n    touch ${prefix}.f1r2.tar.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Merges mutect2 stats generated on different intervals/regions\nTags: gatk4, merge, mutect2, mutectstats", "answer": "process GATK4_MERGEMUTECTSTATS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gatk4:4.5.0.0--py36hdfd78af_0':\n        'biocontainers/gatk4:4.5.0.0--py36hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(stats)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz.stats\"), emit: stats\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input_list = stats.collect{ \"--stats ${it}\"}.join(' ')\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK MergeMutectStats] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        MergeMutectStats \\\\\n        $input_list \\\\\n        --output ${prefix}.vcf.gz.stats \\\\\n        --tmp-dir . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.vcf.gz.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Calls copy-number variants in germline samples given their counts and the output of DetermineGermlineContigPloidy.\nTags: gatk, germline contig ploidy, germlinecnvcaller", "answer": "process GATK4_GERMLINECNVCALLER {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    //Conda is not supported at the moment: https://github.com/broadinstitute/gatk/issues/7811\n    container \"nf-core/gatk:4.5.0.0\" //Biocontainers is missing a package\n\n    input:\n    tuple val(meta), path(tsv), path(intervals), path(ploidy), path(model)\n\n    output:\n    tuple val(meta), path(\"*-cnv-model/*-calls\"), emit: cohortcalls, optional: true\n    tuple val(meta), path(\"*-cnv-model/*-model\"), emit: cohortmodel, optional: true\n    tuple val(meta), path(\"*-cnv-calls/*-calls\"), emit: casecalls  , optional: true\n    path  \"versions.yml\"                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"GATK4_GERMLINECNVCALLER module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def intervals_command = intervals ? \"--intervals ${intervals}\"         : \"\"\n    def ploidy_command    = ploidy    ? \"--contig-ploidy-calls ${ploidy}\"  : \"\"\n    def model_command     = model     ? \"--model ${model}\"                 : \"\"\n    def input_list        = tsv.collect{\"--input $it\"}.join(' ')\n    def output_command    = model     ? \"--output ${prefix}-cnv-calls\"     : \"--output ${prefix}-cnv-model\"\n\n    def avail_mem = 3072\n    if (!task.memory) {\n        log.info '[GATK GermlineCNVCaller] Available memory not known - defaulting to 3GB. Specify process memory requirements to change this.'\n    } else {\n        avail_mem = (task.memory.mega*0.8).intValue()\n    }\n    \"\"\"\n    export THEANO_FLAGS=\"base_compiledir=\\$PWD\"\n\n    gatk --java-options \"-Xmx${avail_mem}M -XX:-UsePerfData\" \\\\\n        GermlineCNVCaller \\\\\n        $input_list \\\\\n        $ploidy_command \\\\\n        $output_command \\\\\n        --output-prefix $prefix \\\\\n        $args \\\\\n        $intervals_command \\\\\n        $model_command\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"GATK4_GERMLINECNVCALLER module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir -p ${prefix}-cnv-calls/${prefix}-calls\n    mkdir -p ${prefix}-cnv-model/${prefix}-model\n    mkdir -p ${prefix}-cnv-model/${prefix}-calls\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gatk4: \\$(echo \\$(gatk --version 2>&1) | sed 's/^.*(GATK) v//; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to quickly download assemblies from NCBI's Assembly database\nTags: fasta, download, assembly", "answer": "process NCBIGENOMEDOWNLOAD {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ncbi-genome-download:0.3.3--pyh7cba7a3_0' :\n        'biocontainers/ncbi-genome-download:0.3.3--pyh7cba7a3_0' }\"\n\n    input:\n    val meta\n    path accessions\n    path taxids\n    val groups\n\n    output:\n    tuple val(meta), path(\"*_genomic.gbff.gz\")        , emit: gbk     , optional: true\n    tuple val(meta), path(\"*_genomic.fna.gz\")         , emit: fna     , optional: true\n    tuple val(meta), path(\"*_rm.out.gz\")              , emit: rm      , optional: true\n    tuple val(meta), path(\"*_feature_table.txt.gz\")   , emit: features, optional: true\n    tuple val(meta), path(\"*_genomic.gff.gz\")         , emit: gff     , optional: true\n    tuple val(meta), path(\"*_protein.faa.gz\")         , emit: faa     , optional: true\n    tuple val(meta), path(\"*_protein.gpff.gz\")        , emit: gpff    , optional: true\n    tuple val(meta), path(\"*_wgsmaster.gbff.gz\")      , emit: wgs_gbk , optional: true\n    tuple val(meta), path(\"*_cds_from_genomic.fna.gz\"), emit: cds     , optional: true\n    tuple val(meta), path(\"*_rna.fna.gz\")             , emit: rna     , optional: true\n    tuple val(meta), path(\"*_rna_from_genomic.fna.gz\"), emit: rna_fna , optional: true\n    tuple val(meta), path(\"*_assembly_report.txt\")    , emit: report  , optional: true\n    tuple val(meta), path(\"*_assembly_stats.txt\")     , emit: stats   , optional: true\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args           = task.ext.args ?: ''\n    def prefix         = task.ext.prefix ?: \"${meta.id}\"\n    def accessions_opt = accessions ? \"-A ${accessions}\" : \"\"\n    def taxids_opt     = taxids ? \"-t ${taxids}\" : \"\"\n    \"\"\"\n    ncbi-genome-download \\\\\n        $args \\\\\n        $accessions_opt \\\\\n        $taxids_opt \\\\\n        --output-folder ./ \\\\\n        --flat-output \\\\\n        --parallel $task.cpus \\\\\n        $groups\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ncbigenomedownload: \\$( ncbi-genome-download --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: It predicts variants using multiple processors\nTags: variant calling, low frequency variant calling, call, variants", "answer": "process LOFREQ_CALLPARALLEL {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lofreq:2.1.5--py38h588ecb2_4' :\n        'biocontainers/lofreq:2.1.5--py38h588ecb2_4' }\"\n\n    input:\n    tuple val(meta) , path(bam), path(bai), path(intervals)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def options_intervals = intervals ? \"-l ${intervals}\" : \"\"\n\n    def alignment_cram =  bam.Extension == \"cram\" ? true : false\n    def alignment_bam = bam.Extension == \"bam\" ? true : false\n    def alignment_out = alignment_cram ? bam.BaseName + \".bam\" : \"${bam}\"\n\n    def samtools_cram_convert = ''\n    samtools_cram_convert += alignment_cram ? \"    samtools view -T ${fasta} ${bam} -@ $task.cpus -o ${alignment_out}\\n\" : ''\n    samtools_cram_convert += alignment_cram ? \"    samtools index ${alignment_out}\\n\" : ''\n\n    def samtools_cram_remove = ''\n    samtools_cram_remove += alignment_cram ? \"     rm ${alignment_out}\\n\" : ''\n    samtools_cram_remove += alignment_cram ? \"     rm ${alignment_out}.bai\\n \" : ''\n    \"\"\"\n    $samtools_cram_convert\n\n    lofreq \\\\\n        call-parallel \\\\\n        --pp-threads $task.cpus \\\\\n        $args \\\\\n        $options_intervals \\\\\n        -f $fasta \\\\\n        -o ${prefix}.vcf.gz \\\\\n        $alignment_out\n\n    $samtools_cram_remove\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Lofreq subcommand to for insert base and indel alignment qualities\nTags: variant calling, low frequency variant calling, variants, bam", "answer": "process LOFREQ_ALNQUAL {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lofreq:2.1.5--py310h47ef89e_10' :\n        'biocontainers/lofreq:2.1.5--py310h47ef89e_10' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    if (\"$bam\" == \"${prefix}.bam\") error \"Input and output names are the same, set prefix in module configuration to disambiguate!\"\n    \"\"\"\n    lofreq \\\\\n        alnqual \\\\\n        $args \\\\\n        -b \\\\\n        $bam \\\\\n        $fasta > ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n        samtools: \\$( samtools --version |& sed '1!d ; s/samtools //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n        samtools: \\$( samtools --version |& sed '1!d ; s/samtools //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Inserts indel qualities in a BAM file\nTags: variant calling, variants, bam, indel, qualities", "answer": "process LOFREQ_INDELQUAL {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lofreq:2.1.5--py38h588ecb2_4' :\n        'biocontainers/lofreq:2.1.5--py38h588ecb2_4' }\"\n\n    input:\n    tuple val(meta),  path(bam)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    lofreq indelqual \\\\\n        $args \\\\\n        -f $fasta \\\\\n        -o ${prefix}.bam \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Lofreq subcommand to call low frequency variants from alignments\nTags: variant calling, low frequency variant calling, lofreq, lofreq/call", "answer": "process LOFREQ_CALL {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lofreq:2.1.5--py38h588ecb2_4' :\n        'biocontainers/lofreq:2.1.5--py38h588ecb2_4' }\"\n\n    input:\n    tuple val(meta), path(bam), path(intervals)\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def options_intervals = intervals ? \"-l ${intervals}\" : \"\"\n    \"\"\"\n    lofreq \\\\\n        call \\\\\n        $args \\\\\n        $options_intervals \\\\\n        -f $fasta \\\\\n        -o ${prefix}.vcf.gz \\\\\n        $bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Lofreq subcommand to remove variants with low coverage or strand bias potential\nTags: variant calling, low frequency variant calling, filtering, lofreq, lofreq/filter", "answer": "process LOFREQ_FILTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lofreq:2.1.5--py38h588ecb2_4' :\n        'biocontainers/lofreq:2.1.5--py38h588ecb2_4' }\"\n\n    input:\n    tuple val(meta), path(vcf)\n\n    output:\n    tuple val(meta), path(\"*.gz\"), emit: vcf\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    lofreq \\\\\n        filter \\\\\n        $args \\\\\n        -i $vcf \\\\\n        -o ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Lofreq subcommand to call low frequency variants from alignments when tumor-normal paired samples are available\nTags: variant calling, low frequency variant calling, somatic, variants, vcf", "answer": "process LOFREQ_SOMATIC {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lofreq:2.1.5--py38h588ecb2_4' :\n        'biocontainers/lofreq:2.1.5--py38h588ecb2_4' }\"\n    input:\n    tuple val(meta), path(tumor), path(tumor_index), path(normal), path(normal_index), path(target_bed)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: \"\"\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def options_target_bed = target_bed ? \"-l ${target_bed}\" : \"\"\n\n    def tumor_cram =  tumor.Extension == \"cram\" ? true : false\n    def normal_cram =  normal.Extension == \"cram\" ? true : false\n\n    def tumor_out = tumor_cram ? tumor.BaseName + \".bam\" : \"${tumor}\"\n    def normal_out = normal_cram ? normal.BaseName + \".bam\" : \"${normal}\"\n\n    def samtools_cram_convert = ''\n    samtools_cram_convert += normal_cram ? \"    samtools view -T $fasta $normal -@ $task.cpus -o $normal_out\\n\" : ''\n    samtools_cram_convert += normal_cram ? \"    samtools index $normal_out\\n\" : ''\n    samtools_cram_convert += tumor_cram ? \"    samtools view -T ${fasta} $tumor -@ $task.cpus -o $tumor_out\\n\" : ''\n    samtools_cram_convert += tumor_cram ? \"    samtools index ${tumor_out}\\n\" : ''\n\n    def samtools_cram_remove = ''\n    samtools_cram_remove += tumor_cram ? \"     rm $tumor_out\\n\" : ''\n    samtools_cram_remove += tumor_cram ? \"     rm ${tumor_out}.bai\\n \" : ''\n    samtools_cram_remove += normal_cram ? \"     rm $normal_out\\n\" : ''\n    samtools_cram_remove += normal_cram ? \"     rm ${normal_out}.bai\\n \" : ''\n    \"\"\"\n    $samtools_cram_convert\n\n    lofreq \\\\\n        somatic \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        -f $fasta \\\\\n        -t $tumor_out \\\\\n        -n $normal_out \\\\\n        ${options_target_bed} \\\\\n        -o ${prefix}\n\n    $samtools_cram_remove\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Lofreq subcommand to call low frequency variants from alignments when tumor-normal paired samples are available\nTags: variant calling, low frequency variant calling, variants, bam, probabilistic realignment", "answer": "process LOFREQ_VITERBI {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/lofreq:2.1.5--py310h47ef89e_10' :\n        'biocontainers/lofreq:2.1.5--py310h47ef89e_10' }\"\n\n    input:\n    tuple val(meta),  path(bam)\n    tuple val(meta2), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    lofreq \\\\\n        viterbi \\\\\n        $args \\\\\n        -ref $fasta \\\\\n        $bam |\n        samtools sort \\\\\n            $args2 \\\\\n            -T ${prefix} \\\\\n            --threads $task.cpus \\\\\n            -o ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        lofreq: \\$(echo \\$(lofreq version 2>&1) | sed 's/^version: //; s/ *commit.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Peak calling of enriched genomic regions of ChIP-seq and ATAC-seq experiments\nTags: alignment, atac-seq, chip-seq, peak-calling", "answer": "process MACS2_CALLPEAK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/macs2:2.2.9.1--py39hff71179_1':\n        'biocontainers/macs2:2.2.9.1--py39hff71179_1' }\"\n\n    input:\n    tuple val(meta), path(ipbam), path(controlbam)\n    val   macs2_gsize\n\n    output:\n    tuple val(meta), path(\"*.{narrowPeak,broadPeak}\"), emit: peak\n    tuple val(meta), path(\"*.xls\")                   , emit: xls\n    path  \"versions.yml\"                             , emit: versions\n\n    tuple val(meta), path(\"*.gappedPeak\"), optional:true, emit: gapped\n    tuple val(meta), path(\"*.bed\")       , optional:true, emit: bed\n    tuple val(meta), path(\"*.bdg\")       , optional:true, emit: bdg\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args_list = args.tokenize()\n    def format    = meta.single_end ? 'BAM' : 'BAMPE'\n    def control   = controlbam ? \"--control $controlbam\" : ''\n    if(args_list.contains('--format')){\n        def id = args_list.findIndexOf{it=='--format'}\n        format = args_list[id+1]\n        args_list.remove(id+1)\n        args_list.remove(id)\n    }\n    \"\"\"\n    macs2 \\\\\n        callpeak \\\\\n        ${args_list.join(' ')} \\\\\n        --gsize $macs2_gsize \\\\\n        --format $format \\\\\n        --name $prefix \\\\\n        --treatment $ipbam \\\\\n        $control\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        macs2: \\$(macs2 --version | sed -e \"s/macs2 //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.gappedPeak\n    touch ${prefix}.bed\n    touch ${prefix}.bdg\n    touch ${prefix}.narrowPeak\n    touch ${prefix}.xls\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        macs3: \\$(macs3 --version | sed -e \"s/macs3 //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Renders a guidetree in clustalo\nTags: guide tree, msa, newick", "answer": "process CLUSTALO_GUIDETREE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/clustalo:1.2.4--h87f3376_5':\n        'biocontainers/clustalo:1.2.4--h87f3376_5' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.dnd\"), emit: tree\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    clustalo \\\\\n        -i ${fasta} \\\\\n        --guidetree-out ${prefix}.dnd \\\\\n        --threads=${task.cpus} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        clustalo: \\$( clustalo --version )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.dnd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        clustalo: \\$( clustalo --version )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Align sequences using Clustal Omega\nTags: alignment, MSA, genomics", "answer": "process CLUSTALO_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-4cefc38542f86c17596c29b35a059de10387c6a7:adbe4fbad680f9beb083956d79128039a727e7b3-0':\n        'biocontainers/mulled-v2-4cefc38542f86c17596c29b35a059de10387c6a7:adbe4fbad680f9beb083956d79128039a727e7b3-0' }\"\n\n    input:\n    tuple val(meta) , path(fasta)\n    tuple val(meta2), path(tree)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"*.aln{.gz,}\"), emit: alignment\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def write_output = compress ? \"--force -o >(pigz -cp ${task.cpus} > ${prefix}.aln.gz)\" : \"> ${prefix}.aln\"\n    // using >() is necessary to preserve the return value,\n    // so nextflow knows to display an error when it failed\n    // the --force -o is necessary, as clustalo expands the commandline input,\n    // causing it to treat the pipe as a parameter and fail\n    // this way, the command expands to /dev/fd/<id>, and --force allows writing output to an already existing file\n    \"\"\"\n    clustalo \\\n        -i ${fasta} \\\n        --threads=${task.cpus} \\\n        $args \\\n        $write_output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        clustalo: \\$( clustalo --version )\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.aln${compress ? '.gz' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        clustalo: \\$( clustalo --version )\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A derivative of GenomeScope2.0 modified to work with FastK\nTags: k-mer, genome profile, histogram", "answer": "process GENESCOPEFK {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container 'ghcr.io/nbisweden/fastk_genescopefk_merquryfk:1.2'\n\n    input:\n    tuple val(meta), path(fastk_histex_histogram)\n\n    output:\n    tuple val(meta), path(\"*_linear_plot.png\")            , emit: linear_plot\n    tuple val(meta), path(\"*_log_plot.png\")               , emit: log_plot\n    tuple val(meta), path(\"*_model.txt\")                  , emit: model\n    tuple val(meta), path(\"*_summary.txt\")                , emit: summary\n    tuple val(meta), path(\"*_transformed_linear_plot.png\"), emit: transformed_linear_plot\n    tuple val(meta), path(\"*_transformed_log_plot.png\")   , emit: transformed_log_plot\n    tuple val(meta), env(KMERCOV)                         , emit: kmer_cov\n    path \"versions.yml\"                                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"GENESCOPEFK module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def GENESCOPE_VERSION = '380815c420f50171f9234a0fd1ff426b39829b91' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    #! /usr/bin/env bash\n\n    GeneScopeFK.R \\\\\n        $args \\\\\n        --input $fastk_histex_histogram \\\\\n        --output . \\\\\n        --name_prefix ${prefix}\n\n    printf -v KMERCOV \"%.2f\\\\n\" \\$( grep \"^kmercov\" *_model.txt | cut -d\" \" -f2 )\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        genescope: $GENESCOPE_VERSION\n        r: \\$( R --version | sed '1!d; s/.*version //; s/ .*//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: MUSCLE is a program for creating multiple alignments of amino acid or nucleotide sequences. A range of options are provided that give you the choice of optimizing accuracy, speed, or some compromise between the two\nTags: msa, multiple sequence alignment", "answer": "process MUSCLE {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/muscle:3.8.1551--h7d875b9_6' :\n        'biocontainers/muscle:3.8.1551--h7d875b9_6' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.afa\") , optional: true, emit: aligned_fasta\n    tuple val(meta), path(\"*.phyi\"), optional: true, emit: phyi\n    tuple val(meta), path(\"*.phys\"), optional: true, emit: phys\n    tuple val(meta), path(\"*.clw\") , optional: true, emit: clustalw\n    tuple val(meta), path(\"*.html\"), optional: true, emit: html\n    tuple val(meta), path(\"*.msf\") , optional: true, emit: msf\n    tuple val(meta), path(\"*.tree\"), optional: true, emit: tree\n    path \"*.log\"                                   , emit: log\n    path \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def fasta_out = args.contains('-fasta') ? \"-fastaout ${prefix}_muscle_msa.afa\" : ''\n    def clw_out   = args.contains('-clw') ? \"-clwout ${prefix}_muscle_msa.clw\" : ''\n    def msf_out   = args.contains('-msf') ? \"-msfout ${prefix}_muscle_msa.msf\" : ''\n    def phys_out  = args.contains('-phys') ? \"-physout ${prefix}_muscle_msa.phys\" : ''\n    def phyi_out  = args.contains('-phyi') ? \"-phyiout ${prefix}_muscle_msa.phyi\" : ''\n    def html_out  = args.contains('-html') ? \"-htmlout ${prefix}_muscle_msa.html\" : ''\n    def tree_out  = args.contains('-maketree') ? \"-out ${prefix}_muscle_msa.tree\" : ''\n    \"\"\"\n    muscle \\\\\n        $args \\\\\n        -in $fasta \\\\\n        $fasta_out \\\\\n        $clw_out \\\\\n        $msf_out \\\\\n        $phys_out \\\\\n        $phyi_out \\\\\n        $html_out \\\\\n        $tree_out \\\\\n        -loga muscle_msa.log\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        muscle: \\$(muscle -version |  sed 's/^MUSCLE v//; s/by.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: IsoSeq - Cluster - Cluster trimmed consensus sequences\nTags: cluster, HiFi, isoseq, Pacbio", "answer": "process ISOSEQ_CLUSTER {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/isoseq:4.0.0--h9ee0642_0' :\n        'biocontainers/isoseq:4.0.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*.transcripts.bam\")               , emit: bam\n    tuple val(meta), path(\"*.transcripts.bam.pbi\")           , emit: pbi\n    tuple val(meta), path(\"*.transcripts.cluster\")           , emit: cluster\n    tuple val(meta), path(\"*.transcripts.cluster_report.csv\"), emit: cluster_report\n    tuple val(meta), path(\"*.transcripts.transcriptset.xml\") , emit: transcriptset\n    tuple val(meta), path(\"*.transcripts.hq.bam\")            , optional: true, emit: hq_bam\n    tuple val(meta), path(\"*.transcripts.hq.bam.pbi\")        , optional: true, emit: hq_pbi\n    tuple val(meta), path(\"*.transcripts.lq.bam\")            , optional: true, emit: lq_bam\n    tuple val(meta), path(\"*.transcripts.lq.bam.pbi\")        , optional: true, emit: lq_pbi\n    tuple val(meta), path(\"*.transcripts.singletons.bam\")    , optional: true, emit: singletons_bam\n    tuple val(meta), path(\"*.transcripts.singletons.bam.pbi\"), optional: true, emit: singletons_pbi\n    path  \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    isoseq \\\\\n        cluster \\\\\n        $bam \\\\\n        ${prefix}.transcripts.bam \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        isoseq: \\$( isoseq cluster --version | head -n 1 | sed 's/isoseq cluster //g' | sed 's/ (.*//g' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch dummy.transcripts.bam\n    touch dummy.transcripts.bam.pbi\n    touch dummy.transcripts.cluster\n    touch dummy.transcripts.cluster_report.csv\n    touch dummy.transcripts.transcriptset.xml\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        isoseq: \\$( isoseq cluster --version | head -n 1 | sed 's/isoseq cluster //g' | sed 's/ (.*//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Remove polyA tail and artificial concatemers\nTags: isoseq, refine, ccs, pacbio, polyA_tail", "answer": "process ISOSEQ_REFINE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/isoseq:4.0.0--h9ee0642_0' :\n        'biocontainers/isoseq:4.0.0--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(bam)\n    path primers\n\n    output:\n    tuple val(meta), path(\"*.bam\")                       , emit: bam\n    tuple val(meta), path(\"*.bam.pbi\")                   , emit: pbi\n    tuple val(meta), path(\"*.consensusreadset.xml\")      , emit: consensusreadset\n    tuple val(meta), path(\"*.filter_summary.report.json\"), emit: summary\n    tuple val(meta), path(\"*.report.csv\")                , emit: report\n    path  \"versions.yml\"                                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    isoseq \\\\\n        refine \\\\\n        -j $task.cpus \\\\\n        $args \\\\\n        $bam \\\\\n        $primers \\\\\n        ${prefix}.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        isoseq: \\$( isoseq refine --version | head -n 1 | sed 's/isoseq refine //' | sed 's/ (commit.\\\\+//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch dummy.bam\n    touch dummy.bam.pbi\n    touch dummy.consensusreadset.xml\n    touch dummy.filter_summary.report.json\n    touch dummy.report.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        isoseq: \\$( isoseq refine --version | head -n 1 | sed 's/isoseq refine //' | sed 's/ (commit.\\\\+//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Consensus module for raw de novo DNA assembly of long uncorrected reads\nTags: assembly, pacbio, nanopore, polish", "answer": "process RACON {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/racon:1.4.20--h9a82719_1' :\n        'biocontainers/racon:1.4.20--h9a82719_1' }\"\n\n    input:\n    tuple val(meta), path(reads), path(assembly), path(paf)\n\n    output:\n    tuple val(meta), path('*_assembly_consensus.fasta.gz') , emit: improved_assembly\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    racon -t \"$task.cpus\" \\\\\n        \"${reads}\" \\\\\n        \"${paf}\" \\\\\n        $args \\\\\n        \"${assembly}\" > \\\\\n        ${prefix}_assembly_consensus.fasta\n\n    gzip -n ${prefix}_assembly_consensus.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        racon: \\$( racon --version 2>&1 | sed 's/^.*v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compute the TCS score for a MSA or for a MSA plus a library file. Outputs the tcs as it is and a csv with just the total TCS score.\nTags: alignment, MSA, evaluation", "answer": "process TCOFFEE_TCS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-a76a981c07359a31ff55b9dc13bd3da5ce1909c1:84c8f17f1259b49e2f7783b95b7a89c6f2cb199e-0':\n        'biocontainers/mulled-v2-a76a981c07359a31ff55b9dc13bd3da5ce1909c1:84c8f17f1259b49e2f7783b95b7a89c6f2cb199e-0' }\"\n\n    input:\n    tuple val(meta), path(msa)\n    tuple val(meta2), path(lib)\n\n    output:\n    tuple val(meta), path(\"*.tcs\")   , emit: tcs\n    tuple val(meta), path(\"*.scores\"), emit: scores\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args          = task.ext.args ?: ''\n    def prefix        = task.ext.prefix ?: \"${meta.id}\"\n    def lib_arg       = lib ? \"-lib ${lib}\" : \"\"\n    def header        = meta.keySet().join(\",\")\n    def values        = meta.values().join(\",\")\n    def unzipped_name = msa.toString() - '.gz'\n    \"\"\"\n    export TEMP='./'\n    filename=${msa}\n    if [[ \\$(basename $msa) == *.gz ]] ; then\n        unpigz -f $msa\n        filename=${unzipped_name}\n    fi\n\n    # Bad hack to circumvent t_coffee bug\n    # Issue described already in: https://github.com/cbcrg/tcoffee/issues/3\n    # Add an A in front of filename if the file begins with A\n    first_letter_filename=\\${filename:0:1}\n    if [ \"\\$first_letter_filename\" == \"A\" ]; then input=\"A\"\\$filename; else input=\\$filename;  fi\n\n    t_coffee -infile \\$input \\\n        -evaluate -output=score_ascii \\\n        ${lib_arg} \\\n        -outfile ${prefix}.tcs\n\n    # Add metadata info to output file\n    echo \"${header},TCS\" > \"${prefix}.scores\"\n\n    # Add values\n    scores=\\$(grep 'SCORE=' ${prefix}.tcs | cut -d '=' -f 2 )\n    echo \"${values},\\$scores\" >> \"${prefix}.scores\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tcs\n    touch ${prefix}.scores\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compares 2 alternative MSAs to evaluate them.\nTags: alignment, MSA, evaluation", "answer": "process TCOFFEE_ALNCOMPARE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-a76a981c07359a31ff55b9dc13bd3da5ce1909c1:84c8f17f1259b49e2f7783b95b7a89c6f2cb199e-0':\n        'biocontainers/mulled-v2-a76a981c07359a31ff55b9dc13bd3da5ce1909c1:84c8f17f1259b49e2f7783b95b7a89c6f2cb199e-0' }\"\n\n    input:\n    tuple val(meta), path(msa), path(ref_msa)\n\n    output:\n    tuple val(meta), path(\"*.scores\"), emit: scores\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix = task.ext.prefix ? task.ext.prefix : \"${msa.baseName}\"\n    def args = task.ext.args ? task.ext.args.contains('compare_mode') ? task.ext.args  : (task.ext.args +'-compare_mode tc ' ) : '-compare_mode tc '\n    def metric_name = args.split('compare_mode ')[1].split(' ')[0]\n    def header = meta.keySet().join(\",\")\n    def values = meta.values().join(\",\")\n    def read_msa = msa.getName().endsWith(\".gz\") ? \"<(unpigz -cdf ${msa})\" : msa\n    def read_ref = ref_msa.getName().endsWith(\".gz\") ? \"<(unpigz -cdf ${ref_msa})\" : ref_msa\n\n    \"\"\"\n    export TEMP='./'\n    t_coffee -other_pg aln_compare \\\n        -al1 ${read_ref} \\\n        -al2 ${read_msa} \\\n        ${args} \\\n        | grep -v \"seq1\" | grep -v '*' | \\\n        awk '{ print \\$4}' ORS=\"\\t\" \\\n        >> \"scores.txt\"\n\n    # Add metadata info to output file\n    echo \"${header},${metric_name}\" > \"${prefix}.scores\"\n\n    # Add values\n    scores=\\$(awk '{sub(/[[:space:]]+\\$/, \"\")} 1' scores.txt | tr -s '[:blank:]' ',')\n    echo \"${values},\\$scores\" >> \"${prefix}.scores\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.scores\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Aligns sequences using T_COFFEE\nTags: alignment, MSA, genomics", "answer": "process TCOFFEE_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-a76a981c07359a31ff55b9dc13bd3da5ce1909c1:84c8f17f1259b49e2f7783b95b7a89c6f2cb199e-0':\n        'biocontainers/mulled-v2-a76a981c07359a31ff55b9dc13bd3da5ce1909c1:84c8f17f1259b49e2f7783b95b7a89c6f2cb199e-0' }\"\n\n    input:\n    tuple val(meta) ,  path(fasta)\n    tuple val(meta2),  path(tree)\n    tuple val(meta3),  path(template), path(accessory_informations)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"*.aln{.gz,}\"), emit: alignment\n    // in the args there might be the request to generate a lib file, so the following is an optional output\n    tuple val(meta), path(\"*.*lib\")     , emit: lib, optional : true\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def tree_args = tree ? \"-usetree $tree\" : \"\"\n    def template_args = template ? \"-template_file $template\" : \"\"\n    def outfile = compress ? \"stdout\" : \"${prefix}.aln\"\n    def write_output = compress ? \" | pigz -cp ${task.cpus} > ${prefix}.aln.gz\" : \"\"\n    \"\"\"\n    export TEMP='./'\n    t_coffee -seq ${fasta} \\\n        $tree_args \\\n        $template_args \\\n        $args \\\n        -thread ${task.cpus} \\\n        -outfile $outfile \\\n        $write_output\n\n    # If stdout file exist and compress is true, then compress the file\n    # This is a patch for the current behaviour of the regressive algorithm\n    # that does not support the stdout redirection\n    if [ -f stdout ] && [ \"$compress\" = true ]; then\n        pigz -cp ${task.cpus} < stdout > ${prefix}.aln.gz\n        rm stdout\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.aln${compress ? '.gz':''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Computes the irmsd score for a given alignment and the structures.\nTags: alignment, MSA, evaluation", "answer": "process TCOFFEE_IRMSD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-a76a981c07359a31ff55b9dc13bd3da5ce1909c1:84c8f17f1259b49e2f7783b95b7a89c6f2cb199e-0':\n        'biocontainers/mulled-v2-a76a981c07359a31ff55b9dc13bd3da5ce1909c1:84c8f17f1259b49e2f7783b95b7a89c6f2cb199e-0' }\"\n\n    input:\n    tuple  val(meta),  file (msa)\n    tuple  val(meta2), file(template), file(structures)\n\n    output:\n    tuple val(meta), path (\"${prefix}.irmsd\"), emit: irmsd\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${msa.baseName}\"\n    \"\"\"\n    export TEMP='./'\n\n    if [[ \\$(basename $msa) == *.gz ]] ; then\n        unpigz -f $msa\n    fi\n\n    t_coffee -other_pg irmsd \\\n        \\$(basename $msa .gz) \\\n        $args \\\n        -template_file $template > ${prefix}.irmsd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${msa.baseName}\"\n    \"\"\"\n    touch ${prefix}.irmsd\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Reformats files with t-coffee\nTags: reformatting, alignment, genomics", "answer": "process TCOFFEE_SEQREFORMAT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/t-coffee:13.46.0.919e8c6b--hfc96bf3_0':\n        'biocontainers/t-coffee:13.46.0.919e8c6b--hfc96bf3_0' }\"\n\n    input:\n    tuple val(meta), path(infile)\n\n    output:\n    tuple val(meta), path(\"${prefix}.txt\"), emit: formatted_file\n    path \"versions.yml\" , emit: versions\n\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    export TEMP='./'\n    t_coffee -other_pg seq_reformat \\\n        -in ${infile} \\\n        $args \\\n        > \"${prefix}.txt\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch \"${prefix}.txt\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        tcoffee: \\$( t_coffee -version | awk '{gsub(\"Version_\", \"\"); print \\$3}')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Call peaks using SEACR on sequenced reads in bedgraph format\nTags: peak-caller, peaks, bedgraph, cut&tag, cut&run, chromatin, seacr", "answer": "process SEACR_CALLPEAK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-03bfeb32fe80910c231f630d4262b83677c8c0f4:f4bb19b68e66de27e4c64306f951d5ff11919931-0' :\n        'biocontainers/mulled-v2-03bfeb32fe80910c231f630d4262b83677c8c0f4:f4bb19b68e66de27e4c64306f951d5ff11919931-0' }\"\n\n    input:\n    tuple val(meta), path(bedgraph), path(ctrlbedgraph)\n    val (threshold)\n\n    output:\n    tuple val(meta), path(\"*.bed\"), emit: bed\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def function_switch = ctrlbedgraph ? \"$ctrlbedgraph\" : \"$threshold\"\n    def VERSION = '1.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    SEACR_1.3.sh \\\\\n        $bedgraph \\\\\n        $function_switch \\\\\n        $args \\\\\n        $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seacr: $VERSION\n        bedtools: \\$(bedtools --version | sed -e \"s/bedtools v//g\")\n        r-base: \\$(echo \\$(R --version 2>&1) | sed 's/^.*R version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: ichorCNA is an R package for calculating copy number alteration from (low-pass) whole genome sequencing, particularly for use in cell-free DNA\nTags: ichorcna, cnv, cna, cfDNA, wgs", "answer": "process ICHORCNA_RUN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-ichorcna:0.3.2--pl5321r42hdfd78af_2' :\n        'biocontainers/r-ichorcna:0.3.2--pl5321r42hdfd78af_2' }\"\n\n    input:\n    tuple val(meta), path(wig)\n    path gc_wig\n    path map_wig\n    path panel_of_normals\n    path centromere\n\n    output:\n    tuple val(meta), path(\"*.cna.seg\")    , emit: cna_seg\n    tuple val(meta), path(\"*.params.txt\") , emit: ichorcna_params\n    path \"*genomeWide.pdf\"                , emit: genome_plot\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def pon = panel_of_normals ? \"--normalPanel ${panel_of_normals}\" : ''\n    def centro = centromere ? \"--centromere ${centromere}\" : ''\n    def VERSION = '0.3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    runIchorCNA.R \\\\\n        $args \\\\\n        --WIG ${wig} \\\\\n        --id ${prefix} \\\\\n        --gcWig ${gc_wig} \\\\\n        --mapWig ${map_wig} \\\\\n        ${pon} \\\\\n        ${centro} \\\\\n        --outDir .\n\n    cp */*genomeWide.pdf .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ichorcna: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: ichorCNA is an R package for calculating copy number alteration from (low-pass) whole genome sequencing, particularly for use in cell-free DNA. This module generates a panel of normals\nTags: ichorcna, cnv, cna, cfDNA, wgs, panel_of_normals", "answer": "process ICHORCNA_CREATEPON {\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-ichorcna:0.3.2--r41hdfd78af_0' :\n        'biocontainers/r-ichorcna:0.3.2--r41hdfd78af_0' }\"\n\n    input:\n    path wigs\n    path gc_wig\n    path map_wig\n    path centromere\n\n    output:\n    path \"*.rds\"        , emit: rds\n    path \"*.txt\"        , emit: txt\n    path \"versions.yml\" , emit: versions\n\n    when:\n        task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def centro = centromere ? \"--centromere ${centromere}\" : ''\n    def prefix = task.ext.prefix ?: \"PoN\"\n    def VERSION = '0.3.2' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    echo ${wigs} | tr \" \" \"\\\\n\" > wig_files.txt\n\n    createPanelOfNormals.R \\\\\n        --filelist wig_files.txt \\\\\n        --gcWig ${gc_wig} \\\\\n        --mapWig ${map_wig} \\\\\n        ${centro} \\\\\n        ${args} \\\\\n        --outfile ${prefix}\n\n    rm wig_files.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        ichorcna: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Concatenating multiple uncompressed sequence files together\nTags: concat, fasta, fastq, merge", "answer": "process SEQKIT_CONCAT {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0':\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(input, stageAs: 'in/*')\n\n    output:\n    tuple val(meta), path(\"*.{fasta,fastq,fa,fq,fas,fna,faa}\"), emit: fastx\n    path \"versions.yml\",                                        emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args         ?: \"\"\n    def prefix      = task.ext.prefix       ?: \"${meta.id}\"\n    def file_type   = input instanceof List ? input[0].getExtension() : input.getExtension()\n    \"\"\"\n    seqkit \\\\\n        concat \\\\\n        $args \\\\\n        in/* > ${prefix}.${file_type}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$(seqkit version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix   ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$(seqkit version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Use seqkit to generate sliding windows of input fasta\nTags: seqkit, sliding, windows", "answer": "process SEQKIT_SLIDING {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0':\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"*.fast*\"), emit: fastx\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta$|.+\\.fa$|.+\\.fas$|.+\\.fna$/) {\n        extension = \"fasta\"\n    }\n    \"\"\"\n    seqkit \\\\\n        sliding \\\\\n        ${fastx} \\\\\n        ${args} \\\\\n        --threads ${task.cpus} \\\\\n        -o ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit | sed '3!d; s/Version: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (\"$fastx\" ==~ /.+\\.fasta$|.+\\.fa$|.+\\.fas$|.+\\.fna$/) {\n        extension = \"fasta\"\n    }\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit | sed '3!d; s/Version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sorts sequences by id/name/sequence/length\nTags: genomics, fasta, fastq, sort", "answer": "process SEQKIT_SORT {\n    tag \"$meta.id\"\n    label 'process_low'\n    // File IO can be a bottleneck. See: https://bioinf.shenwei.me/seqkit/usage/#parallelization-of-cpu-intensive-jobs\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0':\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"${prefix}.*\")    , emit: fastx\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def args2       = task.ext.args2 ?: ''\n    prefix          = task.ext.prefix ?: \"${meta.id}\"\n    def extension   = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz|.+\\.fsa|.+\\.fsa.gz/ ) {\n        extension   = \"fasta\"\n    }\n    extension       = fastx.toString().endsWith('.gz') ? \"${extension}.gz\" : extension\n    def call_gzip   = extension.endsWith('.gz') ? \"| gzip -c $args2 \" : ''\n    if(\"${prefix}.${extension}\" == \"$fastx\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    seqkit \\\\\n        sort \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $fastx \\\\\n        $call_gzip \\\\\n        > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$(seqkit version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix          = task.ext.prefix ?: \"${meta.id}\"\n    def extension   = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz|.+\\.fsa|.+\\.fsa.gz/ ) {\n        extension   = \"fasta\"\n    }\n    extension       = fastx.toString().endsWith('.gz') ? \"${extension}.gz\" : extension\n    if(\"${prefix}.${extension}\" == \"$fastx\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$(seqkit version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Transforms sequences (extract ID, filter by length, remove gaps, reverse complement...)\nTags: genomics, fasta, fastq, transform, filter, gaps, complement", "answer": "process SEQKIT_SEQ {\n    tag \"$meta.id\"\n    label 'process_low'\n    // File IO can be a bottleneck. See: https://bioinf.shenwei.me/seqkit/usage/#parallelization-of-cpu-intensive-jobs\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0':\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"${prefix}.*\")    , emit: fastx\n    path \"versions.yml\"                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def args2       = task.ext.args2 ?: ''\n    prefix          = task.ext.prefix ?: \"${meta.id}\"\n    def extension   = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz|.+\\.fsa|.+\\.fsa.gz/ ) {\n        extension   = \"fasta\"\n    }\n    extension       = fastx.toString().endsWith('.gz') ? \"${extension}.gz\" : extension\n    def call_gzip   = extension.endsWith('.gz') ? \"| gzip -c $args2\" : ''\n    if(\"${prefix}.${extension}\" == \"$fastx\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    seqkit \\\\\n        seq \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $fastx \\\\\n        $call_gzip \\\\\n        > ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$(seqkit version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix          = task.ext.prefix ?: \"${meta.id}\"\n    def extension   = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz|.+\\.fsa|.+\\.fsa.gz/ ) {\n        extension   = \"fasta\"\n    }\n    extension = fastx.toString().endsWith('.gz') ? \"${extension}.gz\" : extension\n    if(\"${prefix}.${extension}\" == \"$fastx\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.${extension}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$(seqkit version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Transforms sequences (extract ID, filter by length, remove gaps, reverse complement...)\nTags: genomics, fasta, fastq, remove, duplicates", "answer": "process SEQKIT_RMDUP {\n    tag \"$meta.id\"\n    label 'process_low'\n    // File IO can be a bottleneck. See: https://bioinf.shenwei.me/seqkit/usage/#parallelization-of-cpu-intensive-jobs\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0':\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"${prefix}.${extension}\") , emit: fastx\n    tuple val(meta), path(\"*.log\")                  , emit: log\n    path \"versions.yml\"                             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    prefix          = task.ext.prefix ?: \"${meta.id}\"\n    extension       = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz|.+\\.fsa|.+\\.fsa.gz/ ) {\n        extension   = \"fasta\"\n    }\n    extension       = fastx.toString().endsWith('.gz') ? \"${extension}.gz\" : extension\n    // SeqKit/rmdup takes care of compressing the output: https://bioinf.shenwei.me/seqkit/usage/#rmdup\n    if(\"${prefix}.${extension}\" == \"$fastx\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    seqkit \\\\\n        rmdup \\\\\n        --threads $task.cpus \\\\\n        $args \\\\\n        $fastx \\\\\n        -o ${prefix}.${extension} \\\\\n        2> >(tee ${prefix}.log >&2)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$(seqkit version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix          = task.ext.prefix ?: \"${meta.id}\"\n    extension       = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz|.+\\.fsa|.+\\.fsa.gz/ ) {\n        extension   = \"fasta\"\n    }\n    extension = fastx.toString().endsWith('.gz') ? \"${extension}.gz\" : extension\n    if(\"${prefix}.${extension}\" == \"$fastx\") error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch ${prefix}.${extension}\n    echo \\\\\n        '[INFO] 0 duplicated records removed' \\\\\n        > ${prefix}.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$(seqkit version | cut -d' ' -f2)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Split single or paired-end fastq.gz files\nTags: split, fastq, seqkit", "answer": "process SEQKIT_SPLIT2 {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0' :\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"**/*.gz\"), emit: reads\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if(meta.single_end){\n        \"\"\"\n        seqkit \\\\\n            split2 \\\\\n            $args \\\\\n            --threads $task.cpus \\\\\n            $reads \\\\\n            --out-dir ${prefix}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            seqkit: \\$(echo \\$(seqkit 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        seqkit \\\\\n            split2 \\\\\n            $args \\\\\n            --threads $task.cpus \\\\\n            --read1 ${reads[0]} \\\\\n            --read2 ${reads[1]} \\\\\n            --out-dir ${prefix}\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            seqkit: \\$(echo \\$(seqkit 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Select sequences from a large file based on name/ID\nTags: filter, seqkit, subseq, grep", "answer": "process SEQKIT_GREP {\n    tag \"$meta.id\"\n    label 'process_low'\n\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0':\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(sequence)\n    path pattern\n\n    output:\n    tuple val(meta), path(\"*.{fa,fq}.gz\")  , emit: filter\n    path \"versions.yml\"                    , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // fasta or fastq. Exact pattern match .fasta or .fa suffix with optional .gz (gzip) suffix\n    def suffix = task.ext.suffix ?: \"${sequence}\" ==~ /(.*f[astn]*a(.gz)?$)/ ? \"fa\" : \"fq\"\n    def pattern_file = pattern ? \"-f ${pattern}\" : \"\"\n\n    \"\"\"\n    seqkit \\\\\n        grep \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        ${pattern_file} \\\\\n        ${sequence} \\\\\n        -o ${prefix}.${suffix}.gz \\\\\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit version | sed 's/seqkit v//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    // fasta or fastq. Exact pattern match .fasta or .fa suffix with optional .gz (gzip) suffix\n    def suffix = task.ext.suffix ?: \"${sequence}\" ==~ /(.*f[astn]*a(.gz)?$)/ ? \"fa\" : \"fq\"\n\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.${suffix}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit version | sed 's/seqkit v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert FASTQ to FASTA format\nTags: fastq, fasta, convert", "answer": "process SEQKIT_FQ2FA {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0' :\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastq)\n\n    output:\n    tuple val(meta), path(\"*.fa.gz\"), emit: fasta\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    seqkit \\\\\n        fq2fa \\\\\n        $args \\\\\n        -j $task.cpus \\\\\n        -o ${prefix}.fa.gz \\\\\n        $fastq\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit | sed '3!d; s/Version: //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.fa.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit | sed '3!d; s/Version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert FASTA/Q to tabular format, and provide various information, like sequence length, GC content/GC skew.\nTags: fasta, fastq, text, tabular, convert", "answer": "process SEQKIT_FX2TAB {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0' :\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"*.txt*\"), emit: text\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"txt.zst\"\n    \"\"\"\n    seqkit \\\\\n        fx2tab \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        $fastx \\\\\n        -o ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit | sed '3!d; s/Version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert tabular format (first two/three columns) to FASTA/Q format.\nTags: fasta, fastq, text, tabular, convert", "answer": "process SEQKIT_TAB2FX {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0' :\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(text)\n\n    output:\n    tuple val(meta), path(\"*.f*\"), emit: fastx\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"fa.zst\"\n    \"\"\"\n    seqkit \\\\\n        tab2fx \\\\\n        $args \\\\\n        --threads $task.cpus \\\\\n        $text \\\\\n        -o ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit | sed '3!d; s/Version: //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Use seqkit to find/replace strings within sequences and sequence headers\nTags: seqkit, replace, sequence, sequence headers, fasta", "answer": "process SEQKIT_REPLACE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0':\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(fastx)\n\n    output:\n    tuple val(meta), path(\"*.fast*\"), emit: fastx\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz/) {\n        extension = \"fasta\"\n    }\n    def endswith = task.ext.suffix ?: \"${extension}.gz\"\n    \"\"\"\n    seqkit \\\\\n        replace \\\\\n        ${args} \\\\\n        --threads ${task.cpus} \\\\\n        -i ${fastx} \\\\\n        -o ${prefix}.${endswith}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit version | sed 's/seqkit v//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def extension = \"fastq\"\n    if (\"$fastx\" ==~ /.+\\.fasta|.+\\.fasta.gz|.+\\.fa|.+\\.fa.gz|.+\\.fas|.+\\.fas.gz|.+\\.fna|.+\\.fna.gz/) {\n        extension = \"fasta\"\n    }\n    def endswith = task.ext.suffix ?: \"${extension}.gz\"\n\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.${endswith}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit version | sed 's/seqkit v//' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: simple statistics of FASTA/Q files\nTags: seqkit, fasta, stats", "answer": "process SEQKIT_STATS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0' :\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.tsv\"), emit: stats\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: '--all'\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    seqkit stats \\\\\n        --tabular \\\\\n        $args \\\\\n        $reads > '${prefix}.tsv'\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit version | sed 's/seqkit v//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: match up paired-end reads from two fastq files\nTags: seqkit, pair, fastq", "answer": "process SEQKIT_PAIR {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seqkit:2.8.1--h9ee0642_0':\n        'biocontainers/seqkit:2.8.1--h9ee0642_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.paired.fastq.gz\")                  , emit: reads\n    tuple val(meta), path(\"*.unpaired.fastq.gz\"), optional: true, emit: unpaired_reads\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    seqkit \\\\\n        pair \\\\\n        -1 ${reads[0]} \\\\\n        -2 ${reads[1]} \\\\\n        $args \\\\\n        --threads $task.cpus\n\n    # gzip fastq\n    find . -maxdepth 1 -name \"*.fastq\" -exec gzip {} \\;\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit version | sed 's/seqkit v//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}_1.paired.fastq.gz\n    echo \"\" | gzip > ${prefix}_2.paired.fastq.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seqkit: \\$( seqkit version | sed 's/seqkit v//' )\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: Identify antimicrobial resistance in gene or protein sequences\nTags: bacteria, fasta, antibiotic resistance", "answer": "process AMRFINDERPLUS_UPDATE {\n    tag \"update\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ncbi-amrfinderplus:3.12.8--h283d18e_0':\n        'biocontainers/ncbi-amrfinderplus:3.12.8--h283d18e_0' }\"\n\n    output:\n    path \"amrfinderdb.tar.gz\", emit: db\n    path \"versions.yml\"      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    \"\"\"\n    amrfinder_update -d amrfinderdb\n    tar czvf amrfinderdb.tar.gz -C amrfinderdb/\\$(readlink amrfinderdb/latest) ./\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        amrfinderplus: \\$(amrfinder --version)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    touch amrfinderdb.tar\n    gzip amrfinderdb.tar\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        amrfinderplus: \\$(amrfinder --version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Identify antimicrobial resistance in gene or protein sequences\nTags: bacteria, fasta, antibiotic resistance", "answer": "process AMRFINDERPLUS_RUN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ncbi-amrfinderplus:3.12.8--h283d18e_0':\n        'biocontainers/ncbi-amrfinderplus:3.12.8--h283d18e_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path db\n\n    output:\n    tuple val(meta), path(\"${prefix}.tsv\")          , emit: report\n    tuple val(meta), path(\"${prefix}-mutations.tsv\"), emit: mutation_report, optional: true\n    path \"versions.yml\"                             , emit: versions\n    env VER                                         , emit: tool_version\n    env DBVER                                       , emit: db_version\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def is_compressed_fasta = fasta.getName().endsWith(\".gz\") ? true : false\n    def is_compressed_db = db.getName().endsWith(\".gz\") ? true : false\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    organism_param = meta.containsKey(\"organism\") ? \"--organism ${meta.organism} --mutation_all ${prefix}-mutations.tsv\" : \"\"\n    fasta_name = fasta.getName().replace(\".gz\", \"\")\n    fasta_param = \"-n\"\n    if (meta.containsKey(\"is_proteins\")) {\n        if (meta.is_proteins) {\n            fasta_param = \"-p\"\n        }\n    }\n    \"\"\"\n    if [ \"$is_compressed_fasta\" == \"true\" ]; then\n        gzip -c -d $fasta > $fasta_name\n    fi\n\n    if [ \"$is_compressed_db\" == \"true\" ]; then\n        mkdir amrfinderdb\n        tar xzvf $db -C amrfinderdb\n    else\n        mv $db amrfinderdb\n    fi\n\n    amrfinder \\\\\n        $fasta_param $fasta_name \\\\\n        $organism_param \\\\\n        $args \\\\\n        --database amrfinderdb \\\\\n        --threads $task.cpus > ${prefix}.tsv\n\n    VER=\\$(amrfinder --version)\n    DBVER=\\$(echo \\$(amrfinder --database amrfinderdb --database_version 2> stdout) | rev | cut -f 1 -d ' ' | rev)\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        amrfinderplus: \\$(amrfinder --version)\n        amrfinderplus-database: \\$(echo \\$(echo \\$(amrfinder --database amrfinderdb --database_version 2> stdout) | rev | cut -f 1 -d ' ' | rev))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.tsv\n\n    VER=\\$(amrfinder --version)\n    DBVER=stub_version\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        amrfinderplus: \\$(amrfinder --version)\n        amrfinderplus-database: stub_version\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Validate, filter, convert and perform various other operations on GFF files\nTags: gff, conversion, validation", "answer": "process GFFREAD {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gffread:0.12.7--hdcf5f25_4' :\n        'biocontainers/gffread:0.12.7--hdcf5f25_4' }\"\n\n    input:\n    tuple val(meta), path(gff)\n    path fasta\n\n    output:\n    tuple val(meta), path(\"*.gtf\")  , emit: gtf             , optional: true\n    tuple val(meta), path(\"*.gff3\") , emit: gffread_gff     , optional: true\n    tuple val(meta), path(\"*.fasta\"), emit: gffread_fasta   , optional: true\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args             ?: ''\n    def prefix      = task.ext.prefix           ?: \"${meta.id}\"\n    def extension   = args.contains(\"-T\")       ? 'gtf' : ( ( ['-w', '-x', '-y' ].any { args.contains(it) } ) ? 'fasta' : 'gff3' )\n    def fasta_arg   = fasta                     ? \"-g $fasta\" : ''\n    def output_name = \"${prefix}.${extension}\"\n    def output      = extension == \"fasta\"      ? \"$output_name\" : \"-o $output_name\"\n    def args_sorted = args.replaceAll(/(.*)(-[wxy])(.*)/) { all, pre, param, post -> \"$pre $post $param\" }.trim()\n    // args_sorted  = Move '-w', '-x', and '-y' to the end of the args string as gffread expects the file name after these parameters\n    if ( \"$output_name\" in [ \"$gff\", \"$fasta\" ] ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    gffread \\\\\n        $gff \\\\\n        $fasta_arg \\\\\n        $args_sorted \\\\\n        $output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gffread: \\$(gffread --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args        = task.ext.args             ?: ''\n    def prefix      = task.ext.prefix           ?: \"${meta.id}\"\n    def extension   = args.contains(\"-T\")       ? 'gtf' : ( ( ['-w', '-x', '-y' ].any { args.contains(it) } ) ? 'fasta' : 'gff3' )\n    def output_name = \"${prefix}.${extension}\"\n    if ( \"$output_name\" in [ \"$gff\", \"$fasta\" ] ) error \"Input and output names are the same, use \\\"task.ext.prefix\\\" to disambiguate!\"\n    \"\"\"\n    touch $output_name\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gffread: \\$(gffread --version 2>&1)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A haplotype-based variant detector\nTags: variant caller, SNP, genotyping, somatic variant calling, germline variant calling, bacterial variant calling, bayesian", "answer": "process FREEBAYES {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/freebayes:1.3.6--hbfe0e7f_2' :\n        'biocontainers/freebayes:1.3.6--hbfe0e7f_2' }\"\n\n    input:\n    tuple val(meta), path(input_1), path(input_1_index), path(input_2), path(input_2_index), path(target_bed)\n    tuple val(ref_meta), path(fasta)\n    tuple val(ref_idx_meta), path(fasta_fai)\n    tuple val(samples_meta), path(samples)\n    tuple val(populations_meta), path(populations)\n    tuple val(cnv_meta), path(cnv)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path  \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def input            = input_2        ? \"${input_1} ${input_2}\"        : \"${input_1}\"\n    def targets_file     = target_bed     ? \"--target ${target_bed}\"       : \"\"\n    def samples_file     = samples        ? \"--samples ${samples}\"         : \"\"\n    def populations_file = populations    ? \"--populations ${populations}\" : \"\"\n    def cnv_file         = cnv            ? \"--cnv-map ${cnv}\"             : \"\"\n\n    \"\"\"\n    freebayes \\\\\n        -f $fasta \\\\\n        $targets_file \\\\\n        $samples_file \\\\\n        $populations_file \\\\\n        $cnv_file \\\\\n        $args \\\\\n        $input > ${prefix}.vcf\n\n    bgzip ${prefix}.vcf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        freebayes: \\$(echo \\$(freebayes --version 2>&1) | sed 's/version:\\s*v//g' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Convert a BED file to a VCF file according to a YAML config\nTags: bed, vcf, conversion, variants", "answer": "process BEDGOVCF {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bedgovcf:0.1.1--h9ee0642_1':\n        'biocontainers/bedgovcf:0.1.1--h9ee0642_1' }\"\n\n    input:\n    tuple val(meta), path(bed), path(config)\n    tuple val(meta2), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\"), emit: vcf\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    bedgovcf \\\\\n        $args \\\\\n        --bed $bed \\\\\n        --fai $fai \\\\\n        --config $config \\\\\n        | bgzip --stdout --threads $task.cpus $args2 > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedgovcf: \\$(echo \\$(bedgovcf --version 2>&1) | sed 's/^bedgovcf version //' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bedgovcf: \\$(echo \\$(bedgovcf --version 2>&1) | sed 's/^bedgovcf version //' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Perform adapter/quality trimming on sequencing reads\nTags: trimming, quality control, fastq", "answer": "process FASTP {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fastp:0.23.4--h5f740d0_0' :\n        'biocontainers/fastp:0.23.4--h5f740d0_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  adapter_fasta\n    val   discard_trimmed_pass\n    val   save_trimmed_fail\n    val   save_merged\n\n    output:\n    tuple val(meta), path('*.fastp.fastq.gz') , optional:true, emit: reads\n    tuple val(meta), path('*.json')           , emit: json\n    tuple val(meta), path('*.html')           , emit: html\n    tuple val(meta), path('*.log')            , emit: log\n    tuple val(meta), path('*.fail.fastq.gz')  , optional:true, emit: reads_fail\n    tuple val(meta), path('*.merged.fastq.gz'), optional:true, emit: reads_merged\n    path \"versions.yml\"                       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def adapter_list = adapter_fasta ? \"--adapter_fasta ${adapter_fasta}\" : \"\"\n    def fail_fastq = save_trimmed_fail && meta.single_end ? \"--failed_out ${prefix}.fail.fastq.gz\" : save_trimmed_fail && !meta.single_end ? \"--failed_out ${prefix}.paired.fail.fastq.gz --unpaired1 ${prefix}_1.fail.fastq.gz --unpaired2 ${prefix}_2.fail.fastq.gz\" : ''\n    def out_fq1 = discard_trimmed_pass ?: ( meta.single_end ? \"--out1 ${prefix}.fastp.fastq.gz\" : \"--out1 ${prefix}_1.fastp.fastq.gz\" )\n    def out_fq2 = discard_trimmed_pass ?: \"--out2 ${prefix}_2.fastp.fastq.gz\"\n    // Added soft-links to original fastqs for consistent naming in MultiQC\n    // Use single ended for interleaved. Add --interleaved_in in config.\n    if ( task.ext.args?.contains('--interleaved_in') ) {\n        \"\"\"\n        [ ! -f  ${prefix}.fastq.gz ] && ln -sf $reads ${prefix}.fastq.gz\n\n        fastp \\\\\n            --stdout \\\\\n            --in1 ${prefix}.fastq.gz \\\\\n            --thread $task.cpus \\\\\n            --json ${prefix}.fastp.json \\\\\n            --html ${prefix}.fastp.html \\\\\n            $adapter_list \\\\\n            $fail_fastq \\\\\n            $args \\\\\n            2> >(tee ${prefix}.fastp.log >&2) \\\\\n        | gzip -c > ${prefix}.fastp.fastq.gz\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            fastp: \\$(fastp --version 2>&1 | sed -e \"s/fastp //g\")\n        END_VERSIONS\n        \"\"\"\n    } else if (meta.single_end) {\n        \"\"\"\n        [ ! -f  ${prefix}.fastq.gz ] && ln -sf $reads ${prefix}.fastq.gz\n\n        fastp \\\\\n            --in1 ${prefix}.fastq.gz \\\\\n            $out_fq1 \\\\\n            --thread $task.cpus \\\\\n            --json ${prefix}.fastp.json \\\\\n            --html ${prefix}.fastp.html \\\\\n            $adapter_list \\\\\n            $fail_fastq \\\\\n            $args \\\\\n            2> >(tee ${prefix}.fastp.log >&2)\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            fastp: \\$(fastp --version 2>&1 | sed -e \"s/fastp //g\")\n        END_VERSIONS\n        \"\"\"\n    } else {\n        def merge_fastq = save_merged ? \"-m --merged_out ${prefix}.merged.fastq.gz\" : ''\n        \"\"\"\n        [ ! -f  ${prefix}_1.fastq.gz ] && ln -sf ${reads[0]} ${prefix}_1.fastq.gz\n        [ ! -f  ${prefix}_2.fastq.gz ] && ln -sf ${reads[1]} ${prefix}_2.fastq.gz\n        fastp \\\\\n            --in1 ${prefix}_1.fastq.gz \\\\\n            --in2 ${prefix}_2.fastq.gz \\\\\n            $out_fq1 \\\\\n            $out_fq2 \\\\\n            --json ${prefix}.fastp.json \\\\\n            --html ${prefix}.fastp.html \\\\\n            $adapter_list \\\\\n            $fail_fastq \\\\\n            $merge_fastq \\\\\n            --thread $task.cpus \\\\\n            --detect_adapter_for_pe \\\\\n            $args \\\\\n            2> >(tee ${prefix}.fastp.log >&2)\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            fastp: \\$(fastp --version 2>&1 | sed -e \"s/fastp //g\")\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix              = task.ext.prefix ?: \"${meta.id}\"\n    def is_single_output    = task.ext.args?.contains('--interleaved_in') || meta.single_end\n    def touch_reads         = (discard_trimmed_pass) ? \"\" : (is_single_output) ? \"echo '' | gzip > ${prefix}.fastp.fastq.gz\" : \"echo '' | gzip > ${prefix}_1.fastp.fastq.gz ; echo '' | gzip > ${prefix}_2.fastp.fastq.gz\"\n    def touch_merged        = (!is_single_output && save_merged) ? \"echo '' | gzip >  ${prefix}.merged.fastq.gz\" : \"\"\n    def touch_fail_fastq    = (!save_trimmed_fail) ? \"\" : meta.single_end ? \"echo '' | gzip > ${prefix}.fail.fastq.gz\" : \"echo '' | gzip > ${prefix}.paired.fail.fastq.gz ; echo '' | gzip > ${prefix}_1.fail.fastq.gz ; echo '' | gzip > ${prefix}_2.fail.fastq.gz\"\n    \"\"\"\n    $touch_reads\n    $touch_fail_fastq\n    $touch_merged\n    touch \"${prefix}.fastp.json\"\n    touch \"${prefix}.fastp.html\"\n    touch \"${prefix}.fastp.log\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastp: \\$(fastp --version 2>&1 | sed -e \"s/fastp //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A Python application to generate self-contained HTML reports for variant review and other genomic applications\nTags: vcf, variant, genomics", "answer": "process IGVREPORTS {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/igv-reports:1.12.0--pyh7cba7a3_0':\n        'biocontainers/igv-reports:1.12.0--pyh7cba7a3_0' }\"\n\n    input:\n    tuple val(meta), path(sites), path(tracks), path(tracks_indicies)\n    tuple val(meta2), path(fasta), path(fai)\n\n    output:\n    tuple val(meta), path(\"*.html\") , emit: report\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def fasta = fasta ? \"--fasta ${fasta}\" : \"\"\n    // If tracks is not null, create a string of the track paths\n    def track_arg = tracks ? \"--tracks \"+ tracks.collect { it.toString() }.join(' ') : \"\"\n    // if \"--tracks\" is in the args, then add track_string immediately after it in\n    // the args string and set the track_arg to \"\"\n    if (args.contains(\"--tracks\") && track_arg) {\n        args = args.replace(\"--tracks\", track_arg)\n        track_arg = \"\"\n    }\n\n    \"\"\"\n    create_report $sites \\\n    $args \\\n    $fasta \\\n    $track_arg \\\n    --output ${prefix}_report.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        igvreports: \\$(python -c \"import igv_reports; print(igv_reports.__version__)\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}_report.html\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        igvreports: \\$(python -c \"import igv_reports; print(igv_reports.__version__)\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Align sequences using learnMSA\nTags: alignment, MSA, genomics", "answer": "process LEARNMSA_ALIGN {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-741e0da5cf2d6d964f559672e2908c2111cbb46b:4930edd009376542543bfd2e20008bb1ae58f841-0' :\n        'biocontainers/mulled-v2-741e0da5cf2d6d964f559672e2908c2111cbb46b:4930edd009376542543bfd2e20008bb1ae58f841-0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    val(compress)\n\n    output:\n    tuple val(meta), path(\"*.aln{.gz,}\"), emit: alignment\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def write_output = compress ? \">(pigz -cp ${task.cpus} > ${prefix}.aln.gz)\" : \"${prefix}.aln\"\n    \"\"\"\n    learnMSA \\\\\n        $args \\\\\n        -i <(unpigz -cdf $fasta) \\\\\n        -o $write_output\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        learnmsa: \\$(learnMSA -h | grep 'version' | awk -F 'version ' '{print \\$2}' | awk '{print \\$1}' | sed 's/)//g')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.aln${compress ? '.gz' : ''}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        learnmsa: \\$(learnMSA -h | grep 'version' | awk -F 'version ' '{print \\$2}' | awk '{print \\$1}' | sed 's/)//g')\n        pigz: \\$(echo \\$(pigz --version 2>&1) | sed 's/^.*pigz\\\\w*//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sort GTF files in chr/pos/feature order\nTags: sort, example, genomics", "answer": "process GTFSORT {\n    tag \"$gtf\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gtfsort:0.2.2--h4ac6f70_0':\n        'biocontainers/gtfsort:0.2.2--h4ac6f70_0' }\"\n\n    input:\n\n    path gtf\n\n    output:\n    path \"*.sorted.gtf\", emit: gtf\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}\"\n\n    \"\"\"\n    gtfsort \\\\\n        -i $gtf \\\\\n        -o ${prefix}.sorted.gtf \\\\\n        -t $task.cpus\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gtfsort: \\$(gtfsort --version |& sed 's/gtfsort //')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${gtf.baseName}\"\n\n    \"\"\"\n    touch ${prefix}.sorted.gtf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gtfsort: \\$(gtfsort --version |& sed 's/gtfsort //')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Classifies metagenomic sequence data using unique k-mer counts\nTags: classify, metagenomics, kmers, fastq, db", "answer": "process KRAKENUNIQ_PRELOADEDKRAKENUNIQ {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krakenuniq:1.0.4--pl5321h6dccd9a_2':\n        'biocontainers/krakenuniq:1.0.4--pl5321h6dccd9a_2' }\"\n\n    input:\n    tuple val(meta), path(sequences)\n    val sequence_type\n    path db\n    val ram_chunk_size\n    val save_output_reads\n    val report_file\n    val save_output\n\n    output:\n    tuple val(meta), path(\"*.classified.${sequence_type}.gz\")  , optional:true, emit: classified_reads\n    tuple val(meta), path(\"*.unclassified.${sequence_type}.gz\"), optional:true, emit: unclassified_reads\n    tuple val(meta), path('*.krakenuniq.classified.txt')       , optional:true, emit: classified_assignment\n    tuple val(meta), path('*.krakenuniq.report.txt')           , emit: report\n    path \"versions.yml\"                                        , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    assert sequence_type in ['fasta', 'fastq']\n\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args ?: ''\n\n    classified   = meta.single_end ? \"\\${PREFIX}.classified.${sequence_type}\"   : \"\\${PREFIX}.merged.classified.${sequence_type}\"\n    unclassified = meta.single_end ? \"\\${PREFIX}.unclassified.${sequence_type}\" : \"\\${PREFIX}.merged.unclassified.${sequence_type}\"\n    classified_option = save_output_reads ? \"--classified-out \\\"${classified}\\\"\" : ''\n    unclassified_option = save_output_reads ? \"--unclassified-out \\\"${unclassified}\\\"\" : ''\n    def output_option = save_output ? '--output \"\\${PREFIX}.krakenuniq.classified.txt\"' : ''\n    def report = report_file ? '--report-file \"\\${PREFIX}.krakenuniq.report.txt\"' : ''\n    compress_reads_command = save_output_reads ? \"find . -name '*.${sequence_type}' -print0 | xargs -0 -t -P ${task.cpus} -I % gzip --no-name %\" : ''\n    if (meta.single_end) {\n        \"\"\"\n        krakenuniq \\\\\n            $args \\\\\n            --db $db \\\\\n            --preload \\\\\n            --preload-size $ram_chunk_size \\\\\n            --threads $task.cpus\n\n        strip_suffix() {\n            local result=\\$1\n            # Strip any file extensions.\n            echo \"\\${result%%.*}\"\n        }\n\n        printf \"%s\\\\n\" ${sequences} | while read FASTQ; do \\\\\n            PREFIX=\"\\$(strip_suffix \"\\${FASTQ}\")\"\n\n            krakenuniq \\\\\n                --db $db \\\\\n                --threads $task.cpus \\\\\n                $report \\\\\n                $output_option \\\\\n                $unclassified_option \\\\\n                $classified_option \\\\\n                $args2 \\\\\n                \"\\${FASTQ}\"\n        done\n\n        $compress_reads_command\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            krakenuniq: \\$(echo \\$(krakenuniq --version 2>&1) | sed 's/^.*KrakenUniq version //; s/ .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        krakenuniq \\\\\n            $args \\\\\n            --db $db \\\\\n            --preload \\\\\n            --preload-size $ram_chunk_size \\\\\n            --threads $task.cpus\n\n        strip_suffix() {\n            local result\n            read result\n            # Strip any trailing dot or underscore.\n            result=\"\\${result%_}\"\n            echo \"\\${result%.}\"\n        }\n\n        printf \"%s %s\\\\n\" ${sequences} | while read FASTQ; do \\\\\n            read -r -a FASTQ <<< \"\\${FASTQ}\"\n            PREFIX=\"\\$(printf \"%s\\\\n\" \"\\${FASTQ[@]}\" |  sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' | strip_suffix)\"\n\n            krakenuniq \\\\\n                --db $db \\\\\n                --threads $task.cpus \\\\\n                $report \\\\\n                $output_option \\\\\n                $unclassified_option \\\\\n                $classified_option \\\\\n                --paired \\\\\n                $args2 \\\\\n                \"\\${FASTQ[@]}\"\n        done\n\n        $compress_reads_command\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            krakenuniq: \\$(echo \\$(krakenuniq --version 2>&1) | sed 's/^.*KrakenUniq version //; s/ .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    assert sequence_type in ['fasta', 'fastq']\n\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args ?: ''\n\n    classified   = meta.single_end ? \"\\${PREFIX}.classified.${sequence_type}\"   : \"\\${PREFIX}.merged.classified.${sequence_type}\"\n    unclassified = meta.single_end ? \"\\${PREFIX}.unclassified.${sequence_type}\" : \"\\${PREFIX}.merged.unclassified.${sequence_type}\"\n    classified_option = save_output_reads ? \"--classified-out \\\"${classified}\\\"\" : ''\n    unclassified_option = save_output_reads ? \"--unclassified-out \\\"${unclassified}\\\"\" : ''\n    def output_option = save_output ? '--output \"\\${PREFIX}.krakenuniq.classified.txt\"' : ''\n    def report = report_file ? '--report-file \"\\${PREFIX}.krakenuniq.report.txt\"' : ''\n    compress_reads_command = save_output_reads ? \"find . -name '*.${sequence_type}' -print0 | xargs -0 -t -P ${task.cpus} -I % gzip --no-name %\" : ''\n    if (meta.single_end) {\n        \"\"\"\n        echo krakenuniq \\\\\n            $args \\\\\n            --db $db \\\\\n            --preload \\\\\n            --preload-size $ram_chunk_size \\\\\n            --threads $task.cpus\n\n        strip_suffix() {\n            local result=\\$1\n            # Strip any file extensions.\n            echo \"\\${result%%.*}\"\n        }\n\n        create_file() {\n            echo '<3 nf-core' > \"\\$1\"\n        }\n\n        create_gzip_file() {\n            echo '<3 nf-core' | gzip -n > \"\\$1\"\n        }\n\n        printf \"%s\\\\n\" ${sequences} | while read FASTQ; do \\\\\n            echo \"\\${FASTQ}\"\n            PREFIX=\"\\$(strip_suffix \"\\${FASTQ}\")\"\n            echo \"\\${PREFIX}\"\n\n            echo krakenuniq \\\\\n                --db $db \\\\\n                --threads $task.cpus \\\\\n                $report \\\\\n                $output_option \\\\\n                $unclassified_option \\\\\n                $classified_option \\\\\n                $args2 \\\\\n                \"\\${FASTQ}\"\n\n            create_file \"\\${PREFIX}.krakenuniq.classified.txt\"\n            create_file \"\\${PREFIX}.krakenuniq.report.txt\"\n            create_gzip_file \"\\${PREFIX}.classified.${sequence_type}.gz\"\n            create_gzip_file \"\\${PREFIX}.unclassified.${sequence_type}.gz\"\n        done\n\n        echo \"$compress_reads_command\"\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            krakenuniq: \\$(echo \\$(krakenuniq --version 2>&1) | sed 's/^.*KrakenUniq version //; s/ .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        echo krakenuniq \\\\\n            $args \\\\\n            --db $db \\\\\n            --preload \\\\\n            --preload-size $ram_chunk_size \\\\\n            --threads $task.cpus\n\n        strip_suffix() {\n            local result\n            read result\n            # Strip any trailing dot or underscore.\n            result=\"\\${result%_}\"\n            echo \"\\${result%.}\"\n        }\n\n        create_file() {\n            echo '<3 nf-core' > \"\\$1\"\n        }\n\n        create_gzip_file() {\n            echo '<3 nf-core' | gzip -n > \"\\$1\"\n        }\n\n        printf \"%s %s\\\\n\" ${sequences} | while read FASTQ; do \\\\\n            read -r -a FASTQ <<< \"\\${FASTQ}\"\n            echo \"\\${FASTQ[@]}\"\n            PREFIX=\"\\$(printf \"%s\\\\n\" \"\\${FASTQ[@]}\" |  sed -e 'N;s/^\\\\(.*\\\\).*\\\\n\\\\1.*\\$/\\\\1\\\\n\\\\1/;D' | strip_suffix)\"\n            echo \"\\${PREFIX}\"\n\n            echo krakenuniq \\\\\n                --db $db \\\\\n                --threads $task.cpus \\\\\n                $report \\\\\n                $output_option \\\\\n                $unclassified_option \\\\\n                $classified_option \\\\\n                --paired \\\\\n                $args2 \\\\\n                \"\\${FASTQ[@]}\"\n\n            create_file \"\\${PREFIX}.krakenuniq.classified.txt\"\n            create_file \"\\${PREFIX}.krakenuniq.report.txt\"\n            create_gzip_file \"\\${PREFIX}.merged.classified.${sequence_type}.gz\"\n            create_gzip_file \"\\${PREFIX}.merged.unclassified.${sequence_type}.gz\"\n        done\n\n        echo \"$compress_reads_command\"\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            krakenuniq: \\$(echo \\$(krakenuniq --version 2>&1) | sed 's/^.*KrakenUniq version //; s/ .*\\$//')\n        END_VERSIONS\n        \"\"\"\n    }\n}\n"}
{"question": "Description: Download KrakenUniq databases and related fles\nTags: metagenomics, krakenuniq, database, download, ncbi", "answer": "process KRAKENUNIQ_DOWNLOAD {\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krakenuniq:1.0.4--pl5321h6dccd9a_2':\n        'biocontainers/krakenuniq:1.0.4--pl5321h6dccd9a_2' }\"\n\n    input:\n    val pattern\n\n    output:\n    path \"${pattern}/\"  , emit: output\n    path \"versions.yml\" , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    krakenuniq-download \\\\\n        --threads ${task.cpus} \\\\\n        -o ${pattern}/ \\\\\n        ${pattern} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        krakenuniq: \\$(echo \\$(krakenuniq --version 2>&1) | sed 's/^.*KrakenUniq version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download and build (custom) KrakenUniq databases\nTags: metagenomics, krakenuniq, database, build, ncbi", "answer": "process KRAKENUNIQ_BUILD {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/krakenuniq:1.0.4--pl5321h6dccd9a_2':\n        'biocontainers/krakenuniq:1.0.4--pl5321h6dccd9a_2' }\"\n\n    input:\n    tuple val(meta), path(custom_library_dir, stageAs: \"library/*\"), path(custom_taxonomy_dir, stageAs: \"taxonomy\"), path(custom_seqid2taxid)\n\n    output:\n    tuple val(meta), path(\"$prefix/\"), emit: db\n    path \"versions.yml\"       , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    custom_db     = custom_library_dir ? \"mkdir $prefix && mv library taxonomy $custom_seqid2taxid $prefix\" : \"\"\n    \"\"\"\n    $custom_db\n\n    krakenuniq-build \\\\\n        $args \\\\\n        --threads ${task.cpus} \\\\\n        --db ${prefix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        krakenuniq: \\$(echo \\$(krakenuniq --version 2>&1) | sed 's/^.*KrakenUniq version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Peak calling of enriched genomic regions of ChIP-seq and ATAC-seq experiments\nTags: alignment, atac-seq, chip-seq, peak-calling", "answer": "\nprocess MACS3_CALLPEAK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/macs3:3.0.1--py311h0152c62_3':\n        'biocontainers/macs3:3.0.1--py311h0152c62_3' }\"\n\n    input:\n    tuple val(meta), path(ipbam), path(controlbam)\n    val   macs3_gsize\n\n    output:\n    tuple val(meta), path(\"*.{narrowPeak,broadPeak}\"), emit: peak\n    tuple val(meta), path(\"*.xls\")                   , emit: xls\n    path  \"versions.yml\"                             , emit: versions\n\n    tuple val(meta), path(\"*.gappedPeak\"), optional:true, emit: gapped\n    tuple val(meta), path(\"*.bed\")       , optional:true, emit: bed\n    tuple val(meta), path(\"*.bdg\")       , optional:true, emit: bdg\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def args_list = args.tokenize()\n    def format    = meta.single_end ? 'BAM' : 'BAMPE'\n    def control   = controlbam ? \"--control $controlbam\" : ''\n    if(args_list.contains('--format')){\n        def id = args_list.findIndexOf{it=='--format'}\n        format = args_list[id+1]\n        args_list.remove(id+1)\n        args_list.remove(id)\n    }\n    \"\"\"\n    macs3 \\\\\n        callpeak \\\\\n        ${args_list.join(' ')} \\\\\n        --gsize $macs3_gsize \\\\\n        --format $format \\\\\n        --name $prefix \\\\\n        --treatment $ipbam \\\\\n        $control\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        macs3: \\$(macs3 --version | sed -e \"s/macs3 //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.gappedPeak\n    touch ${prefix}.bed\n    touch ${prefix}.bdg\n    touch ${prefix}.narrowPeak\n    touch ${prefix}.xls\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        macs3: \\$(macs3 --version | sed -e \"s/macs3 //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: DeDup is a tool for read deduplication in paired-end read merging (e.g. for ancient DNA experiments).\nTags: dedup, deduplication, pcr duplicates, ancient DNA, paired-end, bam", "answer": "process DEDUP {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/dedup:0.12.8--hdfd78af_1' :\n        'biocontainers/dedup:0.12.8--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(bam)\n\n    output:\n    tuple val(meta), path(\"*_rmdup.bam\"), emit: bam     // _rmdup is hardcoded output from dedup\n    tuple val(meta), path(\"*.json\")     , emit: json\n    tuple val(meta), path(\"*.hist\")     , emit: hist\n    tuple val(meta), path(\"*log\")       , emit: log\n    path \"versions.yml\"                 , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    dedup \\\\\n        -Xmx${task.memory.toGiga()}g  \\\\\n        -i $bam \\\\\n        -o . \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        dedup: \\$( echo \\$(dedup --version 2>&1) | tail -n 1 | sed 's/.* v//')\n\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Fast, efficient, lossless compression of FASTQ files.\nTags: FASTQ, compression, lossless", "answer": "process SPRING_COMPRESS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/spring:1.1.1--h9f5acd7_0' :\n        'biocontainers/spring:1.1.1--h9f5acd7_0' }\"\n\n    input:\n    tuple val(meta), path(fastq1), path(fastq2)\n\n    output:\n    tuple val(meta), path(\"*.spring\"), emit: spring\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.1.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def input = meta.single_end ? \"-i ${fastq1}\" : \"-i ${fastq1} ${fastq2}\"\n\n    \"\"\"\n    spring \\\\\n        -c \\\\\n        -g \\\\\n        -t ${task.cpus} \\\\\n        $args \\\\\n        ${input} \\\\\n        -o ${prefix}.spring\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spring: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Fast, efficient, lossless decompression of FASTQ files.\nTags: FASTQ, decompression, lossless", "answer": "process SPRING_DECOMPRESS {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/spring:1.1.1--h4ac6f70_2' :\n        'biocontainers/spring:1.1.1--h4ac6f70_2' }\"\n\n    input:\n    tuple val(meta), path(spring)\n    val(write_one_fastq_gz)\n\n    output:\n    tuple val(meta), path(\"*.fastq.gz\"), emit: fastq\n    path \"versions.yml\"                , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.1.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    def output = write_one_fastq_gz ? \"-o ${prefix}.fastq.gz\" : \"-o ${prefix}_R1.fastq.gz ${prefix}_R2.fastq.gz\"\n\n    \"\"\"\n    spring \\\\\n        -d \\\\\n        -g \\\\\n        -t ${task.cpus} \\\\\n        $args \\\\\n        -i ${spring} \\\\\n        ${output}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        spring: ${VERSION}\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: main GLIMPSE algorithm, performs phasing and imputation refining genotype likelihoods\nTags: phase, imputation, low-coverage, glimpse", "answer": "process GLIMPSE_PHASE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:1.1.1--hce55b13_1':\n        'biocontainers/glimpse-bio:1.1.1--hce55b13_1' }\"\n\n    input:\n        tuple val(meta) , path(input), path(input_index), path(samples_file), val(input_region), val(output_region), path(reference), path(reference_index), path(map)\n\n    output:\n        tuple val(meta), path(\"*.{vcf,bcf,vcf.gz,bcf.gz}\"), emit: phased_variants\n        path \"versions.yml\"                               , emit: versions\n\n    when:\n        task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_${input_region.replace(\":\",\"_\")}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n\n    def map_command           = map           ? \"--map $map\"                    :\"\"\n    def samples_file_command  = samples_file  ? \"--samples-file $samples_file\"  :\"\"\n\n    \"\"\"\n    GLIMPSE_phase \\\\\n        $args \\\\\n        --input $input \\\\\n        --reference $reference \\\\\n        $map_command \\\\\n        $samples_file_command \\\\\n        --input-region $input_region \\\\\n        --output-region $output_region \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_phase --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_${input_region.replace(\":\",\"_\")}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_phase --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Concatenates imputation chunks in a single VCF/BCF file ligating phased information.\nTags: ligate, low-coverage, glimpse, imputation", "answer": "process GLIMPSE_LIGATE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:1.1.1--hce55b13_1':\n        'biocontainers/glimpse-bio:1.1.1--hce55b13_1' }\"\n\n    input:\n    tuple val(meta), path(input_list), path(input_index)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,bcf,vcf.gz,bcf.gz}\"), emit: merged_variants\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    printf \"%s\\\\n\" $input_list | tr -d '[],' > all_files.txt\n\n    GLIMPSE_ligate \\\\\n        $args \\\\\n        --input all_files.txt \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            glimpse: \"\\$(GLIMPSE_ligate --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    def args    = task.ext.args   ?: \"\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_ligate --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Defines chunks where to run imputation\nTags: chunk, imputation, low coverage", "answer": "process GLIMPSE_CHUNK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:1.1.1--h2ce4488_2':\n        'biocontainers/glimpse-bio:1.1.1--hce55b13_1' }\"\n\n    input:\n    tuple val(meta), path(input), path(input_index), val(region)\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: chunk_chr\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def args    = task.ext.args   ?: \"\"\n\n    \"\"\"\n    GLIMPSE_chunk \\\\\n        $args \\\\\n        --input $input \\\\\n        --region $region \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_chunk --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def args    = task.ext.args   ?: \"\"\n    \"\"\"\n    touch ${prefix}.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_chunk --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Generates haplotype calls by sampling haplotype estimates\nTags: Sample, Haplotypes, Imputation", "answer": "process GLIMPSE_SAMPLE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:1.1.1--hce55b13_1':\n        'biocontainers/glimpse-bio:1.1.1--hce55b13_1' }\"\n\n    input:\n    tuple val(meta), path(input)\n\n    output:\n    tuple val(meta), path(\"*.{vcf,bcf,vcf.gz,bcf.gz}\"), emit: haplo_sampled\n    path \"versions.yml\"                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n\n    \"\"\"\n    GLIMPSE_sample \\\\\n        $args \\\\\n        --input $input \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_sample --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args   = task.ext.args   ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = task.ext.suffix ?: \"vcf.gz\"\n    \"\"\"\n    touch ${prefix}.${suffix}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_sample --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compute the r2 correlation between imputed dosages (in MAF bins) and highly-confident genotype calls from the high-coverage dataset.\nTags: concordance, low-coverage, glimpse, imputation", "answer": "process GLIMPSE_CONCORDANCE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/glimpse-bio:1.1.1--hce55b13_1':\n        'biocontainers/glimpse-bio:1.1.1--hce55b13_1' }\"\n\n    input:\n    tuple val(meta), path(estimate), path(estimate_index), path(freq), path(freq_index), path(truth), path(truth_index), val(region)\n    val(min_prob)\n    val(min_dp)\n    val(bins)\n\n    output:\n    tuple val(meta), path(\"*.error.cal.txt.gz\")  , emit: errors_cal\n    tuple val(meta), path(\"*.error.grp.txt.gz\")  , emit: errors_grp\n    tuple val(meta), path(\"*.error.spl.txt.gz\")  , emit: errors_spl\n    tuple val(meta), path(\"*.rsquare.grp.txt.gz\"), emit: rsquare_grp\n    tuple val(meta), path(\"*.rsquare.spl.txt.gz\"), emit: rsquare_spl\n    path \"versions.yml\"                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args         = task.ext.args   ?: ''\n    def prefix       = task.ext.prefix ?: \"${meta.id}\"\n    def min_prob_cmd = min_prob ? \"--minPROB ${min_prob}\" : \"--minPROB 0.9999\"\n    def min_dp_cmd   = min_dp   ? \"--minDP ${min_dp}\"     : \"--minDP 8\"\n    def bins_cmd     = bins     ? \"--bins ${bins}\"        : \"--bins 0.00000 0.00100 0.00200 0.00500 0.01000 0.05000 0.10000 0.20000 0.50000\"\n    \"\"\"\n    echo $region $freq $truth $estimate > input.txt\n    GLIMPSE_concordance \\\\\n        $args \\\\\n        --input input.txt \\\\\n        --thread $task.cpus \\\\\n        --output ${prefix} \\\\\n        $min_prob_cmd \\\\\n        $min_dp_cmd \\\\\n        $bins_cmd\n\n    cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            glimpse: \"\\$(GLIMPSE_concordance --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix  = task.ext.prefix ?: \"${meta.id}\"\n    def args    = task.ext.args   ?: \"\"\n    \"\"\"\n    touch ${prefix}.error.cal.txt.gz\n    touch ${prefix}.error.grp.txt.gz\n    touch ${prefix}.error.spl.txt.gz\n    touch ${prefix}.rsquare.grp.txt.gz\n    touch ${prefix}.rsquare.spl.txt.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        glimpse: \"\\$(GLIMPSE_concordance --help | sed -nr '/Version/p' | grep -o -E '([0-9]+.){1,2}[0-9]')\"\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Deduplicate reads based on the mapping co-ordinate and the UMI attached to the read.\nTags: umicollapse, deduplication, genomics", "answer": "process UMICOLLAPSE {\n    tag \"$meta.id\"\n    label \"process_high\"\n    label \"process_high_memory\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/umicollapse:1.0.0--hdfd78af_1' :\n        'biocontainers/umicollapse:1.0.0--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(input), path(bai)\n    val(mode)\n\n    output:\n    tuple val(meta), path(\"*.bam\"),                   emit: bam,        optional: true\n    tuple val(meta), path(\"*dedup*fastq.gz\"),         emit: fastq,      optional: true\n    tuple val(meta), path(\"*_UMICollapse.log\"),       emit: log\n    path  \"versions.yml\" ,                            emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args   = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.0-1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    // Memory allocation: We need to make sure that both heap and stack size is sufficiently large for\n    // umicollapse. We set the stack size to 5% of the available memory, the heap size to 90%\n    // which leaves 5% for stuff happening outside of java without the scheduler killing the process.\n    def max_heap_size_mega = (task.memory.toMega() * 0.9).intValue()\n    def max_stack_size_mega = 999 //most java jdks will not allow Xss > 1GB, so fixing this to the allowed max\n    if ( mode !in [ 'fastq', 'bam' ] ) {\n        error \"Mode must be one of 'fastq' or 'bam'.\"\n    }\n    extension = mode.contains(\"fastq\") ? \"fastq.gz\" : \"bam\"\n    \"\"\"\n    # Getting the umicollapse jar file like this because `umicollapse` is a Python wrapper script generated\n    # by conda that allows to set the heap size (Xmx), but not the stack size (Xss).\n    # `which` allows us to get the directory that contains `umicollapse`, independent of whether we\n    # are in a container or conda environment.\n    UMICOLLAPSE_JAR=\\$(dirname \\$(which umicollapse))/../share/umicollapse-${VERSION}/umicollapse.jar\n    java \\\\\n        -Xmx${max_heap_size_mega}M \\\\\n        -Xss${max_stack_size_mega}M \\\\\n        -jar \\$UMICOLLAPSE_JAR \\\\\n        $mode \\\\\n        -i ${input} \\\\\n        -o ${prefix}.${extension} \\\\\n        $args | tee ${prefix}_UMICollapse.log\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umicollapse: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '1.0.0-1'\n    if ( mode !in [ 'fastq', 'bam' ] ) {\n        error \"Mode must be one of 'fastq' or 'bam'.\"\n    }\n    extension = mode.contains(\"fastq\") ? \"fastq.gz\" : \"bam\"\n    \"\"\"\n    touch ${prefix}.dedup.${extension}\n    touch ${prefix}_UMICollapse.log\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        umicollapse: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Advanced sequence file format conversions\nTags: sam, bam, cram, compression", "answer": "process STADENIOLIB_SCRAMBLE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/staden_io_lib:1.14.14--h0d9da7e_3' :\n        'biocontainers/staden_io_lib:1.14.14--h0d9da7e_3' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path(fasta)\n    path(fai)\n    path(gzi)\n\n    output:\n    tuple val(meta), path(\"*.cram\") ,emit: cram\n    path \"*.gzi\"                    ,emit: gzi, optional: true\n    path \"versions.yml\"             ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    def inputformat = reads.getExtension\n    def outputformat = \"cram\"\n    if (\"-O sam\" in args) {\n        outputformat = \"sam\"\n    } else if (\"-O bam\" in args) {\n        outputformat = \"bam\"\n    }\n\n    def reference = if fasta && fai : \"--r ${fasta}\" else \"\"\n    if (outputformat == \"cram\" && !reference) {\n        error \"Cannot convert to CRAM without a reference\"\n    }\n\n    def gz_index = if gzi : \"--g ${gzi}\" else \"\"\n    if (outputformat == \"cram\" || outputformat == \"sam\") {\n        gz_index = \"\"\n        warning \"Cannot use gzip index for CRAM or SAM output\"\n    }\n\n    \"\"\"\n    scramble \\\n        $args \\\n        -I ${inputformat} \\\n        $reference \\\n        -t $task.cpus \\\n        ${reads} \\\n        ${prefix}.${outputformat}\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        stadeniolib: \\$(echo \\$(scramble -h | head -n 1 |sed 's/^.*version //'))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Fetch the GO concepts for a list of genes\nTags: mygene, go, annotation", "answer": "process MYGENE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mygene:3.2.2--pyh5e36f6f_0':\n        'biocontainers/mygene:3.2.2--pyh5e36f6f_0' }\"\n\n    input:\n    tuple val(meta), path(gene_list)\n\n    output:\n    tuple val(meta), path(\"*.gmt\"), emit: gmt\n    tuple val(meta), path(\"*.tsv\"), emit: tsv     , optional: true\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    template \"mygene.py\"\n}\n"}
{"question": "Description: Determine Streptococcus pneumoniae serotype from Illumina paired-end reads\nTags: fastq, serotype, Streptococcus pneumoniae", "answer": "process SEROBA_RUN {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/seroba:1.0.2--pyhdfd78af_1':\n        'biocontainers/seroba:1.0.2--pyhdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"${prefix}/${prefix}.tsv\")                              , emit: tsv\n    tuple val(meta), path(\"${prefix}/detailed_serogroup_info.txt\"), optional: true, emit: txt\n    path \"versions.yml\"                                                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    seroba \\\\\n        runSerotyping \\\\\n        $reads \\\\\n        $prefix \\\\\n        $args\n\n    # Avoid name collisions\n    mv ${prefix}/pred.tsv ${prefix}/${prefix}.tsv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        seroba: \\$(seroba version)\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Estimate repeat sizes using NGS data\nTags: STR, repeat_expansions, bam, cram, vcf, json", "answer": "process EXPANSIONHUNTER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/expansionhunter:5.0.0--hf366f20_0' :\n        'biocontainers/expansionhunter:5.0.0--hf366f20_0' }\"\n\n    input:\n    tuple val(meta), path(bam), path(bai)\n    tuple val(meta2), path(fasta)\n    tuple val(meta3), path(fasta_fai)\n    tuple val(meta4), path(variant_catalog)\n\n    output:\n    tuple val(meta), path(\"*.vcf.gz\")        , emit: vcf\n    tuple val(meta), path(\"*.json.gz\")       , emit: json\n    tuple val(meta), path(\"*_realigned.bam\") , emit: bam\n    path \"versions.yml\"                      , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def args2 = task.ext.args2 ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n\n    \"\"\"\n    ExpansionHunter \\\\\n        ${args} \\\\\n        --reads ${bam} \\\\\n        --output-prefix ${prefix} \\\\\n        --reference ${fasta} \\\\\n        --variant-catalog ${variant_catalog}\n\n    bgzip --threads ${task.cpus} ${args2} ${prefix}.vcf\n    bgzip --threads ${task.cpus} ${args2} ${prefix}.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        expansionhunter: \\$( echo \\$(ExpansionHunter --version 2>&1) | head -1 | sed 's/^.*ExpansionHunter v//')\n        bgzip: \\$(echo \\$(bgzip -h 2>&1) | sed 's/^.*Version: //;s/Usage:.*//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.vcf.gz\n    echo \"\" | gzip > ${prefix}.json.gz\n    touch ${prefix}_realigned.bam\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        expansionhunter: \\$( echo \\$(ExpansionHunter --version 2>&1) | head -1 | sed 's/^.*ExpansionHunter v//')\n        bgzip: \\$(echo \\$(bgzip -h 2>&1) | sed 's/^.*Version: //;s/Usage:.*//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: vcf2maf\nTags: vcf, maf, annotation", "answer": "process VCF2MAF {\n\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-b6fc09bed47d0dc4d8384ce9e04af5806f2cc91b:305092c6f8420acd17377d2cc8b96e1c3ccb7d26-0':\n        'biocontainers/mulled-v2-b6fc09bed47d0dc4d8384ce9e04af5806f2cc91b:305092c6f8420acd17377d2cc8b96e1c3ccb7d26-0' }\"\n\n    input:\n    tuple val(meta), path(vcf) // Use an uncompressed VCF file!\n    path fasta                 // Required\n    path vep_cache             // Required for VEP running. A default of /.vep is supplied.\n\n    output:\n    tuple val(meta), path(\"*.maf\"), emit: maf\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args          = task.ext.args   ?: ''\n    def prefix        = task.ext.prefix ?: \"${meta.id}\"\n    def vep_cache_cmd = vep_cache       ? \"--vep-data $vep_cache\" : \"\"\n    // If VEP is present, it will find it and add it to commands.\n    // If VEP is not present they will be blank\n    def VERSION = '1.6.21' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    if command -v vep &> /dev/null\n    then\n        VEP_CMD=\"--vep-path \\$(dirname \\$(type -p vep))\"\n        VEP_VERSION=\\$(echo -e \"\\\\n    ensemblvep: \\$( echo \\$(vep --help 2>&1) | sed 's/^.*Versions:.*ensembl-vep : //;s/ .*\\$//')\")\n    else\n        VEP_CMD=\"\"\n        VEP_VERSION=\"\"\n    fi\n\n    vcf2maf.pl \\\\\n        $args \\\\\n        \\$VEP_CMD \\\\\n        $vep_cache_cmd \\\\\n        --ref-fasta $fasta \\\\\n        --input-vcf $vcf \\\\\n        --output-maf ${prefix}.maf\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        vcf2maf: $VERSION\\$VEP_VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Prodigal (Prokaryotic Dynamic Programming Genefinding Algorithm) is a microbial (bacterial and archaeal) gene finding program\nTags: prokaryotes, gene finding, microbial", "answer": "process PRODIGAL {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/mulled-v2-2e442ba7b07bfa102b9cf8fac6221263cd746ab8:57f05cfa73f769d6ed6d54144cb3aa2a6a6b17e0-0' :\n        'biocontainers/mulled-v2-2e442ba7b07bfa102b9cf8fac6221263cd746ab8:57f05cfa73f769d6ed6d54144cb3aa2a6a6b17e0-0' }\"\n\n    input:\n    tuple val(meta), path(genome)\n    val(output_format)\n\n    output:\n    tuple val(meta), path(\"${prefix}.${output_format}.gz\"),    emit: gene_annotations\n    tuple val(meta), path(\"${prefix}.fna.gz\"),                 emit: nucleotide_fasta\n    tuple val(meta), path(\"${prefix}.faa.gz\"),                 emit: amino_acid_fasta\n    tuple val(meta), path(\"${prefix}_all.txt.gz\"),             emit: all_gene_annotations\n    path \"versions.yml\",                                       emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pigz -cdf ${genome} | prodigal \\\\\n        $args \\\\\n        -f $output_format \\\\\n        -d \"${prefix}.fna\" \\\\\n        -o \"${prefix}.${output_format}\" \\\\\n        -a \"${prefix}.faa\" \\\\\n        -s \"${prefix}_all.txt\"\n\n    pigz -nm ${prefix}.fna\n    pigz -nm ${prefix}.${output_format}\n    pigz -nm ${prefix}.faa\n    pigz -nm ${prefix}_all.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        prodigal: \\$(prodigal -v 2>&1 | sed -n 's/Prodigal V\\\\(.*\\\\):.*/\\\\1/p')\n        pigz: \\$(pigz -V 2>&1 | sed 's/pigz //g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    touch ${prefix}.fna.gz\n    touch ${prefix}.${output_format}.gz\n    touch ${prefix}.faa.gz\n    touch ${prefix}_all.txt.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        prodigal: \\$(prodigal -v 2>&1 | sed -n 's/Prodigal V\\\\(.*\\\\):.*/\\\\1/p')\n        pigz: \\$(pigz -V 2>&1 | sed 's/pigz //g')\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: tool that takes either fragmented metagenomic data or longer sequences as input and predicts and delivers full-length antiobiotic resistance genes as output.\nTags: antibiotic resistance genes, ARGs, identifier, metagenomic, contigs", "answer": "process FARGENE {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/fargene:0.1--py27h21c881e_4' :\n        'biocontainers/fargene:0.1--py27h21c881e_4' }\"\n\n    input:\n    // input may be fasta (for genomes or longer contigs) or paired-end fastq (for metagenome), the latter in addition with --meta flag\n    tuple val(meta), path(input)\n    val hmm_model\n\n    output:\n    tuple val(meta), path(\"*.log\")                                                                               , emit: log\n    tuple val(meta), path(\"${prefix}/results_summary.txt\")                                                       , emit: txt\n    tuple val(meta), path(\"${prefix}/hmmsearchresults/*.out\")                                    , optional: true, emit: hmm\n    tuple val(meta), path(\"${prefix}/hmmsearchresults/retrieved-*.out\")                          , optional: true, emit: hmm_genes\n    tuple val(meta), path(\"${prefix}/predictedGenes/predicted-orfs.fasta\")                       , optional: true, emit: orfs\n    tuple val(meta), path(\"${prefix}/predictedGenes/predicted-orfs-amino.fasta\")                 , optional: true, emit: orfs_amino\n    tuple val(meta), path(\"${prefix}/predictedGenes/retrieved-contigs.fasta\")                    , optional: true, emit: contigs\n    tuple val(meta), path(\"${prefix}/predictedGenes/retrieved-contigs-peptides.fasta\")           , optional: true, emit: contigs_pept\n    tuple val(meta), path(\"${prefix}/predictedGenes/*filtered.fasta\")                            , optional: true, emit: filtered\n    tuple val(meta), path(\"${prefix}/predictedGenes/*filtered-peptides.fasta\")                   , optional: true, emit: filtered_pept\n    tuple val(meta), path(\"${prefix}/retrievedFragments/all_retrieved_*.fastq\")                  , optional: true, emit: fragments\n    tuple val(meta), path(\"${prefix}/retrievedFragments/trimmedReads/*.fasta\")                   , optional: true, emit: trimmed\n    tuple val(meta), path(\"${prefix}/spades_assembly/*\")                                         , optional: true, emit: spades\n    tuple val(meta), path(\"${prefix}/tmpdir/*.fasta\")                                            , optional: true, emit: metagenome\n    tuple val(meta), path(\"${prefix}/tmpdir/*.out\")                                              , optional: true, emit: tmp\n    path \"versions.yml\"                                                                          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    fargene \\\\\n        $args \\\\\n        -p $task.cpus \\\\\n        -i $input \\\\\n        --hmm-model $hmm_model \\\\\n        -o $prefix\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fargene: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n    def VERSION = '0.1' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    touch ${prefix}.log\n    mkdir -p ${prefix}/{hmmsearchresults,predictedGenes,retrievedFragments}\n    mkdir -p ${prefix}/retrievedFragments/trimmedReads/\n\n    touch ${prefix}/results_summary.txt\n    touch ${prefix}/hmmsearchresults/retrieved-${prefix}.out\n    touch ${prefix}/hmmsearchresults/${prefix}.out\n    touch ${prefix}/predictedGenes/predicted-orfs.fasta\n    touch ${prefix}/predictedGenes/predicted-orfs-amino.fasta\n    touch ${prefix}/predictedGenes/retrieved-contigs.fasta\n    touch ${prefix}/predictedGenes/retrieved-contigs-peptides.fasta\n    touch ${prefix}/predictedGenes/${prefix}-filtered.fasta\n    touch ${prefix}/predictedGenes/${prefix}-filtered-peptides.fasta\n    touch ${prefix}/retrievedFragments/all_retrieved_${prefix}.fastq\n    touch ${prefix}/retrievedFragments/trimmedReads/${prefix}.fasta\n\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fargene: $VERSION\n    END_VERSIONS\n    \"\"\"\n\n}\n"}
{"question": "Description: gene/transcript quantification with Salmon\nTags: index, fasta, genome, reference", "answer": "process SALMON_QUANT {\n    tag \"$meta.id\"\n    label \"process_medium\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/salmon:1.10.1--h7e5ed60_0' :\n        'biocontainers/salmon:1.10.1--h7e5ed60_0' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  index\n    path  gtf\n    path  transcript_fasta\n    val   alignment_mode\n    val   lib_type\n\n    output:\n    tuple val(meta), path(\"${prefix}\")              , emit: results\n    tuple val(meta), path(\"*info.json\")             , emit: json_info, optional: true\n    tuple val(meta), path(\"*lib_format_counts.json\"), emit: lib_format_counts, optional: true\n    path  \"versions.yml\"                            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args   ?: ''\n    prefix   = task.ext.prefix ?: \"${meta.id}\"\n\n    def reference   = \"--index $index\"\n    def reads1 = [], reads2 = []\n    meta.single_end ? [reads].flatten().each{reads1 << it} : reads.eachWithIndex{ v, ix -> ( ix & 1 ? reads2 : reads1) << v }\n    def input_reads = meta.single_end ? \"-r ${reads1.join(\" \")}\" : \"-1 ${reads1.join(\" \")} -2 ${reads2.join(\" \")}\"\n    if (alignment_mode) {\n        reference   = \"-t $transcript_fasta\"\n        input_reads = \"-a $reads\"\n    }\n\n    def strandedness_opts = [\n        'A', 'U', 'SF', 'SR',\n        'IS', 'IU' , 'ISF', 'ISR',\n        'OS', 'OU' , 'OSF', 'OSR',\n        'MS', 'MU' , 'MSF', 'MSR'\n    ]\n    def strandedness =  'A'\n    if (lib_type) {\n        if (strandedness_opts.contains(lib_type)) {\n            strandedness = lib_type\n        } else {\n            log.info \"[Salmon Quant] Invalid library type specified '--libType=${lib_type}', defaulting to auto-detection with '--libType=A'.\"\n        }\n    } else {\n        strandedness = meta.single_end ? 'U' : 'IU'\n        if (meta.strandedness == 'forward') {\n            strandedness = meta.single_end ? 'SF' : 'ISF'\n        } else if (meta.strandedness == 'reverse') {\n            strandedness = meta.single_end ? 'SR' : 'ISR'\n        }\n    }\n    \"\"\"\n    salmon quant \\\\\n        --geneMap $gtf \\\\\n        --threads $task.cpus \\\\\n        --libType=$strandedness \\\\\n        $reference \\\\\n        $input_reads \\\\\n        $args \\\\\n        -o $prefix\n\n    if [ -f $prefix/aux_info/meta_info.json ]; then\n        cp $prefix/aux_info/meta_info.json \"${prefix}_meta_info.json\"\n    fi\n    if [ -f $prefix/lib_format_counts.json ]; then\n        cp $prefix/lib_format_counts.json \"${prefix}_lib_format_counts.json\"\n    fi\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        salmon: \\$(echo \\$(salmon --version) | sed -e \"s/salmon //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    touch ${prefix}_meta_info.json\n    touch ${prefix}_lib_format_counts.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        salmon: \\$(echo \\$(salmon --version) | sed -e \"s/salmon //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create index for salmon\nTags: index, fasta, genome, reference", "answer": "process SALMON_INDEX {\n    tag \"$transcript_fasta\"\n    label \"process_medium\"\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/salmon:1.10.1--h7e5ed60_0' :\n        'biocontainers/salmon:1.10.1--h7e5ed60_0' }\"\n\n    input:\n    path genome_fasta\n    path transcript_fasta\n\n    output:\n    path \"salmon\"      , emit: index\n    path \"versions.yml\", emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def get_decoy_ids = \"grep '^>' $genome_fasta | cut -d ' ' -f 1 | cut -d \\$'\\\\t' -f 1 > decoys.txt\"\n    def gentrome      = \"gentrome.fa\"\n    if (genome_fasta.endsWith('.gz')) {\n        get_decoy_ids = \"grep '^>' <(gunzip -c $genome_fasta) | cut -d ' ' -f 1 | cut -d \\$'\\\\t' -f 1 > decoys.txt\"\n        gentrome      = \"gentrome.fa.gz\"\n    }\n    \"\"\"\n    $get_decoy_ids\n    sed -i.bak -e 's/>//g' decoys.txt\n    cat $transcript_fasta $genome_fasta > $gentrome\n\n    salmon \\\\\n        index \\\\\n        --threads $task.cpus \\\\\n        -t $gentrome \\\\\n        -d decoys.txt \\\\\n        $args \\\\\n        -i salmon\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        salmon: \\$(echo \\$(salmon --version) | sed -e \"s/salmon //g\")\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    \"\"\"\n    mkdir salmon\n    touch salmon/complete_ref_lens.bin\n    touch salmon/ctable.bin\n    touch salmon/ctg_offsets.bin\n    touch salmon/duplicate_clusters.tsv\n    touch salmon/info.json\n    touch salmon/mphf.bin\n    touch salmon/pos.bin\n    touch salmon/pre_indexing.log\n    touch salmon/rank.bin\n    touch salmon/refAccumLengths.bin\n    touch salmon/ref_indexing.log\n    touch salmon/reflengths.bin\n    touch salmon/refseq.bin\n    touch salmon/seq.bin\n    touch salmon/versionInfo.json\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        salmon: \\$(echo \\$(salmon --version) | sed -e \"s/salmon //g\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Hierarchical Hi-C compartment computation\nTags: calder2, genome, topology, compartments, domains, hi-c", "answer": "process CALDER2 {\n    tag '$meta.id'\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/r-calder2:0.3--r41hdfd78af_0' :\n        'biocontainers/r-calder2:0.3--r41hdfd78af_0' }\"\n\n\n    input:\n    tuple val(meta), path(cool)\n    val resolution\n\n    output:\n    tuple val(meta), path(\"${meta.id}/\")                    , emit: output_folder\n    tuple val(meta), path(\"${meta.id}/intermediate_data/\")  , emit: intermediate_data_folder      , optional: true\n    path \"versions.yml\"                                     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def suffix = resolution ? \"::/resolutions/$resolution\" : \"\"\n    def cpus = task.cpus ?: 1\n    def VERSION = '0.3' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    # getting binsize as mandatory input for calder\n    binsize=\"\\$(cooler info --field bin-size $cool$suffix)\"\n\n    calder --input $cool$suffix \\\\\n        --outpath ${prefix} \\\\\n        --nproc $cpus \\\\\n        --type cool \\\\\n        --bin_size \"\\${binsize}\" \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        calder: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Predict phage host using iPHoP\nTags: metagenomics, iphop, database, download, phage, bacteria, host", "answer": "process IPHOP_PREDICT {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/iphop:1.3.2--pyhdfd78af_0':\n        'biocontainers/iphop:1.3.2--pyhdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n    path iphop_db\n\n    output:\n    tuple val(meta), path(\"Host_prediction_to_genus_m*.csv\")    , emit: iphop_genus\n    tuple val(meta), path(\"Host_prediction_to_genome_m*.csv\")   , emit: iphop_genome\n    tuple val(meta), path(\"Detailed_output_by_tool.csv\")        , emit: iphop_detailed_output\n    path \"versions.yml\"                                         , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    export PERL5LIB=/usr/local/lib/perl5/site_perl/5.22.0\n    iphop \\\\\n        predict \\\\\n        --fa_file $fasta \\\\\n        --out_dir iphop_results \\\\\n        --db_dir $iphop_db \\\\\n        --num_threads $task.cpus \\\\\n        $args\n\n    mv iphop_results/Host_prediction_to_genus_m*.csv .\n    mv iphop_results/Host_prediction_to_genome_m*.csv .\n    mv iphop_results/Detailed_output_by_tool.csv .\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iphop: \\$(echo \\$(iphop --version 2>&1) | head -n 1 | sed 's/^.*iPHoP v//; s/: integrating.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def min_score = args.contains('--min_score') ? args.split('--min_score ')[1] : '90'\n    \"\"\"\n    mkdir -p iphop_results\n    touch Host_prediction_to_genus_m${min_score}.csv\n    touch Host_prediction_to_genome_m${min_score}.csv\n    touch Detailed_output_by_tool.csv\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iphop: \\$(echo \\$(iphop --version 2>&1) | head -n 1 | sed 's/^.*iPHoP v//; s/: integrating.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Download, extract, and check md5 of iPHoP databases\nTags: metagenomics, iphop, database, download, phage, bacteria, host", "answer": "process IPHOP_DOWNLOAD {\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/iphop:1.3.2--pyhdfd78af_0':\n        'biocontainers/iphop:1.3.2--pyhdfd78af_0' }\"\n\n    output:\n    path \"iphop_db/\"        , emit: iphop_db\n    path \"versions.yml\"     , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir -p download_dir\n    mkdir -p iphop_db\n\n    iphop \\\\\n        download \\\\\n        --db_dir download_dir \\\\\n        --no_prompt \\\\\n        $args\n\n    rm download_dir/*.tar.*\n    mv download_dir/*/* iphop_db\n\n    iphop \\\\\n        download \\\\\n        --db_dir iphop_db \\\\\n        --no_prompt \\\\\n        --full_verify \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iphop: \\$(echo \\$(iphop --version 2>&1) | head -n 1 | sed 's/^.*iPHoP v//; s/: integrating.*\\$//' )\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    \"\"\"\n    mkdir -p iphop_db/db/\n    touch iphop_db/db/All_CRISPR_spacers_nr_clean.fna\n    touch iphop_db/db/All_CRISPR_spacers_nr_clean.ndb\n    touch iphop_db/db/All_CRISPR_spacers_nr_clean.nhr\n    touch iphop_db/db/All_CRISPR_spacers_nr_clean.nin\n    touch iphop_db/db/All_CRISPR_spacers_nr_clean.not\n    touch iphop_db/db/All_CRISPR_spacers_nr_clean.nsq\n    touch iphop_db/db/All_CRISPR_spacers_nr_clean.ntf\n    touch iphop_db/db/All_CRISPR_spacers_nr_clean.nto\n    touch iphop_db/db/GTDBtkr202_and_newrepr_s2_mat.pkl\n    mkdir -p iphop_db/db/Host_Genomes\n    touch iphop_db/db/Host_Genomes/Host_Genomes.ndb\n    touch iphop_db/db/Host_Genomes/Host_Genomes.nhr\n    touch iphop_db/db/Host_Genomes/Host_Genomes.nin\n    touch iphop_db/db/Host_Genomes/Host_Genomes.not\n    touch iphop_db/db/Host_Genomes/Host_Genomes.nsq\n    touch iphop_db/db/Host_Genomes/Host_Genomes.ntf\n    touch iphop_db/db/Host_Genomes/Host_Genomes.nto\n    mkdir -p iphop_db/db/php_db\n    mkdir -p iphop_db/db/rafah_data\n    touch iphop_db/db/rafah_data/HP_Ranger_Model_3_Filtered_0.9_Valids.hmm.h3f\n    touch iphop_db/db/rafah_data/HP_Ranger_Model_3_Filtered_0.9_Valids.hmm.h3i\n    touch iphop_db/db/rafah_data/HP_Ranger_Model_3_Filtered_0.9_Valids.hmm.h3m\n    touch iphop_db/db/rafah_data/HP_Ranger_Model_3_Filtered_0.9_Valids.hmm.h3p\n    touch iphop_db/db/rafah_data/HP_Ranger_Model_3_Valid_Cols.txt\n    touch iphop_db/db/rafah_data/MMSeqs_Clusters_Ranger_Model_1+2+3_Clean.RData\n    touch iphop_db/db/rafah_data/RaFAH_ref_cds.count.tsv\n    touch iphop_db/db/rafah_data/RaFAH_ref_cds.dmnd\n    mkdir -p iphop_db/db/rewish_models\n    touch iphop_db/db/rewish_models/Batch_1.pkl\n    mkdir -p iphop_db/db/wish_data/Decoy_db\n    touch iphop_db/db/wish_data/Decoy_db/Decoy_phages.fna\n    mkdir -p iphop_db/db_infos\n    touch iphop_db/db_infos/All_CRISPR_array_size.tsv\n    touch iphop_db/db_infos/All_CRISPR_spacers_nr_clean.metrics.csv\n    touch iphop_db/db_infos/Host_Genomes.tsv\n    touch iphop_db/db_infos/List_contigs_removed_blast.tsv\n    touch iphop_db/db_infos/Translate_genus_to_full_taxo.tsv\n    touch iphop_db/db_infos/Wish_negFits.csv\n    touch iphop_db/db_infos/gtdbtk.ar122.decorated.tree\n    touch iphop_db/db_infos/gtdbtk.bac120.decorated.tree\n    touch iphop_db/md5checkfile.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        iphop: \\$(echo \\$(iphop --version 2>&1) | head -n 1 | sed 's/^.*iPHoP v//; s/: integrating.*\\$//' ))\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Collapse walk-preserving shared affixes in variation graphs in GFA format\nTags: gfa, graph, pangenome, variation graph", "answer": "process GFAFFIX {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/gfaffix:0.1.5b--h031d066_0' :\n        'biocontainers/gfaffix:0.1.5b--h031d066_0' }\"\n\n    input:\n    tuple val(meta), path(gfa)\n\n    output:\n    tuple val(meta), path(\"*.gfa\"), emit: gfa\n    tuple val(meta), path(\"*.txt\"), emit: affixes\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    gfaffix \\\\\n        $args \\\\\n        $gfa \\\\\n        -o ${prefix}.gfaffix.gfa > ${prefix}.affixes.txt\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gfaffix: \\$(gfaffix --version 2>&1 | grep -o 'gfaffix .*' | cut -f2 -d ' ')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Render an assembly graph in GFA 1.0 format to PNG and SVG image formats\nTags: gfa, graph, assembly, visualisation", "answer": "process BANDAGE_IMAGE {\n    tag \"${meta.id}\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/bandage:0.8.1--hc9558a2_2' :\n        'biocontainers/bandage:0.8.1--hc9558a2_2' }\"\n\n    input:\n    tuple val(meta), path(gfa)\n\n    output:\n    tuple val(meta), path('*.png'), emit: png\n    tuple val(meta), path('*.svg'), emit: svg\n    path  \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    Bandage image $gfa ${prefix}.png $args\n    Bandage image $gfa ${prefix}.svg $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        bandage: \\$(echo \\$(Bandage --version 2>&1) | sed 's/^.*Version: //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Nanoq implements ultra-fast read filters and summary reports for high-throughput nanopore reads.\nTags: nanoq, Read filters, Read trimming, Read report", "answer": "process NANOQ {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/nanoq:0.10.0--h031d066_2' :\n        'biocontainers/nanoq:0.10.0--h031d066_2'}\"\n\n    input:\n    tuple val(meta), path(ontreads)\n    val(output_format) //One of the following: fastq, fastq.gz, fastq.bz2, fastq.lzma, fasta, fasta.gz, fasta.bz2, fasta.lzma.\n\n    output:\n    tuple val(meta), path(\"*.{stats,json}\")                                           , emit: stats\n    tuple val(meta), path(\"*_filtered.${output_format}\")                              , emit: reads\n    path \"versions.yml\"                                                               , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_filtered\"\n    \"\"\"\n    nanoq -i $ontreads \\\\\n        ${args} \\\\\n        -r ${prefix}.stats \\\\\n        -o ${prefix}.$output_format\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanoq: \\$(nanoq --version | sed -e 's/nanoq //g')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}_filtered\"\n    \"\"\"\n    echo \"\" | gzip > ${prefix}.$output_format\n    touch ${prefix}.stats\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        nanoq: \\$(nanoq --version | sed -e 's/nanoq //g')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A tool to merge FastK histograms\nTags: merge, k-mer, histogram, fastk", "answer": "process FASTK_MERGE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container 'ghcr.io/nbisweden/fastk_genescopefk_merquryfk:1.2'\n\n    input:\n    tuple val(meta), path(hist), path(ktab), path(prof)\n\n    output:\n    tuple val(meta), path(\"*.hist\")                      , emit: hist\n    tuple val(meta), path(\"*.ktab*\", hidden: true)       , emit: ktab, optional: true\n    tuple val(meta), path(\"*.{prof,pidx}*\", hidden: true), emit: prof, optional: true\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"FASTK_MERGE module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FASTK_VERSION = 'f18a4e6d2207539f7b84461daebc54530a9559b0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    Fastmerge \\\\\n        $args \\\\\n        -T$task.cpus \\\\\n        ${prefix} \\\\\n        $hist\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastk: $FASTK_VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A fast K-mer counter for high-fidelity shotgun datasets\nTags: k-mer, histogram", "answer": "process FASTK_HISTEX {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container 'ghcr.io/nbisweden/fastk_genescopefk_merquryfk:1.2'\n\n    input:\n    tuple val(meta), path(histogram)\n\n    output:\n    tuple val(meta), path(\"*.hist\"), emit: hist\n    path \"versions.yml\"            , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"FASTK_HISTEX module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FASTK_VERSION = 'f18a4e6d2207539f7b84461daebc54530a9559b0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    Histex \\\\\n        $args \\\\\n        $histogram \\\\\n        > ${prefix}.hist\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastk: $FASTK_VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: A fast K-mer counter for high-fidelity shotgun datasets\nTags: k-mer, count, histogram", "answer": "process FASTK_FASTK {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    // WARN: Version information not provided by tool on CLI. Please update version string below when bumping container versions.\n    container 'ghcr.io/nbisweden/fastk_genescopefk_merquryfk:1.2'\n\n    input:\n    tuple val(meta), path(reads)\n\n    output:\n    tuple val(meta), path(\"*.hist\")                      , emit: hist\n    tuple val(meta), path(\"*.ktab*\", hidden: true)       , emit: ktab, optional: true\n    tuple val(meta), path(\"*.{prof,pidx}*\", hidden: true), emit: prof, optional: true\n    path \"versions.yml\"                                  , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"FASTK_FASTK module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FASTK_VERSION = 'f18a4e6d2207539f7b84461daebc54530a9559b0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n    \"\"\"\n    FastK \\\\\n        $args \\\\\n        -T$task.cpus \\\\\n        -M${task.memory.toGiga()} \\\\\n        -N${prefix}_fk \\\\\n        $reads\n\n    find . -name '*.ktab*' \\\\\n        | xargs chmod a+r\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastk: $FASTK_VERSION\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    // Exit if running this module with -profile conda / -profile mamba\n    if (workflow.profile.tokenize(',').intersect(['conda', 'mamba']).size() >= 1) {\n        error \"FASTK_FASTK module does not support Conda. Please use Docker / Singularity / Podman instead.\"\n    }\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def FASTK_VERSION = 'f18a4e6d2207539f7b84461daebc54530a9559b0' // WARN: Version information not provided by tool on CLI. Please update this string when bumping container versions.\n\n    def touch_ktab = args.contains('-t') ? \"touch ${prefix}_fk.ktab .${prefix}_fk.ktab.1\" : ''\n    def touch_prof = args.contains('-p') ? \"touch ${prefix}_fk.prof .${prefix}_fk.pidx.1\" : ''\n    \"\"\"\n    touch ${prefix}_fk.hist\n    $touch_ktab\n    $touch_prof\n\n    echo \\\\\n    \"FastK \\\\\n        $args \\\\\n        -T$task.cpus \\\\\n        -M${task.memory.toGiga()} \\\\\n        -N${prefix}_fk \\\\\n        $reads\"\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        fastk: $FASTK_VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Performs fastq alignment to a fasta reference using SNAP\nTags: alignment, map, fastq, bam, sam", "answer": "process SNAPALIGNER_ALIGN {\n    tag \"$meta.id\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snap-aligner:2.0.3--hd03093a_0':\n        'biocontainers/snap-aligner:2.0.3--hd03093a_0' }\"\n\n    input:\n    tuple val(meta) , path(reads, stageAs: \"?/*\")\n    tuple val(meta2), path(index)\n\n    output:\n    tuple val(meta), path(\"*.bam\"), emit: bam\n    tuple val(meta), path(\"*.bai\"), optional: true, emit: bai\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def subcmd = meta.single_end ? \"single\" : \"paired\"\n\n    \"\"\"\n    INDEX=`dirname \\$(find -L ./ -name \"OverflowTable*\")`\n    [ -z \"\\$INDEX\" ] && echo \"Snap index files not found\" 1>&2 && exit 1\n\n    snap-aligner ${subcmd} \\\\\n        \\$INDEX \\\\\n        ${reads} \\\\\n        -o ${prefix}.bam \\\\\n        -t ${task.cpus} \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snapaligner: \\$(snap-aligner 2>&1| head -n 1 | sed 's/^.*version //;s/.\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Create a SNAP index for reference genome\nTags: index, fasta, genome, reference", "answer": "process SNAPALIGNER_INDEX {\n    tag \"$fasta\"\n    label 'process_high'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/snap-aligner:2.0.3--hd03093a_0':\n        'biocontainers/snap-aligner:2.0.3--hd03093a_0' }\"\n\n    input:\n    tuple val(meta), path(fasta), path(altcontigfile), path(nonaltcontigfile), path(altliftoverfile)\n\n    output:\n    tuple val(meta), path(\"snap/*\") ,emit: index\n    path \"versions.yml\"             ,emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def altcontigfile_arg = altcontigfile ? '-altContigFile ' + altcontigfile : ''\n    def nonaltcontigfile_arg = nonaltcontigfile ? '-nonAltContigFile ' + nonaltcontigfile : ''\n    def altliftoverfile_arg = altliftoverfile ? '-altLiftoverFile ' + altliftoverfile : ''\n    \"\"\"\n    mkdir snap\n\n    snap-aligner \\\\\n        index \\\\\n        $fasta \\\\\n        snap \\\\\n        -t${task.cpus} \\\\\n        $altcontigfile_arg \\\\\n        $nonaltcontigfile_arg \\\\\n        $altliftoverfile_arg \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snapaligner: \\$(snap-aligner 2>&1| head -n 1 | sed 's/^.*version //')\n    END_VERSIONS\n    \"\"\"\n    stub:\n    \"\"\"\n    mkdir snap\n    echo \"Genome\" > snap/Genome\n    echo \"GenomeIndex\" > snap/GenomeIndex\n    echo \"GenomeIndexHash\" > snap/GenomeIndexHash\n    echo \"OverflowTable\" > snap/OverflowTable\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        snapaligner: \\$(snap-aligner 2>&1| head -n 1 | sed 's/^.*version //;s/\\.\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Deepcell/mesmer segmentation for whole-cell\nTags: imaging, spatial_omics, segmentation", "answer": "process DEEPCELL_MESMER {\n    tag \"$meta.id\"\n    label 'process_low'\n\n    container \"nf-core/deepcell_mesmer:0.4.1_noentry\"\n\n    input:\n    tuple val(meta) , path(img)\n    tuple val(meta2), path(membrane_img)\n\n    // Output a .tif image, don't touch versions\n    output:\n    tuple val(meta), path(\"*.tif\"), emit: mask\n    path \"versions.yml\"           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    def membrane_command = membrane_img ? \"--membrane-image $membrane_img\" : \"\"\n    def VERSION = \"0.4.1\"\n\n    \"\"\"\n    python /usr/src/app/run_app.py mesmer \\\\\n        --squeeze \\\\\n        --nuclear-image $img \\\\\n        --output-directory . \\\\\n        --output-name ${prefix}.tif \\\\\n        $membrane_command \\\\\n        $args\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        deepcell_mesmer: $VERSION\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sequenza-utils gc_wiggle computes the GC percentage across the sequences, and returns a file in the UCSC wiggle format, given a fasta file and a window size.\nTags: sequenzautils, copy number, gc_wiggle", "answer": "process SEQUENZAUTILS_GCWIGGLE {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sequenza-utils:3.0.0--py38h6ed170a_2' :\n        'biocontainers/sequenza-utils:3.0.0--py38h6ed170a_2' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"*.wig.gz\"), emit: wig\n    path \"versions.yml\"              , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    sequenza-utils \\\\\n        gc_wiggle \\\\\n        $args \\\\\n        --fasta $fasta \\\\\n        -o ${prefix}.wig.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sequenzautils: \\$(echo \\$(sequenza-utils 2>&1) | sed 's/^.*is version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Sequenza-utils bam2seqz process BAM and Wiggle files to produce a seqz file\nTags: sequenzautils, copy number, bam2seqz", "answer": "process SEQUENZAUTILS_BAM2SEQZ {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/sequenza-utils:3.0.0--py38h6ed170a_2' :\n        'biocontainers/sequenza-utils:3.0.0--py38h6ed170a_2' }\"\n\n    input:\n    tuple val(meta), path(normalbam), path(tumourbam)\n    path fasta\n    path wigfile\n\n    output:\n    tuple val(meta), path(\"*.gz\"), emit: seqz\n    path \"versions.yml\"          , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    sequenza-utils \\\\\n        bam2seqz \\\\\n        $args \\\\\n        -n $normalbam \\\\\n        -t $tumourbam \\\\\n        --fasta $fasta \\\\\n        -gc $wigfile \\\\\n        -o ${prefix}.gz\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        sequenzautils: \\$(echo \\$(sequenza-utils 2>&1) | sed 's/^.*is version //; s/ .*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: phyloFlash is a pipeline to rapidly reconstruct the SSU rRNAs and explore phylogenetic composition of an illumina (meta)genomic dataset.\nTags: metagenomics, illumina datasets, phylogenetic composition", "answer": "process PHYLOFLASH {\n    tag \"$meta.id\"\n    label 'process_medium'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/phyloflash:3.4--hdfd78af_1' :\n        'biocontainers/phyloflash:3.4--hdfd78af_1' }\"\n\n    input:\n    tuple val(meta), path(reads)\n    path  silva_db\n    path  univec_db\n\n    output:\n    tuple val(meta), path(\"${meta.id}*/*\"), emit: results\n    path \"versions.yml\"                   , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    if (meta.single_end) {\n        \"\"\"\n        phyloFlash.pl \\\\\n            $args \\\\\n            -read1 ${reads[0]} \\\\\n            -lib $prefix \\\\\n            -interleaved \\\\\n            -dbhome . \\\\\n            -CPUs $task.cpus\n\n        mkdir $prefix\n        mv ${prefix}.* $prefix\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            phyloflash: \\$(echo \\$(phyloFlash.pl -version 2>&1) | sed \"s/^.*phyloFlash v//\")\n        END_VERSIONS\n        \"\"\"\n    } else {\n        \"\"\"\n        phyloFlash.pl \\\\\n            $args \\\\\n            -read1 ${reads[0]} \\\\\n            -read2 ${reads[1]} \\\\\n            -lib $prefix \\\\\n            -dbhome . \\\\\n            -CPUs $task.cpus\n\n        mkdir $prefix\n        mv ${prefix}.* $prefix\n\n        cat <<-END_VERSIONS > versions.yml\n        \"${task.process}\":\n            phyloflash: \\$(echo \\$(phyloFlash.pl -version 2>&1) | sed \"s/^.*phyloFlash v//\")\n        END_VERSIONS\n        \"\"\"\n    }\n\n    stub:\n    def prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    mkdir ${prefix}\n    touch ${prefix}/${prefix}.SSU.collection.fasta\n    touch ${prefix}/${prefix}.phyloFlash\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        phyloflash: \\$(echo \\$(phyloFlash.pl -version 2>&1) | sed \"s/^.*phyloFlash v//\")\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Serogroup Pseudomonas aeruginosa assemblies\nTags: bacteria, serogroup, fasta, assembly", "answer": "process PASTY {\n    tag \"$meta.id\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/pasty:1.0.0--hdfd78af_0':\n        'biocontainers/pasty:1.0.0--hdfd78af_0' }\"\n\n    input:\n    tuple val(meta), path(fasta)\n\n    output:\n    tuple val(meta), path(\"${prefix}.tsv\")        , emit: tsv\n    tuple val(meta), path(\"${prefix}.blastn.tsv\") , emit: blast\n    tuple val(meta), path(\"${prefix}.details.tsv\"), emit: details\n    path \"versions.yml\"                           , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args = task.ext.args ?: ''\n    prefix = task.ext.prefix ?: \"${meta.id}\"\n    \"\"\"\n    pasty \\\\\n        $args \\\\\n        --prefix $prefix \\\\\n        --assembly $fasta\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        pasty: \\$(echo \\$(pasty --version 2>&1) | sed 's/^.*pasty, version //;' )\n    END_VERSIONS\n    \"\"\"\n}\n"}
{"question": "Description: Compresses and decompresses files.\nTags: gunzip, compression, decompression", "answer": "process GUNZIP {\n    tag \"$archive\"\n    label 'process_single'\n\n    conda \"${moduleDir}/environment.yml\"\n    container \"${ workflow.containerEngine == 'singularity' && !task.ext.singularity_pull_docker_container ?\n        'https://depot.galaxyproject.org/singularity/ubuntu:22.04' :\n        'nf-core/ubuntu:22.04' }\"\n\n    input:\n    tuple val(meta), path(archive)\n\n    output:\n    tuple val(meta), path(\"$gunzip\"), emit: gunzip\n    path \"versions.yml\"             , emit: versions\n\n    when:\n    task.ext.when == null || task.ext.when\n\n    script:\n    def args        = task.ext.args ?: ''\n    def extension   = ( archive.toString() - '.gz' ).tokenize('.')[-1]\n    def name        = archive.toString() - '.gz' - \".$extension\"\n    def prefix      = task.ext.prefix ?: name\n    gunzip          = prefix + \".$extension\"\n    \"\"\"\n    # Not calling gunzip itself because it creates files\n    # with the original group ownership rather than the\n    # default one for that user / the work directory\n    gzip \\\\\n        -cd \\\\\n        $args \\\\\n        $archive \\\\\n        > $gunzip\n\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gunzip: \\$(echo \\$(gunzip --version 2>&1) | sed 's/^.*(gzip) //; s/ Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n\n    stub:\n    def args        = task.ext.args ?: ''\n    def extension   = ( archive.toString() - '.gz' ).tokenize('.')[-1]\n    def name        = archive.toString() - '.gz' - \".$extension\"\n    def prefix      = task.ext.prefix ?: name\n    gunzip          = prefix + \".$extension\"\n    \"\"\"\n    touch $gunzip\n    cat <<-END_VERSIONS > versions.yml\n    \"${task.process}\":\n        gunzip: \\$(echo \\$(gunzip --version 2>&1) | sed 's/^.*(gzip) //; s/ Copyright.*\\$//')\n    END_VERSIONS\n    \"\"\"\n}\n"}]
